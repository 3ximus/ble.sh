# -*- coding:utf-8 -*-

拡張

  * プログラム補完に於いて、
    補完関数内で compopt -o filter_by_prefix を指定した場合、
    生成される候補を接頭辞が一致するものだけに絞り込む。

制限

  * ble.sh を attach しているとき builtin read -e は動かない。
    代わりに ble.sh が定義したシェル関数 read (組み込みコマンドを上書き)
    を用いて read -e を呼び出す必要がある。

  * bash-3 C-d について

    今は何とか C-d を処理する事に成功しているが完全ではない。

    1 C-d を押した時に bash が出力するエラーメッセージを使って捕捉している。
      このエラーメッセージは言語や設定によって異なると思われる。
      現在は以下のメッセージを調べている。
      - 'Use "exit" to leave the shell.'
      - 'ログアウトする為には exit を入力して下さい'
      - 'シェルから脱出するには "exit" を使用してください。'
      自分の bash が異なるメッセージを出力する時は
      それを bleopt_ignoreeof_message に設定する。
    2 連続で沢山 C-d を押すと "^D" が echo されて表示が乱れるかもしれない。
      最悪の場合 C-d によって bash プロセスが落ちる可能性もあるかもしれない。
      (未だ落ちた事はないが)。
    3 C-d を処理する為に SIGUSR1 を使用している。
      その為 SIGUSR1 を別の目的で使用する事は出来ない。

  * 文字コードについて

    現在は基本的に UTF-8 を想定している。
    それ以外の環境のためには少なくとも以下の修正が必要になる。

    - ble.sh 自体を iconv で変換する事。或いは日本語を完全に排除する事。

      現在のところは日本語はコメント中にしか含まれていないはずである。
      コメントさえ削除すれば何処でも動くようになっていると良い。

    - 使いたい文字コード → unicode のデコーダを自分でかく事:
      これは "function ble-decode-byte+文字コード" を実装すれば良い。

    - Unicode → 文字のコードが正しく動作する様にする事:
      これは .ble-text.c2s (ble-core.sh) の辺りを直せばよい。
      "ble-text-c2b+文字コード"
      "ble-text-b2c+文字コード"
      も実装する必要がある。

    - ble/encoding:$bleopt_input_encoding/generate-binder

      現在 "C-@", "ESC" 及び "ESC *" を bind する為に、
      その符号化形式の非正規な符号に変換している。
      この変換はシェル関数 ble/encoding:$bleopt_input_encoding/generate-binder
      において文字符号化方式毎に (UTF-8 前提の設定を上書きする形で) 定義する。

      また bind を記録したキャッシュは $bleopt_input_encoding 毎に保持するが、
      このキャッシュの更新は bind.sh のタイムスタンプしか見ていない (ble-decode/bind 内)。
      新しい符号化方式を定義する時には、タイムスタンプを参照するファイル
      (ble/encoding:$bleopt_input_encoding/generate-binder を定義するファイル) を決める必要がある。


    他の文字コードは未だ一回も実装していないので上記以外にも必要な作業が出て来る可能性がある。

    + 2015-11-30 Note: ble-decode.sh (generate-source-to-unbind-default)

      文字コード実装時に問題があるかも。

      現在、bind -sp が出力する中途半端なバイトを解釈する為に、LANG=C で awk を起動している。
      UTF-8 の場合には複数バイト文字を構成するバイトは ASCII 文字と被らないので問題ないが、
      Shift_JIS 等の場合には ASCII 文字、特に \ や " を含む可能性がある。
      この場合には LANG=C にしていると問題が生じる。
      というか、bind -sp の出力する中途半端な文字と、複数バイト文字の一部を本質的に区別する方法はない様に思われる。

      ただし、救いは、もし ble.sh を plain な bash の上で起動するとすれば
      日本語で bind -sp に登録がなされていることはないだろうということである。
      つまり、ユーザが手で (或いは .inputrc に) bind '"日本語":"にほんご"' などとしない限りは問題は生じない。

  * bash-4.0, 4.1 において特殊シェル変数 FUNCNAME をユーザが unset した上で、
    関数内から ble.sh を source すると ble の使う連想配列がローカルに定義され問題になる。

    - bash-4.0 以降では連想配列を用いるが bash-4.2 未満では、
      連想配列を明示的にグローバルに配置することができない。

    - FUNCNAME がユーザによって削除されていなければ、
      この変数を用いて関数内から source されたことを検知できるので、
      その時には配列実装に fallback する。
      FUNCNAME が削除されていると fallback に正しく切り替わらずに問題になる。

  * bash-4.3 では C-x は、次の文字が来るまでは受信できない。
    bash-4.0 - 4.4 の他の version では遅延はないのでこれは bash-4.3 特有の問題である。

  * 構文に従った着色の中には bash の不自然な振る舞いや、
    複雑な振る舞いのために正確さを諦めた物がある。

    - bash の最初の [@()] の構文解析とパス名展開時の解析の齟齬

      echo [@(echo|[...])]

      恐らく bash は最初の単語の切り出しで @() を一単位として読み取り、
      ["@(echo|[...])"] の様に読み取る。その上で、改めてパス名展開を適用するが、
      その時には ["@(echo|[.."]")]" の様に解釈する。
      つまり、初めの構文解析とパス名展開の適用の間に齟齬がある。

      ble.sh では構文解析に従った解析・着色をすることにしたので、
      実際のパス名展開の適用結果が着色と異なることがあることに注意する。

    - bash echo {@(,)}

      これについても上と同様のことが起こる。
      単語の切り出しは {"@(,)"} となり、構文エラーは発生しない。
      後のブレース展開では {"@(",")"} と解釈されて分割される。
      単語が分断されてしまうのでパス名展開は起こらない。

    - bash のブレース展開時の ${var:-...}{,} の解析とパラメータ展開時の解析の齟齬

      echo ${var:-{a,b}{a,b}

      恐らく bash は最初にブレース展開を試みる時に、
      ${} の中については {} の入れ子を数えてスキップする。
      従って、上のコマンドの時は ${} が終端しないのでブレース展開は試みられない。
      しかし、パラメータ展開が実施される時には {} の入れ子は考慮に入れられず、
      最初に現れた "}" で終端するので、${var:-"{a,b"}"{a,b}" という解釈になる。

      [予定]
      ble.sh ではどの様に着色するか微妙である。
      理想的には最終的な解釈の ${var:-"{a,b"}"{a,b}" に応じた着色にしたいが、
      後半の {a,b} の部分が {} の入れ子のアンバランスによって
      無効化されている事を検出するのは困難である。
      仕方がないので、ブレース展開の {} の入れ子の勘定はバグとして無視する事にする。
      つまり、echo ${var:-"{a,b"}{a,b} という解釈で着色する。

    - bash のチルダ展開の時の echo a[]b]=~ の解析と、パス名展開の時の解析

      チルダ展開の時には a["]b"]=~ とはならず a[]"b]="~ という解釈になるので、チルダ展開は起こらない。
      一方で、パス名展開のときには a["]b"]"=~" という解釈になり、'ab=~' などのファイル名に一致する。
      ble.sh ではパス名展開の規則の方を優先させる。

    - ble.sh では [[ @({a,b}) ]] のブレース展開が有効であるかの様に着色される。

      実際には、条件コマンドの中ではブレース展開は無効になる。
      これに正確に対応する為には "条件コマンドの中の extglob"
      に対応する文脈値を定義する必要があるが、煩雑になるので対応していない。

    - ble.sh では echo [{@(a|b),[abc]}] の内部の extglob や [...] が有効であるかの様に着色される。

      しかし、実際にはブレース展開を実行したとしても [] の内部なので、
      extglob や [...] は不活性化しているはずである。
      しかし、これも解析が無意味に複雑になるので対応はしない。

    - ble.sh では echo {~user,~user} の内部のチルダ展開に反応しない。

      bash ではブレース展開された後にチルダ展開が実行されるので有効。

    - ble.sh はブレース展開が含まれる変数代入形式単語でも、
      ブレース展開より前のチルダ展開は有効である。

      bash では変数代入形式の単語の右辺でチルダ展開が起こる。
      しかし、ブレース展開が含まれている場合には例外としてチルダ展開が起こらない様だ。

      $ a=~:{a,b}:~:echo      → ブレース展開は起こらず、チルダ展開は起こる。
      $ echo a=~:{a,b}:~:echo → ブレース展開が起こり、チルダ展開は起こらない
                                 ble.sh では一つ目のチルダ展開の解析時点では、
                                 次にブレース展開が来ることを知らないので、
                                 一つ目の ~ はチルダ展開として着色する。

      規則がよく分からないが、取り敢えず ble.sh ではブレース展開が現れたら、
      それ以降はチルダ展開が無効になるようにしている。
      具体的には _ble_syntax_bash_command_IsAssign[ctx] の設定されている文脈は、
      ブレース展開が現れたときに、変数代入形式前の文脈値に戻すようにしている。

    - echo [a[!b

      echo [! の組み合わせは履歴展開にはならない。
      echo [a[!b] の場合にも履歴展開にはならない。
      しかし、echo [!a[!b の場合には履歴展開になる。
      違いは bracket expressions が閉じているか閉じていないかである。
      然し、それを判定する為には先読みをして単語の最後まで見ないといけない。
      それは実装上困難なのでこれは諦める。

      (bash の parser がここでどう動作しているのかは不思議ではある。
      例えば echo [a[!echo""] は無効で [a[!echo"" は有効である。)

    - echo $((echo)>/dev/null)
      よく考えたらこの有名なパターンに対応するのを忘れていた。

    - echo $(case A in A) echo B;; esac)
      実はこのパターン。Bash-4.0 以降では大丈夫だが、
      Bash-3.2 以降では構文エラーになる。ble.sh は bash-4.0 以降の振る舞いしかしない。

    - ${#var[...]修飾}
      この形式は Bash 的には構文エラーになるが、[...] の中身を相当先読みしないと
      修飾があるかないかを見る事ができないので諦めている。

    - set +H; echo ${!!修飾}
      これは Bash では構文エラーだが何故かが分からない。

    - {$v,$w}xxx これは $vxxx $wxxx に展開される。
      つまり、v と xxx がくっついて新しい変数名になる。
      これは分かりにくい動作だが、これを逆に使う人もあるのかもしれない。
      実の所、ブレース展開も文法レベルで実施されるべきなのかもしれない。

  * 2019-02-04 プログラム補完関数の中で標準入力は使えない。
    どうしてもユーザからの入力を得たい場合には、
    現在の補完が自動補完でない事を確認してから /dev/tty から直接取る事。

bash 実装上で注意するべき事

  * 変数の代入は基本的に quote は必要ないが、

    1 チルダで始まる時はチルダ展開を防ぐ為に quote が必要。
      (変数展開の中にあるチルダは quote しなくても大丈夫)

    2 配列要素を空文字列で連結するときは quote が必要。
      つまり、IFS= eval 'declare var=${arr[*]}' とすると空白区切りになる。
      IFS= eval 'declare var="${arr[*]}"' とする必要がある。
      また IFS が中身のある場合には問題は起こらない。

      - bash-4.3 以降では IFS= eval 'var=${arr[*]}' なら OK

    関係あるか分からないが
    http://lists.gnu.org/archive/html/bug-bash/2017-04/msg00001.html
    において以下のような例が紹介されている。これは bash-4.5 で修正されるらしい。

    | bash-4.2$ unset IFS; set ' '; a=$*; printf '<%s>' "$a"
    | < >
    | bash-4.3$ unset IFS; set ' '; a=$*; printf '<%s>' "$a"
    | <>

  * コマンドをつなぐ && と || の優先順位は同じで左結合である
    但し、算術式や [[ ]] に登場する && と || はC言語と同じ優先順位である。

  * unset の引数は quote しないとパス名展開の対象である。
    特に配列要素を消す場合には [...] を quote する必要がある。

  * unset -v または unset -f と明示的に指定しないと、
    意図せず同名の関数または同名の変数を消去してしまう可能性がある。
    変数を消す場合でも unset -v と明示する必要がある (ref #D0893)。

  * コマンドの単語中のパラメータ展開は "" でクォートする必要がある
    (ref #D0943)

    特に値として以下の物が含まれている可能性がある時は絶対必要である。
    先ず始めに IFS に含まれる文字がある場合は意図しない単語分割を抑制する為に "" で囲む。
    次に、グロブの特殊文字 *?[ が含まれている場合にも注意する。
    shopt -s extglob の時には @( や !( の並びにも注意する必要がある。
    更に、'\' が含まれる場合もグロブ特殊文字のクォートに何故か影響を与える様なので注意する。
    これは例えば shopt -s failglob において、a='\'; echo $a'*' がエラーメッセージを出す事で分かる。

  [complete 仕様について]

  * compgen -f はクォート除去、チルダ展開を実行する
    理解できないのはクォート除去した後にチルダ展開をするという事。
    compgen -f "'~/'" としても '~' というディレクトリには決して一致しない。
    compgen -f "'\~/'" 等とクォートした上に backslash も指定しないと行けない。
    結局どういう規則なのか分からないので、寧ろ arr=('~/'*) 等の様にするべき。

    Note: ~ だとちゃんと現在のディレクトリ以下のファイルに一致するようだ?
    Note: compgen -W でも似たような quote 除去・ブレース展開などを行う様だが、
      それでも理解できる振る舞いになっている。
    Note: bash --norc で echo \~/ から補完を実際に実行してみると echo ~/... に書き換わってしまう。
      何処かで quote が消えてしまっている。これはバグと見做すべきであろう。

  * $ complete -F foo -C bar command と登録すると foo, bar の両方が foo bar の順に実行される。
    $ complete -C bar -F foo command と登録すると bar foo の順に実行される。
    しかし、complete -p とすると両者とも
    complete -C 'bar' -F foo
    と表示され登録順・実行順についての情報を取り出す事ができない。

    →今試すと必ず foo bar の順序でしか呼び出されない。compgen でも同様に見える。

  * $ complete -F hoge1 -F hoge2 command とすると、-F hoge2 だけ有効になる
    (complete -p による表示もそうだし、実際に実行されるのも hoge2 だけであった)。
    -F オプションは後からものによって上書きされるという事の様だ。

  * shopt -q は通常の出力はやめてもエラーメッセージは出す。
    つまり未実装のオプション (compat* や autocd) について
    shopt -q をするとエラーメッセージが出力されるので
    結局 &>/dev/null にリダイレクトしなければならない。

  * locale の環境変数 LC_*/LANG を設定する時は &>/dev/null する必要がある。
    ref #D1205 #D1341 #D1355

    元々入っていた値が不正な値である場合、
    元の値を復元した時にエラーメッセージが意図されず出力される。

    ローカル変数として設定する場合は、
    - 値の復元はどうやら関数の本体を完全に実行し終わった後に起こる様なので、
      関数の本体自体を &>/dev/null で囲んでも意味はない。
    - 関数の中で unset を行っても意味はない。
    - 関数の中でもとの値を設定しても意味はない。
      関数が抜ける時に改めて設定される様だ。

    IFS= LC_ALL=C read -t 0 &>/dev/null
    としても復元時のメッセージは何故か抑制できなかった。

    * #D1341 更に、bash-4.1 以下では LC_ALL= LC_COLLATE=C func 等の形式にしても
      効果が現れない。local LC_ALL= LC_COLLATE=C としないと効かない様である。

      外部コマンドを呼び出す時には問題は起こらない。関数経由でも大丈夫。
      逆に外部コマンドの時には "LC_ALL=C awk" の形式にする必要がある。
      もしくは "local -x LC_ALL= LC_COLLATE=C" とする。

      ng$ aaa() { echo ${#1}; }; LC_CTYPE=C aaa あいうえお
      ok$ echo あいうえお | LC_CTYPE=C awk '{print length($0)}'
      ok$ echo あいうえお | LC_CTYPE=C ble/bin/awk '{print length($0)}'

  * Bash 正規表現はシステムの <regex.h> を使用するので環境依存である。

    Linux においては bash 正規表現の POSIX 文字クラス ([[:alpha:]] など) は
    ロケールによって何にでも一致するので信用できない。
    例えば GNU/Linux (Fedora 25) では ja_JP.UTF-8 で [[:alpha:]] は漢字・仮名にも一致する。

  * bind 関数の中で set +o emacs などをして編集モードを無効にすると、

    編集関数の実行自体が中断されるようである。
    具体的には set +o emacs を含む行だけ実行されて、次の行以降は実行されない。
    set +o emacs が eval に含まれる場合は eval が終わると共に中断される。
    また関数内に set +o emacs がある場合は、その関数は最後まで実行されるようだ。

    従って set +o emacs が実行されたことを検知して適切な後処理を実行するのは難しい。
    更にその後で set -o emacs に戻ってくると変な状態になる。
    bind -p ではちゃんと hook された状態になっているが、
    実際に操作してみると keymap はリセットされているように見受けられる。
    この辺りはもう少し詳しく調べてみないと具体的に何が起こっているかはわからない。

    例: 以下の3行のコマンドを実行しようとすると途中で中断され元の状態には戻らなくなる。

    $ set +o emacs
    > echo hello
    > set -o emacs

    直接 readline で実行している場合にはこの問題は起こらない。

  * ble.sh では変数の -i は積極的には使用しないことにした ref #D0894

    関数引数に使用する場合は、そもそも -i の機能を使う機会の方が少ないので
    全ての関数の引数に適用するのは非効率であり、一部の関数の引数にだけ適用するのは
    関数の仕様として分かりにくくバグの元である。そもそも算術式展開が必要化どうかは
    呼び出し元が知っていることのはずなので呼び出し元で算術式展開をするべきである。

    関数内で使用する場合についても明示的に算術式展開を実行すれば良い。

  * bind 関数中の set +v は揮発性 ref #D0930 (Bash 3.0--5.0)

    bind 関数中で set +v 等としてもその状態は
    次の bind 関数の呼び出しの際には元に戻ってしまう。
    この振る舞いは試した全ての bash version で共通だった。

bashbug: 実装上で注意するべき事・バグ

  * bash-5.0 -- 4.4 (ref #D1334)
    trap handler が実行中に return を無引数で呼び出すと、
    無条件に trap handler 起動直前の $? が関数の終了ステータスになる。
    POSIX に要求されていると書かれているが解釈に難がある。
    特に trap handler を抜ける時の戻り値だけに影響を与えるのが自然に思われる。

  * bash-5.0 -- 3.0 (全 version) バグ (ref #D0943)

    $ shopt -s failglob
    $ a='\'; echo $a'*'

    これで failglob になる。\* に一致するファイルは存在しませんのエラーメッセージ。
    ファイルとして '*', '\*', '\a', 'a' 等があっても決して一致しない。
    これを防ぐ為には、パラメータ展開は必ず "" でクォートする様にすれば良い。

  * bash-5.0 -- 3.0 (全 version) バグ

    history -p をコマンド実行中に呼び出すと呼び出す度に履歴項目が減る。
    これは例えば f1() { history | tail -1; history -p '!!'; history | tail; } として、
    f1 を実行すると分かる。f1;f1;f1 等とすると一回で3件消える。
    更に bash-3.0 では bind -x の関数の中であっても history -p を呼び出す度に履歴項目が減る。

  * bash-4.4 -- 4.3 バグ

    \C-@ 関係に bind -x すると正しく動かない
    bash-4.4 での動作については未だ確認していない。
    → bash-4.4 でもやはり動かない。

    これは修正した http://lists.gnu.org/archive/html/bug-bash/2018-03/msg00165.html

  * bash-4.4 -- 3.2, etc

    rex="^([^\$]|\\'[^\\']*\\')+\$" && [[ 'i$' =~ $rex ]] && echo hello
    が一致する。\' の解釈が謎である。単に ' とすれば問題ない。

    rex=$'^([^$]|\\\'.\\\')+$' でも一致する。
    rex=$'^([^$]|\\\')+$' だと一致しない。
    \' は何らかのアンカーとして解釈されるという事だろうか。
    或いは単純に無視されているのか。

  * bash-4.2

    declare -g -r var とした時に、
    グローバル変数が定義されていなければローカルに新しく変数を作る様だ。
    bash-4.3 で直っている。

  * bash-4.2 以下
    bash-4.2 ～ bash-3.0

    \C-x 単体に bind -x して C-x に続けて何か打つと segfault する。
    $ bind -x '"\C-x":echo' → 続けて C-x a 等と入力

  * bash-4.1 以下: LC_CTYPE=C eval 'echo ${#var}' としても
    ${#var} が元のロケールで計算される。"変数代入 コマンド"
    の形式だとロケールの初期化が間に合わないのだろうか。

  * bash-4.0 segfault

    以下で segfault を起こすことが分かった。bash-4.1 以降では直っている。

    bash-4.0 -c 'function f1 { COMPREPLY=(alpha); }; compgen -F f1 2>/dev/null'

    但し、ble.sh の使用中に実際に compgen -F を通して segfault になることはなかった。
    もしかすると何らかの条件が整うと segfault するかもしれないので、
    念のためここに記録に残しておく。

  * bash-4.0 -- 3.0

    $'' 内に \' を入れていると履歴展開が '' の中で起こる?
    例えば rex='a'$'\'\'''!a' とすると !a の部分が展開される。

  * bash-3.2 以下ではプロセス置換に含まれるブレース展開は
    プロセス置換ごと複製してしまう。
    例えば echo <(echo {1..3}) は、
    echo <(echo 1 2 3) ではなくて、
    echo <(echo 1) <(echo 2) <(echo 3) に展開されてしまう。

  * bash-3.2 以下では declare a としただけで空の値で初期化される。
    unset 状態になるという事はないので注意を要する。

  * bash-3.2, bash-3.1 では source にプロセス置換を渡しても読み取ってくれない。
    つまり source <( ... ) としても何も起こらない。
    代わりに eval -- "$( ... )" すると良い。

  * bash-3.2 -- 3.1

    ref #D0857
    10 以上のファイルディスクリプタで使用されている物に対して
    リダイレクションで新しい出力先を設定しようとしても失敗する。
    これは fd>&- として一旦閉じてからリダイレクションすれば良い。

    bash-3.1 では一度開いた fd を改めて開き直したり、
    或いは閉じたりすることができない。
    exec 34>/dev/null とすると、exec 34>&- としても閉じれないし、
    exec 34>a.txt としても /dev/null に繋がったままになってしまう。

  * bash-3.1 では a=(""); echo "a${a[*]}b" | cat -A とすると
    a^?b となって謎の文字が入る。echo "a""${a[*]}""b" 等とすれば大丈夫。

  * bash-3.1 では declare -f funcname の funcname に + 等の文字を含める事ができない。
    一応 declare -F 等とすれば名前は列挙される様ではある。
    bash-3.2 未満では declare -f ではなく type -t で関数かどうかの確認を行う。

  * bash-3.1 での bind -r について
    bind -sp とすると "\M-[C" 等と表示されるがそれに従って bind -r '\M-[C'
    としても削除する事は出来ない。代わりに bind -r '\e[C' とすれば削除できる。

    eval -- "$(bind -sp | awk '/M-\[/{sub(/:$/,"",$1);gsub(/\\M-/,"\\e");print "bind -r " $1}')"

  * bash-3.1
    呼出先の関数で、呼出元で定義されているのと同名の配列を作っても、中が空になる。
    > $ function dbg/test2 { local -a hello=(1 2 3); echo "hello=(${hello[*]})";}
    > $ function dbg/test1 { local -a hello=(3 2 1); dbg/test2;}
    > $ dbg/test1
    > hello=()

    これは bash-3.1-patches/bash31-004 で修正されている様だ。

  * bash-3.1

    - ${#arr[n]} は文字数ではなくバイト数を返す様だ。

    - "${var//%d/123}" は動かない。"${var//'%d'/123}" 等とすればOK。

    - bash-3.0, bash-3.1: local GLOBIGNORE すると、
      関数を出てもパス名展開の時にその影響が残っている。
      (直接変数の中身を見ても何もない様に見えるが。)
      unset GLOBIGNORE などとすると直る。

  * bash-3.0

    - ${#param} は文字数ではなくバイト数を返す、という事になっているらしいが、
      実際に試してみると文字数になっている (bash-3.0.22)。
      何処かで patch が当たったのだろうか。まあいいか…。

      (※${param:ofs:len} は 3.0-beta1 以降であれば文字数でカウントされる)

    - declare -p A で改行を含む変数を出力すると改行が消える。
      例: 一見正しく出力されている様に錯覚するが "\ + 改行" は改行のエスケープではなく、
        長い文字列リテラルを二行に書く為の記法である。つまり、無視される。
      $ A=$'\n'; declare -p A
      | A="\
      | "

  * msys1, msys2: var='^M' とすると CR が消えてなくなる。
    msys2 では var=$'\r' とすれば大丈夫。また変数に入っている物も大丈夫。
    例えば var=$_ble_term_CR はOKである。
    msys1 ではそれでも駄目。local var=$'\r' とすれば大丈夫。
    変数に入っている物でも local を付けないと消滅してしまう。

  * msys1 では named pipe が未対応。従ってプロセス置換も使えない。

bashbug 算術式周りのバグと注意点

  * bash-3.0 - 4.4.7 算術式:

    条件分岐で実行されない部分でも配列の添字は 0 以上でなければならない。
    例えば以下はエラーになる @ bash-3.0, 3.1, 3.2, 4.0, 4.2, 4.3
    ((a=-1,a>=0?b[a]:0))

    もっと調べてみると配列の添字に限らず分岐しない所で式が評価されている様だ:

    + 三項条件式で起こる。true/false branches のどちらでも起こる。&& や || では起こらない。

      $ echo 'x=a=1; ((a=0,0?x:0)); echo $a' | bash      1 (bash-3.0 - 4.3)
      $ echo 'x=a=1; ((a=0,1?0:x)); echo $a' | bash      1 (bash-3.0 - 4.3)
      $ echo 'x=a=1; ((a=0,0&&x)); echo $a' | bash       0 (bash-3.0 - 4.3)
      $ echo 'x=a=1; ((a=0,1||x)); echo $a' | bash       0 (bash-3.0 - 4.3)

      $ echo 'x=a=1; ((a=0,0?b[x]:0)); echo $a' | bash   1
      $ echo 'x=a=1; ((a=0,0&&b[x])); echo $a' | bash    0 (bash-3.0, 3.1, 4.2+ / bash-3.2, 4.0, 4.1 は別の bug で 1)

    + 括弧で囲めば何も起こらない様だ。

      $ echo 'x=a=1; ((a=0,0?(x):0)); echo $a' | bash    0 (bash-3.0 - 4.3)
      $ echo 'x=a=1; ((a=0,1?0:(x))); echo $a' | bash    0 (bash-3.0 - 4.3)

      $ echo 'x=a=1; ((a=0,0?(b[x]):0)); echo $a' | bash 0 (bash-3.0, 3.1, 4.2+ / bash-3.2, 4.0, 4.1 は別の bug で 1)

  * bash-4.2 算術式 seg fault

    https://lists.gnu.org/archive/html/bug-bash-gnu/2013-01/msg00036.html
    https://lists.gnu.org/archive/html/bug-bash-gnu/2013-01/msg00042.html
    https://lists.gnu.org/archive/html/bug-bash-gnu/2013-01/msg00043.html

    算術式の中で配列要素の参照に関係して特定の式構造になると segfault する。
    多分、配列要素の読み出しの次の token が整数または代入式の左辺だと落ちる。
    配列要素を参照したら一旦算術式を閉じるのが良い。
    $ ((a=b[0],c=0))

    以下でも segmentation fault が起こった。
    $ (((klen=node[nofs+k])<0||(kbeg=j-klen)>end0))
    $ (((a=node[1])<2||(b=3)))
    $ (((a=node[1])||(b=3)))
    $ (((a=node[1])<2||b)) # OK
    $ (((a=node[1])||b))   # OK
    $ (((node[1])||(b=3))) # OK
    やはり起こる条件が良く分からない。
    代入式の右辺に配列が来て、
    その後に代入式の左辺に token があると駄目なのか?

  * bash-4.1, 4.0, 3.2: 算術式分岐内配列参照

    bash-3.2.48 で以下の評価に失敗する。
    bash-3.1 以下は大丈夫。bash-4.2, bash-4.3 も大丈夫。bash-4.0 は駄目。

    dbg=()
    ((a=0,b=0,0&&(a=1,x=dbg[0],b=1))) # NG
    配列添字で値を参照 (代入はOK) すると、その部分以降が必ず実行される。
    複合代入であっても駄目である。

    bash-4.0 bash-4.1 でも以下の式で必ず _pos[1]++ が実行されていた。
    ((_eoc[2]&&(_pos[0]=0,_pos[1]++)))


    $ ((a=0,b=0,0&&(a=1,x=dbg[0],b=1))); echo $a $b               → 0 1
    $ expr="a=1,x=dbg[0],b=1"; ((a=0,b=0,0&&expr)); echo $a $b    → 0 1
    $ expr="a=1,x=dbg[0],b=1"; ((a=0,b=0,0&&(expr))); echo $a $b  → 0 1

    更に配列添字も必ず評価されてしまう。
    ((i>=0&&a[i])) は i が負であっても参照される。
    そして、((i>=0&&a[i--])) をすると更に副作用も起こる。

  * bash-4.1 以下 (bash-3.0 ～ bash-4.1)

    配列要素に対して修飾付きのパラメータ展開を実行すると、
    配列添字に指定した算術式が2回評価される。
    例えば "${arr[i++]#a}" を実行すると i が 2 増える。

  * bash-4.0 他 算術式を使って値を計算する時の注意

    算術式の中に初期化されていない変数…例えば ret 等がある場合、
    ret の中身に不正な数式的な物が入っていたりコマンド置換が入っていたりすると、
    文法エラーになったりこれが eval されてしまう。
    実際に 4.0 では 'あ' という文字列が入っているだけでエラーになる。
    (より上の version では識別子名と解釈されているからなのかエラーにはならない。
    しかし、今迄は毎回「あ」等という変数を探していたのだろう。

  * bash-3.1, 3.0

    ?: 演算子の中身は全てカッコで囲まないと構文エラーになる。例えば、
    $ bash-3.1 -c '((a?(b=123):c?(d=321):1))'
    bash-3.1: ((: a?(b=123):c?(d=321):1: syntax error in expression (error token is "?(d=321):1")

bash 配列の宣言に関する仕様・バグと注意点

  * arr=(1 2 3) func の形式で配列をシェル関数に渡そうとすると、
    export arr='(1 2 3)' で渡されてしまう。

  * 既に配列変数になっている物に対して
    export var=value や typeset -x var=value をしても、
    呼び出された別コマンドからは環境変数として見えない。

    $ a=(1 2 3)
    $ (export a=1; bash -c 'declare -p a')
    bash: 0 行: declare: a: 見つかりません

    新しい変数として導入すれば良い。
    例えば関数内で新しく local -x var=value とするか、
    var=value command の形式で呼び出すようにすれば良い。

    $ (a=1 bash -c 'declare -p a')
    declare -x a="1"

  * BUG bash-4.0, 4.1 (local), bash-3.0 ～ 3.2 (declare)

    a[${#a[*}]=value もしくは ble/array#push a value するとき、
    その配列を事前に宣言したければ local -a a のように -a を指定する必要がある。

    [問題]

    bash-4.1 以下で関数内で local arr しただけで ${#arr[*]} が 1 になる。
    その後、要素 #1 を設定しても ${#arr[*]} は 1 のままである。
    これの所為で以下のコードが破綻する:
      arr[${#arr[*]}]=...
    常に要素 #1 にしか代入されない事になる。

    bash-3.2 以下では関数内に限らず declare arr しただけで ${#arr[*]} が 1 になる。
    但し、要素[1] に設定をすると ${#arr[*]} は 2 に増加する。
    従って余分な空要素があるものの ble/array#push は失敗しない。

    [解決]

    local -a arr とすれば問題は起きない。
    ※local arr=() としても問題は起きないがこの記述だと
      今度は bash-3.0 で文字列 '()' が代入されて問題である。

  * BUG bash-3.0: local a=(...) や declare a=(...) とすると、a="(...)" と同じ事になる。
    a=() の形式ならば問題ない。

  * BUG bash-3.0: 今まで local -a a=() の形式ならば問題ないと信じてきたが、どうやら
    local -a a=('1 2') が local -a a=(1 2) と同じ意味になってしまうようだ。
    a="123 345"; declare -a arr=("$a"); このようにしても駄目だ。
    a="123 345"; declare -a arr; arr=("$a"); こうする必要がある。

  * 配列要素を連結する時

    動く例:
      IFS= eval 'value=${arr[*]}'
      IFS= eval 'value="${arr[*]}"'
      IFS= eval 'local value="${arr[*]}"'

    動かない例 (間に空白が入ってしまう):
      IFS= eval 'local value=${arr[*]}'

  * BUG bash-4.0..4.4: ローカルで local -a x; local -A x とすると segfault する。
    ref http://lists.gnu.org/archive/html/bug-bash/2019-02/msg00047.html, #D0924

    f() { local -a a; local -A a; }; f # これで segfault する

    - 別のスコープで定義された配列を -A とした場合には起こらない。
    - 同じスコープの場合でも unset a してから local -A a すれば大丈夫。
    - グローバルでは起こらない。

  * BUG bash-3.0..3.2: ^? や ^A の値が declare -p で ^A^? や ^A^A に変換されてしまう。

bash_features

  * time -- について。
    bash-5.1 以降で time -- command が可能。
    bash-4.2 以降で time -p -- command が可能。
    (bash-4.1 以前では time には -- を指定できない)

  * bash-5.0 以降: EPOCHREALTIME, EPOCHSECONDS
    ref #D0925

  * Bash-5.0 では POSIX に倣ってパラメータ展開結果に \ が含まれる場合に
    グロブパターンと見做す様に変更されたが、
    これにより問題が起こり POSIX が記述に誤りがあることを認めて修正した。
    結局 Bash-5.1 で 4.4 と同じ動作に戻すつもりらしい。
    https://lists.gnu.org/archive/html/bug-bash/2020-03/msg00051.html

  * ${param@a} (attributes) 及び他の transformation は bash-4.4 より

  * read -t timeout

    * -t オプションの対応は 2.04 である。
    * TMOUT 変数の対応は 2.05b-alpha1 以降である。
    * 小数を指定できる様になったのは 4.0-alpha 以降である。
    * `-t 0' で次の文字を読み取り可能かどうかチェックできるのは 4.0 以降である。
    * 4.3 以下では timeout した時に読み取った入力は失われてしまう。
      4.4 以降では timeout するまでに読み取った内容が指定した変数に格納される。

  * グローバル変数に対する属性指定 declare -g は bash-4.2 から

    更に bash-4.3 には declare -gA を二度行うとクラッシュするバグがあったらしい。
    現在の最新版ではそのような振る舞いは見られない?

  * 連想配列 declare -A は bash-4.0 から

  * BASHPID 何と Bash 4.0 以降の機能らしい ref #D1200

    ------------------------------------------------------------------------------
    This document details the changes between this version, bash-4.0-alpha,
    and the previous version, bash-3.2-release.

    c.  There is a new variable, $BASHPID, which always returns the process id of
        the current shell.
    ------------------------------------------------------------------------------

    と思ったら既にソースコードの一部にも Bash 4.0 以降であるとの注記があった。

  * command |& command は Bash 4.0 以降なので使えない。

  * printf -v var %s value

    bash-3.1 以降で使える。
    bash-4.1 以降で var として配列要素 (arr[123] 等) を指定できる。

  * ${!arr[@]} は bash-3.0 より

bash_tips

  * swap の仕方
    local a=$b b=$a
    local や declare などは必要である。

  * [[ ]] の中で =~ で設定された BASH_REMATCH は直後の式で参照できる。
    つまり [[ $text =~ $rex && $BASH_REMATCH == ... ]] の様にできる。

    bash-3.0 から bash-4.4 までで以下のコマンドで確かめた。

    [[ "" =~ ^ ]]; [[ $BASH_REMATCH ]]; [[ a =~ a && $BASH_REMATCH ]]

  * 構文関係でマニュアルに載っていないものが色々ある。

    * }, fi, done, esac の直後に }, fi, done, esac, do, else, elif, then が来る場合はセミコロンは省略できる。

    * for ((expr1; expr2; expr3)) [ ; ] { list; } は比較的有名だが、
      for name [in name]; { list; }
      select name [in name]; { list; } も使える様だ。

    * select name [ [ in word ... ] ; ] do ...; done
      ※in word ... がない場合、do の前のセミコロンは省略可能である。

  * "$(case *) ;; esac)" に対応する可能性があるかと思ったが動きはない
    ref http://lists.gnu.org/archive/html/bug-bash/2017-11/msg00002.html, #D0928

  * function @() { ...; } は成功するが実際には関数は作られない
    ref http://lists.gnu.org/archive/html/bug-bash/2017-03/msg00220.html, #D0927

  * declare -c var という隠し属性がある。Capitalize する。Bash 4.0+
    変数の値の各単語について適用するのではなく本当に最初の文字にしか適用されない。
    この中途半端な機能の為に恐らくマニュアルに載っていないのだろう。

    ソースコードを確認すると他にも declare -G var という謎機能が存在する。
    同じ文脈に局所変数があればそれに設定してそれ以外ならば大局変数に設定する。
    これは丁度他の言語のレキシカルスコープを真似た物という事だろうか。

  * nameref & extra expansion
    気付いたのだが declare -n ref='arr[...]' の ... に任意の式を記述できる。
    これによって新しい乱数変数も定義できるのでは。例えば。

    declare -n var='var_[var_=RANDOM*RANDOM,0]'

    但し、算術式なので整数以外は代入できない。
    更に、$() でプログラムを実行することすらできる。
    然し、任意の文字列という訳には行かないのが問題。
    $() はサブシェルで実行されるので副作用を残す事ができない。

  * let & brace expansion
    これは算術式のページに既に書いた。

  * rcfile を処理している間は

    * 関数内で FUNCNAME, BASH_SOURCE, BASH_LINENO を確認するとFUNCNAME
      の最後の要素は "source" であり、BASH_LINENO の最後の要素は 0 に
      なっている。BASH_SOURCE の最後の要素がファイル名である。

    * bash-4.4 以降では $- に s (標準入力から読み取り中) が含まれない
      事で確かめられる。bashrc を抜けてPROMPT_COMMAND を実行する時には
      s が含まれる様になる。bash-4.4 未満では s は決して含まれない事に
      注意する。

    まとめると以下の様な関数で rcfile 中で走っているかどうかを判定できるのではないか。

    function ble/util/is-running-in-rcfile {
      [[ $- == *i* && ( _ble_bash -lt 40400 || $- != *s* ) ]] || return 1
      local nstack=${#BASH_LINENO}
      [[ ${BASH_LINENO[nstack-1]} == 0 && ${FUNCNAME[nstack-1]} == source ]]
    }


*******************************************************************************
    Memo
-------------------------------------------------------------------------------

2020-05-11

  * Bash の HISTTIMEFORMAT 振る舞いのまとめ [#M0017]

    ref #D1351

    * Bash は、HISTTIMEFORMAT の値に関係なく、コマンドの時刻を常に内部
      的に管理している (#0x10 の件を考えると文字列で記録している疑いが
      ある)。HISTTIMEFORMAT が設定されている時、history コマンドで出力
      されるコマンド履歴に時刻が出力される。

    * 変数 HISTTIMEFORMAT が存在する時 (空文字列や unset も含む)、Bash
      は履歴ファイルに #%s の形式で時刻を保存する。

    * 履歴ファイルからコマンドを読み取る時、直前に #%s があればそれを
      コマンドの時刻とする。それ以外の時はコマンドの時刻は bash の起動
      時刻とする。これは HISTTIMEFORMAT の状態に関係ない。

      履歴ファイルから読み取る時には単一行モードと複数行モードがある様
      だ。変数 HISTTIMEFORAMAT が存在 (空文字列や unset も含む) してか
      つファイルの先頭行が #%s の時に複数行モードになる。

      時刻行は "#数字" で始まっているかどうかで判定する。先頭または #
      と数字の間に余分な空白が含まれている場合は時刻行ではない。"#整数
      " の後に別の文字列があったとしてもそれは無視される。但し、"#0"
      で始まっている時だけは行全体を時刻と見做すようで、余分な文字列が
      あると history で出力する際にエラーになる。

    * history コマンドの出力は HISTTIMEFORMAT が非空文字列の時にタイム
      スタンプが出力される。

      HISTTIMEFORMAT が設定されていても空文字列の時には処理は行われな
      い。これは通常の見た目の振る舞いでは区別がつかない (処理していて
      も処理していなくても出力に違いは出ない) が、履歴ファイルに #0xxx
      の様な無効なタイムスタンプが含まれていた時の振る舞いで分かる。

    * shopt -s lithist は、for 等の文法的に複数行に跨るコマンドについ
      て、そのままの形でコマンド履歴に登録する。単にコマンドラインで複
      数行を入力して実行しても改行で分割してコマンド履歴に登録される。

      これはコマンドを実行した時に Bash プロセスの内部のコマンド履歴に
      登録する際に影響を与える物であって、履歴ファイルへの書出しや履歴
      ファイルからの読み出しには影響を与えない様である。

    現在の ble.sh サポートの制限について。

    * mlfix: bash-4.4 以降では複数行コマンドを history -r で読み出せるが、
      bash-4.3 以前では複数行コマンドは history -s で構築せざるを得ない。
      従って複数行コマンドに関しては正しくコマンド時刻を復元できない。

2020-05-06

  * trap: DEBUG/RETURN trap のまとめ [#M0016]

    DEBUG trap は設置した関数内で有効。set -o functrace (set -T) が設
    置されている時または呼び出される関数に declare -tf を設定している
    時にのみ呼び出される関数に継承される。trap -p の出力は現在処理して
    いる関数毎に異なる (継承しない場合は DEBUG/RETURN trap に対しては
    何も出力されない)。

    DEBUG: bash-4.3 以下では設置した関数の呼び出し元には影響はないが、
    bash-4.4 以降では呼び出し元の DEBUG trap も上書きする。DEBUG trap
    を削除した場合には、呼び出し元には影響は与えない。DEBUG trap の中
    では DEBUG trap は発火しない。

    RETURN:

    * BASH_COMMAND には最後に関数内で実行したコマンドが入っている。
      return を使った場合にはそれが、関数の末端で終わった場合には最後
      のコマンドが入っている。
    * RETURN trap は関数内部で実行されるので、return を呼び出して終了
      ステータスを変更する事ができる。但し、条件をつけないと、RETURN
      trap の return に対して再び RETURN trap が発火して無限ループにな
      るので注意する。
    * RETURN trap の中では RETURN trap は発火しない。それ以外の trap
      では発火する。

    BASH_LINENO, BASH_SOURCE, FUNCNAME についてはまだ詳しく調べていない。

2020-04-14

  * ${###} 等のパラメータ展開・変数展開について [#M0015]

    Bash のパラメータ展開 #D1330

    <param>

    - 位置パラメータ: 1 2 ...
    - 特殊パラメータ: * @ # ? - $ ! 0 _
    - 変数名: /_[[:alpha:]][[:alnum:]]*/ の形式
    - 配列名[添字]
      添字はシェル展開の対象で配列の時は算術式の対象
    - 配列名[@], 配列名[*]

    <modifier>

    - @A 変数の定義
    - @a 変数の属性
    - @Q @E @P 値を加工する
      これらの ops は展開の対象ではない。つまりvar=A として ${xxx@$var} とはできない。
    - #, ##, %, %%
    - /, //, /#, /% (クォートとの兼ね合い)
    - ^ ^^ , ,, ~ ~~
      Note: ~ については https://qiita.com/t_nakayama0714/items/80b4c94de43643f4be51 に書いてあった。
    - = + - ? := :+ :- :?
    - :offset, :offset:length

    * $<param>
      Note: 配列, 2桁以上の位置パラメータは使えない。

    * ${...} の例外規則

      * ${#<param>}
        ${#@}, ${#*}, ${#a[@]}, ${#a[*]} は要素の数。
        それ以外については文字の数。

      * ${!var@} ${!var*}

      * ${!arr[@]} ${!var[*]}

    * ${<param><modifier>}
    * ${!<param><modifier>}

      * ! で始まる物については ${<param>} を変数名とする。

        Note: <param> は !, $ 以外でなければならない様だ。

        $@ $* ${arr[@]} ${arr[*]} の時には "$*" などを変数名と見做す。
        つまり、普通に ${!arr[*]##} 等とすると要素が1個の時以外はエラーになる。
        (arr=(a b c); IFS=; abc=4321; echo "${!arr[*]##}") 等とすると動く。
        (arr=(a b c); IFS=; abc=4321; echo "${!arr[@]##}") は動かない。

    ★${!#} で最後の引数を取れる。${@:$#} でも行ける。
      但し、引数がない場合は $0 に展開される事に注意する。

2020-04-07

  * bashrc に於ける history の操作について [#M0014]
    初回の history -nrs の実行時に "未初期化" であれば初期化を行う。
    "未初期化" の判定は履歴がその時に空であるかどうかによる。

    * "未初期化" の時に history -awcd を呼び出した時は何も実行しない。
    * "未初期化" の時に history -nrs を呼び出した時は、
      履歴ファイル (HISTFILE) を読み取って初期化した後に要求された操作を実行する。
      これは bash の動作とは異なる。bash は履歴ファイルを読まずに操作を実行する。
      その後で何らかの条件で履歴ファイルの読み取りを最初のプロンプト表示の前に行う。
    * history -p に関しては "未初期化" かどうかに関係なく、そのまま実行する。

    bashrc の中で history -r を実行すると履歴の倍加が発生する。
    但し、実行時だけで記録される履歴ファイルは倍加しない。

2019-06-10

  * history -na の動作に就いて [#M0013]

    * どのコマンド以降を新しいものとして取り扱うのか。という事について。
      特に他の Bash が bash_history に書き込んだ新しいコマンドを読み取った時、
      次に自分が history -a する時にどの範囲のコマンドを追加するのだろうかという事など。

      まとめると Bash の動作は恐らく以下の様になっている。
      先ず Bash は2つの変数を使っている。ここでは read_index と write_index と呼ぶ事にする。
      read_index は history -n で HISTFILE から次に読み出すべきコマンドの行番号を保持する。
      write_index は history -a で次に HISTFILE に書き込むべき history 内のコマンドの番号を保持する。
      Bash の起動時には read_index も write_index も同じ値に初期化される。
      history -n を実行すると read_index は HISTFILE の行数に再設定される。
      write_index は読み取った行数だけ増加する。
      history -a を実行すると write_index は history の項目数に再設定される。
      read_index は書き込んだ行数だけ増加する。

      この動作に従うと history -n; history -a や
      history -a; history -n を実行すると問題が生じる事になる。
      書き込み済みのデータ・読み取り済みのデータが混ざった時に正しく範囲を表現できない。
      この事が理由で巷にある動機の設定では history -a; history -cr を実行しているのである。

    * HISTCONTROL=erasedups
      試してみたが erasedups が設定されていたとしても history -n で新しく読み取った
      コマンドと同じ名前のコマンドを削除するとかそういう事は別にしない様である。

2019-02-13

  * keymap: 以下のキーについては既定では同じ動作になる様に設定する事にする [#M0012]
    ref #D0929, #D0752

    - DEL C-? / BS C-h
    - NUL C-@ C-SP
    - RET C-m
    - TAB C-i
    - C-_ C-DEL C-BS

2019-01-01

  * vi: inclusive/exclusive motion の実装に関して [#M0011]

    exclusive な motion は exclusive-goto.impl を呼び出す。
    inclusive な motion は inclusive-goto.impl を呼び出す。
    何れの場合も範囲を修正の後に exclustive-range.impl に委譲する。

2018-08-31

  * decode: 端末の送信するキーシーケンスについて [#M0010]

    * back (BackSpace)
      xterm は back に対して BS (C-h) を送る。
      C-back に対して DEL (C-?) を送る。
      一方で、mintty, RLogin では back に対して DEL (C-?) を送る。
      C-back に対して C-_ を送る。

    * modifyOtherKeys(2)

2018-08-05

  * compgen に指定した単語のクォート除去に関して [#M0009]

    参考: #D0714

    生成するコマンドの種類と、バージョンによってクォート除去されたりされなかったりする。
    以下に、クォート除去されることを期待してクォートしても問題がないかをまとめる。

      compgen -A command   クォート不可
      compgen -A directory クォート不可 (Bash-4.3 以降でクォート除去されない※1)
      compgen -A file      クォート不可 (Bash-4.0, 4.1 でクォート除去されない※2)
      compgen -A function  クォート可
      compgen -A variable  クォート可
      compgen -A arrayvar  クォート可

    ※1 バグと思われる。ble をロードしていると何故かクォート除去されている。
      然し、--norc や ble ロードなしで実行するとクォート除去されない。
      クォート除去が実行されなくなってしまう条件が分からないのでこれは使わない。

    ※2 バグと思われる。

2017-10-31

  * ble 関数の典型的な終了ステータスについて [#M0008]

    127 適切な widget が見つからなかった
      (由来: Bash でコマンドが見つからなかった時の値)

    126 widget を呼び出すことができなかった
      未使用

    125 widget を呼び出したが適切な処理が見つからなかった
      __defchar__ に登録した widget がこれを返したとき
      次のハンドラを用いる。具体的には __default__ の呼び出しを試みる。

    147 ble/util/idle の処理に於いて条件待ち状態に入る時や、
      widget に於いてユーザの入力を待つ為に、
      自発的に一時中断した時に返す値。

      ユーザの入力を非同期に待つ為に一時停止した
      vi-mode のオペレータが 148 を返したとき
      後処理を実行せずにそのまま抜ける (由来: 128+SIGTSTP)

    148 ble/util/idle や isearch や complete に於いて、
      ユーザ入力を処理する為に一旦現在の処理を中断する時に返す値。

    124 プログラム補完において補完の再実行を要求する
      (由来: これは Bash の仕様に倣った)

    27 widget の動作がユーザによってキャンセルされた (由来: ESC = 27))

    6 ble-update で更新の必要がなかった時に内部的に使用 (由来: ACK = 6)

2017-10-18

  * ble-decode: widget に関して [#M0007]

    __defchar__ および __default__ に登録された widget が 125 を返した時、
    その入力に対する適切な処理が見つからなかったことを表します。
    この時、次のハンドラの探索が行われます。
    次のハンドラがない場合には対応するものが見つからなかったというエラーになります。

2017-09-24

  * vi-mode 以下は現在のところ対応しない予定である [#M0006]

    * 2017-09-24 vi-mode: % で用いる matchpairs には現在対応しない

    * 2017-09-17 vi-mode (insert mode/newline):
      インデントを挿入するが何もしなかった時にそれを削除することには対応していない。

      これは実際の所、挿入モードにおける移動と抜ける時の処理において、
      細工を行えば対応できる。現在の挿入モードの操作の繰り返しの記録の仕組みも使えるが、
      もっと別の仕組みを用意しても良い気がする。

    * 2017-09-12 vi-mode: タブ文字上にカーソルがある時のカーソルの表示位置

      後、気付いたことはタブ文字に居る時のカーソル位置は、
      ノーマルモードにいるときはタブ文字の最後の位置である。
      要するに p で挿入される位置を示しているとも言える。
      でも全角文字の場合にはちゃんと全角文字の先頭にカーソルが来る。
      この動作は分かりにくいし更に言うと現状の ble.sh の描画コードでは対応していない。
      これには取り敢えず対応しないことにする。

    以下は積極的に対応する予定はない。
    将来的に対応する場合の注意点がある場合も含む。

    * 2017-10-11 M ( ) [[ ]] { } :s :tag
      これらのコマンドは "ジャンプ" なので、$flag なしで実際にジャンプに成功する場合には
      set-local-mark 96 をする必要がある。

    * done: 2017-10-09 取り敢えず今の所はスクロール (C-b C-d C-e C-u C-y など) には対応しない
      →これは #D0886 で対応した。

2017-09-08

  * vi-mode: 以下のリンクで重要そうなコマンドの一覧が見られる [#M0005]

    http://qiita.com/sfuta/items/0de4ead865c15e9e9b68 ?
    http://qiita.com/sfuta/items/2d646396a6117c8e53e5 g? z?
    http://qiita.com/sfuta/items/fd78f3ece8861f8142ee C-w? [? ]?
    http://vim-jp.org/vimdoc-ja/vimindex.html
    http://vim-jp.org/vimdoc-en/vimindex.html

2015-11-28

  * デモ画像の作り方 [#M0004]

    * ble-0.2 のデモ画像はキャプチャソフトを使った (ref #D0926)

      - Cygwin の mintty を用いた。
        画面の幅は56列にし文字の大きさは14程度が良い。
      - キャプチャソフトには LICEcap というソフトウェアを使った。
      - キー入力を表示するソフトには KeyCastOW を改造した物を用いた
        https://github.com/akinomyoga/KeyCastOW

      ble-0.1 の時に行った基本的な操作に加えて、
      ble をダウンロード・展開して試してみるところも含めた。

    * ble-0.1 のデモ画像は ttyrec & seq2gif を用いて作成した

      準備
      $ # PS1=$'[\e[4;38;5;202mfoo@bar\e[m \\j \\W]\\$ '
      $ TTYREC=1
      $ ttyrec demo.tty

      echo hello, world
      printf hello
      [[ a == b ]]
      echo "hello $(echo bash $(echo world))"
      C-r for
      echo 'select, copy and paste' コピーする
      echo insert mode -> overwrite mode
      ls
      echo complete ble-TABdTAB histexpand !#:2
      echo "$HIST[TAB]"

      $ seq2gif -f 0 -b 15 -h 14 --render-interval=10 -p rosa --play-speed=1.5 < demo.tty > demo2.gif

      gif のフォーマット的には 0.01s よりも小さな遅延は設定できない。
      また、現実のブラウザでは 0.02s (50fps) よりも小さな遅延にすると強制的に 0.10 になってしまう。
      更に、Safari や Internet Explorer では 0.06 (16.67fps) よりも小さな遅延は 0.10 になってしまう。
      更に、Windows に附属している viewer では 0.10 よりも小さな遅延は全部 0.10 になってしまう。

      [[Frame Delay Times for Animated GIFs by humpy77 on DeviantArt>http://humpy77.deviantart.com/journal/Frame-Delay-Times-for-Animated-GIFs-214150546]]
      [[How to match animation rate of gif files accross browsers (Fenrir Developer's Blog)>http://blog.fenrir-inc.com/us/2012/02/theyre-different-how-to-match-the-animation-rate-of-gif-files-accross-browsers.html]]
      [[Nullsleep | Jeremiah Johnson - Animated GIF Minimum Frame Delay Browser Compatibility Study>http://nullsleep.tumblr.com/post/16524517190/animated-gif-minimum-frame-delay-browser]]


2015-08-14

  * [memo] builtin check [#M0003]

    eval "grc --color --exclude=./test '\b(builtin[[:space:]]+)?$command\b' | grep -Ev '\bbuiltin[[:space:]]+$command\b'"

  * [memo] leak variables check [#M0002]

    set | sort | sed -e '/()[[:space:]]*$\|^_\{0,1\}\(BLE\|ble\)/d' -e '/^[[:alnum:]_]\{1,\}=/!d' > a.txt

  * [memo] 解析(ble-syntax/parse)の際の原則 [#M0001]

    データ配列とは _ble_syntax_stat, _ble_syntax_nest, _ble_syntax_tree を指すとする。
    或る点 p1 から或る点 p2 に解析を進める場合を考える。

    1 この時データ配列に対する変更は p1-p2 (exclusive) の間にだけ行われる。
      これは解析状態の復元と再開が適切に動作する為に必要である。

    2 解析の過程でデータ配列に格納されている情報は使用しない。
      これは解析状態の一致チェックの為に必要である。
      データ配列の内容に依存して動作が代わる場合、
      解析状態が一致しても解析結果が異なってしまう可能性があり、不整合を生む。

      但し、_ble_syntax_nest については専用の関数を通して 0-p2 の任意の場所を参照しうる。
      これ(専用の関数を通して得られる情報)については
      解析状態の一致チェックの対象に含まれているからである。
      (_ble_syntax_nest の任意の情報を参照して良いという意味ではない。)

    tree-append および nest-pop に対する制限

      tree-append は _ble_syntax_tree[i-1] に格納を行う。
      従って上記の条件1から p1<=i-1 つまり p1+1 <= i である必要がある。
      これは少なくとも 1 文字 i を進めてからでないと tree-append を呼び出せないという事である。
      nest-pop も内部的にそのまま tree-append を呼び出しているので同じ制限がある。

@todo
*******************************************************************************
    ToDo
-------------------------------------------------------------------------------

2020-11-11

  * syntax: $HOME 等の変数展開があるパスに対して simple-word/eval が重い問題

    中でグローバル変数の復元等の複雑な処理をしている。一回呼び出すだけならば良い
    が $HOME/.mwg/src/ble.sh/archive/layers ... 等の様なパスの着色で各ディレクト
    リの階層で展開を試みている場合に、何度も呼び出す事になると遅さがかなり目立つ
    ようになる。

    単語着色では determine-separated-path -> locate-filename ->
    highlight-pathspec という具合に三段で処理していて各段で毎回 eval しているの
    で特に重い。これは処理を統合して高速化する余地もある。コードが汚くなるという
    問題はある。よく考えたら現在の実装では locate-filename は特に eval は実施し
    ていない。単に : で区切っているだけである。なので locate-filename に関しては
    気にしなくても良い。

    或いは複数のパスを一度に eval する機能があっても良いのかもしれない。その場合
    に結果をどの様に返すのかは難しい。複数単語に展開される事を考えて既に一つの
    eval の時点で ret が配列だからである。各パスの最初の単語だけを返す事にするか、
    或いは全ての単語を全部混ぜて一つの配列に返すか。一つの配列に格納する場合には
    各パスに対応する index の範囲を返す事ができるがインターフェイスとしては分か
    りにくい。

  * bashbug: builtin で while という名前の builtin を load すると他の builtin が
    使えなくなる。

    ? 使えなくなるのは、同じ dll の中の物のみなのか或いは全ての dll の loadable
      builtin が使えなくなるのか。

    ? while 以外にも問題を起こす名前は存在するか。

    ? 影響を受ける builtin はキーワードと一致する名前の物のみか或いは全てか。

2020-11-07

  * PATH=path1:path2:path3 の時に着色が最後の要素にしか適用されないし、また補完
    は全然働かない。全く動かないのならばまだしも中途半端に動くのは変なのでちゃん
    と対応したい。

    →着色に関しては #D1409 で議論する。

    complete に関しては元の bash ではちゃんと動いているので尚の事問題である。

  * highlight: declare 等に指定したオプションの着色についても対応する。

  * highlight: 条件コマンドの中での着色が効かない。着色しても良いのではないだろうか。
    今まで実装していなかったのは正しい文法解析や入れ子などの処理が面倒だったから。

    今確認してみると 条件コマンドの中でも ( && || ) などは特別な意味を持つ様であ
    る。更に & や | を使うとエラーになる。<< 等のリダイレクトもエラーである。必
    ずしも空白で単語が区切られる訳ではない様なので、これに関しては文法解釈のレベ
    ルで修正が必要になる。

2020-11-06

  * complete/mandb: progcomp で生成したオプションに関してもできれば desc を表示する様にしたい。
    progcomp に候補を生成させてもしオプションが含まれていて、
    かつそれが mandb の中に含まれているという事が分かった時に desc-raw を表示する。

    * git 等の場合には man git で得られるオプションと
      サブコマンドで得られるオプションは異なるので注意する。

  * complete/mandb: bash の場合にはビルトインコマンドのオプションまで混ざって列
    挙されてしまって駄目。bash 固有のオプションについてまとめたファイルを用意し
    ておくべきである。

    bash builtins のオプションに関しては builtin ... --help を使用すれば取得でき
    る。これはこれでまた解析の為のコードを書かなければならないが、bash の
    builtin に限れば形式が定まっているので解析のコードを書くのは難しくはない。

  * complete/mandb: 何と man git は .PP ... .RE 4 ... .RS でオプションを説明している。
    この様に .TP を用いない様な場合にも対応するべきなのだろうか。

  * complete/mandb: 同じ意味を持つオプションについて。
    同じ意味を持つ複数のオプションを分ける時に、
    分けてから sort するのではなくて sort してから分けるべきではないか。
    同じ意味を持つオプションは連続されて表示されて欲しい。

2020-11-02

  * source:file において substr を実装する。

  * filter を自前で実行する場合には cand/yield 内部での filter は不要。
    これは flag_source_filter=1 を設定して実行する事にした。

  * done: timjrd を README/acknowledgement に追加する。

  * complete_limit_reached にリークが存在している。
    ちゃんと source:* や candidates/generate などのコメントに使う変数を記述して、
    それから auto-complete の中で candidates/generate を呼び出す前に local で宣言する。

2020-09-27

  * SIGWINCH で job メッセージが出る

    SIGWINCH に対して次の様な job メッセージが表示される様になっている。
    [1] 終了 [[ -n $_dotfiles_blesh_manual_attach ]] | [[ -n $_dotfiles_blesh_manual_attach ]]
    これは .bashrc で設定されている関数の一部である。何故?

    調べてみるとそもそも関数ですらなくて、
    これは ble-attach を呼び出す条件の中に含まれているコマンドだと分かった。
    つまり SIGWINCH に際して ble-attach 関連の何かが呼び出されて、
    そして最後に呼び出された ble-attach の呼び出し時のコマンド文字列が何処かに保持されている?
    もしくは再び .bashrc が source されている可能性もあるがやはりそれは変だ。

    2020-10-10 今試してみると再現しない。

2020-09-07

  * complete: メニュー絞り込みが働いている状態で単一確定ができない場合がある

  * complete: メニュー絞り込みの着色が残ったままになってしまう事がある

2020-09-03

  * main: attach 戦略再考 [#T0004]

    attach の戦略に関する議論は以下にある。
      #D1382, #D1124, #D0940, #D0737

    | a 即attach。PS1 表示
    |   x PS1 が後で変更された時に問題。
    |   x 後の設定の出力が消滅する
    |
    | b 即attach。PS1表示はする。出力抑制はしない
    |   x PS1 が後で変更された時に問題。
    |   x 後の設定の出力と混ざる
    |
    | c 即attach。PS1表示はpromptまで遅延
    |   x keymap初期化に時間がかかる
    |
    | d 即attach。PS1表示する。出力は記録して後でdump
    |   x 後の設定が対話的なインターフェイスを起動した時に問題
    |   x 後の設定が /dev/tty に対して出力したら防げない
    |   x 後の設定が初期化進捗などを出力するとそれが実時間で反映されない
    |
    | e PROMPT_COMMAND。trap DEBUG/RETURN を用いて変更検知
    |   関連: #D1124, #D0737
    |   x DEBUG はコマンド直前の実行なので最終行での書き換えは防げない
    |   x RETURN は rcfile 末尾では発生しない
    |
    | f PROMPT_COMMAND の読み書きを hook する(非ネイティブな)手法はあるか?
    |   x ない
    |
    | g 他の hook/trap を用いて適切なタイミングを検出?
    |
    |   a EXIT はシェルが終了する時なので使えない
    |   b command_not_found も使えない
    |   c kill -USR2 $$ によるハンドラは?
    |     x 試すと rcfile 終了を待たずに次のコマンドですぐに実行される
    |     x kill ... & として別プロセスから投稿しても同様
    |   d bash (execute_prompt_command) を確認したが介入点は他になさそう
    |   e PS1 に kill 等を埋め込んで通知させる
    |     x これは PROMPT_COMMAND よりも信頼できない
    |
    | h PROMPT_COMMAND の中の最初のコマンドを DEBUG で検出?

    可能性があるとすれば h の手法である

    * trap DEBUG/RETURN の性質を熟知していないとユーザの設定した
      DEBUG/RETURN と干渉しない様にするのは難しいと考えられる。
      これは DEBUG/RETURN の枠組みを整えてからにする必要がある。

    rcfile で ble.sh をロードした時には rcfile を抜けた後の
    PROMPT_COMMAND 直前でアタッチを行う。

    * "PROMPT_COMMAND の最初のコマンド" は恐らく判定可能である。

      rcfile 及び最初の PROMPT_COMMAND 内にいる時は BASH_LINENO の最後の
      要素は0 になっている。rcfile 内にいる時は FUNCNAME の最後の要素は
      "source" になっている。更に bash-4.4 以降では rcfile から
      PROMPT_COMMAND に移る時に $- に s が追加される。

      PROMPT_COMMAND で何か実行するならば、最初のコマンドは必ず
      FUNCNAME[-1] != source になっている筈である。

    対話シェルで ble.sh をロードした時は "bashrc を抜けた直後" という戦
    略は使えないが、HISTCMD, ${_histcmd@P} を用いてユーザコマンドか
    PROMPT_COMMAND かの判定が可能である。

    * HISTCMD は ユーザコマンドを実行している時には $(history 1) の最初
      の要素に一致する。PROMPT_COMMAND を実行している時には常に 1 になる。

    * HISTCMD が unset されている場合には代わりに _histcmd='\!';
      "${_histcmd@P}" が使える (bash 4.4)。HISTCMD が unset されているか
      どうかは HISTCMD=A して値が変化するかどうかで判定できる。

2020-09-01

  * trap: ble.sh で上書きする問に元々存在していた trap はどうなっていたか。
  * trap: ble.sh を unload する時に復元する仕組みがあっても良いのではないか。

2020-08-27

  * 真面目に宣伝など考えるべきなのかもしれない。

2020-08-03

  * README: bashrc 設定方法の更新
    関連: #D1382, #T0004

    最終的には bashrc の何処に ble.sh を記述しても動くようにしたい。取
    り敢えず、比較的信頼できる手法が確立するまでは README の load 方法
    はそのままにしておく。

  * macOS で遅いという話 (reported by tigger04)
    https://github.com/akinomyoga/ble.sh/issues/58

    チェック項目は…

    * complete -r の代わりに
      shopt -u progcomp を指定したら改善するか?

    問題になっている可能性がある処理は
    ble/complete/progcomp/.compgen の builtin compgen 経由で呼び出される。
    特にユーザの定義した関数・コマンドは以下の関数経由で呼び出される。
    - ble/complete/progcomp/.compgen-helper-func
    - ble/complete/progcomp/.compgen-helper-prog

    上記の関数に benchmark を設定して stackdump なり何なりを計測する?

    ble/function#advice \
      around ble/complete/progcomp/.compgen-helper-prog \
      ''

    * 対策としては auto_complete の時には progcomp を実行しない
      というオプションを追加するというのが一つの可能性。
      bleopt complete_auto_progcomp=1 という事にするのが良い。

      実現可能性について。
      現在の呼び出し文脈が auto_complete かどうかを判定する必要がある。
      確認してみると comp_type に auto を含めている様である。
      実際にそうなっているのか確認する。

    情報をメールで貰った。
    メールではどの期間だけ complete -r を除いていたか分からないとしているが。

    2020-08-05 05:12:50 IST
    2020-08-05 05:13:27 IST
    2020-08-05 08:43:54 IST
    2020-08-05 08:43:57 IST
    2020-08-05 11:02:53 IST

    まあ、どの期間だけ有効になっていたのかという情報は実はそんなに重要ではない。

    眺めていて気づいた事。

    最後にユーザが入力を行ってから auto-complete が起動するまでに一定の時間がかかっている。
    大体 200ms の様な気がするが、しかし時間帯によって変わっている気もする。
    TAB 補完の場合にはこの delay が存在していない (0.06s) 事を考えると、
    これは history 補完にかかる時間という事だろうか。
    history 補完を無効にしたらこの delay は少なくなると判断して良いだろうか。

    補完が走らずに入力できている部分は history に match している入力であろう。

    どうも後半で時間がかかっているのは history の様に思われる。
    TAB 補完の時には 150ms 程度の遅延だが自動補完の時には 600ms に増えている。
    然し、その後で 200ms 程度に減少したりもしている。
    うーん。或いは単語の展開に時間がかかっているのかもしれない。

    * reject: 取り敢えず history 展開について高速化できないか確認する。

      | search-history-heavy について改善できないか考える。
      |
      | a 特に bash-5.0 以降では history -d range を用いて削除した上で
      |   history -p を実行すれば高速に過去の履歴を読み出す事ができるのではないか。
      |   →と思ったがよく考えたらどの範囲を削除したら良いのか不明である。
      |
      |   !string で一致させてその後その候補が当て嵌まらないと分かったとする。
      |   この時その候補以降の履歴項目を全て削除してから再度 !string で
      |   一致させれば良い様に思うが、最初に一致した候補が何番目の履歴項目か
      |   という情報がないのでどの範囲を削除したら良いのかが分からない。
      |
      |   a 例えば二分法で探索する? と思ったがこれだと二分の一の確率で
      |     サブシェルを生成しなければならない。明らかに非効率的である。
      |     或いは履歴展開に履歴番号も一緒に展開させる方法があったろうか。
      |     ない気がする。
      |   b やはり履歴番号を抽出できないかと思ったが、その様な履歴展開はやはりない。
      |     !string で一致させて単語指示子で履歴番号に置換できれば良かったが
      |     その様な単語指示子は存在しない。
      |   c 或いは、番号を指定しなくても一致した項目以降を削除する方法があれば良い?
      |     然し、history -d の引数はやはり数値であって履歴展開ではない。
      |
      |   この方針は難しいのではないかと思われる。
      |
      | b 或いは、history | grep を用いて最後に一致した項目を取り出す事ができるのではないか。
      |   但し、grep の時の問題は行区切りをどうするのかという事。
      |
      |   grep -z を用いれば NUL 区切りで判定する事が可能。
      |   然し、これは GNU extension である。安易には使えない。

      →うーん。調べてみたがちゃんと history search を呼び出す時に
      stop_check を指定しているのでユーザの入力があった瞬間に復帰する筈である。
      つまりこれ自体に時間がかかっていたとしても動きが遅くなる事はない筈?

      そもそも complete -r で解決したという事を考えると明らかに history は関係ない。

      然し、実際に timing log を見るとユーザの入力が待機されている…という事はない様な気がする。
      やはり現在の情報では history からの自動補完が問題になっていると考える根拠がない。
      従って、(不自然な方法を取ってでも) history 展開の高速化方法について考えるのは不毛である。

    * 再び報告があった。コンピュータ自体の処理が重くなっている時に動かなくなるという事らしい。
      普通に bash を動かしている時には問題ないという事を考えるとファイルアクセスが怪しい。
      ファイルアクセスしている箇所は沢山ある。特に着色のためのパス名展開である。

2020-06-04

  * 行数が極端に少ない時の動作 (横スクロール)
    bash-5.1 では横スクロールモードに移行するそうだ。

    そもそも現状で一行しか使える行がない時に何が起こるか。
    実際に試してみると (line 1) という表示だけになって
    更にその上に何か表示しようとするのでまともに表示できない。
    2行の場合にもまともに動かない。vi-mode の mode name で 1 行消費している為である。
    3行の場合にようやくまともに動く様になるが、それでも vbell が上に被ってしまう。

    横スクロールまで実装しないとしてもまともに動作する様にはしたい。
    そもそも (line N) という表示を省略する様にする?
    現状の実装ではプロンプトは必ず表示する様になっている。
    然し、プロンプトを表示するからこそ変な事になっているのである。

    a 行数が 1 になった時にはそもそもプロンプトを表示しない?
      然し、それだとプロンプトが何も表示されなくなってしまってそれはそれで変だ。

    b プロンプトは固定で残りの部分で文字列を編集する?
      これだとプロンプトが画面よりも長い時に何もできなくなる。

    c プロンプトも一緒に横スクロールする?

      | これに対応する為にはプロンプトの内部の各文字の配置を追跡する必要
      | が出てくる。
      |
      | Bash native でも \[...\] を使っている場合にどうやって数えるのだ
      | ろう? という疑問が残る。
      | →bash の動作を見たところ、prompt も一緒にスクロールする。しかし
      | prompt の途中位置でスクロールが止まる事はない。つまり、prompt は
      | 全体が表示されるか全く表示されないかのどちらかである。
      | →prompt 自体の長さが画面の横幅よりも大きい時には、常に横スクロー
      | ルした状態になってしまい、コマンドの1文字目は常に '<' に隠れて表
      | 示されない状態になる。また表示の乱れも発生する。

      Bash は横スクロールによってプロンプトが表示されるか、全く表示さ
      れないかのどちらかの状態になる。中途半端にプロンプトが表示されて
      いる状態はない。プロンプトの長さが画面の長さよりも大きい場合は対
      応しきれていない。

    * プロンプトが範囲内に収まらない場合には何が起こるのか?
      プロンプトの trace の時に高さを制限していただろうか。
      →駄目。制限はしていない。そもそも制限する事自体が自然な動作なのかも分からない。
      リサイズした時に上に流れた情報を参照したいという場合を考えれば、
      プロンプトは制限せずに上に流れてしまうという振る舞いが自然の気がする。

    現在のスクロールの実装はプロンプト行の次以降で実施する前提になっている。
    つまり画面の高さが1行しかない場合には色々弄らなければならない。
    プロンプトが複数行ある場合にはそれだけ多く画面の高さが必要になる。

    * プロンプトの出力は気にせずに実施する。画面がスクロールしても気にしない。
      →これを実行するとその他の panel の描画位置もずれてしまう事になる。
      他のpanelの内容を上書きしないように事前に空行を挿入しようにも、
      空行を挿入した時点で他の panel の内容が反対側の端から流れてしまう。
      という事を考えると、行数が厳しい時には他の panel は全て潰すのが現実的。

      潰す条件がプロンプトの高さが一行に収まりきらない場合、というのは
      プロンプトとして変な物を指定する場合を考えると制限が強い気もするが、
      その様な場合は余りないと考えればそれでも良い気もする。

      因みにプロンプトの高さが1行に収まらない状況としては、
      プロンプト自体に改行が含まれている場合以外にも、
      プロンプト内に長い文字列が含まれていて何度も折り返す場合を含む。

  * util: ble/dict#* を用意する可能性?

    設定ファイルの自動アップデートの実装に関連して
    ble/dict#* という物を作成しても良いのかもしれないとも思う。
    既に辞書的な構造は ble.sh の各所で個別に実装して使用している。

    辞書の bash-4.0 未満における最適の実装は何だろうか。
    任意の key を取り扱える様にする必要性を考えると、
    : 等を区切りにして scalar に key を格納する訳には行かない。
    そうすると配列に key を格納する必要が出てくる。
    配列が巨大になってくると重くなってくる。

    a 簡単な hash を作るという手もあるだろうか?
      例えば配列サイズが小さい時には最初のバイトだけを使って、
      要素が増えてきたら n 番目のバイトまで使って hash を生成する。
      と思ったがそれだと共通の接頭辞を持つ key が沢山ある時に hash が衝突する。
      例えば /home/murase/... という物が沢山ある場合。

    b 或いは全ての文字を用いて hash を計算する?
      という事にすると今度は長い文字列に対して各文字について文字コードを取得する手間がかかる。
      特に bash-4.0 未満では色々面倒な事をする。何れにしても ble/util/assign を使うので遅い。
      (実際にこれでキャッシュをしていないのは下手にキャッシュするよりも ble/util/assign
      を実行した方が高速であるという事からであろうという気がする。)

    c key の sorted list を管理する。
      文字列で辞書順でどちらが速いかについては [[ str < str ]] で判定できる。
      後はアクセスの度に二分探索を実施すれば良いのである。
      挿入には結構時間がかかりそうな気もするが、まあ、大丈夫。
      然し、よく考えたら bash-4.0 未満の配列はアクセスが線形時間だった気がする。
      という事を考えると二分探索よりも線形探索の方が実は良いのかもしれない。

    使用ケースによって色々なので汎用的な実装はやはり難しい気がする。

    * key が整数の場合には普通に配列を使えば良い。

    * key が有限の単語 (識別子) の集合であれば、
      local apple=1 banana=2 pineapple=3 orange=4 等の様にして、
      普通に arr[apple]=red 等とという風にすれば良い。

      或いは普通に変数に保存すれば良い。
      eval "arr_$key=red" という具合である。
      この場合大量の変数が散らかってしまうが、
      それが気にならなければ最良の気がする。

    * key に ":" が含まれない場合には
      keys にコロン区切りの key の集合を保存しておいて、
      head=${keys%%:$key:*} head=${head//[!:]} 等とすれば
      key が何番目の要素であるかというのを取得する事ができる。

    * key が文字である場合も同様にして
      head=${keys##"$key"*} 等としてから ${#head} で文字数を見れば
      それが何番目の要素であるかというのを判定する事ができる。

    * 辞書をメモ化に用いている場合には実は関数自体の計算時間が
      bash による辞書の模倣よりも速い可能性を考えるべき。
      例えば ble/util/s2c については ble/util/assign printf %d '$c の方が
      下手な辞書よりも高速なのである。

    * key の種類がそんなに沢山でない場合には、
      key を配列に格納して線形探索するというので良い。
      これが最も単純で自然な実装になる。

      key を sorted list に入れて二分探索するという可能性もあるが、
      Bash-4.0 未満の配列のランダムアクセスは線形なので、
      それよりは普通に線形探索で舐めた方が良い気がする (実測すると違うかもしれない)。

    結局使用ケースによって最適な実装方法が異なるという事から統合は難しい。
    ble.sh の内部で使わない以上は用意しても仕方がない様に思われる。
    そもそも ble/dict#... の形式による配列アクセスは文法的にそんなに綺麗でもない。
    等の事を色々考えると、ユーザの為に用意する程でもない。

2020-05-20

  * 破壊的変更と後方互換性

    * done: keymap_vi_nmap_name は keymap_vi_mode_nmap_string 等に改名するかもしれない。
      或いはもっと別の名前? やはり keymap_vi_mode_normal で良いだろうか。
      改名するとしたら complete_stdin_frequency と同様に別名に書き換える様にする。
      実はオプションの改名について枠組みにしてしまっても良いのかもしれないという気がする。

    * 勝手に古い設定を書き換える機能を作っても良いかもしれない。
      毎回一行ずつ書き換えを実行するのではなくて、
      書き換えを実行する sed スクリプトを貯めておいて、一括で書き換えを実行する。
      cp a a.bk && sed "$script" a.bk > a 等の様に実行する。

      sed スクリプトは何処に貯めて於けば良いのだろうか。
      書き換え対象のファイル名と一対一に対応するファイル名にする必要がある。

      a 辞書にファイル名を記録するか或いは hash を用意するか。
        hash は計算に時間がかかるので辞書にファイル名を記録するのが良い気がする。
        然し、bash-4.0 未満ではどの様にするのが良いのか微妙である。

      b 或いは、別に辞書など作らなくても直接ファイルシステム上に書き出しても良い気がする。
        つまり、 "$file.sed" に書き出して置いて、それを適用して削除する。という具合にする。
        問題はファイル名が被らない様にするという事。乱数で決定する事にすると駄目。
        "$file.__BLE_REWRITE__.sed" 的なファイル名にするのが良いのではないか。

    * ble{-edit => }/prompt/{print,process-prompt-string,backslash} についても
      警告を表示する様にする仕組みが必要になる気がする。

2020-05-16

  * TERM=alacritty で何か変な事が起きるらしい。
    https://github.com/rux616/init/commit/b03e7ef3dab5171d1f60aa61323ef823401217d5#diff-0af95dc8119f1c458b7a0fd76dfe8042R37-R39

    調べてみると alacritty:extra/alacritty.info が terminfo らしい。tic -x extra/alacritty.info で入れる。
    然し、何も問題は起きていない様に見える。256color もちゃんと動いている。ずっと使っていると発生する問題だろうか。
    これは時間があれば rux616 に何が起こるのか尋ねても良い。
    所で、いつの間にかに alacritty は jwilm/alacritty から alacritty/alacritty に移動したらしい。

    →cache/alacritty.term を確認した所 ich, ech, dch が空になっている。
    然し、ble.sh は ich, dch は使っていない。ech を使う場合でも、
    [[ $_ble_term_ech ]] の時にのみ有効になる様になっている。

    他に気付いたのは 8-15 の着色が 0-7 と同じになっているという事。
    然し実際に tput で tput setaf 15 とすると CSI 9 7 m になる。
    何かが間違っている。再度実行してみた所、問題なく初期化された。
    と思ったら alacritty.term と xterm-256color.term の内容が同一になった変だ。

    続けて何度試しても問題は発生しない。何が起こったかは謎である。

2020-04-25

  * starship コマンド実行時間の計測
    preexec と precmd を使っている?
    https://github.com/starship/starship/blob/master/src/init/starship.bash

    pipexec という物があるそうだ。と思ったが調べたら C で書かれている。
    https://github.com/flonatel/pipexec

    zsh のテーマである powerlevel10k は実は結構複雑な処理を実装している。
    ごちゃごちゃとした雑多の設定の寄せ集めではない。
    ble.sh 程ではないが単にプロンプトと呼べるレベルを超えている。
    * https://github.com/romkatv/powerlevel10k
    * https://github.com/Powerlevel9k/powerlevel9k
      p9k と initial commit が同じなので再実装というよりは fork の気がする。

    https://github.com/aristocratos/bashtop
    これは最近現れた物で pure bash で色々な UI を実装している。
    オプション引数はなく設定は直接編集する様になっている。
    背景が明るい時の配色に対応していない。256色要求。

    * 実用性よりも見た目重視。これはツールの性格による。
      ble.sh 自体は他のプログラムを呼び出す為の物なので主張は控え目。
      然し、宣伝の為には見た目を派手にした物も必要なのかもしれない。
    * 何故か現れたばかりなのに 6.3k も集まっているし、
      一体何が起こるとこのように話題になるのだろうか。不思議である。
      HN にも reddit にも対して人気になった物は見られない。
      何処から広まってどう人気になったのか不明である。
    * freebsd, aur, debian, fedora/centos にまでパッケージが在る。

  * trap: DEBUG trap を用いて DEBUG trap を再現できるか? [#T0003]
    参考: #M0016

    つまり関数呼び出し毎に DEBUG trap が設定されるというのを実装する必要がある。
    ble.sh が使っていなければ特に問題は発生しないが、
    INT を受信した時に ble.sh が DEBUG trap を設置する事になっている。
    従って、実装できれば実装するのが良いという様に考える。

    要件は以下の通り

    * 何も DEBUG trap が設定されていない時には overhead 0 にする。
      つまり builtin trap で何も設定されていない状態にする。
      ユーザか ble.sh のどちらかが何か設定している時に有効にする。

      実のところ、ble.sh の使い方は一時的な物なのでユーザの trap と
      同レベルの取り扱いで良いという気がする。唯単に trap で列挙されない、
      ユーザの設定した trap も保持する、という事が異なるだけ。

    * 関数呼び出しでの継承・非継承を再現する。
      実はこれはそのまま bash の継承・非継承に従うだけで良い気がする。

    * 呼び出し元への影響についても再現する。
      これは新しく trap DEBUG が呼び出される時に、
      builtin trap DEBUG もやり直せば良い?
      と思ったがそもそもそんな事をする必要もない気がする。
      現在のフレームに既に何か設定してあるという事は
      呼び出し元ではそれが必ず有効という事だから。

      bash-4.3 以下では何れにしても呼び出し元に影響を与える事はできない。
      うーん。bash-4.3 以下では trap DEBUG で保存した trap handler を
      関数が抜ける時に削除する必要があるという気もする。
      これについては実装時に注意深く実装すれば良いだけ。

    * DEBUG trap の中で DEBUG trap は設定できるが発火しない。
      BASH_COMMAND は書き換わらない。

    実の所、DEBUG は C-c の時にしか設定していないので、
    取り敢えず気にしない事にする。

    先ず試験的な実装を作成して見るのが良い気がする。

  * trap: INT
    現在の実装ではユーザの設定した INT で握りつぶしても、
    ble.sh の設定したハンドラによって実行が中断される。
    ユーザが INT を設定している時には握りつぶさない様にするという手もある。

  * [保留] bash-4.4 trap 内無引数 return の修正

    ref #D1350

    bash-4.4 以降では trap 内の無引数 return は trap handler が開始する直前の $? を返す。
    強制的に trap handler の内部での直前の $? を返す様にする方法はあるだろうか。

    * return() { builtin return $?; } とする案
      x 本来の return を実行する方法がない。
        RETURN trap を使って return 関数呼び出し後に builtin return できないか?
        x RETURN trap は抑も終了しようとしている関数内の文脈で実行される。
        x RETURN trap 内部では RETURN は発火しない。
    * alias return で何とか無引数の場合を $? に置き換える事は可能か。
      x 引数がある場合とない場合の両方に alias で対応するのは難しそう。

2020-04-19

  * history: 履歴の管理の枠組みで欲しい物

    1 実行したコマンドを追記で記録する仕組み (勝手に編集したりしない)
      他のシェルと同様に追加の情報も記録する?

      * 実行したディレクトリ。実行した時刻。$$.$LINENO

      * コマンドラインに含まれる有効なファイルパスの集合

        | fish はこの情報を用いて history autosuggestions の時に
        | コマンド履歴のフィルタリングを実行する様だ。
        | 然し疑問なのは echo > a.txt で a.txt など出力ファイルが元から存在していた時には、
        | 新しくファイルを作成したいという時にその履歴が候補に出てこない、
        | という事態になってしまうのではないかという事。
        |
        | その様に考えるとやはり実は個別のコマンド毎に判定した方が良いのではないか。
        | 例えば cd の場合には使い方が決まっているので、
        | 実際にそのコマンドラインを実行した時に成功するか失敗するかはすぐに判定できる。

        自動補完のフィルタリングに関しては完全な判定はできないので
        取り敢えず core でサポートしなくても良い。

      * zsh は実行にかかった時間も記録する様である。

        | 然し、これは微妙。何故ならば bash ではコマンドの実行開始前に履歴を追加するから。
        | 実行後に書き換える仕組みが必要になる。或いは開始の記録と終了の記録を別々にする?
        | そうすると複数のセッションで実行している時に互い違いになってしまう。
        | なので実行するコマンド毎に ID を設定する必要がある気がする。
        | と思ったが ID は $$.$LINENO 等で良い気がする?
        | x と思ったが同じ PID でシェルが起動する事もあるのでは?
        |   o と思ったが同じ PID で複数のコマンドを同時に走らせるという事はないので問題ない。

        開始と終了をそれぞれ記録する。$$.$LINNO でコマンド毎に ID を設定して対応を取る。

    2 記録されたコマンドとは別に bash の履歴で遡れるコマンドのリストを管理する仕組み。
      こちらは長いコマンドを自由に削除したりできる様にする。
      倍加したりすると嫌なので枠組み 1 で得た差分に基づいて更新する?
      差分を取る方法を気をつけないと結局倍加するので、
      ちゃんと同期して差分を取れる様な枠組みを整理する。

2020-04-09

  * 別の bash の枠組みについて
    https://github.com/sio/bash-complete-partial-path
    https://github.com/mgalgs/fuzzy_bash_completion
    https://github.com/brujoand/sbp

2020-04-02

  * test: テストフレームワークの追加機能

    * 単体テストの機能
      * テストを直接本体の関数の近くに書き込める様にする?
        これは mwg_pp.awk の枠組みを用いた対応が必要である。というか出力
        先が ble.osh と分かれている場合を考えると、#%$> の右辺に変数を指
        定するべき? と思ったが #%$> を含む行自体をマクロに入れれば良い。

    * テスト集合の管理
      * 集計・サブシェルで実行した結果も扱える様に。
      * テスト結果のキャッシュ
      * 並列テスト
      * 様々な bash の version の結果を集計

    * 他のフレームワークの機能を確認
      * bats
      * oil/test
      * shellspec
        kcov を用いて coverage が計測できる
        skip を設定できる。前回成功したものをスキップできる。

    * GitHub 用に Travis を設定する。

2020-03-22

  * syntax: { echo $fd; } {fd}>&0 の着色が変。
    これは単語着色の除去ができていない問題であろう。

  * read -t や read line の戻り値が変だ
    →今試してみると別に変な事はない。-e が入っていても入っていなくても。

    一応 C-c で read -e を止めた時の終了ステータスは 130 の所が
    ble.sh の実装では単に 1 になっているという違いはある。

  * bash-3.0 が malloc array.c botched というエラーが出てクラッシュした。
    これは bash のバグである。そして古いバグなので治りそうにない。
    更に言うと再現性もあるのかどうか微妙である。

  * oilshell で色々説明を行った。
    それらの説明へのリンクを作成して後で纏めるのが良い気がする。
    これは後で実行する。

  * decode: 大量の貼り付けの高速化4 (report by dylankb)

    現状の ble.sh の枠組みの中では大幅に改善した。
    然し、やはり decode を自前でやっている。
    そもそも decode の結果を整数の列にする時点で遅い。

    bracketed paste だと分かった時点で、
    stdin から文字列として読み取って、
    文字列としてそのまま挿入する等の事が可能な筈なのではないか。
    そうすれば無駄な処理をする事なく即座にエディタを起動できる。

    現在の nonblocking-read の実装に
    bracketed paste を検出する機能をつけて
    bracketed paste の処理中にはそれを使って
    良い感じに実行すれば良いのだろうか。

2020-03-11

  * __line_limit__ の実装の制限

    1 replace-limited を直接呼び出している箇所については確認したが、
      replace-limited が .replace-range を通して呼び出している時、
      外側で ind, mark を設定していると計算がずれて範囲外になる可能性がある。
      特に vi で .replace-range を多用しているが面倒なので細かくチェックしていない。

    2 容量超過でもコマンドラインが短縮されていない場合
      (これは isearch の途中などで起こりうる)
      複数のキーから為るキーシーケンスが間に入る __line_limit__
      によって無効化される。

      これの対処方法として mouse_move と同様に特別に
      __line_limit__ を keyseq に属さないキーとして取り扱う方法がある。
      然し、現在ではチェックが非効率になるので対応していない。
      或いは keyseq に属さない keycode の範囲を定義して、
      その範囲で判定できる様にするのが良い気がする。
      (その様なキーは実は沢山ある)

  * history: fish の autosuggestions はファイルが存在しない履歴項目はスキップする (suggested by cole-h)
    https://oilshell.zulipchat.com/#narrow/stream/121540-oil-discuss/topic/autosuggestions

    うーん。どうやら fish は履歴を保存する時にその時に使った有効なパスも一緒に記録する様だ。
    Bash はそれを記録しない。という事は ble.sh が代わりに記録する等の工夫をする必要がある。
    然し、ble.sh が代わりに記録するという事になると履歴の一貫性を保つ為に工夫が必要になる。
    或いは、ble.sh の履歴を本体として bash の history は全部それを元に再構築する?
    その様にするしかない気がする。

    或いは cmdinfo:color の実装が完全であれば、わざわざ履歴を見て
    ファイルパスかどうかを判定しなくても、それが有効な履歴かどうかを判定する事が
    可能になる。特に cd に関しては簡単に判定する事ができる筈である。
    という事を考えるとわざわざ実装する必要はないのかもしれないとも思う。

2020-02-02

  * vi mode の時は read も vi mode になっているべきではないのか?
    と思ったが vi mode にはコマンド実行等の色々と
    危ない機能も沢山ついているので、寧ろ cmap を使うべきで、
    然し、cmap を使うのだとしたらそれは殆ど現状の read の様な物だ。

    これはその内に request があるかもしれない。その時に対応する。

    と思ったが既定の readline では vi-map が使える様になっている。
    コマンド実行等はどの keymap に定義されているだろうか。
    或いは accept-line や edit-and-execute-command の意味を差し替えられる様にするか。
    そちらの方が現実的である様な気がする。

2020-01-26

  * progcolor: 非同期で実行できる様にする可能性?
    場合によっては重い計算が必要になるかもしれないし、
    実は非同期で実行しても良いのではないかという事。

  * progcolor: redirect の場合にも対応したい
    実は補完の時にも redirect をプログラム補完しても良いのでは。
    但し、補完と着色で違うのは補完は一つの単語について呼び出されるのに対して、
    着色は一度に複数の単語を着色する事があるという事。
    補完に関しては引数とリダイレクトを別々に処理すれば良いが、
    着色の場合には一度に処理できる様にしたい。

  * progcolor: here document にも対応したい。
    here document に対応するコマンドを抽出する事は可能か?
    →here document は開始部分に対する参照を確か持っていたのでできる筈。

    実際にユーザは何を提供すれば良いのか。
    ble/cmdinfo/color:XXX を呼び出す様にするのか。
    然し、それだとそのコマンドの引数が変更される度に、
    対応する heredoc を抽出する必要が出てくる。それは面倒だ。
    或いは、heredoc に変更があった時に着色するだけで良いのでは。

    というか heredoc は単語ではない。でも一つの nest ではある。
    うーん。然し wrange に登録しているかは謎。
    その辺りも整理しつつ実装すると良い。

  * progcolor: コマンド自身が書き換えられた時には
    全ての引数について再度着色の確認が必要になるのではないか。

2020-01-23

  * 前々から発生していたが曖昧補完などを実行すると時々ごみが残る。
    これは何故だろうか。そもそもカーソルよりも右に何か文字列が入るはずがないのに?

    再現させようとしても再現できない。
    これは実際に起った時に再度確かめる必要があるのである。

2020-01-21

  * lmorg/murex という新しいシェルの対話環境

    https://github.com/lmorg/murex

    このシェルは POSIX 互換でないので微妙。
    パス名展開をするのに面倒な指定をしなければならない。
    既存の様々なツールと相性が良いかというと微妙な気がする。
    しかし fish や PowerShell よりは unix shell よりである。

    一方で対話インターフェイスに関しては色々工夫している。
    入力していくと一行下に現在入力しているコマンドの説明が表示される。
    何も入力していない場合は git リポジトリの情報を表示している。
    (然し、なにか入力するとすぐに消えてしまうので何処まで使いやすいかは分からない)
    kill まで入力すると補完候補としてプロセス ID を表示してくれる。
    プロセス ID に対してコマンドラインを説明として表示している。

    * 所で ble.sh ではメニューの形式は事前にユーザの側で指定する事になっている。
      然し、これは微妙な気がしてきた。というのも説明文があるかどうかの情報は
      補完生成側が知っている事である。なので、補完候補生成器の側で、
      メニューの表示形式を上書きできる様にするべきなのではないかという気がする。

2020-01-17

  * Minix で無限ループになっている?

    echo と入力しようとすると確率的に無限ループになる。
    (それでも可也高い確率で無限ループになる。)
    auto-complete を off にしても発生する。
    menu-filter を off にしても発生する。
    という事は着色か或いは。。

    調べてみると暴走しているプロセスは別の Bash だという事が分かった。
    恐らく子プロセスで暴走している。何が悪いのだろうか。履歴?
    →履歴はちゃんとロードできている。その後で暴走する。
    →再度確かめたらやはり子プロセスの暴走としか思えない。
      と思ったがよく見ると親プロセスの暴走だった。両方で起こる?

    2020-02-03 新しい ble.sh を実行しているが固まるという現象が再現しない。
    これは新しい ble.sh のお陰だろうか、それとも偶だろうか。
    →暫く使っていたが全く再現しないので以前の ble.sh の問題と思って良いだろう。

    と思っていたら実は裏でちゃんと無限ループになっていた。
    どうも ssh が予期せず切断すると無限ループになる?

    気になるのは暴走していたプロセスは stderr にリアルタイムで
    データを出力し続けていたという事。

    | -rw-r--r--  1 murase  users  14174140 Feb  3 21:58 5726.stderr
    | -rw-r--r--  1 murase  users  14324924 Feb  3 21:59 5726.stderr
    | -rw-r--r--  1 murase  users  14504088 Feb  3 22:01 5726.stderr
    |
    | 出力内容は以下の通り 0d 1b 5b 4b の 4B を繰り返し出力している。
    |   $ < $_ble_base_run/5726.stderr od -t x1
    |   0000000   0d  1b  5b  4b  0d  1b  5b  4b  0d  1b  5b  4b  0d  1b  5b  4b
    |   *
    |   67250220   0d  1b  5b  4b  0d  1b  5b  4b
    |   67250230
    |
    | 0d 1b 5b 4b とは何か? \r\e[K である。CR EL である。うーん。
    | ble.sh の該当しそうな部分を調べてみる。
    |
    | * canvas:344 (negative cup:el)
    |   ble/canvas/put-cup.draw 1 $((x0+1))
    |   ble/canvas/put.draw "$_ble_term_el"
    | * canvas:1928 (negative sgr0:cr:el)
    |   ble/canvas/panel#goto.draw "$index" "$x" "$y"
    |   ble/canvas/put.draw "$_ble_term_el"
    | * edit:1520 (negative sgr0:cr:el)
    |   ble/canvas/panel#goto.draw "$_ble_textarea_panel" "$fminx" $((fminy-new_scroll))
    |   ((new_scroll==0)) &&
    |     x=$fminx ble/textarea#render/.erase-forward-line.draw # ... を消す
    | * edit:1680 (negative sgr0:cr:el)
    |   ble/canvas/panel#goto.draw "$_ble_textarea_panel" $((cols+1)) "$y"
    |   ble/canvas/put.draw "$_ble_term_el"
    | * edit:1696 (negative sgr0:cr:el)
    |   ble/canvas/panel#goto.draw "$_ble_textarea_panel" "${pos[0]}" "${pos[1]}"
    |   ble/canvas/put.draw "$_ble_term_el"
    | * edit:3869 (negative cuf:sp:sp:el)
    |   ble/canvas/put-cuf.draw "$advance"
    |   ble/canvas/put.draw "  $_ble_term_cr$_ble_term_el"
    | * edit:7322 (negative cr:el:sgr)
    |   ble/canvas/put.draw "$_ble_term_cr$_ble_term_el${_ble_term_setaf[9]}"
    |
    | うーん。何れも関係なさそうな気がする。
    | もしかして _ble_term_el2 に CR EL が入っている?→確認したがそうでもない。
    | 上の中で一番怪しいのは panel#goto.draw だと思ったが、
    | sgr0 が消滅している理由が分からないし、
    | 一度 CR を出したら _ble_canvas_x=0 になるのだから、
    | 何度も CR を出力し続けるのは変だ。

    暴走した bash は何れも console ではなくて pty だった。
    接続が途中で落ちると無限ループになるのだろうか。
    hp2019 側及び vmminix 側で nc/sshd を kill -9 しても再現しない。

  * 英語圏のニュースサイトに投稿する可能性 (suggestion by dylankb)
    Hacker News を紹介されたがここが適切なんだろうか?

    reddit に投稿した話がある。
    https://rcmdnk.com/blog/2014/02/23/computer-bash-zsh/

    単にリンクを貼るというのでも良いけれども。
    やはり様々な機能を惜しげもなく紹介する
    長い記事を書くのが良い気がする。

    →返信で自分の作品を投稿する時のルールの頁があった。
      なるほど。やはりルールがあったのである。危ない所である。
      https://news.ycombinator.com/showhn.html

      これによると作品の紹介は一度きりしかできないとの事。
      > The community is comfortable with work that's at an early stage.
      と書かれているがまさかこれは初期の作品でなければならないという訳でもあるまい。
      > Blog posts, sign-up pages, and other reading material can't be tried out
      と書かれているが…。使い方の説明記事の様でも駄目なのだろうか。
      Blog posts でなければ良い? 或いは README を派手に改造してしまうという手もある。

    https://news.ycombinator.com/shownew
    ここを観察していると "Show HN: 作品名 ― 説明" という名前の物が多いが、
    実は "Show HN: 今〇〇なのを作っているんだけど" というタイトルの物の方が upvote が多い。
    "作品名 - 説明" だといかにも宣伝という感じで入る余地がない気がする。
    一方で "〇〇なんだけど" みたいに書くと "自分も何か貢献できるんではないか" と錯覚して人がたくさん来る。
    そういう仕組になっているんだろうという気がする。

    * reject: "Show HN: Bash Line Editor -- syntax highlighting, autosuggestions, etc. in Bash"
      これは普通。つまらない

    * "Show HN: I am developing a line editor in pure Bash script. I'd like to hear your comments!"
      これだと面白そうとは思ってくれるかもしれないけれど使ってくれる人は少なそう。
      後 explicit にコメントが欲しい! という事をタイトルに書いても良いのだろうか?
      眺めてみるとそういう投稿はない。やはり雰囲気が分からないのである。

    * reject: "Show HN: I made syntax highlighting, autosuggestions, etc. in Bash"
      これも普通。つまらない

    * "Show HN: "Bash Line Editor" with syntax highlighting, autosuggestions, ... written in pure Bash!"
      やはり宣伝っぽい。

    * "Show HN: Bash Line Editor -- syntax-highlighting, autosuggestions and vim emulation written in pure Bash"
      vim と書くと他のエディタを使っている人やシェルでは別に vim は使わないという人が敬遠してしまわないか?
      然し話題に乗るという事だけであればその辺りを無視して投稿しても良い気がする。

    * reject: "Show HN: I wrote a line editor (syntax highlighting, autosuggestions, vim amulation, etc.) in pure Bash script"
    * reject: "Show HN: I wrote a line editor in pure Bash script which provides syntax highlighting, autosuggestions, vim emulation, etc. to Bash"
    * reject: "Show HN: Bash Line Editor written in pure Bash script for syntax highlighting, autosuggestions, vim emulation..."
      長い
    * "Show HN: Bash Line Editor totally written in pure Bash script"
      案外これぐらいの方が気を引けるのかもしれないと思う。
    * "Show HN: Bash Line Editor -- a next-generation Bash configuration"
      或いはこんな感じに煽った感じのタイトルにしても良い。zplug の真似
      でも技術的に面白いのは pure Bash script であるという事。

      "with syntax highlighting, autosuggestions, vim emulation" 等は書かなくてよい。
      書かない方が煽りになるのである。本当か? と思ってみんなリンクを開く。
      そしてどんな機能があるのかとみんな確認する。
      少なくともこれだけの物があるのだからがっかりする事はないだろう。

      でも落ち着かなければならない。Bash configuration と書くと、
      従来の PS1 や aliases や functions を包含する物と考えられてしまう。
      その様に考えると、Bash plugin と書いた方が良いか?
      或いは、plugin manager として突貫で他の物を取り込める様にするか、
      或いは README に強調しておくことにするか。

      というか Bash configuration というのが良くない。違う。
      もっと土台になるものなのである。
      実のところ "a next-generation Bash Line Editor" なのだ。
      然し line editor という意味では全然 next-generation ではない。普通だ。
      つまり Bash の設定にしては next-generation なのであって、
      line editor として next-generation な訳ではない。

      a next-generation Bash interface/infrastructure/extension/framework

      Framework としての側面も強調してよいのかもしれない。
      (或いは真面目にライブラリとして独立させても良い。
      decode 部分に関しては大幅に手を入れる必要があるかもしれない?)

    * "Show HN: I wrote a featureful line editor in pure Bash scripts"
      みたいな単純な物の方が気を引けるのではないかという気がする。

    調べるとスタートアップという文字が頻りに見える。
    投稿してみた感想を観察してみるとやはり何かのお誘いがある様である。
    タイトルに文字数制限は在るのだろうか。

    何れにしても今は忙しいので沢山の要望などが来てしまっては困る。
    従って暫くはこのまま放置するというので良い気がする。

2020-01-05

  * Homebrew の設定を作成する?

    先ず Linuxbrew (Homebrew for Linux) を ~/opt/linuxbrew に入れた。
    普通と違う場所に入れようとしたので色々問題が起こって時間を食ってしまった。

    * brew tap について調べてみる事にする。

      % brew tap akinomyoga/ble.sh を実行すると https でダウンロードしようとする。
      % brew tap akinomyoga/ble.sh git@github.com:akinomyoga/ble.sh.git とすれば良い様だ。
      % それから brew install を試そうとするがどうやっても動かない。
      % どれをやってもそんな formula は見つかりませんのエラーになってしまう。
      % もしくは tap を確認すらしない場合もある。不思議だ。
      % $ brew install akinomyoga/ble.sh
      % $ brew install akinomyogable.sh
      % $ brew install akinomyoga/homebrew-ble.sh
      % $ brew install homebrew-ble.sh
      % $ brew install brew-ble.sh
      %
      % $ brew tap
      % を実行してみると。自分が登録した物の他に homebrew/core がある。
      % homebrew/core は中に formula を沢山入れた repo の筈である。
      % もしやと思って調べてみる。
      %
      % https://qiita.com/wkentaro/items/d4981582e08b134f1e1d

      どうも user/name に対応して github.com:user/homebrew-name を作成して、
      その中に formula.rb を入れて置くという事になっている様だ。
      面倒なのでそれよりは直接 core に取り入れてもらった方が楽だ。

    * 自分で formula を作ってみるのを試す

      仕方がないので自分で formula を作ってみるのを試す事にした。
      $ brew create --set-name blesh

      全て自分で記入しなければならない様だ。適当に formula を作成してみる。
      sha256 は何の sha256 を記入すれば良いのか分からないのでコメントアウトする。
      結局分からないので以下を参考にして埋めてみる事にする。
      https://github.com/10sr/homebrew-pkg/blob/813de30c121e8dea970f11e7c1e63e57d3a6a0ed/Formula/ble-sh.rb_
      * ビルドは gawk に依存しているので gawk に依存させてみる。
      * gmake については調べてみた所 macOS ではデフォルトで GNU make だそうなので不要?
        然し、mac ではデフォルトで make が入っているのだろうか。
        或いは自分で追加で入れる必要があったりするのだろうか。よく分からない。

      と思ったが何処にも *.rb が作られていない。
      $ find ~/opt/linuxbrew/ | grep blesh
      で調べてみたら ~/opt/linuxbrew/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/blesh.rb
      に新しく blesh.rb が作成されていた。これを使う事にする。
      試しに $ brew install blesh としてみたら動き出した。
      gawk を入れるためにその依存関係まで全てダウンロードしてインストールしようとしている。

    ? brew では自分で何処かで入手した formula を使うにはどうすればよいのか?

    * homebrew-core に登録する為には test を用意しなければならないようだ。

2019-12-31

  * progcolor: 引数の中の着色 (zsh -c '...' の ... の部分)。

    いつか実装しようと思っていたら fast-syntax-highlighting が既に実装している。

    | fast-syntax-highlighting
    | →引数の中も着色すると思ったら '$(...)' の中も着色を行っている。
    | 然し、zsh -c '...' に関してはちゃんと zsh や -c を認識して着色している様だ。
    | 調べてみると awk もちゃんと文法的なチェックを行っている。
    | (→ うーん gawk --source '...' で文法チェックをできる様だ。)
    | sed に関しては行っていない。何れにしてもコマンド毎の着色を実現している。

    * コマンド毎の着色設定を指定できる様にした #D1245

    | 次に例えば awk に対応する事を考える?
    | 或いはそれよりは sh もしくは bash に対応する方が楽?
    | 色々考えてみたがちゃんと対応するのは可也大変である。
    | 先ず単語が単純単語でない場合にどの様に実装するか。
    | 等、色々難しい。既にある文法構造を利用して何とかできる可能性はある。
    |
    | awk に対応するとしても awk の様々な実装によってオプションなど異なる。
    | このオプションが異なっていると異なった着色になって、
    | ユーザに混乱を齎す。従って対応するとしたら完全に対応している時にだけ有効にする。
    | 何れにしても面倒である。awk よりは先に bash で対応した方が懸命ではないか。
    | awk の対応に関しては自分の blerc の中だけに留めておく。
    | その自分の blerc の中での awk の着色の設定で必要になると
    | 思われる補助機能をble.sh の方で実装する。

    * awk の着色対応を通じて ble.sh 側で支援の必要な機能を実装する。

    * 単純単語に関して。評価値を求める方法。
      評価値の各文字が元の単純単語のどの位置に対応するか。
      或いはその逆? どちらの方が適切だろうか。

      例えば引用符等に関しては対応する文字はないのでそのままの色が良い。
      従って評価後の文字に対応する評価前の範囲を取得すると良い気がする。
      然し、逆に評価前の $a が評価後に沢山の文字列になる事もある。
      その場合には評価後の各文字の色を評価前に割り当てるのは難しい気がする。

    * 対応する物がない文字をそのままの (下の層の) 色にする事は可能だろうか。
      恐らく getg 等で取得しなければならない。面倒である。
      或いは ble/highlight/layer:syntax では少し違う様に処理していた気もする。

    * 複雑な単語に関しては文法構造を利用する事も考える。

    * 現在の layer:syntax の枠組みでは一旦着色情報を wattr に格納してから、
      それを word table に対して適用するという仕組みにしている。
      この様にする事に何の意味があったのだったか?

      直接 word table に適用した方が早いのではないか?
      →これは何度も単語着色を求め直すのを省略する為である。
      つまり、単語着色を決定する部分と実際に適用する部分を分けて、
      前者をできるだけ省略する様にしている。

      実際に適用する必要がある場合でも前回求めた値を
      そのまま使えば良い場合があるという事なのである。

  * fast-syntax-highlighting の機能を確認する
    https://github.com/zdharma/fast-syntax-highlighting

    * コマンド毎の着色。オプションや引数が正しいかのチェックも行う。
      これは丁度 ble.sh で将来的に対応したいと思っている機能である。
    * 括弧の対応に応じた着色
    * gawk --source による文法チェック?

  * theme: 流石に theme を作った方が良い気がしてきた。
    少なくとも枠組みだけでも作って置くと良い気がする。
    と思ったが実際に例がないと枠組みの良い設計も分からない。
    zsh-syntax-highlighting はどうしているのだろうか。
    zsh-syntax-highlighting theme で検索してみる。

    どうも zsh-syntax-highlighting は theme を提供していない様だ。
    https://highlightjs.org/static/demo/
    ここは dark/light の両方を提供している theme があって参考になる。
    但し、ファイル名着色に使う色は色々調整しなければならないが。。

    fish の theme はあるだろうかと思って探すと。
    https://github.com/oh-my-fish/oh-my-fish/blob/master/docs/Themes.md
    どうもシェル業界では theme というのはプロンプトの事を指す様で。
    然し、fish のブラウザ設定画面ではタブは colors となっている物の、
    色々な設定の部分には theme という文字も見える。
    何れにしても theme というのは紛らわしいかもしれない。
    注意書きを書いておく必要があるかもしれない。

  * TUI 設定画面?
    fish はユーザフレンドリーを謳っている。
    ブラウザで設定できるなど (リモートの場合には使えない気がするが)。
    ble.sh ではブラウザでなくても TUI で設定画面を用意しても良いのかもしれない。
    マウスサポートまですればブラウザでなくてもOKなのである。

    →fish の web 設定画面を確認してみた。
      実は theme と prompt が選べるだけだった。
      他は関数・変数・履歴・束縛・略語展開の一覧が見えるだけで、
      何も設定することはできないのだった。
      但し履歴項目の削除はする事ができる。
      略語展開も実は編集することができた。
    →theme に関しては配色が選べるだけで、
      具体的にどの色がどの意味というのは余り考えられていない気がする。
      適当に順番に割り当てただけなのではなかろうか?

    その様に考えると履歴の着色でも良いのかもしれない等と。

  * complete: 重い補完関数に対する対策

    * 曖昧補完の為に何度も progcomp を呼び出していて非効率的
      →無駄があると思ったが実際にどういう補完を行っているか調べると
      様々な補完点を試しているのだった。うーん。
      自動補完の補完候補がすぐに見つかる場合にはそんなにたくさん呼び出されない。
      補完交互が見つからない時には自動補完によって何度も補完が実行されて遅くなる。

      もしかすると自動補完を off にしたいという人は時間のかかる
      補完関数を使っているという事なのかもしれない。
      よく考えたら peco の類を設定している場合大変に面倒な事になるのでは?
      自動補完が実行される度に選択メニューが表示されてしまう。
      そもそも補完に peco を設定している時点で変ではあるが。

      色々な補完点で試すとしても現在の単語を 0 文字または 1 文字しか
      入力していない場合には、同じ状態で呼び出す事もあるだろうという気がする。
      その場合の為に compgen の呼び出し結果をキャッシュする利点はあるだろうか。
      つまり、同じ補完状態で再度呼び出される事を見込めるかどうかが問題になる。

    * 或いは、処理を非同期で呼び出すというのが良いのかもしれない。
      その場合には計算結果を何処かファイルに書き出す様にしなければならない。

      非同期で呼び出すのは -CF が設定されているときだけで良い。
      と思ったが -F の中で環境を変更したいという場合にはどうするのだろう。
      非同期で呼び出すという事にすると環境に対する変更が適用されない。
      これは bleopt で変更できる様にしても良いのではないだろうか。

  * complete: menu-complete 中の通常文字挿入は
    絞り込みに戻すのが良いのではないか。
    というか普通にキャンセルして挿入すれば絞り込みになるのでは?
    と思ったが menu-complete 状態からは抜ける事になる。

    後、suffix を挿入せずに確定する方法がなくなる。
    これについては別の操作方法について考えると良さそう。
    例えばスペースを押すと suffix 挿入を抑制して確定する等。

    →やはりこれは分かりにくいのではないか。
      fish, zsh の動作を確認してみたが menu-complete 中に
      新しい文字を入力すると何れも現在の選択肢を確定させた後に
      続きの文字が入力される様になっている。
      これらのシェルと異なる振る舞いをするのは良くない。

      だとすると絞り込みをする為には明示的に
      絞り込みのモードに入るキーを設定するべきなのでは。
      例えば M-e 等?

      因みに emacs で試してみると M-e, M-a は end/beginning of
      sentence 的な動作をしている様に見える。
      なので上書きしてしまっても良い様な気がする。
      うーん。でも end of line の代わりに使っている人がいるだろうか?

      因みに現在の ble.sh では M-e は何にも紐付いていない。
      うーん。M-e を勝手に補完の絞り込みモードに割り当てる事にする。
      絞り込みモードにいる時にはカーソルの動く範囲と編集範囲を制限する。
      と思ったが vi の様な複雑なモードの場合にそれを実現することは可能か?
      移動だけならば __after_widget__ で範囲外に出た時に
      強制的に範囲内に移動させる事が可能であるが、編集まで入ると困難である。
      編集を禁止しなければならないがそれは難しい。

      だとすると新しいプロンプトで編集させるというのが現実的だろうか。

2019-12-29

  * color: term_true_colors=auto

    自動判定は難しい。screen-4.99.0 が truecolor on/off
    のオプションを持っているので実際にユーザが有効にしているかどうかは
    TERM や DA2 を使っても分からない。結局試しに色を設定して、
    その色を読み出すという事をしなければ判定できないのだろうか。
    然し、これも端末によって問い合わせができたりできなかったり
    (セキュリティ上の都合から)無効になっていたりする気がする。

    以下の優先順位で試すというのが妥当な実装方法の気がする。
    然し 1 の判定を非同期に行わなければならないので面倒である。

    1. 色を設定して問い合わせる

      http://nanno.dip.jp/softlib/man/rlogin/ctrlcode.html
      https://qiita.com/kefir_/items/c2bd46728364bdc7470b
      OSC 10 ; ? ST で前景色RGB問い合わせ、
      OSC 11 ; ? ST で背景色RGB問い合わせの様である。
      応答は OSC 10 ; "rgb:rrrr/gggg/bbbb" ST の形式?

      よく考えたら現在の実装では ESC-[ (CSI) しか特別扱いしていない。
      これに対応する為には "ESC ]" (OSC) についても処理する必要がある。
      これは ble-decode-char/csi/consume の辺りを拡張する必要がある。
      特に BEL または ST (ESC \) で終端する様に処理を書く事に注意する。

    2. DA2 を元に判断する
      然し https://gist.github.com/XVilka/8346728 のページには
      各ターミナルの対応 version が書かれていないので使えない。
      自分で調べ上げるしかないのだろうか。

    3. TERM を元に判断する (*-24bit *-24bits *-truecolor)
    4. terminfo を元に判断する (setf24, setb24, tc, RGB)

2019-10-21

  * ずっと起動していると段々と遅くなっていくのは何故か。

    Ubuntu bash-4.3 (song437) で動かしていて気づいた。
    bash として新しく起動すると速い。
    ble-update や ble-reload をしたり、
    ble-detach / ble-attach しても直らない。

    カーソル移動だけでも遅くなって行くので描画が関係しているとは思われない。
    また、reload しても直らないという事から考えられる事は何か。
    履歴がどんどん溜まって重くなるという事でもない様な気がする。

    或いは変数のアクセスが遅くなって行くという事なのだろうか。
    変数に代入するスクリプトを回してみたが特に遅いという事はない様だ。
    (それにそもそも使用している時間に比例して変数が増えていくという物でもない)

2019-09-24

  * ble.sh で export PATH=aaa:bbb:ccc で最後の部分しか着色されない。
    それぞれ着色するべきなのではないか。

2019-09-22

  * complete: = を含むファイル名を補完すると = 以前の部分が重複して挿入されてしまう。

    →今確かめてみると再現しない。\= としていても = としていても同じ。

    2019-12-31 ./configure の引数で --prefix= を補完している時に
    = が \= になったり --prefix= も丸ごと置換されたりなど変な動作をする。
    一方で、complete -r で progcomp を消してやると変な事は起こらない。
    これは要するに progcomp の仕様の微妙な違いに起因して変な事が起こっている。

2019-07-16

  * complete: パス名展開で複数語に展開される場合の補完に関して
    現在の実装ではパス名展開が起こったとしても展開された最初のファイル名を使って補完を実行する。
    然し、実際には展開された各パス名について補完を実施しても良いのではないだろうか。うーん。

    更に failglob の場合には続きを入力したら一致したかもしれなくても常に展開に失敗してしまう。
    というか現状でそもそも failglob だった時にそれを検出しているのかどうかすら怪しい。
    確認する必要があるのである。

    既に COMPV には複数の値が入る仕組みになっていた。
    それならばと COMPV に入っている値の数だけ source を呼び出せば良いのかと考えたが、
    実際に試してみると全く同じ候補が何度も生成されるだけに終わってしまった。
    よく考えたら progcomp では独自に展開を行っていたのではあるまいか。
    調べてみたらやはりそうである…。これに対応するのは面倒である。

    或いは複数語に展開される場合には先ず始めにその内のどれか一つに絞らせるという可能性もある?
    然しそれはそれで不便な気もする。

2019-07-09

  * history.mlfix: bash-3.0 で実現する方法?
    history -s が使えないので複数行の履歴を登録する事が不可能である。

2019-07-02

  * menu: 複数選択を可能にしても良いのではないか
    C-@ で toggle をする等。抜ける時に全てを挿入する?
    然し使いみちがよく分からない。使いたくなったら追加するというので良い気がする。

2019-06-18

  * history: interactive な history 編集に対応できたらする
    つまりメニューを表示して其処で選択したり削除したりする。
    検索などもできる様にする。遅延で着色をする。

    core-complete に実装されている既存のメニューの枠組みは、
    menu item を配列に格納する。従って容量を食う。
    更に重そうである。これは独自に新しく実装した方が良いだろうか。

2019-05-27

  * 次に機能を追加するとしたらマウスなのだろうという気がする。
    fish は未だマウスに対応していない。
    zsh はそういう拡張があるらしいがちゃんと動くのかは知らない。

    zsh extension: https://unix.stackexchange.com/questions/444601/any-terminal-shell-with-mouse-support
    fish suggestion: https://github.com/fish-shell/fish-shell/issues/4918
    question: https://superuser.com/questions/322367/are-there-any-unix-shells-that-support-mouse-reporting

    マウス対応の問題点はマウスが有効になっていると、
    従来の端末に対するマウス操作(端末に表示されている内容のコピー・ペーストなど)が使えなくなる事である。
    端末に表示されている内容まで全て ble.sh の管理下であればそういう事もできたかもしれない。

    部分的なサポートとして何らかのモードに入っている時だけマウスを有効にするというのはあるかもしれない。
    例えば補完のメニューを出している間だけ、など。然し、それもなかなか分かりにくい気はする。
    或る特定の範囲だけでマウスを有効にするという制御機能があった様な気がする。
    それが使えればそれを使ってマウスを有効にするというのが可能になる気がする。
    何れにしてもこれは考察が必要になるのである。

    2019-07-22 どうも既存の端末では Shift を押しながら操作すると
    Mouse report ではなくてローカルでの端末上でのマウス操作になる、
    というのを採用している物が多い、という話を何処かで見かけた。
    何処で見掛けたかは忘れたし実際にそうなのかの確認はしていないが。

2019-04-21

  * 実は背景色を判定する方法はなくはない様だ。
    https://qiita.com/kefir_/items/c2bd46728364bdc7470b
    しかしそうだからと言って暗い背景用に配色を調整する必要があるので、
    それを実行するまでは対応しても仕方がないかもしれない。

    % というか、調べていたら DECSCNM (SM/RM(?5)) が背景が暗いか明るいかの設定の様だ。
    % という事は DECRQM して DECRPM を受け取れば普通に背景が明るいか暗いか分かるのでは。
    % そして Poderosa や screen の側でもそれを設定すれば良かったのではないか…。
    % と思ったが xterm は明るいか暗いかが反転している。
    % つまり、DECSCNM は飽くまでその端末の既定の背景と比べて反転しているかどうかしか分からない。
    % 既定の背景色が明るいか暗いのかの情報は取る事ができない。

    一方で、背景色の問い合わせで返ってくる色が DECSCNM の影響を受けるのか
    は気にして置かなければならない。

2019-03-23

  * menu: alias select='while myselect $# "$@"' 等として select を上書きできるのでは

    というか現在の ble.sh で select を実行すると悲惨な事になる気がする…。
    と思ったが select は別に readline は使っていない様子だ。
    元の bash でも全然行編集できない感じの入力になっている。
    なので現状で問題が発生しているという訳でもない。

    もし置き換える事ができるのであれば便利かもしれないという程度である。

  * menu: 今後の拡張性

    * 因みにフィルタリング機能は menu-filter を統合・整理する形で実装したい。
      フィルタリング文字列の入力に関しては isearch や iswitchb の様な、
      単に文字を入力するか BS で戻るかだけしかできない様なものでも良い事にする。

      フィルタリングに関してはフィルタリングを実行する関数と、
      フィルタリングを誘発する為の機能を分離して実装する事にする。
      既存の menu-filter の機能は自動的にフィルタリングを呼び出す。
      明示的なフィルタリングの場合には keymap にフィルタリングを紐付ける。

    * cdhist では更にリスト編集機能までついている。
      つまり項目を並び替えたり削除したりと言った事ができる。

      うーん。これをどの様に返すかは微妙かもしれないが、
      _ble_complete_menu_items にある物を呼び出し元で参照してもらうというので良い気がする。
      或いは callback でどの様に並び替えたかを返すという手もあるが分かりにくいだろうか。
      両方という事で良い気がする。使う側で便利そうな方を選んでもらう。
      どの様に並び替えたかの操作が欲しければ callback を使うし、
      最終的な結果だけ欲しければ _ble_complete_menu_items を参照してもらう事にする。

    * callback という事で思ったが、実は accept だとか cancel だとかも
      全て menu_class 経由で定義した方が良いのではないだろうか。
      一つずつ全て callback を変数に設定していくのは面倒である。
      更に、並び替えの callback だとかどんどん増やしていくと際限がない。

2019-03-22

  * menu-filter の使い心地が微妙なのはもしかして
    menu-complete を実行中に絞り込みができないからなのではないか。
    現在は menu-complete を実行している途中に入力をするとその場で確定してしまう。

    では bash の振る舞いはどうなっているだろうか。
    確認してみた所、bash の menu-complete はもうその場所に挿入してしまう。
    そして文字を入力すれば続きに挿入される事になる。

    現在の ble.sh の振る舞いはどうだろうか。
    その場で入力すると addtail 等の処理をせずにいきなり続きから入力されてしまう。
    少なくとも addtail ぐらいはするべきなのではないか。
    また、絞り込みを実行しても良いのではないかという気もする。
    然し、それでも何か違う様な気がする。

    絞り込みの入力欄と現在選択されている内容というのは別に一致している必要はない。

2019-03-19

  * complete: 実装されていない補完関連の rlvar は以下の通りである。
    実際に対応するかどうかも含めて考察する必要がある。

    - set completion-map-case off
    - set disable-completion off
    - set expand-tilde off
    - set horizontal-scroll-mode off
    - set page-completions on
    - set completion-display-width -1
    - set completion-prefix-display-length 0
    - set completion-query-items 100

    うーん。これらの設定は bash の既定値では余り便利ではなかったりする。
    ble.sh で折角実装してもユーザに使ってもらえないのでは仕方がない。
    それならば最初から ble.sh の bleopt として提供してしまった方が良いのでは。
    元々 bash を普通に使っていて設定している人の為に、
    bash の規定値と異なる値を敢えて選択している時に限り
    ble.sh でその効果を再現する様にすれば良い。

2019-02-09

  * うーん。git や bash-it の様に ble.sh でも ble コマンドの様な物を提供するべき?

    と思ったが既に何処かには ble という名前のコマンドが存在していて、
    これらは Bluetooth のサービスの開始・終了などを実行するのに使われている様子である。
    もしこれらが広範に用いられている物なのだとしたら使いにくい。

    また、ble の名前の由来である zle コマンドの事を考えると、
    ble widget の様な使い方を想像してしまうのではないかとの問題もある。

    混乱を防ぐためには ble ではなくて ble.sh または blesh の様な名前が良いだろう。
    しかしそうすると現状の ble-import だとかの機能を呼び出すのに余り適していない気がする。
    つまり、blesh import ... で ble-import が呼び出されるというのは分かりにくい。
    或いは現状の ble-import を blesh-import に改名するという手もあるかもしれないが、
    そういう事を考え始めると全ての関数を ble から blesh に改名したくなる。
    それは面倒だし、元の zle という名前から離れていくので余りやりたくない。

    実のところ、現状のまま ble-* の方が自動的に補完が効くので嬉しい。

    bash.env は bash.env という名前のコマンドを提供する様である。
    https://github.com/midwire/bash.env
    そういう事であれば ble.sh でも ble.sh という名前の関数を提供すれば良い気がする。
    しかし ble.sh が入力しやすいのかというと微妙ではある。

    bash-it の場合には bash-it-update だとか bash-it::update だとかだと
    格好が悪いので bash-it update という形の関数名になるというのは分かる。

  * main: --attach=prompt の問題は何だったか
    ref #D0940

    何か問題があって現在はこれを使っていないが、それは何だったろうか。
    何処かに記録されていて良い筈なのに何処にも記述がない。
    対応した時の記録は #D0737 にある。
    動かしてみた所、ちゃんと動いている様に見える。

    →恐らく、先ず古い ble.sh の version では使えないという事。
      それから PROMPT_COMMAND を上書きすると使えなくなってしまうからという事。
      ユーザに PROMPT_COMMAND を設定しないように要求するのは面倒である。

2018-09-21

  * [保留] 2018-09-15 complete: 文脈の変更範囲で end0 だけ負になるバグ (ref `#D0818`)
  * [保留] 2018-09-11 complete: 端末が操作を受け付けなくなるバグ (ref `#D0817`)

2018-08-16

  * complete: オーバーレイによる実装?

    現在の実装では仮挿入しているが、
    これによって現在の入力内容でエラー着色するべき所が、
    補完が実行された後の着色になってしまっていて、
    補完前の現状でエラーなのかどうなのかが判別できなくなっている。

    やはり仮挿入ではなくて overlay で実装するべきなのではないか。
    しかし overlay の仕組みを実装するのは面倒である。
    どの様な仕様にするのが良いのかの吟味から実装まで。
    しかし、これについては後回しで良いだろう。

    以下に仮入力の4種類の方法について言及がある。
    https://mattn.kaoriya.net/software/vim/20170905113330.htm

    リンク先は消えている。web archive のリンクを追記 (2018-09-23)。
    https://web.archive.org/web/20110630165743/https://www.mozilla-japan.org/projects/intl/input-method-spec.html

    * 2018-09-23 自動補完時の着色について
      cmplstofB さんからも指摘があった。
      https://github.com/akinomyoga/ble.sh/issues/5

      自動補完の候補文字列は実際に挿入しているので構文着色に影響を与える。
      "現在の内容" で着色するべきなのではないか、ということ。
      そうしないと例えば今入力したコマンドが実際に存在するコマンドなのかどうかが分からない。

2018-08-05

  * edit: set blink-matching-paren on に相当する機能
    対応するならカーソル移動ではなくて着色でやった方が良い。

    | 括弧の対応と region が両方走っていると分かりにくい。
    | 既に region には複数箇所を highlight する機能がある。
    | そういう意味で region を使うという手もある。
    | と思ったが、分かりにくい問題に関しては region の方を上に配置すれば良い。
    | 複数箇所を highlight する機能は実装を参考にするだけで良い。
    | 論理的には全く異なる (region は _ble_edit_mark を参照する) し、
    | それぞれ独立に on/off する事を考えれば別の highlighter にするべき。

    region の複数箇所着色の実装を参考にする可能性も考えつつ、
    region とは独立な highlighter にしたい。
    その時は region の一つ下の層に挿入したい。

    また対応する括弧はどの様に検出するのが良いだろうか。
    やはり文法構造を参照する実装にするしかない様に思われる。
    しかし、括弧の対応には色々ある。引用符の対応、
    括弧の対応、if then else などのキーワードの対応、
    ヒアドキュメントの始まりと終わりの対応である。
    それらは必ずしも記録されていないし、また、記録されているとしても
    様々な形式で記録されている。取り敢えず一番簡単な対応として
    nest に記録されている物を着色するというのが良さそうである。

2018-07-29

  * complete: メモ

    - 生成候補のキャッシュを行うとすれば source 内で実装するべきである #D0705

2018-07-19

  * ble-decode: 'set convert-meta on' 的な操作

    ref #D0699 (LANG=C bash で ble.sh をロードすると全く操作できない)

    ble.sh の内部環境では set convert-meta off にしているが
    (そうしてないと特殊文字の受信時に無限ループになる)、
    外部環境で set convert-meta on だった時に、
    それをエミュレートする様な動作を行っても良い。

    外部環境における set convert-meta の状態は
    変数 _ble_term_rl_convert_meta_external に記録してある。

  * 現在の `LC_CTYPE` で表現できない文字を入力した時の `self-insert` の振る舞い

    ref #D0699

    self-insert で入力するのは逆符号化したバイト列であるべきでは?

    というのも LC_CTYPE が正しくない場合でもファイルシステムのファイル名などは
    そのまま謎の文字列として取り扱われるからである。
    然し逆符号化したバイト列は文字列として正しくないかもしれない。
    逆符号化したバイト列を更に一バイトずつ現在の LC_CTYPE に変換すると意味がない。

    これは文字列を編集などしようとすると分からない事になりそうなので、
    取り敢えず現段階では \u???? を出力するという現状の振る舞いを維持する。
    後で落ち着いてから再考する事にする。

    以下の c2s 使用箇所は一貫している必要がある。

    ble/widget/self-insert 編集文字列の入力
    ble/widget/vi-command/search-char.impl/core 検索文字列の入力
    ble/widget/vi_xmap/visual-replace-char.hook 置換に使う文字の入力
    ble/lib/vim-surround.sh/get-char-from-key 囲み文字の入力 (あらゆる遅延入力)

2018-03-14

  * emacs: C-w を続けて実行すると kill-ring に追記にするべき

2018-02-21

  * vi-mode: nmap (, ), {, }

    カーソルを N 文元に戻す or 先に進める。N 段落元に戻す or 先に進める。

    これは operator:d,c で "- ではなく "1 に記録するという例外の対象であるので、
    対応したらその例外のリストに登録する必要がある。

    2020-08-27
    https://www.youtube.com/watch?v=hIJh-KlQ7io
    この動画で zsh/bash の vi mode に (){} がない事を嘆いている。
    然し、"文" をどの様に定義するのか。文法的なコマンドで定義するのか、
    或いは、元の vim と同様に . の位置で判断するのか。
    シェルの機能としては . の位置で判断するのは使いようがない。
    一方で、シェル文法の . で移動する様にすると
    vim に使い慣れた人に取っては混乱の元である。

2018-02-12

  * [保留] vi-mode: operators 保留項目 [#tmp0002]

    * 領域折り畳み zf には対応しない。

    * gq の formatexpr, formatprg には未対応である。

2018-02-11

  * [保留] keymap/emacs: 連続する delete-backward-char の場合 undo の記録をまとめる可能性?

    現状では一文字ずつ記録しているので一文字ずつ undo される。
    現在の振る舞いの方が良いのか emacs と同様にまとめた方が良いかは微妙な所である。

2017-11-26

  * highlight: 配列代入の解析の不整合? [tmp0003]

    最初から arr[index まで入力した時の着色と
    arr[index] まで入力してから一文字削除した時の着色が異なる。

    | _ble_syntax_attr/tree/nest/stat?
    |  7 aw   000 'a'  stat=(CTX_CMDX w=- n=- t=-:-)
    |  8 a e  001 '['  nest=(CTX_VRHS w=ATTR_VAR:0- n=- t=-:-)
    |  8*a    002 'a'  stat=(CTX_EXPR w=- n=@1 t=-:-)
    |  6*a e  003 'b'
    |  |    s 004 ^@  stat=(CTX_EXPR w=- n=@1 t=-:-)
    | \_ 'a[ab'
    |     \_ '[ab'
    |
    | _ble_syntax_attr/tree/nest/stat?
    |  7 aw   000 'a' |  stat=(CTX_CMDX w=- n=- t=-:-)
    |  8 aw   001 '[' || nest=(CTX_VRHS w=ATTR_VAR:0- n=- t=-:-)
    |  8*aw   002 'a' || stat=(CTX_EXPR w=- n=@1 t=-:-)
    |  |*aw   003 'b' ||
    |  8*aw   004 ']' ++ word=CTX_CMDI:0-5>@4 word="a[":1-5 stat=(CTX_EXPR w=- n=@1 t=-:-)
    |  |    s 005 ^@    stat=(CTX_ARGX w=- n=- t=$5:-)
    | \_ 'a[ab]'
    |     \_ '[ab]'
    |
    | _ble_syntax_attr/tree/nest/stat?
    |  7 a    000 'a'  stat=(CTX_CMDX w=- n=- t=-:-)
    |  8 a e  001 '['  nest=(CTX_VRHS w=ATTR_VAR:0- n=- t=-:-)
    |  8*aw   002 'a'  stat=(CTX_EXPR w=- n=@1 t=-:-)
    |  6*awe  003 'b'
    |  |    s 004 ^@  stat=(CTX_EXPR w=- n=@1 t=-:-)
    | \_ 'a[ab'
    |     \_ '[ab'

    どうも構文の状態は同じだ。単語の着色が異なる。
    しかしそもそも何故単語着色が起こっているのだったか。
    単語着色は CTX_CMDI としての着色が残っているということ。
    これは単語着色の側の問題であって、解析の問題ではない。

    2019-02-13 "{ echo; } 3>&1" と入力した時にも
    似たような事になる。"{ echo; } 3" まで入力した時の単語エラー着色が
    最後まで残ってしまう。#D0930

2017-11-21

  * syntax: for^J で改行にエラーが設置されるが見えない [#T0005]

    改行のエラーは何らかの方法で見える様にするか、
    或いは、改行位置にエラーがある様な時は、
    その前の文字でエラーが発生する様にチェックを行うべき。

    Note: これは端末によっては表示されたりする。端末による。
    エラー着色はどの様に行われているのか。for の後には FARGX1 に入る。

    これは ble-syntax:bash/ctx-command/.check-delimiter-or-redirect の冒頭部分が怪しい。
    と思ったが FARGX1 に関してはチェックが入っていないのでやはり関係ないだろうか。
    うーん。調べるとやはり文法レベルでの着色になっている。

    2019-03-11

    | rps1 で表示している時に EL を空白で代替していると、
    | 改行の着色が空白に反映される。これでも良いような気がしてきた。
    | 然し、右側が全て着色されるというのもうるさい。
    | 最初の1文字だけ着色して SGR(0) するかと思ったが、
    | そうするとその次にある文字の着色も消えてしまう。
    |
    | それの対策のために _ble_textmap_ichg があるのでは。
    | と思ったが、実装を見てみると違っている様に見える。
    | _ble_textmap_ichg は着色の調整に使っている事は確かだが、
    | _ble_textmap_ichg に登録されている文字の着色を計算しているのであって、
    | _ble_textmap_ichg に登録されている文字の次の文字の着色は計算していない様に見える。
    | うーん。_ble_textmap_ichg は他の箇所では全く使っていない。
    |
    | そうだ。思い出した…。_ble_textmap_ichg に登録されている文字は、
    | 配置の場所によって中身が変わるので、shift が使えないという事だった。
    | 特に、中身が変化している場合には文字を取り出して変更を行うのだった。
    | では以前 ichg に登録されていて、現在位置では ichg に登録されていない文字はどうなるのか。
    | と思ったら既定の文字形は別の所で決定されている様だ。
    | ble/highlight/layer:plain/update/.getch である。

    a 右側の1文字だけ着色される様にする?

      x 問題点はコピーペーストした時に必ず余分な空白が入る事である。
        これは右側の全てを着色させる場合にも同様の問題が生じる。

        また、エラーが有る時にだけ (着色の必要がある時にだけ)
        右側に空白を入れるという方法もある。
        しかし、その為にはその位置にエラーが有るのかないのかを
        外部から取得しなければならない。

        ble/textmap#update は edit.sh だとかの仕組みに依存しない、
        独立した枠組みにしたいので余り変な機能は取り付けたくない。

      x また実装上の問題点として、rps1 が表示されている時に、
        _ble_term_ech を使わない場合、2文字目以降の空白文字を SGR(0)
        でクリアしなければならない事である。この場合、
        改行の次の文字の SGR を復元する為には…

        _ble_textmap_ichg に次の文字の番号も追加するか、
        或いは現在の改行文字の SGR 状態を復元する必要がある。
        しかし textmap の処理をしている間は、
        未だ着色が完了していないので SGR 状態を取得できない。

        或いは着色部分だけ textmap#update よりも前に持ってきても良いのだが、
        その様にしたとしても色情報を textmap#update に伝達する手法が必要である。
        例えば getg なる関数を textmap#update から呼び出してもらう事にするのか。
        或いは呼び出す関数名も外から指定できる様にするのか。

    b やはり改行の前の1文字を描画時に強制的に着色するという手もあるのではないか。
      と思ったが…エラー着色だけ特別扱いするというのも変な話である。

    c その様に考えると初めから改行にはエラー着色はしないというのが正しい気がする。

      改めて調べると ble/syntax:bash/ctx-command-compound-expect がエラーを設置している。
      うーん。for だけの問題では無い様である。他に select, case の時にも同様である。

      ('for'|'select'|'case')
        [[ ${text:i:1} == $'\n' ]] &&
          ((_ble_syntax_attr[i-1]=ATTR_ERR))
        case $word_expanded in
        ('for')    ((ctx=CTX_FARGX1)) ;;
        ('select') ((ctx=CTX_SARGX1)) ;;
        ('case')   ((ctx=CTX_CARGX1)) ;;
        esac
        processed=begin ;;

      実際に上記の様にして見たら見える様になった。
      しかし rps1 が有効になっている時はやはりうるさく感じられる。
      また端末に依っては rps1 が無効になっていても行全体が赤く着色される。
      そういう端末 (mintty など) どういう発想なのかはよく分からないが…。

      更に here documents も行末にエラーを設置する。
      これについても対策したいが、here documents に関しては、
      nest の終端がない事によるエラー着色である。
      これは nest の範囲を変更しないと着色を変更できない。

      何だか中途半端な実装の気がしてきたので取り敢えずこの変更はなかった事にする。

    d うーん。右側の内容の消去は実は改行文字を使って行うのではなくて、
      描画した後に消去するという方法にした方が良いのだろうか。
      しかし、その様にすると、今度は urange の中にある行末というのを列挙して、
      それから各行末について位置を計算して実行するという事をしなければならない。
      textmap さえあれば指定範囲内の行末は二分法によって特定する事が可能である。
      しかし面倒である事に変わりはない。もっとまともな方法はないのだろうか。

    結局実装の面倒さを考えなければ三種類の仕様が考えられる。

    a 右側に1文字赤く表示する
    b 行末まで赤く表示する
    c 行の最後の文字を赤くする
    d 表示されなくても気にしない

2017-11-09

  * complete: 候補の優先順位? 例えば拡張子でフィルタすると絞りすぎることがある。
    拡張子の要件を満たすものを先に表示して、満たさないものを後に表示する。
    満たさないものに関してはサブ候補として、TAB による接頭辞挿入には寄与しない。

    2018-07-28 候補間の優先順位をつける可能性。
    weak な優先順位は、候補を表示する時の順序。
    strong な優先順位は、候補絞り込みの際に一番優先順位の高いものが一つしかない場合にはそれに確定する。

2017-11-05

  * vi-mode

    :help 関連の気になること:

    - v_p v_P: Implementation details に書かれている処理の順序は実際は逆
    - exclusive-linewise: ここの inclusive/linewise になる条件の記述は曖昧だし全く合っていない
    - star: vim-jp の文書だと WORD と書いてあるが、振る舞いは word (しかも \<\> で囲まれる) に近い

    振る舞いで気になること

    - i<C-o><C-c> とすると普通のノーマルモードに移行したように見えるのに、
      モード表示は -- (挿入) -- のままである。これは何故だろう。
      ble.sh ではノーマルモードに完全に移行する。

    - qa<C-c>q とすると ^C が二重に記録される。これは何か?
      ble.sh では単に ^C は入力された通りに一個だけ記録する。

    - C-v <bracketed paste> では矩形挿入にするべきなのではないか。
      ble.sh では矩形挿入を行う。


2017-11-03

  * vi-mode (registers): 各種特殊レジスタの対応

    http://vim-jp.org/vimdoc-ja/change.html#registers

    - done: "% は現在のファイル名を保持するが、これは $HISTFILE の内容を返す事にした。

    - done: ": は一番最後のコマンドラインの内容である。
    コマンドラインを入力し途中でキャンセルした場合などには記録されない。
    空のコマンドラインで確定した時にも記録されない。
    コマンドが入力された場合は、それが存在しないコマンドであっても記録される。
    コマンドが実行されている途中では未だ設定されていない。
    つまり、そのコマンドが実行された後で値が設定される。

    - ". は挿入モードで挿入された文字列を保持する。挿入モードから抜ける時に記録すればよいだろうか。
    と思ったが説明をよく読んでみるとそういう振る舞いという訳でもなさそうだ。
    よく分からないので実際に動かして試してみる必要がある。

    - "# は代替ファイル (副ファイル) の名前だそうだが何か良くわからない。
    C-^ の動作と関係しているそうだ。これは未だ実装しない。

    - "= これは複雑だ
    - "* "+ "~ これは GUI で選択した範囲を表すものだそうだ。

2017-10-31

  * [保留] vi-mode (_ble_keymap_vi_REX_WORD): Unicode categories?

    Bash の正規表現 (<regex.h> ERE) で対応するのは難しい。
    また必ずしも Unicode (UTF-8) で実行されるとは限らない。
    現在は UTF-8 しか対応していないが枠組みとしては
    別の文字コードにも対応できる余地は残して置きたい。

2017-10-12

  * vi-mode まだ対応していない・考えていないコマンドを列挙する

    意外とそんなに残っていないようなので。

    * nmap: C-^ '括弧 `括弧
      C-t C-] M Q ZZ ZQ do dp { }
      [{char} ]{char} z{char} C-w{char}
      g<C-a> g<C-g> g<C-h> g<C-]> g# g* g$ g&
      g` g' g+ g, g- g8 g; g< gD gH gN gP gQ gT gV
      g] ga gd gf gF gh gn gp gq gs gt gw gx g@

  * [保留] vi-mode: xmap <C-]>

    % <C-]> なる物は今見ても存在しない。vivis https://qiita.com/b4b4r07/items/8db0257d2e6f6b19ecb9
    % 辺りに在ったものかとも思ったが、ない。zsh-vimode-visual を見てもない。
    % vim で C-] としてもベルが鳴る。何かの間違いで C-[ を C-] と書いてしまっただけなのかもしれない。
    % と思って改めて vimindex を見ていたら実はあった。

    C-] で "選択した文字のタグ" へジャンプと書かれている。
    タグとは何だろうと思ったら http://vim-jp.org/vimdoc-ja/tagsrch.html に説明がある。
    ctags のタグと同じものと思って良さそうだ。因みに :help ... で表示されるのもタグの様だ。
    またノーマルモードの C-] はカーソル位置の単語を ":ta" で検索と書かれているが、
    実質 xmap の時と同じことのようだ。

    % これについてはシェルの操作としてどの様な意味を持たせるのかというのは微妙な所である。
    % 履歴項目のブックマーク的なものとして利用することはできるかもしれない。
    % しかし、既にコマンドラインに入力されている文字列を元にジャンプをするとなると矢張り微妙だ。
    % 唯一意味がありそうなのは、指定した単語がコマンドライン上で定義された
    % シェル関数だった時にそこにジャンプするという物だが…本当に需要があるのかは微妙である。
    % しかし、シェル関数の定義を確認したいのであれば寧ろ command-help を呼び出せば良い。
    % シェル関数を修正するという目的ならば使えるかもしれない。
    % 然し、必ずしもシェル関数をコマンドラインで定義したとは限らないし、
    % 該当するファイルがあったとしてもそれをコマンドラインで表示する訳にも行かない。

    既に入力した文字列に対応して適切な履歴項目またはコマンドライン中の文字があればそこにジャンプする。
    例えばシェル関数を定義した履歴項目に跳んだり、変数名から declare に移動するなど。
    そういう機能でまともそうなのが定義できればそれを実装する。

2017-10-01

  * syntax: case $x in (a b) : ;; esac のパターン "a b" はエラー

    どうやら一個の単語までしか駄目な様子?

    更に case aaa in ((aaa)) echo;; esac 等の様に () の入れ子もエラーになる。
    shopt -s/-u extglob に拘らずエラーになる。
    一方で extglob の @() に関しては中で () の入れ子が可能である。
    つまり、case の中の (...) と extglob @(...) の文脈は異なる。

    他にも違いはある。@(<>) は許されるが、in (<>) は許されない。
    @(&&) は許されるが in (&&) は許されない。
    in (a|a|a) は許されるが in (a||a) や in (||) は許されない。
    in (&), in (|), in (;), in (<), in (>) は何れも駄目。
    in (a&b), in (a;b), in (a<b), in (a>b) も何れも駄目。

    どうも全然違う文脈の様に思われてきた。

    現在の実装では ble-syntax:bash/ctx-case から CTX_PATN に突入している。
    (他に CTX_PATN に入っている箇所を探すと、
    関数の引数の括弧に何か変な物が入っている場合と、
    コマンドの途中で突然括弧が現れた場合である。
    これらはエラーに対する復帰としての CTX_PATN なのでそんなに気にしなくて良い)

    どうも振る舞いを観察すると ctx-conditions と ctx-globpat の中間のように思う。
    単語を設置しなければならないという観点で言うと ctx-conditions に近い。
    一方で対応している構文の集合という観点で言うと ctx-globpat が幾らか近いように思う。

    2017-11-27 追記
    どうやら () の中の単語ではチルダ展開も有効のようだ。以下で hello が出力される。
    case a=~ in (a=/home/murase) echo hello; esac # これは対応済み
    case a=/home/murase in (a=~) echo hello; esac

2017-09-18

  * vi-mode: operator = [#tmp0001]

    :help = を見ると (設定 equalprog || 内部関数 C-indenting, lisp || 外部コマンド indent) が使われるそうだ。
    但し、indentexpr が非空白の時、indentexpr が使われる (参照: indent-expression)。

    インデントの規則について調べる。
    先ず初めに空行 (空白だけの行) を隔てて前の行に括弧がある場合には、
    それを考慮に入れて初めのインデントが決定される。
    空行を隔てて前の行がインデントされていればそれを継承する。

    結局空行を隔てた前の行のインデントまたは最後の括弧の位置を継承するということ?

    また括弧の種類は () しか見ていない {} や [] は見ていないようだ。
    デフォルトが lisp だからだと思われる。
    これは実のところシェルに適したインデントを実行するようにするべきなのだと思われる。
    しかしながらシェルのインデントはかなり面倒くさい。
    特に if, then, else, while, do, done 等については現在の解析では状態を記録していない。

    関連してコマンドが閉じていない時 RET を押すと改行挿入にするという物がある。
    この機能を実装する為にも現在の入れ子の状態を調べる仕組みが必要になる。
    RET で改行挿入にする機能のほうが幾らか単純なので、
    それを先に実装してからこれを実装する方が良い気がする。

  * vi-mode: 関連して [/ 等の実装についても調べたい。

    既に vim-surround.sh で類似の機能について実装したが、
    [/ についても個別に実装したい所である。

    他にテキストオブジェクトで [{ [} [( [) などと同等の機能も実装している。

    [# [' [( [* [/ [` [D [I [P [p [[ [] [c [d [f [i [m [s [z [{ [<mouse2>
    ]# ]' ]) ]* ]/ ]` ]D ]I ]P ]p ][ ]] ]c ]d ]f ]i ]m ]s ]z ]} ]<mouse2>

  * vim-surround: ds cs インデント

    surround.vim では改行が絡むとき = によるインデントを実行している。
    現在 vim-surround.sh ではインデントを実行していない。

    2017-10-09 追記

    yS ySS でもインデントは起こる様である。
    更に、xmap S でもインデントを行う (xmap gS はインデントは行わない)。

2017-09-17

  * cmplstofB: ビジュアルモード・選択モード?

    関連 #D0672 選択モード対応

    * テキストオブジェクトで範囲を選択し、また範囲を拡大する。

      どうやらテキストオブジェクトの拡大では左右の両端からの拡大を試みるような気がする。
      決して右端からテキストオブジェクトを拡大するというわけではないようだ。

      というのも変なところから初めて (...) の中に右端を移動して、
      その上で ib としてもエラーになるからである。或いは短くなる。
      どうも ib の動作としては左端から外側の ( を見つけて、
      それに対応する ) を右端に直すようである。

      うーん。これはテキストオブジェクトによって動作が異なるのかもしれない。
      aw などは明らかに右に向かって拡大を行っている。
      因みに矩形選択かどうかは気にしないようだ。
      同じ動作をする。行の右端に行くと次に次の行に普通に移動する。

    2018-02-22 現状の xmap におけるテキストオブジェクトの状況について整理する。
    - ble/keymap:vi/text-object/word.impl に於いては既に xmap での振る舞いに対応している様子である。
    - ble/keymap:vi/text-object/quote.impl は明らかに対応していない→対応した #D0670
    - ble/keymap:vi/text-object/block.impl も対応していない
    - ble/keymap:vi/text-object/tag.impl も対応していない
    - ble/keymap:vi/text-object/sentence.impl も対応していない
    - ble/keymap:vi/text-object/paragraph.impl も対応していない

2017-09-16

  * cmplstofB: vim-surround.sh: ds cs cS yS ySsd ySSd S gS 'C-s' 'C-g s' 'C-g S'

    現在のところ特に要望は出ていないが ds cs あたりは使いたくなるのではないかと思われる。
    → ds cs に関しては要望が出たので対応した。
    → cS yS ySs ySS vS vgS にも対応した。

    残っているのは imap <C-s> <C-g>s <C-g>S のみである。

2017-09-15

  * cmplstofB: here string 候補について

    here string 候補にファイル名以外のものがあれば対応する。返信待ち → やはり候補は難しい。

    コマンド名に応じた補完関数の設定を可能にする?
    例えば python3 に対する here document の場合には、import を補完候補に出すなど。

    2018-10-02 C++ の場合にはこんな感じに clang を呼び出せば良い様だ。
    clang -cc1 -fsyntax-only -code-completion-at=test2.cpp:7:7 test2.cpp
    http://d.hatena.ne.jp/ohtorii/20110319/1300514225

    Here document で補完候補を出す為には、
    Here document の内容 (先頭から現在位置まで) が
    単純内容 (単純単語に近いがシェルの特殊文字を使える) でなければならない。
    その為の関数を追加する必要がある。simple-word の実装を真似れば良い。

2017-08-19

  * [保留] cmap/default.sh: "CAN @ ?" 代替?

    "CAN @ ?" は "C-x C-x" と較べて曖昧ということで現在無効にしている。
    これの代替キーシーケンスを定義しても良いかもしれない。
    といいつつ現実の端末に存在するものを登録しなければ意味がない。
    (そういう意味では "CAN @ ?" もこれに対応する現代的な端末が実在するのか怪しいのであるが。)

    思うに s-x だとか H-x だとか A-x を送りたければ CSI 2 7 ; ... ; ... ~ を使えば良い。
    何故 Emacs が "CAN @ ?" に対応しているのかは謎である。

    →実はこれは isolated esc と同じ方法を用いて区別して受信可能かもしれない。
    しかし、何れにしても "CAN @ ?" に対応している端末は殆どないので、対応する理由がない。
    https://superuser.com/questions/407391/super-key-over-ssh によると Konsole がこの形式を使うそうだ。

2017-03-04

  * syntax: bug ヒアドキュメントによる nparam の更新が追いついていない。

    これは何でかというと nparam の計算に stat 保存点を超えた過去の情報を用いているからである。
    部分更新をしている為に過去の情報が書き換わったとしても
    stat 保存点で解析状態が一致したと見なされてしまい、
    其処で解析が中断してしまうのがいけない。

    これを解決する為にはヒアドキュメントの word に相当する部分は
    一気に解析する様に修正しなければならない。
    結局 word 部分は最終的には独自の方法で読み取るのが良い様な気がする。

    或いは暫定的に範囲を指定して stat を消去する様な機能があったような…?
    →昔その様な処理の仕方をしていたような気がするが、いま確認してみるとない。
    恐らく何か問題が色々生じて結局その方法は使わないという事になった様な気がする。
    記憶が正しければそれは time ... や function func () だとか func () を解析する時の話だった。
    結局何れの場合でも一回の解析で行けるところまで解析するという事になった。
    ヒアドキュメントでもその様に実装するのが一貫している。

  * syntax: ヒアドキュメント 終端 word 着色

    todo: 取り敢えず RDRS 等と同様に完全に入れ子を追跡する様に実装する。

    $() ${} の入れ子も含めた実装が必要になる。

    実は、通常通りに解析してしまって、
    後の着色で一様な色に塗り潰してしまうという方策で良いのではないか。
    しかしそれだと tree-enumerate の際に $() の内部で着色が起こる気がする…。
    % 特に部分更新などをすると確実に内部での着色が発生するのでは…??
    % →部分更新の時は一番外側の単語についても着色が判定されるから特に
    % 部分更新仮想で内科に依る違いは発生しないと思われる。

    取り敢えずの実装として通常通りに解析する様に変更した。
    単に ble-syntax:bash/ctx-heredoc-word から
    ble-syntax:bash/ctx-redirect に処理を委譲するだけで良かった。
    ヒアドキュメント特有の処理は ble-syntax:bash/ctx-heredoc-word/check-word-end
    の方にしかなかったからである。
    また、同時に CTX_RDRI, CTX_RDRH の単語を上から塗りつぶす様にした。
    しかし、やはり予想通り $() の内部などの単語の着色は発生してしまっている。

2017-03-02

  * syntax: パラメータ展開・算術式評価内部の quote 除去が為されない状況での _ble_syntax_attr

    以下の項目で対応しきれなかった (対応しないことにした) ものをここにまとめる。
    cf. #D0375 "2017-03-02 [2016-08-06] syntax: extquote と "${}" の入れ子に関して"

    > - $(()) の中の () のネストに関しては対応していない。
    >   つまり () が一つでも挟まれば quote 除去が有効であるかのように着色される。
    >   →これは対応した。

    - $((a['1+1'])) などの添字の quote 除去は有効であるが、現実装では quote の着色はしていない。
      つまり $(('1+1')) などと同様に quote 除去が為されない物として着色を行っている。

      これに対応する為には $(()) の中でも [] に対応するネストを判定する様にしなければならない。
      ※一方で [] の中では () に対応するネストの判定はしなくても良い。

    - $(("${hello}")) などの構造では CTX_QUOTE の中で自身が有効かどうかを判定して
      自身の着色を変更したりするのは面倒なので、普通に (有効であるかの様に) 着色している。

      算術式の場合には quote 除去されないと分かっている時点で文法エラーになるので
      1文字目をエラーの色にするというので良い気がする。
      パラメータ展開の内部の場合には quote 除去されないからと言ってエラーにはならない。

    - bash では "${var# ... }" の中の '' は quote 除去される一方で、
      "${var:- ... }" の中の '' は quote 除去されない。
      この実装では取り敢えず quote は除去されるという取り扱いである。

      これらについては包括的に振る舞いを調査する必要があるだろう。
      他にも様々な種類のパラメータ展開があるし、
      また将来的に各種類のパラメータ展開についての詳細な構文解析にも対応する可能性がある。
      (特に ${var//a/b} の quote (\?) の取り扱いがややこしいのでこれは視覚的に分かる様にしたほうが良い。)

    - 現状では $(("a")) はエラー着色になっているが実は文法的に有効である。
      同じクォートでも $(('a')) や $((\a)) は文法的に駄目。

    - Bash 5.1 以降では (('a')) がエラーになる様に文法が変わった。

2016-07-15

  * isearch: 現在の履歴内の位置を % で表示しているが、
    これは検索の進捗状況の表示の方が分かりやすいのではないか。

  * complete: declare の引数を特別扱いしているがこれも compgen があればそれに従うべきでは。
    もしくは、何か特別な処理をするとしても compgen を介して特別な処理をするべきではないのか。

    現状の実装だと、declare などの変数を宣言する組み込みコマンドについて、
    ユーザが complete によって補完の制御を行う事ができない。

2016-07-08

  * prompt: 最終行・先頭行に何か表示する機能があっても良い。

2016-07-07

  * isearch: 正規表現検索?

    →取り敢えず vi-mode で実装した #D0513。incremental ではない。

    正規表現で incremental にすると一度通り越したものに一致する可能性があるので直観的でない。
    もし incremental にする需要がある場合には再度考える必要がある。
    因みに、emacs は (分かりにくい動作だが) 現在の位置から続きの検索をする。

  * edit: 置換モード (正規表現・固定文字列・globパターン)?

    その為には置換前・置換後を入力する欄を別に表示する必要がある。
    入力欄でも様々な binding が使えた方が嬉しい。

2016-06-22

  * prompt-toolkit という物がある様だ。ちょっと観察してみるのも良い。

    基本的には補完候補を勝手に出すという事と、
    表示の仕方が emacs auto-complete と同様に
    overlay によって実現されているという事。

    所で overlay で実現するためには複数行で編集を行っている時に、
    下の行にある内容を記憶しておく必要性が生じる。
    Emacs の場合には表示している内容を完全に内部に保持しているので問題にならなかった。
    (a) 現在の実装で実現するためには内容を完全に記憶するか、そうでなければ
    (b) 複数行で編集を行っている場合には枠の位置・大きさを変更する際に
    毎回下の方にある行を再描画するかといった事が必要になるだろう。

    Bash では 2 次元配列を実現するのは辛いので
    結局内容を完全に記憶するというのは余り嬉しくない事だろうか。
    と思ったが、表示領域の幅 (COLUMNS) さえ把握しているのであれば、
    実は 1 次元配列の上に terminal の内容を保持してしまっても問題ない気がする。
    というか枠の大きささえ決まっていれば普通に sub window の様な物も
    bash で実現する事ができる。今まで余り考えたくないとして避けていたことだが、
    この方法ならば楽である。

  * GUI Window System を整える? Window を出したり消したりだとかそういう事。

2016-04-05

  * tree-enumerate による skip の実装と解析一時中断の不整合に関して。

    ble-syntax.sh: ble-syntax/parse/shift.impl2 の問題点である。

    現状の方法では、解析一時中断を行った時に shift 対象の高速な列挙が出来なくなる。
    唯一の現実的な高速化手法は "直前非空白要素の位置" を管理するように変更する事である。
    これは解析自体の動作とは全く関係なく、_ble_syntax_tree/stat/nest の配列としてのデータ構造を拡張するという事である。
    解析自体の実装とは直交して実装する事が可能と思われるが、新規情報の管理コストが増えるという問題点が残る。

    →一方で tree-enumerate を使った場合には閉じている単語内部の shift を省略できるなどの利点がある。
      最終的にはこれらを組み合わせたような shift が必要になるだろうと考えられる。
      もう少し詳しく考察を行う必要性がある。

2015-12-20

  * complete: 履歴を用いた候補生成? 特に単語について。

    2018-09-23 これは動的略語展開によって部分的には対応された。
    しかし処理の重さから一度に全ての候補は計算しないし、
    また文法的な単語ではなくて COMP_WORDBREAKS によって分割された単語である。
    これを本当に対応しようと思ったら background でプログラムを
    走らせるなどの事が必要になる気がする。

2015-11-21

  * 公開までに追加であった方が良いかも知れない物

    + 拡張性の提供 (拡張の仕方の説明)
      + theme の枠組を整える事 (setting files の置き場?)
        ble-color-list
      + 文字コード拡張 (Unicode との mapping)
      + 端末制御コード拡張
        tput からもっと積極的に読み込むべきなのでは?
        cmap/default.sh に加えて cmap/tput.sh 的な物も?
        > minimal.sh, xterm.sh, rosaterm.sh の整理。

    + 簡単なキーボードハンドラのサンプル (テトリスとか? 或いは sentaku 再実装とか)

      サンプルとしては、端末の出力画面に現れる物よりは、
      画面を altscreen で完全に切り替える物の方が実装しやすいと思われる。
      それでいて、read -t 0 などを有効に使えるとなるとテトリスなどになるだろうか。

    + マウス対応

    + キーボード入力内容を全部 vbell で表示する方法?

2015-11-06

  * まったく同じ nest 状態になると思われるのに解析中断が起こらない

    ☆これは表面上は何の問題も起きない。多少無駄な処理をするだけである。
      従ってそんなに対処に緊急を要しない。

      | function ble-syntax/parse/nest-equals {
      |   local parent_inest="$1"
      |   while :; do
      |     ((parent_inest<i1)) && return 0 # 変更していない範囲 または -1
    -->     ((parent_inest<i2)) && return 1 # 変更によって消えた範囲
      |
      | local _onest="${_tail_syntax_nest[parent_inest-i2]}"
      | local _nnest="${_ble_syntax_nest[parent_inest]}"
      | [[ $_onest != $_nnest ]] && return 1
    変更によって消えた領域を指している場合は、
    既に消えた領域のデータを捨てているので nest の判定を行う事ができない。
    そんな訳で解析中断はできないと判定されてしまうのである。

    ここで解析中断を出来るようにする為には消えた領域のデータも取って置いて、
    その上で全く同じ解析結果になったら解析中断を行う、という事になろう。
    以降の解析の動作に違いがなければ良いのだから
    過去の nest の状態だけが一致していれば解析中断には充分である。
    これは別項目として独立させて残す事にする。

    ※問題は解析領域拡大によって i1 が後退する事によって
      変化の無かった部分についても解析結果が消去されてしまう事にある。

2015-08-20

  * エラー検出・表示の管理について

    現状

    現在エラーは様々な方法で使用者に対して提示している。
    解析の途中状態で既にエラーと分かる物については
    _ble_syntax_attr に ATTR_ERR を設定している。
    これは _ble_highlight_layer_syntax1_table を経由して表示の着色に反映される。
    もう一つのエラーの種類は入力したコマンドラインの末端で入れ子が閉じていない物である。
    これは一番最後の文字と対応する入れ子の開始点の色を変更する事によって提示する。
    この着色は解析点より前に対して行われるので部分更新の対象とする事は難しい。
    従って _ble_highlight_layer_syntax3_table を介して、毎回全消去・再計算を実行している。

    以下に改善したい箇所について列挙する。

    - この様に複数の方法を用いてエラーを提示しているのは少し醜い。
      もう少し統一した枠組を作っても良いのではないかという気がする。

    - ATTR_ERR を用いて設定したエラーは、
      後の処理で追加される単語毎の着色によって上書きされてしまう。
      つまり、折角エラー通知の為に着色を設定していても使用者に見えない事がある。
      別の場所にエラーを登録しても良いのではないかという気がする。

    - 各エラー項目に対して何が問題なのか・何のエラーなのかのメッセージを設定したい。
      これらのメッセージも枠組の中で管理して、カーソルの位置に応じて表示できる様にしたい。

    もう少し現状について調べて実装の方法について考える。
    先ずエラー情報を記録する為の配列の形式について。
    既存のエラー着色に使っている配列 _ble_highlight_layer_syntax3_table が気になる。
    これを拡張する形で実装する事はできないだろうか。。
    →この配列は部分更新できないような情報を保持するのに使っている。
      部分更新できない様な着色であっても今回の実装によって
      よりましな方法に変更できるのではないか、という気もするが、
      それは今回の実装が終わってから考えれば良い事である。
      (初めからその様な物にも対応できる様に今回の実装を設計するという事も出来るが
      複雑になるので、取り敢えずは何も考えずに実装する事を目指す。)

    つまり、_ble_highlight_layer_syntax3_table は non local な着色の為に使うとして残し、
    それとは別にエラーを管理する為の配列を作成する。

    部分更新の際の効率を考えると _ble_syntax_attr と同様に、
    編集文字列中の位置を配列のインデックスとする方法が良さそうに思われる。
    然し一方で、エラーの数はそんなに沢山になるとは考えがたい (sparse) なので、
    リストにして管理するという方針も考えられる。どちらの方が良いだろうか。
    リストにしている場合、"エラー設置点 エラー開始点 エラー終了点 メッセージ" というデータ形式になるだろうか。
    shift や解析中断後の再開に際してはエラー設置点を用いた filtering を行う。
    % このエラー情報の内容は解析の動作に全く影響を与えないし、
    % 解析が同じように進めば全く同じエラー情報を生成すると期待できるので、
    % 解析中断の判断基準に含める必要はないと考えられる。
    →本当だろうか。エラー開始点・終了点などの情報は解析状態が同じになっても異なる値になりうるのでは?
      特に、現在 _ble_highlight_layer_syntax3_table で管理している物はその最たる例である。
      ここで、エラー開始点・終了点が正しく設定される為には次の条件が必要である。

      エラー設置点を p1 とする。ble-syntax/parse の 1 step で i=i1 から
      i=i2 まで進む (但し i1 <= p1 < i2) 時、エラー開始点 p2, 終了点 p3 は、
      i1 <= p2 < p3 < i2 を満たす。

      この条件が揃っている時のみに現状の解析中断条件で部分更新安全である。
      因みに p2, p3 を設置点からの相対位置で記録しておけば shift の操作が必要なくなるのでその様にするべきである。

2015-08-16

  * 入れ子構造を考慮に入れた効率的な単語着色

    現状: 新規生成単語及び消滅単語の範囲 (range1) に関して再度単語の着色を実行する。

    x 但し、着色は "消滅単語の存在していた範囲" 及び "新規生成単語登録位置の範囲"
      に登録されている単語及びその子孫だけになっている。
      本来は、range1 に被さっている全ての単語について処理を実行するべきである。

    - 考慮に入れるべき事として、将来的に解析を途中で停止した場合でもそれなりに動くような方法がよい。
      しかしながら未だ解析を終えていない部分については結局どうしようもないから、
      解析が完了している部分文字列について木構造を作成して処理する事になるだろう。
      結局、現在 shift を実行するのに用いているのと同じ事をする事になる。
      (そしてそれは tree-enumerate/.initialize で実装されているので余り気にする事はない。)

    方法

    a 一つの方法は tree-enumerate を使用して末端から順に単語の範囲をチェックしていく方法である。
      つまり、現状の shift の実装と同じになっている。

    b もう一つの方法は、先に単語の木構造の情報だけ構築してから、
      range1 に対応するノードを列挙して構築する方法である。
      木構造として親ノードの位置・子ノードの配列を保持していれば、
      指定した範囲に対応するノードの範囲を効率的に計算する事が出来る。

      ただし、木構造の情報の構築自体にどれだけのコストがかかるかについて考える必要がある。
      木構造は後ろから掘り出すようにして実行する為、
      更新範囲の beg から文字列の末端 iN 迄を完全に構築し直す必要がある。
      部分更新するというのが難しいと思われる。

      しかし、部分更新は全くできないのでは等と考えていたが、
      考えてみると意外と部分更新も出来るのではないかという気になってくる。
      更新範囲に含まれていないノードの内部構造に関しては実は更新の対象ではない。
      また、更新範囲より前にあるノードの内部構造についても同様である。
      但し、親ノードの位置は、更新範囲より前にあるノードであっても更新する必要がある。

    c 或いは、parse の過程でより分かり易い木構造データも同時に構築してしまうという手もある。

      x parse の内部状態を増やせば増やす程、解析中断が難しくなるが
        最終的に構造を再構築するのであれば結局中断してもしなくても同じかも知れない…?
        しかしながら木構造を考えずに parse した後、木構造に対する更新を行った方が処理量は少なくなるはずである。
        というのも木構造を考えながら parse する事にすると、
        更新の必要のない文法的処理も木構造の構築と同時に実行してしまうからである。
        それよりは、文法的処理で必要最低限の所を parse で処理して、
        木構造の構築について必要最低限の所を後の処理で実行する、という形の方が良さそうである。

      o ただ、parse の過程で木構造も一緒に構築するようにした方が、
        データ同士の依存関係が整理されて良いという側面もある。
        parse の後で木構造としてどの範囲を更新するべきかを決定するのは面倒でありバグを生む原因にも成る。
        →parse の後で処理をする際にも何らかの "原則" を決めてその下で実装するなどした方が良いと思う。
        (逆に言えば上手に原則を決める事さえ出来れば、parse で木構造を構築する事の利点はなくなる。)


    入れ子構造の実装後に改善できる箇所
    - tree-enumerate-in-range 及びその呼出元
      現在は愚直に範囲内に設置されている単語識別子を

2015-08-15

  * syntax: `function ...' において関数名の部分に使用した履歴展開を解釈する?
    履歴展開だけを解釈する新しい文脈が必要になると思われる。

    然し乍ら、履歴展開の結果として複数の単語になる場合などを考えると、
    そもそも一つの単語として読み取って良いのかなど疑問点が残る。

    % 或いは、その場で履歴展開としての妥当性を検証して色をつけてしまうという手もある?
    % →これだと正しく解釈されない。例えば履歴展開には $ が含まれて良いが関数名には $ が含まれないので、
    %   先に関数名としての切り出しを実行すると $ の直前で不正に関数名が中断する事になる。

2015-08-14

  * 高速化: ble-syntax/parse: より厳密な shift 範囲の特定・省略?

2015-08-11

  * 今後必要になる大きな書換・再実装は2つある:
    1 コマンドライン着色の効率的方法の模索
    > 2 shift の高速化の為の _ble_syntax_word, etc. のデータ構造の変更

2015-02-24

  * layer の仕組みに対する問題提起

    | 現在の実装では各レイヤーは下のレイヤーが提供した文字配列を弄る事によって動作している。
    | しかし、実の所受け継ぐのは文字配列ではなくて描画属性の配列の方が良いのではないだろうか。
    |
    | o 先ず第一に実装の簡便さがある。
    |
    | o 次に、更新範囲というのは複数のレイヤーで似たような箇所になりがちなのではないかと思う。
    |   属性の配列で渡して置いてから一番最後の所で更新範囲に対して切り貼りをして文字配列を構築した方が良いかも知れない。
    |
    | x ただ、文字配列にするという事の利点も存在する。
    |   region 等の様に大域的に色を一時的に変更する様な物の場合、
    |   文字配列として region の下層にあるレイヤーについて記録を行っておく事は有意である。
    |   選択が解除された時に再び構築し直すというのは時間が掛かる。
    |
    |   但し、その様な動作をする物は限られている様にも思われる。
    |   殆どの場合には纏まった箇所でコンパクトに更新が行われる。
    |
    | x 括弧の対応などの場合、まとめて描画属性から文字列を構築する場合に細かい最適化が出来ない。
    |
    |   複数のレイヤーの描画属性の配列からまとめて文字列を生成する場合、
    |   複数のレイヤーが報告した更新範囲を総合してその範囲で文字列を再生成する事になる。
    |   しかし、括弧の対応など、実際の変更が小規模に渡るにも拘わらず、
    |   離れた二点で実施される色付けの場合には、変更の実体に反して範囲が拡大する。
    |
    |   今迄の様に文字列を各層で構築する方式の場合には、
    |   更新を各層の関数の中で自由に行う事ができるので、
    |   自身の変更の update に関しては最適な方法で更新する事ができる。
    |
    |   とはいいつつも更に上のレイヤーに渡す更新範囲はやはり巨大な物になる為、
    |   上のレイヤーでの合成作業が大域に渡る事は考えておかなければならない。
    |   実のところ合成作業についてはちゃんと実装していない。
    |   region に関しては可能な限り最適な方法になる様に実装したが滅茶苦茶複雑になった。
    |   実際の実装では被覆によって隠される更新などについては考慮に入れなくても良いが、
    |   複雑になりそうだという事に代わりはない。
    |   結局、内部的に描画属性の配列を持って更新に望まなければならないという事態になりそうだ。
    |
    | 何れにしても現在の実装は、今後拡張していく上で非現実的な感じがする。
    | ベースを (下層の情報を含まない) 描画属性の配列を上流に渡す方法に変更した方が良いのではと思う。
    | region 等の実装の際には cache を行う様にする等の工夫をその上で実装する様にしてみたい。
    |
    | また、実装が複雑になるが仕様がない。
    | 取り敢えず現在の所まともに着色を行っている所が syntax だけなので、
    | これを ble-highlight-layer:syntax に対応する上で考えてみる。
    |
    | ble-highlight-layer:syntax の内部で三つの描画属性の配列を用意し、
    | これらの三つの描画属性の配列を総合する事で文字列を構築する様にしてみた。
    | 可もなく不可もない感じの実装である。
    | 少なくとも各層で文字列を構築する様な実装はしたくない。
    | これぐらいが丁度良い実装の複雑さである様に思う。

    将来的には描画属性の配列で対応できる様にする。

2015-02-23

  * bleopt_suppress_bash_output 制限

    - SIGWINCH (ウィンドウサイズ変更) の時に bash の表示する物になってしまう

  * 描画ちらつき: DCH や ICH 等を用いた効率化?

2015-02-18

  * エラーメッセージの設定を可能にする

2015-02-16

  * syntax: ToDo

    - [[ 条件式の文法。より正確に。特に括弧の入れ子。

      →括弧の入れ子というのはどういう意味であったか?
      今試してみた所括弧の入れ子などは関係なく ]] が来れば条件コマンドは終了とみなされる様である。
      例えば $ [[ ( [[ == ]] ) ]] は構文エラーになる。初めの ]] で条件コマンドが終了と解釈される為である。

2013-06-10

  * sword で quote を正しく処理する?
    これは少なくとも解析器が出来た後に考える。

2013-06-01以前

  * ble-decode
    + [kbd] terminfo からの読み取り (entry 名は tmux が参考になる)
    * ble-bind: -s オプションで文字入力の羅列を指定できる様にする (2019-02-10 #D0915 で実装)

  * 説明書
    + 文字コード decoder の追加方法
    + keysequence を指定する文字列の文法 (2018-09-23 done)
    + スタイルを指定する文字列の文法 (2018-09-23 done)

    取り敢えず GitHub の Wiki 上に作る事にした。


*******************************************************************************
    Done (実装ログ)
-------------------------------------------------------------------------------

2020-11-12

  * syntax: オプションの単語着色にも対応したい [#D1410]

    コードを少し確認してみたが複雑になりそう。- で始まる物については強制的にオプ
    ションと見做す様にする。但し、-- が途中にある場合には着色しない様にする。

    と思ったがその様に実装する為には、コマンド抽出をして -- がないかどうか確認す
    る必要が出てくる。つまり、処理が重くなる可能性があるという事? と思ったが現在
    の実装ではコマンド抽出はどうなっていたのだったか。独自の着色を許すのだとした
    ら何れにしてもコマンド抽出を始めに実行しなければならない。そして各単語につい
    て毎回コマンド抽出をしていると非効率である事から、普通に考えて単語情報はちゃ
    んと既にあると考えるのが自然。現在の実装を確認。

    呼び出し元で -- の確認をしてオプションを付加するのが良い気がする? 実装を確認
    してみたが、単に各単語について word:default を呼び出しているだけであった。つ
    まり、つまり単語について調べる必要がある。

    実装してみたが微妙。途中に = や : がある場合は除外している。本来は = の左側
    と右側で独立に着色を決定したい。右側も着色する為には右側に対してパス名の着色
    を適用できる様にしなければならない。

    パス名については =, : で区切って着色を与えているが最後のパスしか着色していな
    い。パス名の着色について再考してから対応する必要がある気がする。

    → #D1409 で一緒に実装した。

    * -- という引数が指定された後はオプションとして解釈しないという処置が未実装。
      →対応した。

    * mandb による補完候補の着色にも同じ色を用いる。

  * highlight: =, : で区切られたパス名の着色について再考 [#D1409]

    現在の実装では locate-filename で最初に全体に一致を試みて、それから次に先頭
    から順に削っていくという方法になっている。この様になっているのは
    https://... 等の形式の URL または C:\... の形式のファイル名を認識する為であ
    る。これを拡張して任意の場所で切れる様にするにはどうしたら良いか?

    例えば A:B:C となっていたとする。できるだけ長く一致させたいので A:B:C から順
    に試していく? A:B, A と試して、駄目であれば B:C, B, C という順に試していく。
    途中で一致した場合にはそれで確定して、未処理の文字列についてまた続きから試す。

    現在の実装では =, : を等価に取り扱っているが、= は最初の一つだけ処理する様に
    したい。或いは、最初に = で分割して、その後で : で分割する? 何だかよく分から
    ない。。。というより、= については左辺の形に制限を加えるべき。変数代入形式か、
    或いは -[-[:alnum:]_]+ で一致させる事にする。

    a. ^-[-[:alnum:]_]+= に一致する場合には、= 以前を強制的にオプション着色にす
      る。この場合には右辺の中の = は分割に寄与しない。右辺は : で分割しても良い。
    b. ^[[:alnum:]_]+= に一致する場合には全体をファイル名と見做しても良いし、或
      いは、右辺をファイル名と見做しても良い。右辺は : で分割しても良い。
    c. それ以外の場合には = は分割でない。: で分割しても良い。

    1 先ず初めにオプションに一致するか確認して、もし一致したら其処までを処理済みにする。
    2 オプションに一致しない場合には変数代入の形式になっているか確認して、
      もし変数代入の形式であれば = を可能な分割点の候補として登録する。
    3 残りの部分は : を分割点の候補として登録する。
    4 分割点の候補を元にしてできるだけ長く一致させる。

    eval の戦略についても考える必要がある? 分割点が決まったら先に各要素を eval
    してしまうか、或いは、試行の度に eval を実行するか。うーん。各要素を eval し
    てから繋ぐ事を考えていたが、実は試行の度に eval しても良いのではないかという
    気がしてきた。OK

    * done: ble/syntax/progcolor/wattr#* の整備

      次に考えるべき事。各パス要素毎に着色をするとすると、前のパス要素の結果を明
      示的に処理しなくても自動で構築できる様な方法で登録する必要がある。

      wattr を動的に構築できる様に枠組み (ble/syntax/progcolor/wattr#*) を整えた。
      先ずは既存の振る舞いを壊さない様に wattr#* に移行する。以前よりもコードが
      すっきりした。

      更に progcolor/word:default についても全体に wattr#* を使う様に書き換えた。
      前より少しぐちゃっとしている気がしないでもないが、恐らく慣れの問題だろう。
      客観的に考えれば変数の変な取り回しも除かれて前よりも整理されている筈。

    オプションの着色は後回しにして、取り敢えずパス名の着色について再度。

    取り敢えず = による分割は確定という事にして、探索は : 区切りだけにする。或い
    は , も区切り文字として解釈しても良いかもしれない。というのも、
    -Wl,-rpath,... 等の様なオプションの指定の仕方をする事がある為。

    * done: locate-filename を複数のパスを抽出する様に書き換える。
      →書き換えた。ret は配列になり第一要素は今迄と同じく範囲の開始である。
      但し、最後の範囲ではなくて最初の範囲の開始である事には違いがある。
      これだと範囲の開始点以降全てをファイル名とみなす実装に於いて問題が出るが、
      関数の意味的にはそんなに変な拡張ではないので良しとする。

    * done: locate-filename を用いて新しく各パス要素を着色する様に変更した。動い
      ている。古い実装はもう削除しても良い様な気がしている。オプションに関しても
      ちゃんと動いている。

    * ok: highlight: echo hello:~ において ~ の着色が行われない。と思ったが、こ
      れは恐らく意図した振る舞いである。と思ってコードを確認したが、やはりちゃん
      と処理していない気がする。変数代入形式の時には ~ を有効にしたい。と思って
      実際に試してみるとちゃんと変数代入形式の場合には ~ の着色が有効になってい
      る。これについてはどうやって実現されているのか改めて確認が必要である。

      →これについては分かった。文法解釈を参照して tilde がチルダ展開の物かどうか
      判定している。この実装で良い。

    x fixed: パス要素が誤っている場合に locate-filename でファイル名と検出されず
      に着色されない。この場合には途中の正しいディレクトリ名までは着色したいが、
      全体が無効な文字列となってしまっているので全く着色されない。

      認識できないパスに関してはどの様に取り扱うか。: で強制的に区切って着色する
      か、或いは greedy に探索して駄目だった所からまた : を見つけて着色するか。
      自然な振る舞いになる様にしようとすると後者になるが、実装が複雑になる。もし
      その様に実装するのであれば、: で区切ってから着色するのではなくて、最初から
      / と : で区切りながらパスを着色して行く実装にするべきだった。

      うーん。再実装するべきだろうか。再実装するとするとファイルが存在しない時の
      取り扱いについて確認が必要。コマンド名の時にはエラー着色にしていた。然しコ
      マンド名は : による分割の対象ではないので問題ない。

      うーん。どうするのが良いか。: で区切るという規則の引数の場合には何れにして
      も : で分割する。ファイルが存在するかしないかで : で区切るかそうでないかが
      変わるという事はありえない。一方で URL を受け付ける様な引数の場合には : で
      区切るという事はない。色々考えると、URL 判定は : で区切った後に実行するの
      ではなくて、最初に実行するべきなのでは。URL に一致しない時に指定された引数
      が : で区切ったパスなのかそうでないのかの判定が現在の問題である。

      うーん。結局全体が一致しなければ即座に : 区切りであると判断して良いのでは
      ないだろうか。と思ったが新しい未だ存在していないファイルを指定する場合で、
      ディレクトリ名に : が含まれている場合には全体を path として取り扱っても良
      いのではないだろうか。つまり、先ず初めに / で切りながら存在するディレクト
      リまで取得を行う。ディレクトリが存在しなくなってそれ以降に : が含まれてい
      たら : で区切られる物と見做す。ディレクトリ名に : が含まれていた場合には強
      制的に : は無効で良いのではないか。整理すると以下の様になる。

      1 最初に全体に対して URL 判定 / C:\... 判定を行う。
      2 / で切りながら存在するディレクトリまで読んでいく。
      3 (2) のディレクトリ名に : が含まれていれば : 区切りではない。
      4 (2) の残り部分に : が含まれていれば : 区切りである。
        つまり存在するパスに : が含まれず存在しない部分に
        : が含まれる時にのみ : 区切りである。
        どちらにも : が含まれない時にはどう取り扱っても良いので、
        実際の所は、存在するパスに : が含まれていれば : 区切りではない。
        : が含まれていなければ : 区切りである。という判定で良い。

    x ok: 実装してみたがかなり遅い。と思ったが、これは eval の中でグローバル変数
      の復元等の複雑な処理を行っている為である。$HOME などのパラメータ展開が存在
      する場合にはそんなには遅くならない。

      これに関してはまた別の課題として後で考える事にするのが良い。

    x detect-separated-path を実装したら動かなくなっている。常に単一パスと判定さ
      れている。調べたら detect-separated-path の中でファイルが存在しているかど
      うかの判定をするのを忘れていた。常に存在する取り扱いになっていた。修正した。

      しかし、未だ動かない。今度は locate-filename が動いていない気がする。丁寧
      に見てみると実は wtxt を更新するのを忘れていた。直した。今度は動いている。

      うーん。PATH=... の場合にはこれで動く様になったが、今度は通常の引数の場合
      に全く動いていない。prefix が存在しない場合でも動かなくなっている。何故だ
      ろう。

  * syntax: [:alnum:] 等を使ってしまったが [#D1408]

    良く考えたら locale 依存で変な文字も含むのでやはり直接 a-zA-Z0-9 等と指定す
    る必要がある。

    →これは全体的に書き直した。vi.sh の [:alnum:] は vim の単語の判定に似せた物
    なので [:alnum:] で良い。decode.sh に残っている [:alnum:] に関しても、通常文
    字でない事の判定なのでそのままで良い。

2020-11-11

  * global: 改めて ble/bin/* の使用について確認する [#D1407]

    core-syntax.sh に関しては #D1406 により完全に ble/bin/* は排除した。

    edit.sh に関しては

    - bash-4.3 以下で ttyname を取得する為に tty を使用している
    - command-help を表示する為に awk, man を使用している。
    - removed: suppress_bash_output の終了処理で rm を使用している。
      実はこれは _ble_base_run の一括の削除に任せれば良いのではないか。
      →うーん。やっぱりそうだ。$_ble_base_run で削除されるのだから
      わざわざここで rm を呼び出す必要はない。
      ファイルの存在・非存在が振る舞いに影響を与える物でもない。
      一応中身をクリアしておく事にする。
    - bash-3.2 以下では C-d を捉える為に色々していて、その為に
      grep, rm, mkfifo を使っている。これは仕方がない。

    ble.pp

    - rm, mkdir, chmod, readlink: ble.sh のディレクトリの初期化・終了処理

    def.sh

    - blehook/.compatibility-ble-0.3/check: cat (ユーザーにメッセージを表示する)

    util.sh

    - ble/util/declare-print-definitions: awk
      declare -p の出力結果のバグを修正する為に用いている。
    - ble/util/strftime (bash-4.1 以下): date
    - ble/util/msleep (bash-4.3 以下): rm, mkfifo, sleep, sleepenh, usleep, etc.
    - ble/util/getmtime: date, stat (この関数自体使われていない)
    - ble/term/stty: stty ユーザーコマンドを実行する時の環境の調整

    decode.sh

    - ble/decode/nonblocking-read: od (大量の入力があった時の処理の為)
    - ble/decode/cmap/initialize: awk (cmap キャッシュ初期化)
    - ble/decode/bind/.generate-source-to-unbind-default: (初期化)
    - ble-bind -L: sed
    - ble/builtin/bind/.reconstruct-user-settings: sed, cat, mv, awk

    benchmark.sh

    - (diagnose) ble-measure: awk (小数の計算)

    history.sh

    - awk, mv, sed, wc

    core-complete.sh

    - (performance) grep, sed, awk, sort
    - (mandb) man, gzip, nroff, mkdir

    取り敢えず wiki/Note.md にまとめた。

    * 他に > でリダイレクトしている箇所がまた現れていたのでこれを >| に修正する。

  * syntax: enable -p | grep で builtin を判定しているのは何故か [#D1406]

    core-syntax.sh 及び edit.sh (command-help) で以下の様な判定をしている。

    enable -p | ble/bin/grep -q -F -x "enable $cmd" &>/dev/null

    何故単に type -t $cmd を用いなかったのか。或いは初期からあったコードの可能性
    もある。と思ったが 3 forks + 2 exec と書いている事から速度については意識して
    いた筈の気もする。どの時点でこのコードになったのか経緯を調べる必要がある。

    変更履歴を辿ると以下の様になっている。

    9aa1e267 (Koichi Murase 2015-02-16 03:55:37 +0900 2396)     elif enable -p | fgrep -xq "enable $cmd" &>/dev/null; then
    a4f89a71 (Koichi Murase 2015-12-03 08:10:41 +0900 4425)     elif enable -p | command grep -q -F -x "enable $cmd" &>/dev/null; then
    1649187a (Koichi Murase 2018-02-12 13:52:39 +0900 5832)     elif enable -p | ble/bin/grep -q -F -x "enable $cmd" &>/dev/null; then

    9aa1e267 は一番最初に ble-syntax.sh を repository に追加した commit である。
    つまり、enable -p の使用は一番最初期のコードの名残である。
    これは type -t $cmd を用いた実装に切り替えて良い気がする。

    と思ったが微妙。どうも keyword が quote されていてコマンドとして取り扱う必要
    がある時に、どうやってそのコマンドの種類を特定するのかという話の様だ。
    loadable builtin で keyword と同名のコマンドをロードしていた時にどの様に取り
    扱うのかという事。type -tは "keyword" を返すので使えない。

    * 実際にダミーの builtin を作成して試してみる? Cygwin で builtin をコンパイ
      ルしようとしたらできない。昔コンパイルした様な気がする。その時にはどうした
      のだったか。libbash.dll 的な何かを作った様な気がする。

      ? と思ったが bash の既定の loadale builtin ではどの様にコンパイルしている
        のだろうか。或いは、実は cygwin 上では loadable builtin はコンパイルしな
        い?  →実際に確認した所コンパイルされていない。Makefile は生成されている
        のでディレクトリに入って make して見るが、そうするとやはり同様のエラーが
        出てコンパイルできない様だ。

      bash の Makefile に ($(Program) に対するルールを弄って) 以下を追加して libbash.dll を得た。

      libbash: libbash-5.0.11.dll
      libbash-5.0.11.dll:  .build $(OBJECTS) $(BUILTINS_DEP) $(LIBDEP)
          $(PURIFY) $(CC) $(BUILTINS_LDFLAGS) $(LIBRARY_LDFLAGS) $(LDFLAGS) -shared -o $@ $(OBJECTS) $(LIBS)

      これに対してリンクしてビルドすると一応ビルドはできた。然し実際に実行してみ
      ようとすると先ず libbash-5.0.11.dll が存在しないとロードに失敗する。そして
      実際に実行してみると libbash-5.0.11 の内部の変数に対して処理を実行している
      様で、本体の bash に対して変数に対するアクセスが反映されていない。駄目だ。

      唯、keyword と同名の物が存在する時にどう振る舞うのかについての実験はできる
      だろう。これで実際に簡単なコマンドを作成して実行してみる事にした。hello と
      いう名前の builtin コマンドは無事に作成して呼び出す事ができたが、time や
      while と言った名前のコマンドについては駄目。enable -f でロードする所までは
      できるが、実際に呼び出そうとするとコマンドが見つかりませんでしたというメッ
      セージが出て実行されない。

      これは cygwin 特有の問題だろうか。chat でも試してみたが駄目だった。
      bash-3.0 でも振る舞いは同じである。つまり、enable -p で確認するとちゃんと
      出力されていたとしても keyword と同名のコマンドは定義しても使えない。

      % 結局、enable -p は実際にその builtin が使えるかどうかの判定には使えない。
      % 表示されていても keyword に一致するコマンドは実行する事ができないからで
      % ある。

      と、思ったら 'while' を上書きするとコマンドが見つかりません、という状態に
      なるが、'time' というコマンドを上書きするとちゃんと動く。'while' を続けて
      ロードすると 'time' までも使えなくなってしまう。Cygwin でも再現した。

    試してみて分かった事は enable -p はコマンドを実際に使えても使えなくても表示
    してしまうが、enable "$cmd" はコマンドが有効でないと失敗するという事。

    うーん。分かった。type -a -t $cmd を実行すれば良い。実際に使える時に2番目以
    降にちゃんと候補が表示される。ちゃんと 'while' をロードすると他も使えなくな
    るという振る舞いも type -a に反映されている。どうせなので ble/util/type で
    -a を指定して全ての候補について取得してしまう事にした。

2020-11-06

  * complete: コマンドラインオプションの説明を表示する機能 [#D1405]
    https://www.reddit.com/r/bash/comments/joafpu/is_it_possible_to_achieve_zsh_like_completion_in/

    やはりそういった要望は存在する物である。

    x 然し、問題は man から抽出するにしても --help から抽出するにしても、別にこ
      れらのファイルは文法が決まっている訳でもないので、抽出ミスが生じる可能性が
      あるという事である。

      man (roff) の形式の方が未だ信頼性はある。然し、サブコマンドのオプションを
      拾う可能性や諸々がある。更に -- の後に続く引数がオプションとして取り扱われ
      るかそうでないかというのもコマンドに依存して色々だろうと考えられる。これら
      に対する完全な解は存在しないと思われる。或る程度の間違いをユーザに許容して
      もらわなければならない。これに関してはオプションでユーザに有効化してもらう
      事にするのが良い気がする。

    x 更に言うと --help を認識しないコマンドで勝手に実行すると困るものだって存在
      するかもしれない。例えばユーザーが作った command.sh 等のような物は引数を水
      に既定の処理を実行する物だって存在する。という事を考えると勝手に知らないコ
      マンドに対して --help をつけて呼び出す訳には行かない。

    zsh でどうなっているのか調べてみる。autoload -U compinit; compinit とすると
    初期化される? オプションを補完している時にはオプション名と説明が表示されるが、
    ファイル名が表示されている時にはファイル名だけが表示される。何を補完している
    かに応じて表示の形式を変更している様である。そもそも引数が - で始まらない場
    合にはオプション名は補完候補に出さない。また - で始まる引数の場合には通常の
    ファイル名は補完候補に出さない。という具合に排他的になっているからである。

    ble.sh の argument でもその様に実装して良いのかもしれない。現在の実装だと -
    で始まる引数であってもファイル名に曖昧補完してしまって使いにくい。- で始まる
    場合には専らにオプションとして補完するのが自然だろう。

    zsh のオプションの説明は grep で確認した所 man でも --help でもない。どうも、
    自前で用意した説明を表示している可能性?

    * man の解析
      取り敢えず ble.sh では man を解析するという具合にしても良い気がする。
      man の解析は…awk を使っても良いだろうという気がする。
      然しその前に man の文法についてちゃんと調べておく必要がある気がする。

      - .XX は特別に処理する必要がある。
      - \- は - に置換する。
      - \^ は空文字列に置換する。
        (grep の man で -- が \-\^\- とエスケープされている。\-\- だと駄目な理由が存在する?)
        groff を見ると \^ はとても小さな空白 (1/12em よりも小さい)という事になっている。
      - [ や ] の周辺の空白は除去する。
      - "..." はそのまま表示する。

      groff のマニュアルを見ても .TP 等は載っていない。
      https://man7.org/linux/man-pages/man7/roff.7.html に載っている .XX には
      結構 man で使われている物が載っているがそれでも .TP は載っていない。

      - https://linuxjm.osdn.jp/html/LDP_man-pages/man7/man.7.html に .TP が載っている。
        https://linuxjm.osdn.jp/html/GNU_groff/man7/groff_man.7.html にも説明が載っている。
        どうやら -mNAME でマクロ定義ファイル NAME.tmac を読み込む事ができて、
        man の指定は an.tmac というマクロファイルにあるので roff のオプションに
        -man と指定できるという仕組みになっている様である。

      - 様々の複雑な指定が存在している事を考えると man のソースではなくて、
        man の出力を見るべきだろうか。うーん。或いは、
        自前で色々弄った後に groff に食わせる。groff -Tascii -man file.1 で行ける。
        試しに適当な内容を作って groff に食わせたが何も起こらない。
        どうも .TH で最初にページ名などを初期化しなければならない様だ。
        groff がない場合はどうするのか。troff と nroff を試してみたが、
        troff はよく分からない出力結果になった。nroff は groff と同じ結果。
        調べると troff は印刷専用のようである。

      うーん。候補と表示内容を変更したい時にはどうすれば良いか。
      既存の物でそれを実行していた物があったような気もするし、
      なかった様な気もする。表示内容を勝手に変更した時の問題は、
      部分一致の太文字を表示できなくなるという事。
      という事を考えるとやはり候補と表示内容は一致させている気がする。

      →と思ったら init-menu-item で prefix と suffix を指定する事ができる。
      ここで [=WHEN] だとかその他諸々を記録すれば良い。

      取り敢えず補完の表示に必要な情報は抽出できた様な気がする。
      然し問題点はこれをどのように bash の配列に記録するのかという事。
      例えば抽出した情報はファイルに保存しておく。
      補完を実行する時にその情報を読み取り候補生成する。
      全てのデータを DATA に保存してしまう事にすれば良い気がする。

    * 指定したコマンドに対応する man を探し当てる方法?
      MANPATH 及び /usr/share/man を探す?
      man1, man8 の辺りを探索すれば良い気がする。
      : で区切られたパスからファイルを探す関数は既にあっただろうか。
      ない気がする。新しく実装して良い気がする。

      manpath は /etc/manpath.config), ~/.manpath, MANPATH
      /usr/local/etc/man_db.conf など様々な場所に保存されている?
      どうやら man -w で manpath 一覧が出力される様だ。
      更に man -w grep 等で実際のファイルの場所が出力される様だ。
      然し、これは POSIX ではない様である。

      従って、(1) man -w grep を試す (2) man -w を試す (3) /etc/* を読み取る (4)
      MANPATH を参照する…。と思ったが、/etc/* の中身は結構複雑である。そもそも
      /etc/* の設定に対応している man 実装は高機能なので -w ぐらい対応していても
      良い気がする。殊更に独自実装をする必要はないのではないか。単に
      /usr/share/man:/usr/local/share/man:/usr/local/man を探索すれば良いのでは
      ないだろうか。→その様に実装した。実は簡単だった。わざわざパス検索用の関数
      を用意する程でもない?

    これ以降の変更は core-complete.sh に対する変更が必要なので取り敢えずここまで。

    * 実際に得られた結果を用いて実装した所、呆気なく動いている様な気がする。

    x done: 但し、説明を表示する為には bleopt を desc-raw に設定していなければな
      らない。という事を考えると menu_style を動的に変更できる仕組みを整えるべき
      かもしれない。然し、menu_style が動的に変わってしまうと問題になるので、
      menu の何処かに記録しておく必要がある…と思ったがそれは既にその様にしてい
      る筈。これも簡単に対応できた。

  * complete: filter を cand/yield の中で実行する枠組みを整える (motivated by timjrd) [#D1404]

    filter:substr に対して source:file がより緩い条件で候補を生成したとしても、
    後の filter:substr/filter で除外されてしまう。そもそも後で一括して filter す
    る事自体が物事を複雑にしている。cand/yield で cand_cand その他に登録する時点
    で filter してしまって良い様な気がする。

    更に、source:file でフィルタを実行しても良いという事を確かめる必要がある。

    先ずその様に書き換えても問題が起こらないかを確認する。

    * 先ず filter でやっている事を確認する。

      filter-by-regex は cand_cand に対してフィルターを実行している。
      filter-word-by-prefix は cand_word に対してフィルターを実行している。
      →これは別の filtering で使っている物であって関係ない。
      cand_cand は補完単語を格納していて、cand_word が実際に挿入される文字列を格納している。
      filter-by-command はコマンドを指定できる物である。
      実際に使っているのは filter:substr

    * 問題がある。独自に filter すると filter:substr/match の実装が乖離してしまう。
      つまり、メニュー選択で太字の着色がなされなくなってしまう。
      候補ごとにフィルターを記録する様にするとまた面倒になる。

      或いは始めから一致位置を計算して記録する事にする? 然し実際には使われない事
      の方が多いのでやはり重さを考えると一致位置を一緒に計算するのは避けたい。
      action に処理を紐付ける事にする? 然し filter の種類の情報も記録しなければならない。

    取り敢えず独自にフィルターを実行するかどうかはさておき、
    cand/yield の内部でフィルタを実行するという実装にはする。
    そちらの方が自然だからである。

    * done: comp_filter_type と comp_filter_pattern の宣言されている場所、
      代入されている場所、使用している箇所を確認する。
      現状では別々の場所で宣言・代入しているが、
      両者の取り扱いを統一できればしたい。

      comp_filter_type について先ず調べる。

      宣言 ble/complete/candidates/generate-with-filter
        ここで宣言したものは以下で使用されている。
        使用 ble/complete/source:*

        通常の補完の場合にはどうだったかと思ったが、
        調べてみると head フィルタを使っていたので、
        ちゃんと ble/complete/candidates/generate-with-filter
        を経由して呼び出されていた。

        ble/complete/source:* の呼び出し元は他には存在していない。

      宣言 ble/complete/menu-complete.class/render-item
        ここでの宣言・設定はこの関数の中で閉じている気がする。
        ややこしいのでこれは単に filter_type 等に変更するのが良い気がする。
      宣言 ble/widget/auto_complete/self-insert
        ここでの宣言・設定もこの関数の中で閉じてはいるが、
        comp_filter_pattern については共有している。
        対称性を考えるとこのまま comp_filter_type で良い気がする。

      comp_filter_pattern について次に調べる。

      宣言 ble/widget/complete
      宣言 ble/complete/menu-filter/.filter-candidates
      宣言 ble/complete/auto-complete/.check-context
      宣言 ble/widget/auto_complete/self-insert
      宣言 ble/complete/source:sabbrev

        どうやら兎に角 filter を呼び出している箇所で全て宣言している様である。

      設定 ble/complete/candidates/filter:*/init
      使用 ble/complete/candidates/filter:*/filter
      使用 ble/complete/candidates/filter:*/test

        実際の値の設定などに関しては filter 内部で閉じている。

      filter の関数を呼び出している箇所は多岐に渡る。

      ble/widget/complete
        ble/complete/insert-common
          ble/complete/candidates/determine-common-prefix
            ble/complete/cndidates/filter:*/count-match-chars [OK]
        ble/complete/insert-braces
          ble/complete/insert-common..

      ble/complete/menu-complete.class/render-item
        ble/complete/cndidates/filter:*/match [OK]

      ble/complete/menu-filter/.filter-candidates
        これは内部で宣言・使用する事にした。

      ble/widget/auto_complete/self-insert
        これも内部で宣言・使用する事にした。

      関数 ble/complete/menu/generate-candidates-from-menu

        ここで comp_filter_pattern の値を復元しようとしているが、実際には空の値
        を設定している。source の内部でしか使わないからというコメントが書かれて
        いるが、実際には insert-common の内部でcount-match-chars を使っている。
        と思ったが、count-match-chars は実は comp_filter_pattern は使っていなかっ
        た。従って comp_filter_type も comp_filter_pattern も使っていない。代わ
        りに、自分で filter_type も自分で明示して呼び出す必要がある。

        実は全く使っていないのであればそもそも comp_filter_pattern を設定する必
        要はないのでは。というより ble/widget/complete の内部で宣言する必要はな
        いのではないか。

      うーん。ble/complete/candidate/filter:*/init 等の呼び出しを実行する
      関数を追加してしまう? comp_filter_type はその時に pattern と一緒に宣言する。

        ble/complete/candidates/filter#init head "$COMPS"
        ble/complete/candidates/filter#apply
        ble/complete/candidates/filter#test "$cand"

      match, count-match-chars は stateless なので直接呼び出して使う事にする。

    * done: 現在 comp_filter_pattern は ble/widget/complete の内部で宣言しているが、
      これは実際に filter を使う箇所で宣言するだけで良いのではないか。
      改めて filter#* が使われている箇所を確認する。

      - ble/complete/candidates/generate-with-filter
        comp_filter_type, comp_filter_pattern は ble/widget/complete ではなく
        generate-with-filter の内部で宣言する事にした。
      - ble/complete/menu-filter/.filter-candidates
        これは既にその場で宣言している。
      - ble/widget/auto_complete/self-insert
        これも既にその場で宣言している。
      - ble/complete/source:sabbrev
        これは source の内部なので comp_filter_type,
        comp_filter_pattern は既に宣言されている。

    次に cand/yield の内部で filter を実行する様に変更する。

    * done: その様に変更した。というより一行追加しただけである。
      同時に複数の関数が不要になった気がする。
      大分コードが綺麗になった気がする。

    ? cand/yield で filter するとしても、menu-filter では結局 filter されてしま
      う。従って menu-filter でも filter 方法を変更する必要があるのではないか。

      或いは substr では候補を何も生成せずに hsubseq まで行ってから substr に相
      当する候補を生成して、もし何もなければ本来の subseq や hsubseq を生成する
      という方針も考えられる…。と思ったが、そうすると別の source による結果が
      存在する時に substr でそちらの候補だけが表示される事になり不自然な結果に
      なる。

      そもそも曖昧補完の substr で path component 毎に substr にして生成する必
      要性があるだろうか。考えてみたが余り複雑な事をしてもユーザがついて行けな
      い。という事を考えると、やはり *dir1/dir2/file* の形式だけを取り敢えず許
      すというので良いのではないか。或いは何も生成しない。

    % source 側で(既定と異なる) filter するに当たっての現状の問題点は以下の二つ
    %
    % * menu-filter で結局通常の filter 動作で除外されてしまうという事
    % * menu の着色でどのように一致したのかの着色が正しく反映されない事
    %
    % * 共通部分の何処までを挿入するかの決定。
    %
    %   これは実は各候補毎に決定しているのではなくて共通の設定として決定しているの
    %   で、単純に source:file に合わせて計算するという事はできない。これは遡った
    %   書き換えが起こった時に今までの候補生成ができなくなる事を防ぐ為のものなので
    %   特別な処理はしなくて大丈夫な気がする。しかし source:file の様に足並みを外
    %   すような物があった場合に本当に正しく動くのかに関しては注意が必要である。
    %
    %   そもそも共通部分の挿入によって候補生成が破壊されるのはどのような時だったか。
    %   うーん。分かった。まず最初に通常の common-prefix を求めているが、曖昧補完
    %   の場合には必ずしも common-prefix が元々の COMPV の文字を全て含んでいるとは
    %   限らない。(本来は common-prefix ではなくて common subseq に対応する何かを
    %   求める必要があるが、展開などを考えると難しいという事か)。
    %
    % DATA 経由で特別な動作を実装する?
    %
    % * source:file は action:file 及び action:tilde を生成している。
    %   と思ってよく見てみると action:tilde の場合にはチルダ展開のみしか
    %   候補生成していないので、実際には action:file を気にすれば良い。
    %
    %   一方で source:glob も action:file を生成している。
    %   source:glob については曖昧補完の時には候補を生成していない。
    %
    %   何れにしても action:file に対して DATA を指定している物は存在していないので、
    %   気にせずに DATA に新しく filter_type 等指定しても良い気がする。
    %   と思ったら source:argument も file を生成している。
    %
    % 自前の filter を実行しているかどうかに関しては、
    % cand/yield の時点で判定可能なので、内部で処理する?
    % と思ったが自前でフィルタしていても元のフィルタの振る舞いに準拠している可能性もある。
    % その場合には自分で処理するのではなくてやはり既定の filter に処理してもらいたい。
    %
    % うーん。改めて確認すると construct-pathname-pattern を使用している箇所は複数存在する。
    %
    % source:file,directory でファイル名を列挙している箇所 (action:file)。
    % source:argumet で = の右側のファイルを生成している箇所 (action:file_rhs)。
    % source:command でディレクトリ名を列挙している箇所 (action:command)。

    うーん。色々考えると substr を source:file に対して特別に実装する必要がある
    のか疑問である。実のところ同等の候補が subseq, hsubseq で生成されるのだから
    substr の段階で候補を生成しなくても良い気がする。

    特別な実装はしないという事に決めた。

  * syntax: [!...] が常にエラー着色になっている問題 [#D1403]

    うーん。これは ble/syntax:bash/simple-word/is-simple が成功しているのに、
    ble/syntax:bash/simple-word/evaluate-path-spec が失敗しているのが行けない。
    正規表現の構築で ! を含めるのを忘れているという事だろうか。

    is-simple で使っている正規表現は以下の通り。
      local letter='\[[!^]|[^'${_ble_syntax_bashc_simple}']'
      _ble_syntax_bash_simple_rex_element='('$bquot'|'$squot'|'$dquot'|'$param'|'$letter')'
      _ble_syntax_bash_simple_rex_word='^'$_ble_syntax_bash_simple_rex_element'+$'

    evaluate-path-spec で使っている正規表現は以下の通り。
      local letter1='[^'$sep$_ble_syntax_bashc_simple']'
      rex_element='('$bquot'|'$squot'|'$dquot'|'$param'|'$letter1')+'

      あー。分かった。letter で特別扱いしている物を入れるのを忘れている。

    他にも同様の違いがある物が色々ある。これは #D1303 の cmplstofB さんの報告が
    あった時の修正で中途半端な修正になっていたのが原因。合わせて関連する letter
    の正規表現も一括して修正する。

  * syntax: glob bracket expression で POSIX [...] に対応していない (reported by alvinseville7cf) [#D1402]
    https://github.com/akinomyoga/ble.sh/issues/66

    これは簡単に対応できると思ったが動いていない。何故?
    どうも [...] の2文字目は既に特別に処理してしまっている様子。
    と思ったがそうではなかった。条件コマンドの [[ を判定する為に、
    [[ の連なりは連続して読み取るという事にしていたのである。

    これをどうにかして防ぐ?  [[= [[. [[: の時には 1 文字だけしか読まない様にする?
    これだと余分に先読みしている事になるが仕方がない。

    またそれとは別の問題として [![:lower:]] が何故か常にエラー着色になる。
    failglob かどうかに関わらず。履歴展開が関係している可能性?
    というより [!x].txt としてもエラー着色になっている。
    もう ! が存在しているだけでエラーという事なのだろうか。
    うーん。然し glob でなければ問題は起こっていない気がする。
    [^x].txt でもエラー着色になる。

    更に [[:lower:]] が simple words ではない事になっている?

2020-10-10

  * 2020-09-07 prompt: rps1 の内容が長くなった時に表示が乱れる [#D1401]
    次の行に改行してしまう。これは表示している内容に依存せずに長さだけで決まる様だ。

    入力部分に未だ 10 文字程度の余裕がある段階で問題が発生している。
    これはもしかするとプロンプトを表示しなくする条件と関連している可能性?
    或いはプロンプトの範囲を制限する事に失敗している可能性?
    スペースが限られている時に rprompt をどの様に処理しているか確認する必要がある。

    変なのは長さが足りなくなると一番最後の列から表示し始める様に変化してしまう
    という事。謎。或いは本当は全く表示しない様にした筈なのに表示されてしまって
    いるという事なのだろうか。

    →分かった。修正した。rps1_show の時にだけ表示するべき所が常に表示される様
      になっていた。

    * 然し、rps1_clear と rps1_show というのがあって、これの違いは何だろうか。
      rps1_clear は前回は表示されていたけれども新しく消す事になったという事を表
      すのだろうか。だとすると、動的に rps1 の内容が変化した時に残像の様な物が
      残ってしまうのではないだろうか。と思ったが、残像が残ってしまうのはどの様
      にしてもやはりそうなのではないかという気がする。

      % →取り敢えず rprompt を描画する場合には先ず消去を行う事にした。(本来は
      % rprompt の前回の表示内容を管理してそれに応じて消去・更新をするべきなの
      % だとは思われる。)

      と思ったら、消去に関しては既にその様になっていた。然し、消去の判定は単に
      rps1_transient によって、次の行に移る時に削除するという処理だけの様である。
      rps1 の内容が変更された時には前の描画を削除するという様な処理は行わない様
      である。というより、rps1 の内容が変更されたという事が分かる時には既に前回
      の rps1 の内容についての情報は喪われているので現在の実装では消去する事が
      できない。

      現在の実装では transient によって rps1 が消去された時に、改めて
      ble/textarea#render/.cleanup-trailing-spaces-after-newlineを呼び出してい
      る。これが何だったかというと…。端末に無駄な空白が記録されるのを防ぐ為だっ
      た。rps1 が表示されている時にその間に空白が埋められるのは仕方がないとして、
      rps1 がない時には空白ではなくて NUL がそこにあるという状態にしたい。

      - rps1_clear=1 rps1_show= → 消去
      - rps1_clear= rps1_show=1 → 描画or再描画
      - rps1_clear= rps1_show= → 前回表示した物のまま

      前回表示していなくて今回新しく表示する場合はどうなるか?
      →大丈夫。消去して新しく描画する事になる。
      前回表示していて今回表示しない場合にはどうなるか。
      →表示したままになってしまう。これだと表示を取り消す筈なのにそのまま
        前回の内容が残ってしまう。

      問題は前回表示していたのか表示していなかったのかの情報が記録されていない
      という事。前回表示していたかどうかに関わらず動作する方法は存在するだろう
      か。前回表示していても表示していなくても、今回表示するのであれば
      $_ble_edit_rprompt_dirty に委ねれば良い。では今回表示しない場合にどうする
      か。前回表示していれば消去するし、前回表示していなければそのままで良い。
      取り敢えず毎回消去すれば良いだろうか。然し、そうすると表示していない状態
      の時には更新がある度に毎回消去が発生する事になり非効率的であ
      る。_ble_edit_rprompt_dirty を参照しても表示を実行していないので常に 1 に
      設定されている。そういう事を考えるとやはり新しい変数を作って現在非表示か
      どうかを管理した方が良いのではないだろうか。

      →取り敢えずコードを整理した。rps1_{enabled,clear,show} 等の様々な変数が
      あったが、整理して rps1_enabled だけを用いる事にした。

  * prompt: 丁度折返しの起こる場所の直後が全角文字の時に空白文字が余分に入る [#D1400]
    screen の中でも発生しているし contra の中でも発生している。
    →確認したら普通に padding 文字の幅の計算をみすしていた。修正した。

  * ble_debug 配列の表示が冗長なのを改善できないか [#D1399]
    多少コンパクトになる様にして quote を着色する様にした。

  * ble_debug 改名 [#D1398]
    bleopt syntax_debug に改名した。

  * complete: shopt progcomp_alias とは何だろう [#D1397]
    progcomp の補完関数の探索に alias 展開も考慮に入れるという物。
    この機能自体は ble.sh にもある様な気がするが、
    実際に progcomp に対して有効になっていたかは分からない。
    →これは実際に確かめてみた所、実装済みだった。
    単に shopt -q progcomp_alias を見て機能を無効化できる様にした。

  * menu: やはり上下移動は一番最初の列を覚えておくべき [#D1396]
    実装した。逆方向の探索の実装は非効率的な気がする。
    現在の実装では最初から全ての要素を見ていって調べる事になっている。

    a 一つの方法は二分探索して同じ行の始まりに移動するという事。
    b もう一つの方法は逆方向から要素を参照するという事。最近の実験によれば実は
      配列を逆方向に触るのは最近の bash ではそんなに遅くない。何より大量の要素
      を抱えた配列でなければ問題は起こらない。今の場合は探索対称の配列は現在の
      ページに含まれている要素しか含んでいないので、要素数が物凄く沢山という事
      もないし、逆方向に探索する事による速度の問題はないと考えられる。

    取り敢えず逆方向から一つずつ見ていく方式で再実装した。
    速度は改善した気がする。ちゃんと動いている。

2020-09-26

  * edit: 行末まで色が残ってしまう問題を修正したと思ったが直っていない [#D1395]

    % どうやら contra & ble.sh のバグが組み合わさって
    % screen の内部でも再現しなくなっていただけで未だ問題は直っていない様だ。

    否、rps1 が表示されている時には問題ないが、rps1 がない時に問題が生じるという事の様だ。

  * 2020-09-01 color: 24bit color を使うと背景色がおかしくなる [#D1394]

    これは contra の方で修正した。

    | $ ble-color-setface command_builtin 'fg=#4bd'
    | $ echo hello
    | $ echo
    | $
    |
    | auto_complete の背景色がクリアされないまま残ってしまっている?
    | printf '\e[m' してもそのままになってしまう。
    | C-l しても背景色がクリアされないまま残っている。
    | layer のキャッシュに削除しきれない物が残っている?
    | と思ったがそうでもないようだ。
    |
    | どうも contra の方のバグの様な気がする。ED 等の塗りつぶしに使う属性が
    | 書き換えられてしまっているか或いは描画時のブラシの管理が狂っている。
    | contra x11 でも再現する。xterm, mintty では再現しない。
    | やはり contra のバグだろう。

  * edit: mc の対策として sgr0 を省略する様にしたら着色が残ってしまう様になった [#D1393]

    何故だろうか。うーん。contra の中だと発生しない。
    screen の中だと発生する。mintty や cygwin/ConPTY でも発生する。

    contra の中で発生していないし rps1 がなくても発生している事を考えると、
    別に空白文字が実際に大量に出力されているという訳でもないのだろう。
    具体的にどの様な出力がされているのかについて調べてみる事にする。

    →調べると ECH(113) が出力されている。成程、これで contra と他の terminal の
    振る舞いの違いが説明できる。ECH の出どころは何処か。put-ech.draw を見張って
    見たが此処は通過しない様だ。_ble_term_ech で調べると、

    * reject: もう一つは textmap#update にある。eraser という所で行のそれ以降の
      文字列を消去している。取り敢えずここに _ble_term_sgr0 を入れる事にする。
      →と思ったが此処を修正しても何も変化がない。此処は関係ない?

      ? 懸念: SGR を復元する必要があるのではないか?

        _ble_textmap_ichg は関係あるだろうか。
        _ble_textmap_ichg は改行について登録している。
        というかこれは #T0005 で議論している内容である。
        #T0005 の内容は改行にエラー着色がある時にそれをどう表示するかという話。
        改行の "SGR が行末まで反映されるのを防ぐ" のではなくて、
        "一文字だけ着色" などの細かい制御をどうするかという話である。
        確かに、全く表示しないというのでも良いのかなど色々単純ではない。
        今回は textmap#update に対しては変更は行わない事にする。

    * ok: もう一つの箇所は ble/textarea#render/.erase-forward-line.draw である。
      ここにも _ble_term_sgr0 を入れる事にした。
      →これにより動く様になった。

    * ok: rps がない場合には EL が使われている。
      この時にもちゃんと対策する必要があるのでは。
      →これも上と同じ箇所での処理である。同様に _ble_term_sgr0 を入れる。

    * ok: contra が ECH に対して現在の背景色を適用しないのは意図的だったか。
      うーん。変だ。既定では mode_bce が true なので現在の背景色で ECH する筈。
      然し、実際には反映されていない。何故だろうか。うーん。これはバグである。
      →これは contra を修正した。

  * edit: mc と一緒に使うと mc が固まる (reported by onelittlehope) [#D1392]
    https://github.com/akinomyoga/ble.sh/issues/62

    報告した症状は起動時に 10s の delay が入るということ。
    これは自分の手許でも再現する。

    | 何故だろうか。取り敢えず実行してみると mc は新しく PTY を作って、その中で
    | bash を interactive に起動する様子である。
    |
    | というか mc はどういう言語で書かれているんだ?  PTY を生成しているという事は
    | bash という事はなかろう。何のために bash を起動している? 不思議なのは実際に
    | コマンドを実行する場合にはnon-interactive の bash が使われているということ。
    | 或いは、ble.sh がロードされていなければ interactive になるのか。fallback と
    | して non-intarcive の bash になっているのか。
    | →どうやらその様である。
    |   ble.sh なしで起動した時には interactive mode になっている。

    * mc はコマンドを受け取る為に PTY を開いて中で bash を interactive mode で起動する。
      然し、ble.sh が有効の時には何らかの timeout により non-interactive bash に fallback する。

    | prompt-attach をしない様にすればOK? と思ったが実際に attach するとやはり動かない。
    | うーん。mc は一体何を期待しているのだろうか。或いは… C-q 等の状態になっている可能性?
    | 或いは stty の状態を ble.sh が変更しようとするのがいけない可能性?
    |
    | もしかして mc はプロンプトが表示されるのを待っている可能性?
    | そして PS1= を設定している。と思ったが、vi モードの時には -- INSERT -- を表示するから
    | それを prompt だと判定しても良いのではないかという気がする。
    | 実際に一回起動してから source ble.sh すると -- INSERT -- をプロンプトだと思う様である。
    | それに PS1= を設定するのにプロンプトが表示されるのを待つというのは変である。

    mc の中にいる事を判定できる方法はあるだろうか。例えば環境変数が設定されているかなど。
    調べてみると以下の変数が設定されているので検出する事は可能である。
    そもそも mc は自身の line editor を使っている様なので、
    ble.sh が使えなくても特に問題はない。
    なので基本的には mc の内部では ble.sh を無効にするという方法で良い筈。

    declare -x MC_SID="30814"
    declare -x MC_TMPDIR="/var/tmp/mc-murase"

    一方で何故この様な振る舞いになるのか調べておく必要はある。
    ソースコードは以下にある。C言語で書かれている。
    https://github.com/MidnightCommander/mc

    | ソースコードを検索してみたが特に bind を使って bash と交信しているという事はない気がする。
    |
    | * TERM も別に mc の物を設定しているという訳ではない。
    | * ble-0.1 でも同様に問題は発生する。
    | * PS1 に変な物が指定されているという事もない。
    | * PS1='\$ ' として見ても問題は変わらない。
    | * bleopt_internal_suppress_bash_output= を試したがやはり振る舞いは変わらない。
    |
    | mc は一体何を待っているのだろうか。エラーメッセージもないので分からない。
    | mc のソースコードの何処かに non-interactive で起動するのと
    | interactive で起動するのの二種類が存在する筈である。
    | 或いは PTY ありとなしで起動しているだけの可能性もあるが。
    | うーん。grantpt で検索したら subshell/common.c に init_subshell という関数があって、
    | 其処で色々と初期化している様に見える。
    |
    | mc をコンパイルした。試してみる。確かに init_subshell の中で 10s 過ごしている。
    |
    | どうも PROMPT_COMMAND に pwd >&XXX を設定していて、
    | これが実行されるのを待っている様だ。
    | と思ったが、もしそうならば --noattach & attach でちゃんと動く筈なのでは。
    | 実際に試してみると PROMPT_COMMAND は ble-attach 時には空になっている。
    | →PROMPT_COMMAND を何処で設定しているのかと思ったら一回起動した後に、
    |   PROMPT_COMMAND=... というコマンドを pty 経由で入力している。
    |
    | ble.sh はコマンド履歴を受け取っていない気がする?
    | それなのに .bash_history にはちゃんと文字列が追加されている。
    | これは一体どういう事なのだろうか。別の経路で bash 本体がコマンドを受信している?
    | と思ったが分からない。それは考えにくいという気がする。
    | 或いは単に見落としだろうか→見落としだった。
    | ちゃんと実行されていた。然し問題はコマンドの途中の改行で分割されて実行されているという事。
    | 多分 syntax が初期化される前なので文法チェックがなされずに直接コマンド実行されているという事?

    状況をまとめると。mc は bash に対して 'PROMPT_COMMAND=云々' というコマンドを送信する。
    そして次のプロンプトが表示される時に PROMPT_COMMAND に設定した pwd >&15 というコマンドを経由して
    現在のディレクトリを受信する。現在のディレクトリを受信する迄待ち 10s で timeout すると失敗と見做す。

    ble.sh は最初のコマンドを受信するが受信した文字列を、
    途中の改行で分割して個別に実行しようとする為、PROMPT_COMMAND の設定に失敗する。
    従って pwd >&15 がいつまでも実行されないのでブロックされる事になる。

    syntax.sh がロードされていない状態でもちゃんと
    文法チェックをする様にした方が良いのかもしれない。

    うーん。分かった。何故効かないのかというと \n (C-j) を使って改行を入力しているからだ。
    一方で ble.sh では C-j を強制実行に割り当てている。

    % 取り敢えず ble-bind -s C-j $'\r' 等としておけば問題は発生しない様だ。
    % 報告されているもう一つの問題もこれで一緒に解決する。
    % 対策としては MC の中にいる時には既定で上記の設定に切り替える。
    % もしくは最初のコマンド実行迄は C-j を強制的に C-m に読み替える様にする。
    % MC の中にいるかどうかをより正確に判定するにはどうすれば良いか。
    % MC_SID の有無だと更に subshell の中に入った時にも対策が起動してしまう。
    %
    % * 強制的に attach している筈なのに ble-detach 状態になっている。何故か。
    %   と思ったらそもそも ble-attach していなかった。そしてble-bind で解決したかに見えたのも、
    %   単に ble-attach していなかったからである。

    改めて回避方法について考える。ble-bind -f C-j nop とすると、
    ごみの bash_history すら追加されなくなる事を見ると、
    ちゃんと ble-bind は効果を持っている。然し、反応がなくなってしまう。

    とここで分かった。先ず ble.sh の C-m は文法構造に関係なく、
    続きに何か入力がある時には改行挿入と見做す。
    そして一旦改行がコマンドラインに入ると以降は multiline mode になって
    以降どんなに改行が現れても改行挿入にしかならない。

    つまり ble.sh の C-m でも C-j でもない振る舞いにしなければならない。
    うーん。accept-line でも文法チェックを行う?
    →結局 accept-line に syntax という引数を与えるか、
    或いは $$MC_SID == $$ 且つ LINENO == 0 の時に文法的に完全かどうかをチェックする事にした。

    x fixed: 実際にコマンド履歴に妙な物が大量に出力されている。
      これについてもどうにかする必要がある。
      或いは特に問題が発生しない限りはコマンド履歴に変な物が登録される事はないのだろうか。

      というか普通に bash が起動できた場合にもこのごみが出力されるのだろうか。
      →確かにごみが .bash_history に残ってしまう。
      cd の記録程度であればまあ残っていても良い気がするが、
      PROMPT_COMMAND 云々は .bash_history に残す理由もないし消したい所である。

      うーん。ble.sh だと PROMPT_COMMAND= と PS1= の二種類のコマンドが履歴に書き
      込まれてしまって、最初の物は空白が前置されているので HISTCONTROL に
      ignorespace が入っている distro では何も起こらないが、二番目の PS1= は空白
      が前置されていないので本当に履歴に書き込まれてしまう。所が bash の中で実行
      すると PROMPT_COMMAND しか設定されない。この違いは何処から来るのだろうか。
      或いは何かのエラーが起こった時に fallback として PS1 を設定している?

      ソースコードを見るとちゃんと PROMPT_COMMAND と共に PS1= が送信される様になっている。
      然し実際に起動した物を見ると PS1 は設定されていない様に見える。何故。
      うーん。どうもこれは kill -STOP $$ がどの時点で発動するかという問題の様だ。
      元の bash では \n が来た時にコマンドの解釈が途切れるので、
      その時点で SIGSTOP が来て bash が取り敢えず動作を停止する?
      一方で、ble.sh では kill -STOP をしてもお構いなく入力されたコマンドを全て実行する。
      結果として後に続く PS1= も一緒に実行されるという事である。

      これは意図的にその様に動作する様にしているのだと思われるが何故かはよくわからない。
      取り敢えず現状のままに ble.sh の中では PS1= も実行してしまうという振る舞いのままにする。
      cd に関してはユーザの設定で HISTCONTROL=ignorespace でも追加してもらう事にする。

    x fixed: プロンプトが消滅している。これは rps1 やその他の特別なプロンプトを
      $MC_SID == $$ の時には表示しない様にすれば良い気がする。
      と思ってその様に対策したがそれでもプロンプトが消滅したままである。

      明示的にプロンプトの設定を全て削除してもやはりプロンプトは消滅したままである。
      というかそもそもプロンプトが食われてしまって何も表示されない。
      という事はプロンプトを抽出するコードで何か問題が生じているという事。

      調べると正に read_subshell_prompt という関数が存在している。
      うーん。というかもしかして kill -STOP を用いて区切れを判定している?
      そして kill -STOP のタイミングが変なのでプロンプトではなくコマンドの出力と思われている可能性。
      然し、実際にはプロンプトが消滅してしまっているという事を考えるとやはり違うのだろうか。
      或いはプロンプトが消滅してしまっているのは単に \r\e[K して現在行を消去しているからという可能性もある。
      それにテストしている最中に -- INSERT -- をプロンプトと認識してしまう事もあったので、
      恐らく kill -STOP のタイミングによる問題ではないのではないか。

      * 改めて read_subshell_prompt の動作について確認する必要がある。

        read_subshell_prompt の呼び出しを見てみると通常の bash では一回しか呼び出
        されていないのに、ble.sh の中ではコマンドを実行する度に 3 回呼び出されてい
        る。最初の呼び出しでは空文字列が読み取られ、二回目の呼び出しでちゃんと内容
        が読み取られる。最後の呼び出しで \e[m が読み取られて終わる。
        どうして呼び出しの回数が異なるのか。

        何処から呼び出されているのか。filemanager/layout.c の do_load_prompt から
        呼び出されている。そして do_load_prompt は更に load_prompt から呼び出され
        ている。呼び出し経路を調べてみると、

        bash (1) do_load_prompt -> read_subshell_prompt (有限)
        ble.sh (1) do_load_prompt -> read_subshell_prompt (空)
        ble.sh (2) load_prompt -> do_load_prompt -> read_subshell_prompt (有限)
        ble.sh (3) load_prompt -> do_load_prompt -> read_subshell_prompt (sgr0)

        の様になっている。ble.sh では load_prompt 経由の読み取りが余分にある。
        そして load_prompt は filemanager/midnight.c の初期化時に

          add_select_channel (mc_global.tty.subshell_pty, load_prompt, NULL);

        の様にして登録されている以外は使われていない。要するに pty で何か受け取っ
        た時に load_prompt が呼び出されるという事の様に思われる。それにしても何を
        trigger にして呼び出されるのだろうか。

      * 3回目の read_subshell_prompt の呼び出しで sgr0 を読み取ってしまうのが原因に思われる。
        この3回目の read_subshell_prompt が起こらない様にすればよいのではないか。
        その為にはこの sgr0 の出どころを調べる必要がある。

        何が起こっているのか分かった。ble/textarea#render を実行すると、
        特に更新の必要がない場合には ble/textarea#focus が呼び出され、
        カーソル位置を ble/textarea#render の現在位置に移動する。
        この時に sgr0 を出力してから移動しようとするのである。

        もう一つの疑問は何故二つに分けて出力されているのかという事。
        うーん。分かった。ble/textarea#render -> ble/util/idle.do
        -> ble/textarea#render の順に呼び出されている。従って、
        ble/textarea#render が二回呼び出されるのである。

      うーん。goto しても移動がない場合には _ble_term_sgr0 は出力しない事にする?
      他に影響があるかどうか分からないが多分大丈夫だろう。
      →これでちゃんと動くようになった。実は set -o vi でもちゃんと動いている。
      -- INSERT -- を表示するタイミングとプロンプトを表示するタイミングが偶々
      良い感じになっていたからだと思われる。

      それでも C-o の画面に戻るとプロンプトが消滅してしまってはいる。これは画面
      の一番下にいる時に発生している。どうも mc はコマンドを実行する時に画面の一
      番下の行にカーソルを持ってくる様である。ble.sh の canvas は行を全て管理で
      きていると思っているから、消去したい panel に普通に CUD で移動して削除しよ
      うとする。然し、実際には CUD で移動するのに失敗して誤って現在の行を削除し
      てしまうという事。これは対策できる気がする。対策した。

  * widget: keymap による自動的な振る舞いの切り替えの仕組みを作る [#D1391]

    うーん。何だか面倒になってきた。そもそも vi_imap の時にだけ振る舞いが変わる
    物が多過ぎて widget が色々異なるのが面倒である。ble/widget/newline を呼び出すだけで
    現在の keymap に応じて適切に振る舞いを変更する様に変更したらどうだろうか。
    edit.sh に全ての実装を書き込むと edit.sh が肥大化してしまうので、
    動作を自動的に切り替える仕組みを作るというのでも良い。

    と思ったが ble/widget/newline に関してはユーザの好みで振る舞いを変えたい事もあるかもしれない。
    等と考えると、keymap で固定してしまうのではなくやはり自分で設定できる様にするべきだろうか。
    うーん。然し、それはオプションで制御できる様にしても良い気がする。
    或いは、もしユーザが自前で widget を作るのだとしたらそれは備え付けの ble/widget/newline とは
    関係がないのだから気にしなくても良い。

    というか今その対策をする必要はあるだろうか。
    うーん。この対策をせずに実装しようとすると、
    accept-line についても vi_imap 云々という keymap 判定をしなければならなくなる。
    取り敢えず暫定の実装として accept-line の内部で keymap 判定を実行する様にするか、
    或いは先に keymap 判定を自動的に実行する仕組みを作って整理してから accept-line
    に対する対策を実行するか。

    先に ble/widget/newline 等の実装を自動で切り替える仕組みを実装する事にする。
    対象は newline, accept-single-line-or, accept-line である。

    accept-single-line に関しては vi-command 版もある。
    vi-command/accept-single-line-or は vi_nmap でしか使われていないが、
    名称的には vi_[onx]map で使っても問題がない様に設計されている気がする。

    これらにちゃんと対応する為には vi_omap, vi_xmap についても機能を追加するか、
    或いは vi_nmap しか対応しないか、或いは vi_[onx]map の時には特別に
    vi_command も一緒に探索する事にするか。取り敢えずは vi_nmap だけの対応で良い
    気がしてきた。

    * dispatch 先の関数名をどうするか。

      a 取り敢えずの実装としては ble/widget/NAME に対して ble/widget/KEYMAP/NAME
        を試行する事にした。このルールは既存の緩やかなルールに合致しているので既
        存のコードを大きく書き換える必要はないだろう。

      b また ble/widget/NAME/.keymap:KEYMAP 等の名称よりはわかりやすい気がする。
        と思ったが、: が含まれる場合も widget として列挙されない様な気がする。と
        いう事は ble/widget/NAME/keymap:default でも良い様な気もする。

        うーん。keymap 特有の accept-line を呼び出す時に内部的に accept-line を
        呼び出したい時にble/widget/accept-line ではなくて
        ble/widget/default/accept-line を呼び出さなければならないという事を思う
        と、ble/widget/accept-line/keymap:default の方が良い? と思ったが、何れに
        しても ble/widget/accept-line/keymap:default と書いて呼び出さなければな
        らない。ble/widget/accept-line の儘で呼び出せる方法はないのである。なの
        で、やはり名称は ble/widget/default/accept-line でも変わらない。

      c この観点だと ble/widget/accept-line.default や
        ble/widget/accept-line.vi_imap 等だったら分かりやすかったかもしれないが、
        ble/widget/*.* の形式の補助関数は沢山あるのでそれと被ってしまう問題があ
        る。

      やはり取り敢えずは dispatch 先の関数名は a の方針で行く事にする。

    [変更]

    - done: newline 対応した。
    - done: accept-single-line-or

      実はこれは今対応する必要はない? というのも accept-line から newline を呼び
      出した時にもう既に自動的に keymap に対応する関数が呼び出される様になっている。
      従って特別に実装する必要はないのではないか。

      一方でコードの綺麗さという観点で考えるとやはり此処は統一した枠組みの上で実
      装したい。うーん。やっぱり accept-single-line-or についても keymap dispatch
      に対応する事にする。

    - done: accept-line
      これも既に vi-command/accept-line という物があるので keymap dispatch にする。
      vi-command/accept-line は vi_nmap/accept-line に名称を変更。
      実は vi_nmap/accept-single-line-or はこれで不要になる。

    他にも vi_imap/... 等は存在している気がするが、これらは互いに呼び出す等の事
    をして複雑になっている訳でもないので、追々置き換えていけば問題ない。
    取り敢えず動いている気がするので気にしない事にする。

2020-09-15

  * [解消] 2020-09-07 complete: 空白を含むファイル名の補完候補が増殖する [#D1390]
    Note: #D1389 で解決した。

    更にファイル名のパターンによって同じ候補が沢山表示されることもある。
    これは一般の引数で発生する。complete -r しても同様。
    どうもファイル名に含まれている空白の数だけ候補が増殖する様子である。

    これは bash_completion では発生しない。
    自前の補完を用いた時に発生する問題である。

    先ずは再現させなければならないが再現できない。新しい ble.sh で自然
    に直ったのかとも思ったが古いセッションでやっても再現しない。
    →再現できた。少なくともファイル名に完全一致している状態で<TAB>すると起こる。
    然し新しい ble.sh では再現できていない。

    一応何が原因で発生していたのか調べる必要がある。OK。発生は確かめた。
    次に確認するべき事は何かというと、…候補生成で何が起こっているのかという事。

    分かった。これも glob pattern が単語分割されているのが原因だった。
    echo 'a b c' に対してパターンが以下の様になり、
    結果として3つに展開されていたという事である。

      pattern: ret='*a* *b* *c*'
      expanded: ret=('a b c' 'a b c' 'a b c')

    これは #D1389 で自然に解決したと見て良い。

  * 2020-09-10 complete: mkdir aaaaaaaaaaa. とすると無限ループになる [#D1389]
    →aの数が少ないと問題が起きない。という事を考えるとこれは曖昧補完で使っている
    正規表現またはパス名展開による物と思われる。
    実際には無限ループになっているという訳ではなくて指数関数的に処理量が大きくなっている。
    これに対する対策はしておかなければならない。

    同じ文字数でも abcdefg.... という文字列だと問題は起こらない。
    つまりこれは同じ文字が連続で存在している時に発生する問題である。

    一つの対策方法は同じ文字が複数並んでいる時の曖昧文字列生成について。
    然しそれでも abababababa というパターンに対しては脆弱になるのではないか。

    というよりそもそも、a*a となっている時に最初の * の中に
    a が含まれる事を禁止すれば良いのではないか。
    a*b の場合には b を禁止する。その様にすれば必ず literal b match は、
    a の後に現れる最初の b という事になるので曖昧さはなくなり、
    様々な種類のパターン一致を試す必要もなくなるのではないか。
    そしてそれはグロブパターンならば *([!b]) 等とすれば良い。
    正規表現ならば [^b]* とすれば良い。

    然し、本当にこれで問題ないだろうか。実はこれによって一致しなくなっ
    てしまうパターンなどがあったりするのではないか? と思ったが…。多分
    大丈夫である。元のパターンで一致する文字列であれば必ず制限をかけた
    パターンでも一致するという事を示せば良い。そしてそれは自明の事のよ
    うに思われる。

    chatoyancy 上で再現できないと思ったらどうやら bash-4.4 では問題が
    起きるが bash-5.0 では問題は起きない様子だ。何れにしても再現できる
    様になったので修正できる。

    取り敢えず *([!b]) に変換する様にしてみたがこれでちゃんと動作するかは分からない。
    先ずはちゃんと ambiguous expansion が働くかどうか。動く。
    そして bash-4.4 で遅くなってしまう問題も解決している。
    取り敢えずこれで様子見する事にする。

  * 2020-09-10 最初に起動した時に bleopt prompt_screen_title が反映されていない [#D1388]

    これは分かった。ble.sh は _ble_term_TERM を見て
    prompt_screen_title を出力するかどうか決めている。然し
    _ble_term_TERM は DA2 応答があるまでは代入されない。
    最初は空なのである。

    _ble_term_TERM が空の時には TERM も確認する事にした。
    流石に screen, screen.* に設定しているのは screen か tmux だけだろう。
    screen が xterm に設定している場合には判定できないが仕方がない。

  * 2020-09-07 complete: メニュー補完で引用符が消える [#D1387]

    引用符で囲んでいる状態でメニュー補完すると引用符が消える。何故だろう
    試していた所メニュー補完でなくても問題が生じる事が分かった。
    これは cd の引数でだけ発生する? →どうもその様である。

    然しディレクトリ名のパターンによって発生したりしなかったりする。
    OK. 再現する。

    $ mkdir 'a b'
    $ cd 'a b       <--この状態で TAB を押すと引用符が消える。

    実は bash_completion を有効にしている場合は cd だけでなく mkdir でも起こる。
    原因が同じかどうかは分からない。

    ble/cmdinfo/complete:cd を削除すると再現しない。
    ble/cmdinfo/complete:cd で直接 ble/complete/source:file,dir 等を実
    行する様にしている場合は再現する。

    →普通にquote-insert も呼び出している…と思ったが、調べてみると、
    COMPS も COMPV も設定されていないということが判明した。何故。

    →調べると一回目の呼び出しではちゃんと有限の文字列になっていて引用符も含ま
    れている。然し、それに対しては候補生成に失敗して、更に 曖昧補完として
    COMPS, COMPV を空にして再度呼び出された時に候補が生成されるという事である。
    ここで二つの問題がある。

    x fixed: 何故最初の引用符ありの補完に失敗しているのか

      これは分かった。glob で "$COMPV"*/ に等価な物を生成しようとしているが、

      % $COMPV の部分をエスケープする時に空白文字のエスケープをしていないのが原
      % 因。然し、実際に一文字ずつエスケープする必要があっただろうか。実は
      % '...'*/ としたり、或いは最早 "$COMPV"*/ でも良かったのではないだろうか。
      % 然し、それはどの様にパス名展開を引き起こしているのかに依存する。もし
      % eval "a=($pattern)" としているのであれば良いが、もし a=($pattern) とし
      % ているのであれば quote 除去や変数展開は使えない。展開は実際に
      % ble/complete/util/eval-pathname-expansion で行われていて、その中では以
      % 下の様にして展開が実行されている。
      %
      % IFS= GLOBIGNORE= builtin eval 'ret=(); ret=($pattern)' 2>/dev/null
      %
      % つまり後者なので quote 除去や変数展開は使えないのである。
      %
      % ? 然しここで疑問が生じる。もしこの様にしているのであれば、何故空白をファ
      %   イル名の一部としてパス名展開が行われないのか。と思ったが、それよりも
      %   先に単語分割が先に行われてしまう。
      %
      % ? もう一つの可能性として eval "ret=(); ret=($pattern)" の様に書き換える
      %   という事。こちらの方が融通が効くのではないかという気がする。然し、
      %   "$COMPV" の様な特定の変数の値が保持されている事を前提とする物は使いた
      %   くない。だとすると '...' による quote に頼る事になる。実は \ に対する
      %   グロブ自体の quote と対して変わらないのではないかという気がする。
      %
      %   然し、もしちゃんと \ によるエスケープで動作できる様にするのであれば、
      %   その儘の形で意図した物にちゃんと一致する様にパターンを構築した方が自
      %   然の気がする。という事を色々考えるとやはり現状の方針を変えずにエスケー
      %   プを修正するという方向で直す。
      %
      % ? ファイル名に改行が含まれている場合にはどうなるのか?
      %
      %   この場合は単純に pattern=$'a\\\nb*' 等としても一致しない気がする。
      %   実験してみる事にする。動かない。というより気づいてしまったが、
      %   実は通常の空白であっても \ を前置しても単語分割を防ぐ事はできない様だ。
      %
      % ? ok: bash-5.0 pathname expansion quirk の問題はあるか
      %
      %   一方で bash-5.0 の特別な振る舞いとして \ が含まれているか含まれていな
      %   いかで、ret=($PATTERN) とした時に PATTERN がグロブパターンとして取り
      %   扱われるかどうかが切り替わるという話がある。これは bash-5.1 でまた昔
      %   の動作に戻った。これに関しては、ble.sh で使う時には必ず * 等のパター
      %   ンを含んでいるから常に意図的にパス名展開の対象であるので"意図せずパス
      %   名展開が起こった" という事態にはならない。

      →変数に含まれるグロブパターンに於いて空白をエスケープする手段は存在しな
      いという事が判明した。つまり ret=($pattern) という展開自体が駄目という事。
      代わりに pattern を適切にエスケープした上で eval "ret=($pattern)" とする
      必要がある。

      先ず ble/complete/util/eval-pathname-expansion の呼び出し元を確認する。
      全て ble/complete/source:file/.construct-pathname-pattern の結果を使っている。
      なので、両方を書き換えれば問題ない。

      ? util: 実は ble/util/eval-pathname-expansion でも同様に注意が必要なのでは?
        と思ったが、調べてみると ble/util/eval-pathname-expansion では始めから
        eval "ret=($1)" の形式を採用していたのでこの手の問題は発生しない。

      * 単に pattern='"$COMPV"*' とすれば良いのではないかと考えたが、
        それだと is-cygwin-slow-glob の判定をすり抜けてしまうので、
        やはり自分で展開して quote する形にするのが良い気がする。

      どの様に quote するか。単純に考えれば '...' で良いが特別の文字を含む時に
      限って'...' の形式に移行するというのでも良い気がする。
      →これに対しては新しく ble/string#quote-command という関数を作った。
      取り敢えずこの問題に関しては修正された気がする。

    x 二回目の補完で COMPS が消滅しているのにも関わらず、COMPS が存在していると
      いう前提での文脈に応じた escape をしている。これは単に COMPS に応じて
      escape の種類を変えるという事で対処できる。

      quote-insert から呼び出している escape では comps_flags を参照している。

      こちらについては修正されていない。先に前者の方を修正してしまったので、
      改めてこれを再現させる方法を考えなければならない。と思ったが、
      単に head による候補列挙を一時的に停止すれば良いだけの気がする。

      と思ったら空白を含むファイルの補完候補が増殖する問題が邪魔をして再現でき
      ない。取り敢えずそちらを先に解決する事にする。と思ったが勘違いだった。中
      途半端に head による候補列挙をスキップした為に候補が重複して生成されてい
      ただけだった。取り敢えず問題を再現させる所までは行った。原因は明らかであ
      る。問題はどの様にしてこれを実装するべきかという事である。

      元々の quote では元々存在している文字列を置換しないという事を前提としてい
      た。なので quote 状態は破壊されないという前提であった。或いは COMPV がちゃ
      んと quote 状態に対応しているという前提があったのである。然し、曖昧補完の
      時には COMPV を強制的に置換してしまっているので、quote 状態と COMPV が対
      応していない状態になっているのが元々の問題点である。

      COMPV を置換せずに曖昧補完であるという事を伝達するか、或いは曖昧補完の時
      には quote 状態のフラグも一緒に変化させてしまうか。後者の場合には、元々の
      quote の種類が補完によって変わってしまうという事を意味する。やはりできる
      だけ quote の種類は保持する様に置換を実行したい。或いは現状のままで
      COMPV= が特別に曖昧補完であるという事にして、quote を処理するという方針?
      この方が良い様な気がしてきた。

      念の為 COMPV= を設定している箇所について確認する。調べるとどうやら各
      source に於いて独自の判断で COMPV を空にしている様である。これは本来は内
      部の変数にコピーしてから改変するべきなのではないかという事。COMPV はその
      儘にしておく事で quote の側ではこれにより補完で遡った書き換えが起こったか
      どうかを正しく判定する事ができる。

      | a 例えば COMPV から compv にコピーして処理するという事。この時に何らかの
      |   問題が生じる可能性があるだろうか。COMPV を使用している箇所について確認
      |   する。結果分かった事は COMPV は候補生成の時にしか使われていなくて、寧ろ
      |   元の文字列を参照する必要があるのは quote をする時だけの様であるという事。
      |   つまり、逆に COMPV は現状の様に処理して、代わりに別の変数に本来の COMPV
      |   を保持するべきではないか、という事。もしくは COMP_POINT か何かの変数を
      |   用いて自前で COMPV に対応する文字列を抽出する?
      |
      |   と思ったが、COMPV は eval 後の値である為そう単純ではない。というか、本
      |   当に COMPV による判定だったろうか?
      |
      |   判定は [[ $comps_flags == *v* && $CAND == "$COMPV"* ]] で行われている。
      |
      |   この時に一致している部分までを COMPS に置き換えてそれ以降をエスケープし
      |   て追記している。うーん。或いは、COMPS= COMPV= としたのが行けなくて、
      |   COMPS に引用符などを保持して置くべきだったのかもしれない。それは一つの
      |   解決方法である。
      |
      |   x compv の使用箇所について確認を行う。ほとんど使われていない。使われて
      |     いるのは filter を実施する関数内で icasematch を実行する為に内部で
      |     lower case に変換して差し替える為に置き換えている所のみである。
      |
      |   x 然し一方で小文字の compv を特殊変数名とするのには抵抗がある。やはりで
      |     きるだけ特殊な関数の間で共有して動的スコープでアクセスする変数は
      |     prefix をつけるか大文字にするかして区別する様にしたい。
      |
      | b COMPV= とする時に COMPS の方にちゃんと引用符等の quote も含めた値を設定
      |   する。もしくは、quote 状態のフラグを修正する。
      |
      | c 或いは COMPS が空で quote 状態が設定されている時には曖昧補完として
      |   COMPS/COMPV が上書きされたと判定する?

      うーん。b の方法が現在のところ一番良い様な気がする。取り敢えず COMPS=
      COMPV= を実行している箇所を関数に置き換える事にする。と思ったが微妙な事が
      残る…。COMPS=${COMPS::1} 及び COMPV=${COMPV::1} しているのは駄目である。
      例えば COMPS が 'hello' だった場合に、COMPS=\' COMPV=h という状態になって
      しまう。これだと h が補完後に消滅してしまう事になる。現状でも問題になるの
      ではないだろうか。今まで問題が起こらなかったのは何故だろうか…。

      実際に試してみると確かに問題が発生している。

      $ touch hello
      $ echo 'hll <-- ここで TAB を押すと補完結果が 'ello' になってしまう。

      COMPS=${COMPS::1} としている部分も含めてちゃんと対応する必要がある。一方
      でどの様に切り出すのが正しいのかというのはかなり謎。うーん。COMPS は別に
      自分で勝手に作り出しても良いのではないだろうか。どうせ曖昧補完なので遡っ
      て書き換わってしまうのは仕方がない。それに実際に置換する時には、呼び出し
      元の関数で処理するので書き換わった COMPS の影響はない。飽くまで候補生成に
      影響を与えるだけなので気にしなくても良い。

      という訳で何れにしても COMPS として適当な物を合成する方針にする。これだと
      例えば abc"def<TAB> とした時に "abcdef... になるという動作になるが、まあ
      それで良いだろうという気がする。

      x 取り敢えず実装した…と思って動作確認したら全く直っていない。どういう事
        だろうか。確認したら簡単なミスだった。コードの整理もした。

    ? ok: source:command を見ると command の曖昧補完は起こらない様になっている?
      と思ったが実際にやってみると動いている。何故だろうか。確認する必要がある。

      改めて確認すると source:command/gen を呼び出して更にその中の
      source:command/gen.1 に於いて曖昧補完の設定をして実際の展開を行っている。
      これについてはOK

    ? comps_fixed がある時 (ブレース展開がある時) 曖昧補完を実行しようとすると何が起こるのか?

      | 例えばブレース展開がある所までは展開結果が一致していたとしても、引用符
      | 関連で書き換えが起こるとすると補完できないという事になるのでは。以下を
      | 試したら補完できなかった。これについては他を修正してから改めて確認する。
      |
      |
      | $ touch hello
      | $ echo h{'ll<TAB>
      |
      | これに関しては曖昧補完の場合でも comps_fixed に対応する部分まではそのまま
      | にして補完を実行するのが良い気がする。問題は、h{xxx,ll<TAB> とした時に何
      | 処までが fixed_part なのかという事。"h{xxx," が fixed part になって展開結
      | 果が h になるのであればOK。何れにしても取り敢えず実装して様子を見る。

      →これは次のテスト項目で一緒に取り扱う事にする。

    以下の動作確認を行う。

    | $ touch hello
    | $ echo 'hll<TAB>
    | $ echo 'hello'
    | これは動いた。
    |
    | $ echo h"ll<TAB>
    | $ echo "hello"
    |
    | これは動かない。何故だろうか。うーん。もしかして h"ll は単純単語ではない?
    | 実際に呼び出してみると別に単純単語でないという事はない。ちゃんと h"ll" に
    | 変換してその上で hll に変換される。一応 h'll の場合には期待通りに全体が
    | '...' で囲まれた形で補完されるので当初期待した機能はちゃんと実装できてい
    | る。問題は何故 ' で動いて " で動かないのかという事。これはまた独立に調べ
    | る必要がある。
    |
    | $ echo h{'ll<TAB>
    | $ echo h{'ello',
    |
    | これも動かない。echo h{ello', になってしまう。ブレース展開の場合には
    | quote が外されてしまうので、末端の ' をつけてはいけないという事。ブレース
    | 展開があっても適当な所で始まりの quote を挿入する様にしなければならないの
    | である。と思ったが、分からない。
    |
    | 調べてみると先ず $CAND == "$COMPV"* のテストには失敗する。曖昧補完先頭一
    | 致の場合には COMPV=hl という具合に最初の一文字を含んでいるからである。
    |
    | * うーん。実は COMPV に既に文字が含まれている場合には先頭一致でも COMPV
    |   に新しい文字を追加する必要はない。そうしないと CAND == COMPV のフィルタ
    |   リングで無駄に候補が削られてしまうから。というよりそもそも hl から始ま
    |   る単語しか生成されなくなってしまう。と思ったが、それは或る意味期待した
    |   事なのでは? うーん。然し、やはり h から始まる単語にした方が直感的な気が
    |   する。その点に関してはまた後で修正する。
    |
    | x ok: もう一つの問題は何故か COMPV に文字列を設定しているのにも関わらず、
    |   関係ない候補が沢山生成されているという事である。後でフィルタリングされ
    |   るとは言え無駄である。これは bash_completion だろうか。或いは ble.sh 自
    |   体の問題だろうか。→ complete -r したら生成されなく鳴ったのでこれは
    |   bash_completion である。無視して良い。
    |
    | x pinned: 何故か quote-insert の時に COMPS/COMPV が変化してしまっている。
    |   quote-insert は source:* の中で呼び出されているのではないのか。実際に確
    |   かめてみると source:argument の中で呼び出されている。つまりちゃんと
    |   COMPS/COMPV は補正されている筈である? やはり内部で書き換わってしまって
    |   いる。代入している箇所は他にはない気がする。一体何が起こっているのか改
    |   めて確認する。先ず何処で書き換わっているのかを特定する。
    |
    |   うーん。どうやら分かった。 COMPS/COMPV を補正しているのは
    |   .generate-user-defined-completion の中であるが、実際に yield しているの
    |   はそれよりも外側の関数という事の様である。何故だろう。
    |
    |   分かった…。source:file がそもそも曖昧補完に対応していないか壊れている?
    |   調べてみると source:file はパス名展開を用いて曖昧候補を生成する仕組みに
    |   なっている。つまり別の枠組みで生成している。
    |
    |   これは今までにもあったバグだろうかと思って調べてみるとやはり以前から存
    |   在していたバグの様である。これも別に修正しなければならない。と思ったが、
    |   これの前に修正したバグで再現していただけかもしれない。何だか分からない。
    |   少なくとも新しく問題が起こる様になった訳ではない。
    |
    | * comps_fixed が quote を含んでいないという点には注意する。この時何処かに
    |   は quote を入れる必要があるのである。これについては改めて考察する必要が
    |   ある。

    問題がまた絡み合ってきたので改めて現状について整理する。以下のテストケース
    を考える。

      $ touch hello
      $ echo 'hll<TAB>

      $ echo h"ll<TAB>

      $ complete -r
      $ echo 'hll<TAB>

      $ echo h{'ll<TAB>

    上記が全て動くようにならなければならない。既知の問題は、

    x fixed: source:file の実装で曖昧補完の時の quote 再現に対応できていない。
      これに対応する為にはどうしたら良いか。うーん。単純に開始 quote を
      quote-insert の側で挿入してしまうという事? まあそれで良い気がする。これは
      "曖昧補完による特別処置 COMPV= の時の特別な振る舞い" ではなくて、一般に
      "COMPV にも comps_fixed にも一致しなかった時の振る舞い" として適当な物で
      あるから ad hoc な処置ではない。

    x fixed: ブレース展開がある時 comps_fixed は "h{" になるのであって、quote
      の開始 "'" を含む訳ではない。comps_fixed に続いて quote 文脈に応じた
      quote 開始を挿入する必要がある。

      これに関しても comps_flags に応じて勝手に引用符を挿入するというので良い気がする。
      comps_fixed に入る文字列はちゃんと quote を閉じていると期待したい。
      因みに h{aaa,'ll となっている場合は comps_fixed は一体どうなるのか?
      と思って調べた所、

    * done: [[ $compv ]] のチェック in reduce。COMPV から compv_fixed を取り除
      いた後 compv= (空文字列) になっている時に、"最初の一文字を切り出す" 処理
      をするのは変である。見た感じ問題が起こりそうな気配もないがちゃんとチェッ
      クしておく。

    o echo 'hll<TAB>
    o echo 'hll<TAB> (complete -r)
    o echo h{'ll<TAB> (complete -r)
    o echo h{aaaa,'ll<TAB> (complete -r)

  * complete: bash_completion の autoload が初回に失敗する問題 [#D1386]

    [まとめ] これは echo h"ll 中に見つかった不自然な振る舞いから。結局、
    autoload した後再度補完を実施する事を要求する 124 の終了ステータス
    を受け取った時、改めて補完関数の探索からやり直す所で、default opts
    が残っていた所為で、新しい補完設定ではなくて再び complete -D の補
    完設定を使って読み取りを行おうとしていた事が原因だった。これは 124
    を受け取った時に default opts を削除して再度補完を実行する様に変更
    して解決した。

    | 不思議な事に最初の一回はちゃんと補完されて、二回目以降からは補完
    | 候補が一致しない物も含めて全て表示される様になる。
    |
    | 最初の呼び出しではプログラム補完が見つからずにデフォル
    | トの補完が走って、それが失敗する事によって次の曖昧補完に移行し
    | ている。二回目以降の補完ではプログラム補完が呼び出されてそれが
    | 成功するので曖昧補完が走らない。
    |
    | プログラム補完が見つからないとご判定されているのかと考えたが、
    | 実際に補完は見つかっておらず complete -p echo しても補完指定が
    | 見つかりませんでしたと表示される。という事は別の箇所で echo に
    | 対する補完指定が設定されているという事になる。何処だろうか。
    |
    | 恐らく default を使って compgen を呼び出したタイミングだろう。
    | 中を覗くとちゃんとデフォルトの補完が読み込まれて 124 を返して、
    | 結果として再度補完が走って、最終的にちゃんと補完が呼び出される。
    |
    | % ここで気づいた事…。何故か compgen に渡されている compv が空
    | % になっている。124 で再ロードした後にのみちゃんと値が設定され
    | % ている。と思ったらこれは勘違いだった。
    |
    | 一回目と二回目を比較してみると…どうも compopt の内容が違う。ど
    | うして前者では候補が生成されず (期待通り)、後者では合致しない候
    | 補が生成されてしまうのか。
    |
    | H2332:builtin compgen -o bashdefault -o de
    | fault -F ble/complete/progcomp/.compgen-he
    | lper-func -- 'hll' 2>/dev/null
    | comp_func=_python_argcomplete_global
    |
    | H2332:builtin compgen -F ble/complete/prog
    | comp/.compgen-helper-func -- 'hll' 2>/dev/
    | null
    | comp_func=_minimal
    |
    | 補間関数も含めて比較してみると両者が異なっている。何故? というよ
    | りリロードして評価した筈なのに何故再度同じ関数が呼び出されている
    | のか?? 漸く分かった。compgen の引数に "default" が入っているので、
    | 124 で再ロードしても default 用の補間関数が呼び出されてしまうと
    | いう問題であった。

  * complete: echo h"ll<TAB> で bash_completion が全ファイル名を列挙する [#D1385]

    [まとめ] これは extract-command で閉じていない単語を回収するのに失
    敗していたのが原因だった。閉じていない単語を仮に実体化していたがそ
    の時の単語の種類 wtype が CTX_ARGX になっていた。然し、
    extract-command は CTX_ARGI しか回収していなかった。単語を仮に実体
    化する時に、ctx-word-end で実際にやっているのと同様に wtype を補正
    する事にした。

    | これはどうも bash_completion が入っていると駄目のようである。
    | bash_completion の生成する候補に問題がある?
    | もしくは、progcomp による yield に問題がある?
    | うーん。実は bash_completion による候補は filtering で全て消える?
    |
    | 一回どのような候補が生成されているのか確認する必要がある? 取り敢
    | えず bash_completion は全てのファイル名を列挙する。filter:head
    | は何もしていない様に見える。実際に動作を見てみると何もしていない。
    | つまり、progcomp が生成した物をそのまま使うという作戦になってい
    | る。これはまあ理解できる。一方で bash_completion が遡って書き換
    | えの起こる候補を全て出すのも理解できる。
    |
    | これに完全に対応する為には bash_completion の生成した候補に対し
    | てフィルタをかける必要があるが…うーん。フィルタをかけて有限個の
    | 候補が残ればOK、そうでなければそのまま沢山の候補を保持するという
    | 作戦? でもよくわからないのは最初の補完ではちゃんと補完ができると
    | いう事。何故だろう。
    |
    | 改めて bash_completion の振る舞いについて確認する。ble.sh なしで
    | 実行すると h"ll に対してエラーメッセージが出るが最終的にはちゃん
    | と何も候補を生成せずに終わる。然し、経由だと全ての候補が列挙され
    | てしまっている。つまり、ble.sh の時と bash の時でやはり何らかの
    | 違いがあるという事だろうか。具体的に ble.sh による呼び出しの時と、
    | bash による呼び出しの時でどのような違いがあるのかについて調べる
    | 事にする。
    |
    | * 取り敢えず今までに埋め込んだデバグ用の出力は全て削除する。
    | * _minimal に対して advice を仕掛ける。
    |
    | | ble.sh の下では、
    | | -----------------
    | |
    | | COMP_CWORD='1' COMP_KEY='67108969' COMP_LINE='echo '
    | | COMP_POINT='5' COMP_TYPE='9'
    | | COMP_WORDS=('echo' '')
    | | COMPREPLY=('a b' 'a b' 'a' 'bc' 'a xyz' 'h ello')
    | |
    | | bash の下では
    | | -------------
    | |
    | | COMP_CWORD='1' COMP_KEY='9' COMP_LINE='echo h"ll'
    | | COMP_POINT='9' COMP_TYPE='9'
    | | COMP_WORDS=('echo' 'h"ll') COMPREPLY=()
    |
    | 成程、これは ble.sh が悪い。COMP_WORDS の復元に失敗している。空
    | の単語になってしまっている。COMPV 等に基づく候補生成はちゃんと動
    | いているという事を考えると、extract-command か或いは COMP_WORDS
    | の構築に失敗している。
    |
    | 確かめた所、extract-command の時点で失敗しているという事が判明し
    | た。問題は h'll の時にはちゃんと成功しているのに何故 h"ll の時に
    | はうまく行かないのかという事。" が中に構造を持つ事ができるという
    | 事に関係しているだろうか。
    |
    | 実際に構文木を見てみると確かに nest が設置されていて単語が構築で
    | きていない状態になっている。本来は擬似的に文法構造を閉じてその上
    | で解析するのではなかったか。覚えていないがその様な処理が何処かに
    | あった筈。これである。
    |
    | ble/syntax/tree-enumerate/.initialize で TE_root を
    | ${_ble_syntax_tree[iN-1]} の補正版として初期化している。本来はこ
    | れによって nest が閉じられて単語になって欲しいのだが、実際にはそ
    | うはなっていない。然し、f11 による画面でも文法構造が確定せずエラー
    | の様な状態になっている。と思ったが f11 による画面では文法構造を
    | 閉じていないので当然といえば当然である。具体的に問題の起こる状況
    | で TE_root がどの様に復元されているかを確認すると以下の様になっ
    | ている。
    |
    | TE_root='3 4 0 5 -- none 3 -1 -1 -- '
    |
    | 3 は wtype で 4 は現在の単語の長さである。此処までは正しい。0 は
    | 子単語までの offset であり、実は同じ位置に子単語が存在している。
    | 子ノードは wtype=none (nest 構造) であり、長さは 3 である。子や
    | 兄要素は存在しない。実際にこれに問題があるのかどうかの判定は分か
    | らない。見た感じは明らかな異常はない様に見える。特に長さが "4"
    | となっている以上は長さ4の単語を抜き出せて良いのではないだろうか。
    |
    | 何故正しく単語を抜き出せないのかについては、実際にどの様に
    | tree-enumerate が走るのか確認するしかない。
    |
    | * 色々分かった。TE_root の復元によって生成された単語は CTX_ARGX
    |   になっている。一方で通常の単語は CTX_ARGI である。
    |   extract-command では ARGI な単語しか収集していない。つまり
    |   ARGX による単語は register-word が呼び出されず登録されない事に
    |   なる。
    |
    |   一方で、一番最初に見つかった単語の終端がが現在の起点の位置より
    |   も前にある場合には、現在の起点の位置に長さ 0 の単語が存在して
    |   いると見做して、"" の単語を挿入する。この空単語は ARGX になっ
    |   てスキップされた単語とは何の関係もない。
    |
    | この状況に於いてどのように修正するのが正しいか。TE_root を構築す
    | る時に ARGX → ARGI の規則を適用するのが良い気がする。その様にし
    | たらあっさりと動く様になった。

2020-09-05

  * ln23.para.bscc が何故か SM(?1004) Any event mouse を設定する [#D1384]
    これにより focus/blur で SS3 I, SS3 O が送信される様になって
    ble.sh が混乱している。SS3 I は TAB になっている。
    SS3 O は何のキーにも束縛していないので ESC O O という入力になってしまう。
    取り敢えず SS3 O を認識する様に修正する。

2020-09-03

  * 2020-08-31 util: is-global の実装はちゃんとしているのだろうか [#D1383]
    つまり変数が unset 状態にある場合等に対しても予想通りに動作するのだろうか。
    また、現在の実装ではヘルパー関数を用いているがこれは本当に必要だろうか。

    →試してみると global に declare だけしている変数を local と勘違いする様である。
    global に declare だけしている時に readonly すると local でも変数を作れるという事?
    と思ったらテストの問題だった。テストは恐らく関数の中で実行しているので、
    トップレベルに declare v1u 等としているつもりでも関数内に変数が作成されている。
    declare -g を使って明示的にグローバルに unset 変数を作成してテストした所ちゃんと動くことを確かめられた。

  * 2020-08-03 ble.sh ロード方法と attach 戦略に対する考察 [#D1382]
    関連 (attach=prompt): #D0940, #D0737, #D1124

    そろそろ .bashrc の設定方法を変更しても良いのではないだろうか。
    特に、 .bashrc の末尾に記述するのが良い気がする。
    或いは未だ先頭に . ble.sh を記述する必要性があっただろうか。

    ユーザーが ble.sh の有無で bashrc の中の設定を切り替える場合がある。
    この場合には最初に source して BLE_VERSION を用いて判定するのが良い。
    然し、ble.sh の有無はユーザが独自に判定している場合も多いので、
    わざわざこれの為に二箇所に ble.sh のコードを書くのはやはり変かもしれない。

    * BLE_VERSION を使って判定する為にはちゃんと読み込みに失敗した時に
      unset されていなければならない。ちゃんとその様になっているか。

      * _ble_bash と BLE_VERSION の初期化されている位置をまとめた。
      * また、_ble_bash 初期化前に値を参照している箇所があったので使わない様に修正した。
      * BLE_VERSINFO についても同様に unset する様にした。
      * ble/base/unload で _ble_bash, BLE_VERSION, BLE_VERSINFO を削除する様にした。

    以下の attach 戦略に対する考察は #T0004 に纏め直した

    | 初に記述すると他のフレームワークが勝手に PROMPT_COMMAND を書き換えた時に動かない。
    | 後に記述すると他の設定で ble.sh の有無で切り替えを行いたい時に不便である。
    | うに、どの場所に記述しても動く様にするのが本当は良いのだろう。
    | 状の問題点としては PROMPT_COMMAND を上書きされると動かないという事だけである。
    |
    | 或いは、その場で attach してしまう方向で改良する手もあるのかもしれない。
    | と思ったがそれだと PS1 の設定などが反映される前にプロンプトを表示してしまう?
    | その直後に PS1 が設定されて次のキーボード入力の際に更新されるのだろうが、
    | それだとちらついたりしてよくない。
    |
    | 或いは、その場で attach した時には最低限の処理を行って、
    | それでユーザの入力を受け付ける様にする。
    | PROPMT_COMMAND が生きていれば続きの処理を行って、
    | もし上書きされて動いていない場合でもできるだけ問題が起こらない様に処理する。
    |
    | ble-attach して最初は出力抑制しない作戦
    |
    | もっと具体的に考える。その場で attach した時の問題点は何かというと、
    | attach してプロンプトを表示して、然しその後で bashrc の中から何か
    | メッセージが画面に表示しようとしても出力が抑制されているので
    | 内容が消えてしまうという事である。
    |
    | 然し、ble-attach の時は出力を抑制しないでその次のユーザの入力の
    | 時に初めて抑制をするという手もある。
    |
    | x この時には最初のユーザ入力の際に一瞬だけちらつきが発生してしま
    |   う。
    |
    | x もう一つの問題点は ble-attach した後に、bashrc の別のシェル設
    |   定が画面に何か出力すると表示が乱れてしまうという事である。
    |
    | 後者の問題を解決する為に、プロンプトの表示は PROMPT_COMMAND まで
    | 遅延するという可能性もある。
    |
    | x しかし、そうすると起動までの時間が気になる。ble-attach すると
    |   いう事は bind するという事で、bind するという事は keymap の初
    |   期化を行うという事である。つまり時間がかかる。本来はそれより前
    |   にプロンプトは表示しておきたい。まあ、これはそれ程気にしなくて
    |   も良いかもしれない。
    |
    | 前者のちらつきの問題に関しては、PROMPT_COMMAND が正しく機能すれ
    | ば特に問題ない筈である。
    |
    | ble-attach して出力抑制もする。後で出力内容を dump する作戦
    |
    | 或いは ble-attach してから次のユーザ入力を得るまでの間に bashrc
    | から出力された内容は適当なタイミングで画面に出力する様にする?
    | これは一つの手であるような気がする。PROMPT_COMMAND が有効であれば、
    | その瞬間にそれまでに出力された内容を dump すれば良い。
    |
    | x ただし、時間のかかる処理やプログレスバー等の表示があると最後に
    |   一気に表示するので期待はずれの動作になる
    |
    | x 更にユーザの入力を求める処理があると何も表示されない状態になっ
    |   て困る。いざ /dev/tty に対して読み書きするプログラムがあったとし
    |   ても、今度は逆に画面の表示が乱れてしまう。
    |
    | 等などの事を考えるとやはり ble-attach してから、後の bashrc の処
    | 理を適当に流すというのは難しいのではないか。或いは本格的に bash
    | の出力を別のプロセスに繋げて、そのプロセスで出力内容を選別しなが
    | ら適当に描画を乱さない様に調整する? と思ったがそれだと本格的に端
    | 末を実装する様な物だし、/dev/tty を使われたら結局調整もできなく
    | なる。駄目。
    |
    | 或いは trap RETURN もしくは trap DEBUG を用いて PROMPT_COMMAND
    | を監視する? 上書きされたり破壊されたりしたら復元する。
    |
    | 関連する議論が #D1124 及び D#0737 にある。然しこれも微妙である。
    |
    | x trap DEBUG はコマンドの実行直前に実行されるので、bashrc の一番
    |   最後の行で PROMPT_COMMAND が書き換えられると駄目。それに trap
    |   DEBUG 自体を上書きされてしまうと動かなくなってしまう。それに
    |   trap DEBUG は結構面倒である。
    |
    | x trap RETURN は bashrc の末尾では発生しないようなのでこれは全然
    |   使えない。
    |
    | れ以外に不定期で呼び出される hook の類は存在しただろうか。本当は
    | OMPT_COMMAND が変更された時にそれを検出できたら良い。或いは
    | OMPT_COMMAND に対する読み書きを全て hook できたら良い。然し、ス
    | リプトだけでそれを実現する方法はないのだろうという気がする。
    |
    | EXIT はプロセスが終了する時にしか呼び出されないし、ERR もコマン
    | ドが失敗した時にしか発生しない。bashrc の最後に自動的に失敗する
    | コマンドを呼び出させる方法もない。
    |
    | command_not_found_handle はコマンドが見つからない場合にしか呼び
    | 出されない。それにディストリビューションによって何か処理が設定さ
    | れるだろうから PROMPT_COMMAND と同様の問題がある。寧ろ、処理の追
    | 加という事ができないので PROMPT_COMMAND にも増して使いづらい。
    |
    | bashrc の処理を見たら bashrc の最後に介入する方法が見つかったり
    | しないか。と思ったが eval の最後に何もないように bashrc の最後に
    | も特別な物は何もないだろうという気がしてならない。
    |
    | bash は maybe_execute_file という関数を用いて bashrc を呼び出す
    | 様である。調べてみるとどうもファイルの中身を丸ごと文字列 string
    | に読み込んで、更にそれを parse_and_execute で一気に実行する様で
    | ある。第三引数のフラグには SEVAL_RESETLINE を設定している。然し、
    | parse_and_execute の中には介入できそうな場所はやはりない。
    |
    | 或いは execute_prompt_command を見たら何かないだろうか。またはそ
    | の呼び出し元。execute_prompt_command を見たら単に PROMPT_COMMAND
    | を見ているだけである。呼び出し元は parse_command であり、その冒
    | 頭で run_pending_command を呼び出している。うーん。これが使える?
    |
    | kill -USR2 $$ をしたら trap handler が実行されるのはどのタイミン
    | グだろうか。もし bashrc が終わってから一括で実行されるのであれば
    | kill -USR2 $$ で bashrc 直後の処理を予約できる。
    |
    | うーん。駄目だった。その場で実行される。kill -USR2 $$ & として見
    | ても駄目だった。USR2 が届いてから次のコマンドを実行する直前に実
    | 行されるという事の様である。
    |
    | PROMPT_COMMAND の代わりに PS1 に $(kill -USR2 $$) をしかける等の
    | 手もあるかもしれないが、これは PROMPT_COMMAND と同じ問題が在る。
    | というより、PS1 は追記ではなく置き換えて使う物なので
    | PROMPT_COMMAND よりも信頼性は低い。
    |
    | もし PROMPT_COMMAND を上書きした犯人がいるのだとしたら、上書き後
    | のコマンドを必ず実行する筈で、だとすればそれを trap DEBUG で判定
    | できるのではないか。
    |
    | | そして bashrc の中か外かの判定ができれば OK. と思ったが #D1124
    | | を見ると 4.3 以降で動く微妙な方法しかない様だ。
    | |
    | | * reject: 或いは bashrc の中で declare などしておけばそれが消滅
    | |   した事を見れば bashrc の外に来たと分かる? と思ったが実際に試し
    | |   てみるとbashrc の中で設定した declare はそのままグローバルスコー
    | |   プになる様だ。なのでこれは使えない。
    | |
    | | どうやら関数の中で ${BASH_SOURCE[-1]} を参照してそれが bashrc と
    | | 一致しているかを確かめれば良さそうだ。と思ったが…。現在の
    | | bashrc が何かを知る方法がない。BASH_ENV に入っているのは別の変数
    | | の様子だ。grep して確かめると BASH_ARGV の末端には bashrc の名称
    | | が格納されている様だが、これは関数の中では何れにしてもトップレベ
    | | ルの関数名が入っているので区別できないのでは。
    | |
    | | 唯、一つ明らかなのは、bashrc の中にいる間は BASH_SOURCE に何か設
    | | 定されていて、PROMPT_COMMAND を実行しようとした瞬間には何も設定
    | | されていないという状態になるという事。なので原理的に可能である。
    | |
    | | x PROMPT_COMMAND に関数定義だけ設定されている等の時、DEBUG は呼
    | |   び出されないのでは。まあその様な特殊な場合には仕方がない。
    | |
    | | * 重大な問題として bashrc の中で source ble.sh したのと、普通の
    | |   対話コマンドの一部として source bashrc して間接的に source
    | |   ble.sh したのをどう区別するのかという事。後者の場合には、
    | |   source bashrc; echo hello 等としていた時のためにトップレベルま
    | |   で戻ったとしても即座に PROMPT_COMMAND になったと判定して発火す
    | |   るのではなくて、本当の PROMPT_COMMAND が現れるまで待たなければ
    | |   ならないのでは無いか。
    | |
    | |   LINENO を参照すれば判定できる? と思ったが LINENO は対話コマン
    | |   ドではコマンドの番号であるが、bashrc の中ではファイル内の行番
    | |   号という事になっている。使えない。
    | |
    | |   うーん。もしかして BASH_LINENO[-1] が常に0?
    |
    | PROMPT_COMMAND など外部のコマンドの実行直前に発火したい。bashrc
    | の外に出た事を検出する必要がある。
    |
    | * DEBUG で [[ ${FUNCNAME[-1]} == source ]] である事を監視して最
    |   初にそれが破れた瞬間を PROMPT_COMMAND もしくは別のコマンドと考
    |   えれば良い気がする。
    |
    | * [[ $BASH_COMMAND == $PROMPT_COMMAND ]] は使えない。何故なら
    |   PROMPT_COMMAND が単一のコマンドとは限らないから。それに古い
    |   version の bash だと BASH_COMMAND は本当に今のコマンド [[
    |   ... ]] になってしまうので当てにできない。
    |
    | x PROMPT_COMMAND が空に設定されてしまった時や、PROMPT_COMMAND に
    |   関数定義だけが記述された場合には検出ができなくなってしまうが、
    |   その様な場合は稀であるし、それで逃したとしても次の別のコマンド
    |   の実行時に attach が発火するので問題ない気がする。
    |
    | * 現在 rcfile の実行中である場合には ${BASH_LINENO[-1]} == 0 に
    |   なっている。
    |
    |   然しよく考えたら rcfile かどうかを区別する必要はあるのだろうか。
    |   対話コマンドで source .bashrc と入力した場合を考えると、この場
    |   合にも .bashrc の中で PROMPT_COMMAND を上書きされる可能性を考
    |   えると同様に対策が必要になるのではないだろうか。
    |
    |   * rcfile で実行している時には rcfile の外に出た瞬間に attach
    |     して良い。何故ならば rcfile の外に出たら次は PROMPT_COMMAND
    |     の実行以降であり既に attach のタイミングになっているから。
    |
    |   * 対話コマンドで実行している時には top level の source を抜け
    |     たとしてもすぐに attach して良いとは限らない。何故ならその後
    |     に直接また別のコマンドを記述しているかもしれないから。ここで
    |     出来るのは PROMPT_COMMAND に別の値が設定されていた時にそれを
    |     ble.sh のそれに修正する事である。然し、現在 PROMPT_COMMAND
    |     が実行されている時に限れば、その場で attach しなければならな
    |     い。その為には現在実行しているのが PROMPT_COMMAND なのか或い
    |     は通常のコマンドなのかを判定する必要がある。それは
    |     BASH_LINENO が増えたかどうかで判定できるだろうか? と思ったが
    |     多分難しい。
    |
    |   * どうやら HISTCMD / ${_histcmd@P} の結果で判定できる気がする。
    |     対話コマンドの実行中は HISTCMD には履歴項目の個数が入ってい
    |     るが、PROMPT_COMMAND の実行中は 1 に展開される。HISTCMD が
    |     unset されていたとしても ${_histcmd@P} (_histcmd='\!') は 1
    |     に展開される。HISTCMD が unset されているかどうかは
    |     ((HISTCMD++)) して数が変化するかどうかを確認すれば良い。
    |
    |   * ソースコードも確認したがやはり PROMPT_COMMAND を区別するのは
    |     本質的に難しい? PROMPT_COMMAND は parse_and_execute 経由で実
    |     行していて、この時フラグに SEVAL_NONINT|SEVAL_NOHIST を指定
    |     している。つまり $- を見たら違いが分かるかもしれない? と思っ
    |     て確認したら通常コマンドも PROMPT_COMMAND も himBHs だった。
    |
    |     別に分かった事は rcfile の処理中は $- に s が存在していなく
    |     て、PROMPT_COMMAND の時には s が存在しているという事。s は何
    |     か。man によると bash の起動時の -s は位置パラメータの指定が
    |     あるかどうか? いや、標準入力から読み取るモードになっている時
    |     に s が入るのである。
    |
    |     類似の変数として $BASHOPTS があるが、こちらは rcfile とそれ
    |     以降で違いは見られない。
    |
    |     bash の変数 "interactive" で振る舞いが変わる物を使って
    |     interactive の状態を検出できるだろうか。ソースコードを検索す
    |     ると取り敢えず alias は non-interactive の時にだけ有効になっ
    |     ている気がする。
    |
    | * DEBUG trap の取り扱いが難しいという事に注意する。これについて
    |   は未解決の task が存在した筈である。


2020-08-29

  * 2020-08-24 auto-menu を有効にしていると vbell がずっと鳴っている状態になる [#D1381]
    auto-menu は大々的には告知していないし manual にあるだけなので
    使っている人はいないのだろうという気がするが修正する必要がある。

  * 2020-08-23 main: bash-5.1 で PROMPT_COMMANDS が定義されている時 --attach=prompt が効かない [#D1380]

    PROMPT_COMMANDS 経由で attach する様にしなければならない。
    また PRPOMPT_COMMANDS 経由で attach した場合は、
    attach した後に自身を消去する必要がある。

    書いている内に分からなくなった。PROMPT_COMMAND と共存する為にどう
    したら良いのか。結局 bug-bash で議論を呼びかけてみたが良い解決方法
    は存在しないし、Chet はこれに対する対策はする気がない様である。

    * Chet は distro が PROMPT_COMMANDS と PROMPT_COMMAND の両方に設定
      を行うと主張しているが謎である。もし両方有効になるという具合に宣
      伝したらちゃんとバージョンを見て一方だけに設定するに違いない。そ
      の場の思いつきで適当な事を書いているのではないかと疑わしい。

    * 結局、不完全な対策方法しかない。或いは PROMPT_COMMAND を
      readonly unset するか。と思ったがそうした所で警告が発生されるだ
      けで問題が解決する訳ではない。

    取り敢えず不完全な解ではあるが、PROMPT_COMMAND に値が設定されてい
    て、かつ PROMPT_COMMANDS に何も設定されていない時に限り、
    PROMPT_COMMAND を PROMPT_COMMANDS に変換して、その上で値を設定する
    事にした。まあ、これが妥当な妥協点であろう。

    2020-08-31 attach した後に PROMPT_COMMANDS から項目を削除するのを忘れていた。
    と思って気づいたが PROMPT_COMMANDS を実行中に PROMPT_COMMANDS を編集すると何が起こるのか。
    →実際に試してみると PROMPT_COMMANDS を再代入した時に後続の処理が実行されなくなる。
    なので ble/array#remove を使うのではなくて空文字列で上書きするか unset するかする必要がある。

    - 新しく ble/array#replace を実装してそれを使う様にするか。
      然しもしこの bash の振る舞いが修正されるのだとしたら、
      わざわざ新しく変な関数を追加する必要もないのではないか。

    - 問題は現在の bash-dev の振る舞いが変更される見込みはあるのかという事である。
      これが意図的な振る舞いだとしたらそうなる可能性はない。
      もしこれが意図的な振る舞いでないとしたら、
      現在の振る舞いが直感的であるとは思われないので変更の余地はある。
      もしこれにより実際に変な事 (メモリ破壊など) が起こる可能性があるのであれば、
      明らかに問題であるのでパッチを受け入れて貰える可能性がある。

      % 従って何れにしても先ずは bash の実装を調べるという事である。
      bash の振る舞いに関してはまた別に議論する事にした。

    2020-08-31 と改めて確認してみたら PROMPT_COMMANDS は PROMPT_COMMAND に改名されていた。
    コードを書き換えなければならない。書き換えた。
    面倒なので取り敢えずは bash の将来的な修正はさておくとして ble/array#replace を使った。

2020-08-25

  * syntax: syntax-highlighting を無効にする機能 (requested by pjmp) [#D1379]
    https://github.com/akinomyoga/ble.sh/issues/61

    #58 に関連して実装しようかと思っていたが丁度 request が来た。実装する

    * done: 取り敢えず三種類のオプションを実装した。
    * done: wiki と blerc にも説明を書いた。

    * 完全に着色を消滅させるには以下を実行すれば良い筈だが、
      自動補完やメニュー補完による一次挿入などが見えなくなるので余り有用性はないだろう。

      $ _ble_term_color=1
      $ bleopt term_true_colors=none

      これはコメントで書くだけに留める。

    * done: 動作テストも実施した。幾つか修正した。

2020-08-22

  * prompt: bleopt prompt_screen_title や prompt_xterm_title 等を用意しても良い [#D1378]

    * done: 自動的に screen/tmux を判定してこれらを有効にする。
      どちらも異なる TERM を設定している事があるので DA2R によって判定したい。

      https://qiita.com/kefir_/items/0bda5e55f43392420d66 によると tmux の DA2 は
      0;95;0 という事になっているが実際に確かめてみると 84;0;0 になっている。
      0:95:0 だと xterm と区別がつかないので無視する事にする。

    * done: ASCII 以外の文字を自動的に # 等に置換する機能も考えられる。

    * done: tsl, fsl で囲む様にする。と思ったが微妙な気がする。
      tsl, fsl は status line の内容を指定する物で、
      tmux の terminfo は OSC 0 と同一視しているが、
      xterm 等他の terminfo は OSC 0 とは考えていない。
      tmux は確かに OSC 0 の内容をステータスに表示するからそれで正しいのだろう。
      然し、端末によってはステータスバーが別個にある場合もあり必ずしも
      tsl/fsl が OSC 0 に対応している訳ではない。

      →新しく独立した設定を作成する事にした。

    結果として
    - bleopt prompt_xterm_title
    - bleopt prompt_screen_title
    - bleopt prompt_status_line
    の三種類の設定を追加する事になった。

    * done: wiki.en, wiki.ja, blerc

  * prompt: bleopt prompt_rps1= を clear しても内容が残り続けて表示が乱れる [#D1377]
    prompt_rps1 に別の有限の大きさの文字列を指定した時には問題は起こらない。
    これは prompt_rps1= の時に rprompt の情報が全く更新されないのが問題だった。
    クリアすらされなくなってしまう。修正した。

  * contrib: prompt-git で適当にキャッシュを行うようにしたい [#D1376]
    ble.sh の側からは cache の更新を管理するために、
    _ble_prompt_update という変数を提供する事にした。
    contrib/prompt-git でキャッシュする様にした。

    これは mshex で screen の window-title にリポジトリ名を表示するため。
    取り敢えず mshex にこれを利用して git name を PS1 screen title から
    表示する様に実装してみた。動いている。

  * complete: menu に高さ制限を加えるオプションを追加する [#D1375]

    menu に高さ制限を加えた方が良いかもしれない。
    自動的に表示される物で画面がクリアされてしまうのは不便といえば不便である。
    自動で表示する場合には menu に高さ制限を加えるのも一つの手である。
    然し、自動でメニューを表示した後に手動のメニューに移行する場合にどのようにするのか。
    例えば、メニューの項目に入る時に再配置が起こるのは問題がある気がする。
    然し、だからと言って TAB で表示したメニューと自動で表示したメニューで
    高さが異なるままメニュー選択に入るのも一貫性がない様な気がする。

    実は、通常の場合でも高さ制限を加えたいという需要はあるかもしれない。
    ユーザが高さ制限を指定してそれを TAB 補完でも自動メニューの共通の設定とするのが自然。

    どの様に高さを決定しているのかを調べようとしたが、
    どうも cols lines の変数の初期化が怪しい。
    複雑になりそうなので先に auto_menu だけでも commit する事にする。

    | - "$menu_class"/render-item
    |   - ble/complete/menu#render-item
    |     - ble/complete/menu-style:align/construct/.measure-candidates-in-page
    |       - "$menu_style"/construct-page
    |         - ble/complete/menu#construct (init)
    |     - "$menu_style"/construct-page (done)
    |     - ble/complete/menu#select (init)
    |
    | - "$menu_style"/guess
    |   - ble/complete/menu#construct (done)
    |
    | - [fixed] ble/complete/menu#construct
    |   これは中で使っている様に見えるが呼び出し元を確認しても設定している様子がない。
    |   更に、同じ関数内の後で local cols lines として初期化を行っている。
    |   これは書き換えのミスではないだろうか。
    |
    |   少なくとも一つのケースで cols= lines= と空である事を確認した。つまりこれはミスである。
    |
    | - [fixed] ble/complete/menu#select (1)
    |   内部で cols lines を初期化しているがどの関数が使っているのか不明。
    |   ble/complete/menu/show しか使っていない様に見えるが、
    |   ble/complete/menu/show は cols lines を外から受け付けたりはしない筈である。
    |   後で再確認する→やはり ble/complete/menu/show は cols lines を外から受け付けない。
    |   この初期化は削除する事にする。
    |
    | - ble/complete/menu#select (2)
    |   もう一箇所では cols lines を初期化した後に
    |   ble/complete/menu#render-item を呼び出している。
    |   これは必要な初期化である。

    既存の cols lines の仕様については整理した。OK
    新しく行数を制限する様に実装した。動いている。OK

  * prompt: \q{...} で存在しない物を指定した時 [#D1374]
    文字を入力するたびにエラーメッセージが表示される。
    これが意味する所は実はキー入力をする度にプロンプトの計算を
    再実行しているのではないかという事。
    確認する必要がある。

    先ず再現する事を確認する→再現する。つまり毎回 instantiate しているという事。
    分かった…。強制的に更新する場合に force=1 を設定する所が、最初から force=1 になっていた。
    06381c96 (2020-05-21 12:32:58 +0900) で埋め込まれたバグである。
    修正したら毎回 instantiate するという事はなくなった。

    然しこれが速度に大きな影響を与えているとは思われない。
    と思ったら…何と毎回シェル展開まで実行していた。
    つまり $() 等のコマンドもキー入力が起こる度に呼び出されていた事になる。

  * 2020-08-05: complete: auto-complete で menu も出してしまう? [#D1373]

    * bleopt complete_auto_menu=DELAY で設定する。
      ble/complete/auto-complete.idle の中で
      ble/complete/auto-complete.impl の直後に
      local delay=$((bleopt_complete_auto_menu))
      ble/util/idle.push -S"$delay" "show-menu" を呼び出して
      遅延でメニューを表示させる。

      と思ったがよく考えたら自動補完候補とメニュー補完では候補が異なる。
      特に履歴項目から自動補完を実行している時。
      というか自動補完を実行している時は候補一覧を保存していない気がする。

      或いは別に自動補完とメニュー補完の内容が一致していなくても良い気がする。
      →取り敢えず独立な内容を提示する様にする事にする。

    適当に実装してみたら微妙な事になっている。
    これらはゆっくり修正すれば良い気がする。

    x fixed: コマンドラインが空でもメニューが表示されてしまう。
      空白の文字列からは補完が開始しない様にするべきかもしれない。
      ble/widget/complete に non-empty 的な opt を追加する。

      →今度は二文字以上入力しないと show_menu されない様になってしまった。
      何故だろうか。とにかくまた後で調べる事にする。
      →これは以下の問題を解決したら一緒に直った。

    x fixed: menu が表示される場合と表示されない場合がある。
      auto-complete で self-insert した時に起動しない様になっていた。
      auto_complete/self-insert の直後でも起動する様に修正した。

    x fixed: 最後のユーザー入力からの経過時間で起動するべきところが、
      最初の auto-complete からの経過時間で起動している。
      これは auto-complete と同様の方法で起動するべきではないだろうか。

    x fixed: menu が表示されている状態で一文字でも入力するとメニューが閉じてしまう。
      これは menu-filter 状態になっていないから?
      勝手に menu-filter 状態に移行するのも考え物だが…。

      どうやら menu-filter が無効になっている様子だ。
      _ble_complete_menu_active= になっている。
      調べてみると一旦は _ble_complete_menu_active=1 になるが、
      直後に get-active-range に失敗して menu/clear が呼び出される様だ。

      分かった。auto-complete の中から menu に入っている為に、
      記録される left,right の中身が auto-complete によって
      一時的に挿入されている物を含む様になっている。
      menu 表示次の状態記録で keymap が auto_complete の時には、
      一時的に挿入されている文字列を除去する事にした。

    * todo: complete_auto_menu の説明
      * done: blerc
      * done: wiki 英語
      * done: wiki 日本語

2020-08-06

  * fzf の設定でエラーが発生する (reported by @tigger04) [#D1372]
    https://github.com/akinomyoga/ble.sh/issues/60

    bind '"...": fzf-file-widget' の様に -x を
    指定し忘れたかの様なエラーメッセージが出ている。
    更に、_fzf_setup_completion というコマンドが
    存在しないというメッセージも出ている。
    然し、fzf のソースを見る限りはその様な事はあり得ない。変だ。

    | fzf を最新版に更新してもらったが変化はない。
    | 実際に使われている completions.bash, key-bindings.bash を貼って貰ったが
    | やはり勝手に編集しているという事はなくて
    |
    | ? bash 5.0.18 が悪い?
    |   コンパイルし直してみたが別に問題は発生していない。
    |
    | ? 或いは ble.sh が bind を上書きする前に fzf が bind を実行して、
    |   その後で ble.sh が bind -X の設定を読み取る時に失敗している?
    |
    |   然し、そうだとしても _fzf_setup_completion の問題の説明が付かない。
    |   というより、_fzf_setup_completion のエラーが
    |   どう ble.sh と関わってくるのか謎である。
    |
    |   x fixed: .fzf.bash を先に実行すると設定が反映されていない?
    |     →試しに先に .fzf.bash を source する様にしてみたが機能していない。
    |     というより、そもそも bind -x の結果がちゃんと呼び出されていない気がする。
    |     或いは、bind の出力結果から設定を復元する機能が有効になっていない?
    |
    |     調べると ble/builtin/bind/read-user-settings で復元する機能が有効になる筈。
    |     ここでちゃんとユーザ設定として fzf の設定が残っているか確認する。
    |     →何とユーザー設定は空である。
    |
    |     うーん。どうも途中でクラッシュしている様だ。
    |     振る舞いを見ると標準出力に何か出力しようとすると終了する。
    |     SIGPIPE が怪しい。という事は後段の awk が勝手に終了してしまっている。
    |     →分かった。ble/bin/awk を呼び出すべき所を /ble/bin/awk を呼び出そうとしていた。
    |     つまり、そもそも後段のプログラムが正しく起動していなかったのが原因。
    |     これを修正した所、ちゃんと fzf の設定が反映される様になった。
    |
    |   そして .fzf.bash を先に読み込んでも
    |   報告されているエラーメッセージは特に表示されない。
    |
    | うーん。やはり謎である。取り敢えず確実である。
    |
    |   shopt -s extdebug
    |   ble/function#advice before bind \
    |     '[[ ${ADVICE_WORDS[*]} == *fzf* ]] && ble-stackdump'
    |
    | これを試してもらおうと思ったがそもそも contrib 経由で呼び出している時には、
    | bind を封じている筈なので bind からエラーメッセージが出てくる筈がない。
    | これが示唆する事は何かというと @tigger04 は別の箇所で .fzf.bash も呼び出している。
    |
    | 恐らく Option 2 で出ているエラーメッセージは .fzf.bash を
    | 他の場所で source しない様にお願いすれば解決する。
    | 一方で _fzf_setup_completion が見つからないというエラーメッセージの方は謎である。
    |
    | どうやって調べたら良いのか。
    | そもそも問題のメッセージは本当に completions.bash の中で発生しているのか。

    bashrc の内容を教えてくれた。

    * どうも _fzf_setup_completion は bashrc の中から直接呼び出している様だ。
      ble.sh を設定していると何が問題になるのかというと、
      fzf の設定の初期化が遅延されるので、
      .fzf.bash を読み込んだ直後に _fzf_setup_completion を実行しても
      設定が未定義になっているという事である。

      これは .fzf.bash の中の ble-import で -d を指定しない様にすれば良い。

    * うーん。次の報告が来た。
      やはり ble.sh (bind) のエラーは bind の中で発生しているらしい。
      もしかすると shopt によって変な振る舞いをしている可能性?

      あー。分かった nocaseglob が悪いんだ。
      改めて bashrc を見ると nocasematch が設定されている。

    ? では何故自分の手元で実行した時には問題が発生していなかったのか。
      調べてみるとやはり問題は起こらない。
      何故かと言うと、blerc は nocasematch の設定よりも先に呼び出されるからである。
      @tigger04 が option 2 をどの様に構成したのかは分からないが、
      或いは option 2 を設定した上で更に .fzf.bash も source したという可能性がある。
      これは option 2 の使い方として予期したものではないのでこちらでは再現できなかった。


    何れにしても問題は明らかになったのでそれの対策をする。
    この nocasematch の問題に対してはどの様に対処すれば良いだろうか。
    先ず nocasematch の設定について動作を確認する。
    どうも nocasematch が入っていると [[ a == A ]] すら一致してしまう。
    これは問題になるのではないか。特に opts で一文字の物は変な事が起こる可能性がある。

    と思って調べてみると ble/base/adjust-bash-options で
    ちゃんと nocasematch の調整は行っている。
    うーん。では何故ちゃんと nocasematch の状態になっていないのか。
    と思ったが、分かった気がする。そう、builtin bind はユーザの側から呼び出されるので、
    nocasematch によって調整されていない文脈で呼び出される可能性があるのである。

    core-complete.sh の nocasematch は実は不要なのではないか、
    と思ったが、この部分は逆に敢えて一時的に nocasematch を有効にして、
    大文字・小文字に関係ない補完を実現するのに使われているのだった。
    これはこのままで良い。

    取り敢えず bind については nocasematch を一時的に保存復元する事にする。

2020-08-04

  * textarea: vi-mode strings がある時の計算がおかしい (reported by @tigger04) [#D1371]
    https://github.com/akinomyoga/ble.sh/issues/60

    先ず、再現するかどうかを確認する必要がある。
    再現する。どうも、プロンプトを更新する度に vi-ins-mode-string が
    有効になったり無効になったりしてるようである。

    * 呼び出し元を調べる必要がある?
      呼び出し経路を調べると殆ど同じだが、
      ble-edit/bind/.tail の中での行番号が 3 だと有効で 4 だと無効になっている?
      然し、両方とも更に呼び出しているのは ble/textarea#render である。
      調べてみると、3行目は idle.do の前で、
      4行目は idle.do で何らかの処理が走った後である。
      然し、これだけで振る舞いが変化するというのも不思議である。

    * fixed: 分かった。_ble_decode_keymap が原因だった。
      と思ったが、別に表示が乱れる訳ではない…。
      もしかすると別の原因かもしれないが取り敢えず直した。

      以下はデバグに使ったコード。

      > #ble-stackdump "$(cat -A <<< "$expanded")" >> a.txt
      > echo "opts=$opts" >> a.txt
      > echo "processed: $(cat -A <<< "$processed")" >> a.txt
      > echo "expanded: $(cat -A <<< "$expanded")" >> a.txt
      > bind -v | grep -E 'show-mode|mode-string' >> a.txt
      > echo ---------------------- >> a.txt

    * もう一つの問題がある。auto_complete から抜けて prompt の内容が変化しても、
      prompt の再描画が実行されていない。prompt の再計算はちゃんとできている。
      prompt が変化したらそれを検出できる様にしているのではなかったか。
      prompt の再計算と描画がどの様に呼び出されているか改めて確認する。

      prompt の再描画は _ble_textarea_invalidated が設定されている時にのみ発生する。
      ここで prompt が変更された時に全体を再描画するか、もしくは
      部分更新でも特定の条件で prompt の再描画を実施するかという選択肢がある。
      部分更新でも prompt の再描画を実行するのが良い気がする。

      ble/prompt/.instantiate はプロンプトに変更があったかどうかを終了ステータスで知らせる。

2020-07-18

  * TERM=xterm-direct で一部の色が正しく表示されない [#D1370]
    どうも TERM=xterm-direct の時には 256 色を terminfo から使う事ができない様である。
    という事を考えると xterm-direct の時には init-term.sh で特別に処理する必要がある?
    2:r:g:b の形式で 16 色を決め打ちで設定してしまう事も考えたが、
    それだとユーザが好みで設定した 16 色の色を使わない事になってしまって良くない。
    やはり、ユーザの設定した 16 色を利用する様にする必要がある気がする。

  * color: xterm の最新版の既定の TERM が xterm-direct になっていた [#D1369]
    xterm は 24bit color を direct color という呼ぶ事にした様だ。

    当初 xterm の version 判定を使おうとしたが、もしかするとユーザが
    24bit color を使いたくなくて敢えてversion を使うという事もあるかも
    しれないと考えて、取り敢えずは TERM だけで判定する事にする。

2020-06-04

  * bash-5.1 のその他の変更。ble.sh に修正が必要かもしれない項目 [#D1368]

    > 3. New Features in Bash
    >
    > j. shell-transpose-words: a new bindable readline command that uses the same
    >    definition of word as shell-forward-word, etc.
    >
    > p. BASH_REMATCH is no longer readonly.
    >
    > 4. New Features in Readline
    >
    > c. Readline automatically switches to horizontal scrolling if the terminal has
    >    only one line.
    >
    > e. rl-clear-display: new bindable command that clears the screen and, if
    >    possible, the scrollback buffer (bound to emacs mode M-C-l by default).

    新しい readline bindable に関しては自動的に検出する枠組みを作っても良いのではないか。
    一応、以下のコマンドで列挙できる:

    $ join -v1 <(bash-dev -c 'bind -l' 2>/dev/null | sort) <(sort keymap/emacs.rlfunc.txt)

    現在の所は clear-display, shell-transpose-words が新しい bindable である。
    shell-transpose-words は良い。

    clear-display は clear-screen と何が違うのだろう。
    というより scroll buffer まで clear するという事が果たして可能なのだろうか。
    →よく分からないので実際に実装を調べてみると termcap E3 を用いて scroll を clear している様だ。
      https://www.man7.org/linux/man-pages/man5/user_caps.5.html によるとこれは ncurses の拡張?
      tput clear で出力されるのはこれであると書かれている。
      また、infocmp -x | grep E3 としても何も出てこない。
    →一方で通常の clear は clear_screen/clear/cl だそうだ。うーん。変だ。
    →https://invisible-island.net/xterm/terminfo.html によると E3=\E[3J らしい。
    つまり、\E[2J が clear_screen で、\E[3J が clear_display という事だ。
    取り敢えず現状は \e[3J を直接その場で出力する事にした。

    横スクロールに関しては複雑ですぐには実装できそうにないので別項目で議論する。

  * syntax: bash-5.1 では time -- が許される (from Bash-4.1 CHANGES) [#D1367]
    以前は time -p -- echo は OK だったが、
    time -- echo は -- がコマンド名と解釈されてしまって駄目だった。

2020-05-20

  * prompt: transient prompt (suggested by Dave-Elec) [#D1366]
    https://github.com/akinomyoga/ble.sh/issues/57#issuecomment-631648877

    powerline10k に transient prompt という設定があるそうだ。
    しかし、README には機能の存在は紹介されているが設定の仕方が書かれていない。
    https://github.com/romkatv/powerlevel10k#transient-prompt
    Reddit に使い方が投稿されている。
    https://www.reddit.com/r/zsh/comments/dsh1g3/new_powerlevel10k_feature_transient_prompt/
    trim するらしい。使い方が良く分からない。

    AndyChuがプロンプトを書き換えてコマンド開始時刻を表示する話について言及していた。
    https://github.com/oilshell/oil/issues/719
    https://redandblack.io/blog/2020/bash-prompt-with-updating-time/
    https://news.ycombinator.com/item?id=22912226

    zsh の "setopt transient_rprompt" に関しては二値の設定なので余り参考にならない。

    実装に関しては簡単そうである。既に rps1_transient を実装している。
    単に opts == *:leave:* を見てプロンプトを切り替えれば良い様に見える。
    trim するのは実は非効率的である気がする。
    (或いは .newline 等の別のレベルで trim しても良い。)
    どの様な機能を実装するかについて考察してから実装するのが良い。

    bleopt ps1_transient=same-dir:trim
    bleopt ps1_transient=

    * これを機にプロンプト設定の名前も整理するのが良い。

      bleopt prompt_ps1_preexec=
      bleopt prompt_ps1_transient=
      bleopt prompt_rps1=
      bleopt prompt_rps1_preexec=
      bleopt prompt_rps1_transient=

      bash を終了する時にも置き換えるのだとしたら、preexec は変ではないか。
      と思ったが、プロンプトの再描画は .newline の時に実行されるのであって、
      Bash を終了する時には置き換えられない。という事を考えるとやはり preexec
      という名前が適切な気がする。"exit" で抜ける場合にはちゃんと消える。
      C-d 等、widget 経由で抜ける時には消えない。取り敢えずそれで問題ない気がする。

      transient には same-dir を指定できる様にする。
      と思ったが preexec との相互作用が変な気もする。
      "same-dir を指定すると preexec が使われない" という動作である。変である。
      更に、transient になにか指定しないと ps1_preexec が表示されないというのも変だ。

      思うに ps1_preexec だけで良いのではないか。
      これが有限の文字列であればそれに置き換える。
      ps1_transient=trim が設定されていれば更に trim する。
      それ以外の場合には ps1_preexec も ps1 も表示しない。

      名前については preexec よりも final の方が良い気がしてきた。

    実装

    * done: 取り敢えず prompt_{ps1_{final,preexec},rps1_final} を追加した。
    * done: 古い設定名も書き換える。
    * done: 古い設定名に対する警告を表示する。

    * done: trim の対応? → 対応した。
      然しやはり ps1_transient を指定した時に trim でなければ
      プロンプトを完全に消すというのは変な気がする。
      然しだからと言って既定で trim というのは rps1_transient と振る舞いが違う。
      →やはり対称性を重視して完全にプロンプトを消す事にした。

    x fixed: 動かしてみると keep-info の時に info が消滅している→直した。

    * done: blerc, Manual を更新する。新しい設定の追加と名称変更についての注記。
      これらについてはちゃんと更新した。

  * prompt: プロンプトに vim mode を表示できる様にする (suggested by Dave-Elec) [#D1365]
    https://github.com/akinomyoga/ble.sh/issues/57

    keymap_vi_nmap_name 以外のモード名の設定。

    [関連情報]

    * readline には以下の変数が存在する。
      set show-mode-in-prompt on
      set vi-cmd-mode-string "(cmd)"
      set vi-ins-mode-string "(ins)"

      ble.sh ではいきなり独立行にこれを表示するので、
      この設定が使えなくなってもそれ程迄に気にする人はいないだろう。

    * prompt に新しい設定を追加するには。
      特に \p{name} 的な形式で指定できる様にしたい。
      p の代わりにもっとましな文字を使いたい。例えば、

      a 正規表現の参照的には \k<name> \k'name' \k{name}
        \'name' 或いは \'{name} \{name} \"{name}

      b printf %()T 的には、\(name)N 等? でも分かりにくい。

      c zsh prompt は %D{strftime format} に対応している。
        zsh では以下の特殊文字について既に % が定義されている。
        %% %# %! %? %_ %^ %/ %~ %. %{..%} %(...)
        %<...< %>...> %[>...] %[<...]

      d 良く考えたら既に Bash も \D{format} に対応している。
        この様に考えると \X{...} の形式にするのは確定。
        \! \# \$ \[ \] は既に使われている。
        この雰囲気だと \' \" 等は今後も使われる事が無さそうな気がする。
        \'{name} 等でどうだろうか。取り敢えず \'{name} で対応する事にする。

    [変更]

    * done: ble-edit/prompt/backslash:name は
      ble/prompt/backslash:name に変更する事にする。
      Recipe から以前の名前を使っている人がいるかもしれないので、
      関数が見つからない場合には古い名前を使用する。

    * fixed: 実際に動かしてみて気付いたが \'{name} だと、
      PS1 を指定する時のエスケープと被ってしまって良くない。
      別の文字にするか或いは \{name} にする?
      \{name} は余り使いたくない。やはり \D{name} が存在する以上は
      それに従うのが自然だろうと思われる。

      アルファベットは今後使われる可能性がある。
      従ってやはり記号の類が良い気がする。
      \?{name} は正規表現の名前に似ているが、
      \? が別の目的で使われないとも限らない。
      うーん。\:{name} にしようか。lisp 的に \,{name} でも良い?
      或いはやはりアルファベットを使うか。\q にするのが良い気がしてきた。

      OK 動いている。\q{name} というのも分かりやすい気がしている。

    * done: mode名を表示しない設定を作るのも良い気がしている。
      bleopt keymap_vi_mode_show=
      取り敢えず対応した。動作確認をして修正もした。

    * done: 次にモードが変化した時にプロンプトを invalidate することについて考える。
      これはもう全体を invalidate してしまっても良い気がする。
      更にそれと同時に prompt のキャッシュも強制的に更新させる必要がある。
      →実はこれは単に ble/prompt/clear を呼び出せば良いという事だろうか。
      そんな気がする。取り敢えず動いているという事を確認した。

    * done: readline の設定に対応するべきだろうか?

      取り敢えず振る舞いについて確認する。

      set show-mode-in-prompt on
      set emacs-mode-string "@"
      set vi-cmd-mode-string "(cmd)"
      set vi-ins-mode-string "(ins)"

      bind で設定する時に "\1\2" 等とした場合に、
      bind -v ではどの様に出力されるのだろうか。
      →何と直接表示された。つまりこれは ble/prompt/print で追加するべき。

      * モードが変化した時に ble/prompt/notify-readline-mode-change
        を呼び出して強制的に prompt を再計算させる事にする。

      vi 内部でのモードの変更は update-mode で実行すれば良い。
      emacs, vi の切り替えに関しては現状の枠組みでは必ず
      reset-default-keymap 経由で実行される。そしてその際には __attach__ が呼び出される。
      従って __attach__ でモードをチェックして set show-mode-in-prompt になっていたら
      prompt を強制更新するという具合にするので良い。

      動作確認を実行する。以下の設定で期待通りに動く事を確認した。OK

      bind 'set show-mode-in-prompt on'
      ble-bind -m vi_imap -f C-t emacs-editing-mode
      ble-bind -m emacs   -f C-t vi-editing-mode

    * done: Manual を更新する。新しい bleopt を追記した。
    * done: vi guide も更新する
    * done: blerc も更新する。新しい bleopt を追記

    * done: Manual: プロンプト文字列に関する説明
      プロンプトの改造の仕方の説明
      これらは rps1 付近に追記すれば良いだろう。
      或いはプロンプトに関する独立した章を設ける。
      readline variable の解釈についてもちゃんと書きたい。

    [返答の準備]

    取り敢えずサンプルを提示する?
    或いは、contrib にサンプルを追加してしまっても良い気がする。
    →contrib に追加した。

2020-05-18

  * 複数行履歴中の \ が q に化けてしまう (reported by cmplstofB) [#D1364]
    https://github.com/akinomyoga/ble.sh/issues/56

    これは 4bcbd71 support timestamp で導入されたバグである。簡単な修正だった。

    一方の複数行コマンドの復元ができていない問題に関しては謎。
    一回再現できたが、もう二度と再現しない。何故だろう。
    再現できた時には eval -- $'a q\nb q\nc' の形になっていた。
    履歴ファイルには eval -- $'a \\\nb \\\nc' で登録されているので、
    つまり、mlfix が走った後で history/load が走って、その時になにかに失敗している。
    然し、何をどう失敗するとこうなるのか謎。取り敢えず様子見。

2020-05-16

  * 元のリポジトリが消滅している時にも update を可能にする [#D1363]
    https://github.com/rux616/init/blob/7e1a5d2e0dbaa792f4a0a4830ea2f8b92b433b44/install#L422
    →その様に修正した。

  * util: escape 単語先頭の ~ や # は escape しなくて良いのか [#D1362]
    ble/string#escape-for-bash-specialchars

    調べてみると core-complete.sh が使っている。

    * そして試しに touch '#hello' '~hello' で調べてみると正しく escape されない。
      →これについては修正した。
      x 単語先頭以外でも \# \~ に修正されてしまう。
        単語先頭かどうかを判定する事は可能だろうか。

    * fixed: 更に \~hello に至ってはチルダ展開が起こって補完候補にも現れない。
      '~hello' の場合にはちゃんと候補が列挙される。
      →どうもこれは bash-completion が悪い様である。
      然し、'~' の場合にはちゃんと生成できている。何が悪いのだろうか。
      具体的にどの様な情報が渡されているのか確かめる必要がある。

      調べるとシェル関数の引数である cur prev に渡されている情報が悪い。
      cur="'~" の時には bash-completion は何も生成できない。
      cur="\\~" の場合には bash-completion は何故かユーザー名を列挙する。
      然し、よく考えてみるとそもそも COMP_WORDS の方も対応する様に
      エスケープしなければならないのではないか。
      その上で COMP_WORDS に一致する様に cur prev を用意するべきなのではないか。
      もっと振る舞いを調べると bash-completion は引数と COMP_WORDS の両方の情報を使っている。

      * 先ず COMP_WORDS の値を修正する必要がある。修正した。
      * 更に、cur prev として渡している値も COMP_WORDS に変更したら動く様になった。

      ? no: 然し、この部分は過去に何らかの議論があってこの様に修正した気がする。

        | 改めてこの部分について調べる必要がある。調べると c8433971 43bb0749 が怪しい。
        |
        | 2018-08-05 09:15:39 c8433971
        | 2019-03-23 21:41:19 43bb0749
        |
        | と思ったが、 c8433971 は quote を変更しただけである。更に遡る。
        |
        | 2015-11-24 04:05:14 1929132b (complete.sh) ここで導入されている。
        |
        | 更にその前のコードはどうなっていたかと言うと、以下の様な具合になっていて、
        | そもそも COMP_WORDS と comp_words の区別がなかったし、更に関数に引数を渡していなかった。
        | というより上の commit の僅か 4 時間前の事である。要するに実装してすぐに
        | cur=${comp_words[comp_cword]} だったという事である。
        |
        | | 2015-11-23 23:58:01 cdd38598 (complete.sh)
        | | function ble-complete/source/argument/.compgen-helper-vars {
        | |   COMP_WORDS=("${comp_words[@]}")
        | |   COMP_LINE="$comp_line"
        | |   COMP_POINT="$comp_point"
        | |   COMP_CWORD="$comp_cword"
        | |   COMP_TYPE=9
        | |   COMP_KEY="${KEYS[${#KEYS[@]}-1]:-9}" # KEYS defined in .ble-decode-key/invoke-command
        | | }
        | | function ble-complete/source/argument/.compgen-helper-func {
        | |   local -a COMP_WORDS
        | |   local COMP_LINE COMP_POINT COMP_CWORD COMP_TYPE COMP_KEY
        | |   ble-complete/source/argument/.compgen-helper-vars
        | |   [[ $comp_func ]] && eval "$comp_func"
        | | }

        結論: COMP_WORDS ではなくて comp_words を使っているのに特に意味はない。
        未だ COMP_WORDS と comp_words に区別のなかった一番最初の実装の時からこうだった。
        従って気兼ねなく変更する事ができる。変更した。

    * ~ は ble.sh が勝手に展開してから bash_completion に渡しているが、
      ~ の儘にして渡した方が良いのではないだろうか。
      特に ~ という単独の単語の時にのみ特別扱いとするのである。

      →対応した。候補はちゃんと生成される様になったが、
      quote されてしまう。\~murase という具合に。これは期待する動作ではない。
      実際に bash の場合には勝手に quote されるという事はなかった。
      complete -p echo しても特に -o noquote が指定されている訳でもないし、
      また、compopt の呼び出しを確認しても compopt -o filenames が呼び出されるだけで
      compopt -o noquote が呼び出されるわけでもない。

      元の Bash の振る舞いについても確認しておく必要がある。
      →どうやら元々の Bash は ~ に関しては quote しない様だ。
      そう思って quote しない様にしてみたら
      今度は \~hello の様なファイル名で期待通りに動かない。
      候補としては ~hello が生成されている。

      不思議な事が起きている。bash_completion 経由だとメニューの表示には
      \ 無しで表示されているのにも拘らず実際に補完される時には \ 付きで挿入される。
      自分で作った補完関数で試してみるとどちらも COMPREPLY に格納した通りにしかならない。
      或いは文脈に応じて bash_completion は quote の仕方を変えるという事なのだろうか。
      →分かった。bash は compopt -o filenames が指定されている時、
      ローカルファイル名に "~..." が一致する時に限り tilde の quote を実施する。

      →Bash の振る舞いの通りに実装してみたがこれで良いのか分からない。
      本来はいつでも先頭の ~ は quote するべきの気もするがまあこれで大丈夫だろう。

2020-05-14

  * loadable builtins を積極的に使うという可能性について [#D1361]

    | builtin mkdir, rmdir, rm, mktemp -d 等を積極的に使っても良いのではないか。
    | 然し問題点はユーザが /usr/bin/mkdir を使いたい時に
    | 勝手に builtin の方が呼び出されるという事。
    | という事を考えると enable を使って一時的に有効にして使う?
    |
    | 然し、元から有効だったかどうかをどの様に判定するのか。
    | 調べてみたが type コマンドを使うぐらいしか方法がない気がする。
    | enable の終了ステータスを使って判定する方法はあるだろうか。
    | やはりない気がする。やはり勝手に enable/disable するのは良くない気がする。
    |
    | といってサブシェルで実行するというのだと fork は結局する。
    | でも fork/exec よりは効率が良い様な気もする。

    * というより、sleep の場合でも問題が起きるのではないだろうか。
      調べてみると coreutils sleep は 1s や 1m 等の指定を受け付けるが、
      builtin sleep は整数と小数にしか対応していない。
      これの対策については真面目に考える必要がある。

      a 例えば sleep は関数で上書きしてしまって内部では command sleep を呼び出す。
        然し、msleep からは builtin sleep を使う様にする。
        然し、これはこれでユーザが sleep 関数を定義したい場合や、
        ユーザが enable -f ./sleep を実行したい場合に不都合が起きる。

        うーん。builtin と明示的に指定した時にのみ builtin として使える、
        という感じの仕組みがあると良いのだが、難しい。

      b 或いは、いっその事 ble.sh 専用の builtin を作ってしまうというのも手なのである。
        x loadable builtin に手を出したらもう ble.sh の存在意義が失われる気がする。
          それだったら初めから loadable builtins だけで全部実装すれば良かったのである。
        x 一応コンパイラの存在しない環境の為に loadable builtin を使わない
          場合も用意する事ができるが、頻度が低くなるとテストが十分にできな
          くなり問題を起こす可能性がある。然し、その為の単体テストではない
          のだろうか。という事を考えるとそういう意味では問題はない。

      取り敢えずこれはそれ程深刻ではない気がするので放置で良いのではないか?
      或いは 1m や 1s 等の表記にシェル関数を使って対応してしまうという可能性。
      どうせならその方が良いという気がする。

      取り敢えず coreutils 的な sleep をシェル関数で実装する事にした。
      この様にすればユーザが普通の sleep の機能を使いたい場合でも大丈夫だし、
      或いは enable -f sleep で sleep を有効にして組み込み sleep を使いたい場合でも
      どちらでも大丈夫。

      他に現実的な解もない気がするのでこれで良しとする。

    [結論]

    色々考えた結果 sleep 以外に関しては builtin を読み込むのは却って管
    理が複雑になるという事。また、それ程迄に必要という訳でもないという
    事。それよりは stty を builtin にするべきという事。

    loadable builtins には既定で mkfifo, mkdir 等、システムのユーティ
    リティと同名の物が提供されている。loadable builtins を読み込むとシ
    ステムのユーティリティが上書きされてしまう。loadable builtin の方
    が一般的にシステムが提供するコマンドよりも機能が少ないので問題にな
    る。

    mkdir() { /usr/bin/mkdir "$@"; } とすれば単に mkdir と呼び出した時
    には必ずシステムのユーティリティを呼び出して、builtin mkdir とした
    時にだけ読み込んだ物を使う様にできる。然し、この様にすると逆にユー
    ザが意図的に loadable builtin の mkdir を読み込んだ時に、builtin
    を読み込んでいるのにも拘らず builtin が使われないという状況になっ
    てしまう。

    sleep は他に良い代替手段がないという事と、coreutils sleep の振る舞
    いをシェル関数でも実現できるという事から、load してシェル関数によ
    る実装で上書きする事にした。一方で mkfifo, mktemp, mkdir は
    SELinux の context 等の対応が難しい。rm は更に様々な機能がある。

    [まとめ]

    ユーザが file コマンドを使いたい場合と builtin を使いたい場合があ
    る。それに干渉したくないので基本的に同名の loadable builtins は使
    わない。代わりに ble 的な builtin を作成して其処から様々な関数を呼
    び出すという可能性はある。

  * syntax: 何故か {aa}> はちゃんと認識されるが {a}>&1 は認識されない [#D1360]
    文字数が1文字だと駄目になっているようだ。
    これは簡単な修正だった。

  * main: ble-update で新しい commit が fetch できなかったとしても [#D1359]
    現在の ble.sh repo の状態が、現在ロードされている version と違えば
    その場で reload するべきなのではないか。

    序でに一時ファイルを全て $_ble_base_run/$$/ という
    ディレクトリに移動することを考えたが、これだとディレクトリを作る為に
    fork が必要になるので初期化時間が伸びてしまう。
    これは取り敢えずは現状の儘にしておくという事で良い。

2020-05-13

  * complete: 変数代入の中で変数名の補完が効かない [#D1358]
    例えば var=1234 が存在している時に x=$va に対して補完が効かない。

    実際に試してみると v=$B に対して "rhs 2" という候補しか生成されていない。
    うーん。"variable 3" という物が生成されても良いのではないか。
    以前、変数代入を代入の右辺からの候補を生成する様にした。
    この時に元々ある候補が生成されなくなってしまったという事。

    調べると .check-prefix から直接 .check-prefix/ctx:rhs に移動している。
    そして其処で rhs の開始点まで遡るという事をしている。
    確かに $B となっている時の懐石再開点は $ の直前であり、其処での文脈は VRHS である。
    逆に通常の文脈ではどの様に処理していたのだったか。
    例えば ARGI の時には inside-argument を呼び出している。
    更にその中で ble/syntax/completion-context/.check/parameter-expansion を呼び出しているのだった。

    他にも似たような物はないか確認したが > file$BASH や
    time $BASH でもパラメータ展開の補完ができなかった。


  * prompt: PS0 という物が Bash 4.4+ には存在する様である [#D1357]
    何故か http://linuxjm.osdn.jp/html/GNU_bash/man1/bash.1.html には反映されていない。
    もしかするとこのマニュアルは更新が Bash 4.3 で止まっているのかもしれない。
    https://github.com/rcaloras/bash-preexec/issues/28
    http://superuser.com/a/1052132
    https://stackoverflow.com/questions/43201274
    これは対応した。簡単だった。

2020-05-12

  * history: "bleopt history_share=1" でエラーメッセージが発生する (reported by rux616) [#D1356]
    https://github.com/akinomyoga/ble.sh/issues/50#issuecomment-627061087

    これは新しく埋め込んだバグだろう。エラーメッセージを見ると、
    ble/history:bash/resolve-multiline/readfile であろう。
    要するに新しい履歴項目がない場合にそもそも TMPBASE.part が作られないという事では?
    調べると reason=resolve の時には作られるけれども、reason=read の時には作られない。

    然し、ble/history:bash/resolve-multiline/readfile の呼び出し元を確認した時に不思議なのは、
    ちゃんと呼び出し元ではファイルが空でないという事を確認しているという事。
    #%s の行しか存在していない時にはこういう事が起こるのかもしれないが、
    それも何だか変である。実際に何が起こっているのか再現させて調べるしかない。

    →再現させる事ができた。然し、ファイルの中身はちゃんと存在している。awk が悪い?
    これは単純なミスであった。修正した。

  * LC_COLLATE=C で検索すると未だ LC_COLLATE=C func の形式の物が残っている [#D1355]
    これは問題が起こるので避ける様にした筈。調べると
    LC_XXX=C external_cmd の場合には問題は起こらない様子である。
    従って、組み込み機能で処理を行う場合には全て local に入れる必要がある。

    その他、わざわざ bash-4.1 で処理を切り替えている物を
    新旧 bash のどちらでも動く方法を使う様に統一した。

2020-05-11

  * main: bashrc で source ble.sh を2回実行すると固まる (reported by GavinRay97) [#D1354]
    https://github.com/akinomyoga/ble.sh/issues/51

    bashrc に設定したら ble-reload というメッセージが表示されて操作できなくなる。
    ble 0.3.2 で source ble.sh を2回実行すると発生する。
    ble-0.4 でも ble-attach を手で実行すると発生する。

    また ble-0.4 で同じ事を --attach=prompt で実行すると
    リダイレクトエラーが沢山発生する。文字列を入力する度に発生する。
    これはつまり stdout.on, off で問題が発生しているという事だろう。
    (too many open files とは一体どういう事だろうか。)

    bashrc の中で2回以上 source ble.sh するとエラーが発生する。

    $ bash --rcfile bashrc.1.bash
    bash: リダイレクトエラー: ファイル記述子を複製できません: Too many open files
    bash: /dev/null: Too many open files
    bash: リダイレクトエラー: ファイル記述子を複製できません: Too many open files
    bash: /dev/null: Too many open files
    bash: リダイレクトエラー: ファイル記述子を複製できません: Too many open files
    bash: /dev/null: Too many open files
    bash: リダイレクトエラー: ファイル記述子を複製できません: Too many open files
    bash: /dev/null: Too many open files

    これはどうも単に stdout.off の状態でロードすると駄目という問題の気がする。

    ? と思ったが --attach=prompt でも問題が起こるという事はそんなに簡単ではない。
      →ソースコードを確認した所、別に attach しなくても ble.sh を読み込んだ時点で
      ble/fd#alloc _ble_edit_io_stdout '>&1'
      ble/fd#alloc _ble_edit_io_stderr '>&2'
      を使ってリダイレクト先を設定している。
      というよりこれらは実は明示的に /dev/tty に繋ぐべきなのでは?

      * 取り敢えず修正としては /dev/tty に繋ぐという事。
      * unload の際に stdout.on を実行するという事。
        実際に確認してみた所、ちゃんと stdout.on が呼び出される様に実装してある気がする。

      またもう一つ変なのは --attach=prompt を使っているという事は、
      二回目の ble.sh の時点では未だ stdout.off の状態になっていない筈という事。
      それでも問題が発生するというのは何か別の事が起こっている?
      →実際に確認してみた所 1 も 2 も /dev/null に繋がっている。
      stdout.off の状態になっているという事を意味する?

      何処で stdout.off が呼び出されているのか調べようとしたが、
      実は stdout.off は呼び出されていない?
      何らかの別の場所で 1,2 が /dev/null に繋がれている?
      そもそも本当に 1,2 は /dev/null に繋がっているのだろうか。

      また、ls -la /proc/$$/fd を見た感じだと _ble_edit_io_stdout 等はちゃんと
      tty に繋がっている。変な物に繋がっているという事はない様である。

    x fixed: PROMPT_COMMAND 無限ループ

      % ? too many open files というエラーメッセージは恐らく間違ったメッセージの気がする。
      %   →これについては確認してみた所、別に沢山の file descriptors を開いている訳ではない。
      %   という事はつまりこれは単にエラーメッセージが間違っているだけである。

      うーん。stdout.off で実際に確かめてみた所、
      実は本当にファイルディスクリプタを使い果たしている様だった。
      というか PROMPT_COMMAND で無限ループになっているという事の様だ。

      これは一体どの様にして回避したら良いのか。
      PROMPT_COMMAND が ble/base/attach-from-PROMPT_COMMAND なら
      _ble_base_attach_PROMPT_COMMAND を上書きしないというのが愚直な対策だが、
      ユーザが PROMPT_COMMAND="$PROMPT_COMMAND;..." 等と変更していた場合を考えると、
      コンポ天気な対策になっていない。

      % fixed: 先ず ble/base/attach-from-PROMPT_COMMAND の最初で
      % _ble_base_attach_from_prompt= を設定して何度も実行されない様にする?
      % と思ったが違う気がする。_ble_base_attach_from_prompt= は
      % 何度も attach を実行してしまわない為の物であって、
      % PROMPT_COMMAND の呼び出しを抑制する為の物ではない。
      %
      % 実際に attach しているかどうかに関わらず
      % PROMPT_COMMAND を入れ子で実行してしまわない為の物である。
      %
      % →lambda を使って実装し直したので結局この修正は不要になった。

      * 問題は何処にあるのか。

        更に元々ユーザが設定していたコマンドは何処に退避するのか?
        現状の設定だと _ble_base_attach_PROMPT_COMMAND= に待避されていた
        ユーザのコマンドは消滅してしまう。うーん。
        実は unload する時に復元するべきなのではないだろうか。
        と思ったが更にユーザが PROMPT_COMMAND を変更していた場合、
        勝手に復元する訳には行かなくなる。

        二回実行した時に既に退避していたコマンドを実行するのか、
        或いは完全に削除してしまうのかどうするべきか。

        | そもそも ble.sh を reload する事を許しているのはユーザが source ~/.bashrc
        | した時に改めて初期化する事を可能にする為。そういう事を考えると、
        | PROMPT_COMMAND が累積して行くというのは変といえば変な話である。
        | 本来は bashrc の先頭でクリアしてしまうべきなのではないかという気がする。
        |
        | 然し、現実にはわざわざその様にする事はない。
        | というか重複して実行されても良いのではないだろうか。
        | その様になってしまうのはユーザが何度も実行するから。
        | と思ったがユーザが登録する時には PROMPT_COMMAND に既に
        | 自分の設定した文字列が含まれているかどうかを確認してからという事もある。
        | そういう事を考えると、やはり何度も実行してしまうのは変な気がする。
        |
        | というか同じ問題が普通に reload した時にも起こる。
        | _ble_base_attach_PROMPT_COMMAND= に指定していた設定が消滅するという事。
        | これに対してどう処理するのが正しいのか。。
        |
        | 本来は ble.sh の設定した PROMPT_COMMAND は一時的な物なので跡形もなく消したい。
        | 然し、実際にはユーザの別の設定に取り込まれたりするので後で消し去れない事もある。
        | その時に如何に透明になる事ができるかというのが問題である。
        |
        | _ble_base_attach_PROMPT_COMMAND を配列にして上書きする?
        | 或いは _ble_base_attach_PROMPT_COMMAND に既に値が設定されていた場合には、
        | それを更に別の変数に退避して、ble/base/attach-from-PROMPT_COMMAND が
        | 二重に呼び出された時にそれを実行するという事にする?
        |
        | うーん。ble/base/attach-from-PROMPT_COMMAND という名前ではなくて、
        | 適当にラムダ関数として重複の無いようにその場で関数を生成する?
        | そうすればちゃんとそれに紐付いた関数として呼び出す事ができる。
        | うーん。それが良い気がしてきた。

      * lambda で実装するのが良い気がしてきた。

        改めて方針について整理する。
        実際に登録するのはラムダ関数にする。
        そのラムダ関数から ble/base/attach-from-PROMPT_COMMAND を呼び出す。
        古い PROMPT_COMMAND は変数に保存するのではなくて、ラムダの本体に埋め込む。
        また、ラムダを削除する為に、ble/base/attach-from-PROMPT_COMMAND にラムダの関数名を渡す様にする。

        ble/base/attach-from-PROMPT_COMMAND 'old-prompt-command' "$FUNCNAME"

        ble/function#lambda 変数名 'function-body' というインターフェイスにする。

      * ok: lambda を使って実装した時に再帰呼び出しが発生する可能性はあるだろうか。
        考えてみる。

        一回目の source で PROMPT_COMMAND=lambda/1 になる。
        元の PROMPT_COMMAND は lambda/1 から呼び出される。
        二回目の source で PROMPT_COMMAND=lambda/2 になって
        此処から lambda/1 が呼び出される。

        実際に PROMPT_COMMAND が評価されるとどうなるか。

        | - lambda/2
        |   - ble/base/attach-from-PROMPT_COMMAND lambda/1 lambda/2
        |     1 PROMPT_COMMAND=lambda/1
        |     2 lambda/1
        |     | - ble/base/attach-from-PROMPT_COMMAND 元々の値 lambda/1
        |     |   1 PROMPT_COMMAND=元々の値
        |     |   2 元々の値
        |     |   3 PRECMD-=lambda/1
        |     |   4 _ble_base_attach_from_prompt=
        |     |   5 ble-attach
        |     3 PRECMD-=lambda/2
        |     4 [[ $_ble_base_attach_from_prompt ]] || return

        の様になって無限ループは防げる。

        PRECMD が重複して登録されてしまっているのは気になるが、
        まあ大丈夫だろうという気がする。
        PROMPT_COMMAND が複数回実行される程度の気がする。うーん。本当だろうか。
        PRECMD 経由だと何が起こるかというと…。
        登録した順に呼び出されるという事を考えると変な事になる。

        | - lambda/1
        |   - ble/base/attach-from-PROMPT_COMMAND 元々の値 lambda/1
        |     1 local PROMPT_COMMAND=元々の値 (PROMPT_COMMAND (lambda/2) != 元々の値なので local)
        |     2 元々の値
        |     3 PRECMD-=lambda/1
        |     4 _ble_base_attach_from_prompt=
        |     5 ble-attach
        | - lambda/2
        |   - ble/base/attach-from-PROMPT_COMMAND lambda/1 lambda/2
        |     1 PROMPT_COMMAND=lambda/1
        |     2 lambda/1
        |     |   ble/base/attach-from-PROMPT_COMMAND 元々の値 lambda/1
        |     |   1 PROMPT_COMMAND=元々の値
        |     |   2 元々の値
        |     |   3 PRECMD-=lambda/1
        |     3 PRECMD-=lambda/2
        |     4 [[ $_ble_base_attach_from_prompt ]] || return

        この様に考えてみると単に "元々の値" が二回実行されるだけである。
        或る意味これは自然と言えば自然な気もする。
        ユーザが二回初期化を実行したのだから。
        そして各 source ble.sh 毎に1回ずつプロンプトの計算が走る。
        また、最終的には PROMPT_COMMAND も PRECMD も解除される。

        次の場合はユーザが後になって PROMPT_COMMAND を修正した時に何が起こるかという事。
        これについては PROMPT_COMMAND の復元が行われないというだけで PRECMD は削除される。
        PROMPT_COMMAND の復元に関しては実は行われなくてもそう大きな問題にはならない気がする。
        attach も二度は起こらないし単に無駄に関数呼び出しが実行されるだけである。

      * ok: ble.sh が PROMPT_COMMAND を設置した後にユーザが更に何か追加する可能性がある。
        →これに関しても lambda を使って実装すれば大した問題にはならない。

      x fixed: これで --prompt=attach に対しては動くかと思いきやプロンプトが表示されない。
        これは /dev/null にリダイレクトしているのが原因である。
        と思ったがよく見るとちゃんと PROMPT_COMMAND の標準エラーは外に伝わる様になっている。
        という事はこれが原因ではないという事? ble-attach がそう何度も実行されるとは考えにくい。

        然し、実際のこのリダイレクトを修正したら問題が発生しなくなった。
        何が起こっているのだろうか。番号を指定してリダイレクトしている事によって
        何らかのファイルディスクリプタが上書きされてしまっている?

        或いは、2>/dev/null によって ble-attach の内部で実行した恒久的な exec redirection
        が復元されてしまっているのが原因だろうか。何か違いが生まれるとすればこれしかない。
        然し、何故これによってその様な症状になるのかというのは謎である。

        →何だか分からないがやはり attach は一番最後に行うべき気もするし、
        そういう意味でも一番外側で実行するべきである。その様に修正した。

    結局、--attach=prompt の時のファイルディスクリプタの問題と、
    ble-attach を強制的に実行した時に何も表示されなくなる問題は独立の問題だった。
    それがはっきりした今改めて状況について整理する。

    * ble-attach を実行したあとで source ble.sh を実行した時に、
      本来であれば stdout.off が unload で呼び出される筈で、
      結果として stdout.off, on が破壊されるという事はない筈である。

      という事は起こっている問題は stdout.on, off の問題ではない?
      或いは stdout.off に失敗している所為でこれが起こっている?
      まずはこれがどちらなのかを確認する必要がある。

      →確認した。二回目の初期化に於いて stdout.off 状態になっている。
      ここでの謎は何故 unload で stdout.on が実行されなかったのかという事。

      実際に調べてみるとちゃんと stdout.on は呼び出されていて
      状態は復元されている。と思ったら分かった。
      ble/base/unload-for-reload &>/dev/null として呼び出していたので、
      ble/base/unload-for-reload の実行が終わった後に
      1,2 が呼び出し前の状態に復元されてしまうのだった。

      そもそもこの &>/dev/null は何の為の物だったろうか。
      これを削除してしまっても特に問題はないのではないだろうか。
      或いは set -x 等の状態復元に関係があるだろうか。
      実は set -x の状態復元は此処では行っていない様に見える。
      →実際に set -x を実行してみたが特に何か出力されるという事もない様だ。

      念の為この部分の変更を履歴を調べておく。

      | 59995c62 (Koichi Murase 2015-08-11 19:42:02 +0900 226) if [[ $_ble_base ]]; then
      | fc45be68 (Koichi Murase 2019-01-11 20:38:38 +0900 227)   if ! ble/base/unload-for-reload &>/dev/null; then
      | fc45be68 (Koichi Murase 2019-01-11 20:38:38 +0900 228)     echo "ble.sh: ble.sh seems to be already loaded." >&2
      | fc45be68 (Koichi Murase 2019-01-11 20:38:38 +0900 229)     return 1
      | fc45be68 (Koichi Murase 2019-01-11 20:38:38 +0900 230)   fi
      | 59995c62 (Koichi Murase 2015-08-11 19:42:02 +0900 231) fi
      |
      | 59995c62 (Koichi Murase 2015-08-11 19:42:02 +0900 226) if [[ $_ble_base ]]; then
      | 59995c62 (Koichi Murase 2015-08-11 19:42:02 +0900 227)   echo "ble.sh: ble.sh seems to be already loaded." >&2
      | 59995c62 (Koichi Murase 2015-08-11 19:42:02 +0900 228)   return 1
      | 59995c62 (Koichi Murase 2015-08-11 19:42:02 +0900 229) fi
      |
      | commit fc45be6841be364d152cb2228e662ca842bf4fc3
      | Author: Koichi Murase <myoga.murase@gmail.com>
      | Date:   Fri Jan 11 20:38:38 2019 +0900
      |
      |     main: support "ble-update"

      対応する項目は #D0874 の様である。
      ちゃんとは読んでいないが特に >/dev/null の処置についての言及はない様である。
      取り敢えず何も起こっていない様なのでそのままで良い事にする。bash-3.0 でも大丈夫。

  * [別要因] menu: bleopt complete_menu_style=dense の座標計算が間違っている? [#D1353]

    | dense-nowrap では問題が起きていない事を見ると wrap で問題が発生しているという事か。
    |
    | 初め trace-text に渡している nonewline オプションが悪いのではないかと思ったが関係ない?
    | nonewline は confine 等とは関係なくて、単に改行文字を出力しないという事らしい。
    | 勝手に wrap するのは許す実装になっている気がする。
    |
    | そもそも何故座標計算がずれてしまうのか。どういう座標になっているのか?
    |
    | dense-nowrap で問題が発生しないということは
    | やはり右端で折り返す候補が来た時の処理が問題になっている。
    |
    | 幅は174 である。x0=169 で始まって x=19 で終わっている。
    | 出力している文字列は generate-release-note.sh である。
    | gener 折返し ate-release-note.sh という具合になる筈である。
    | 何も間違う所はない気がする。
    |
    | うーん。更に実際に描画している物を見ると複数行ある筈の所が同じ行に出力されている。
    | 最終的に行がカーソル位置が上に移動してしまっている。
    |
    | 何だかわからないので実際に表示を行っている部分を確認する。
    | construct-page が実際に出力するシーケンスを esc に格納している。
    | これを出力して確認してみるのが良いという気がする。
    |
    | かなり謎の振る舞いをしている。というか cat して表示した内容と、
    | Emacs で開いてみてみた内容が対応していないこれはどういう事か。
    | 暫く観察してこれは screen が悪いのではないかという事に思い至る…。
    | echo {1..100} を実行してみると改行せずに途中までしか表示されない。
    | 試しに新しい画面を C-a C-c で開いてみると直る。
    | DECAWM が変な状態になっているという事?
    | echo $'\e[?7h' としたら直る? 7l を何処かで間違って実行してしまったという事だろうか。
    | ble.sh の中には少なくとも 7l という文字列はない。
    | ble.sh の変数の中にも 7l が含まれている物はない。
    | という事はこれは恐らく何か別のプログラムが変な設定をして抜けたか、
    | 或いは別のプログラムがクラッシュした時に残したなにかである。
    | この pty では ssh はしていないと思うので途中で接続が切れて中途半端になったという事ではないと思う。
    |
    | 或いは履歴を探すとそういうコマンドが残っている様だ。
    | このセッションで実行した物ではない様に思われるが、
    | 子 bash で試してそのままになっているという事の様な気もする。
    | と思ったがこの bash を起動したのは 2020-04-26 23:43:05 JST だし、
    | この bash 自体が別の bash の子供という訳でもない。不思議である。

    結局これは端末の状態が変になっていただけであった。DECAWM が無効になっていた。
    然し、何故この様な状態になってしまったのかは終に分からない。
    ble.sh 自体には CSI ? 7 l を実行しそうな物は含まれていないので、木にしなくて良さそう。

  * complete: blerc で bleopt complete_menu_style を設定できない (reported by rux616) [#D1352]
    https://github.com/akinomyoga/ble.sh/issues/54

    指定した設定が存在しているかどうかのチェックをその場で行っている。
    core-complete.sh の初期化前なのでその設定が存在している事を確認できないのが原因。
    core-complete-def.sh に complete_menu_style 用の autoload を追加する事にした。
    これは単純な修正なのでテストしなくても良いだろうという気がする。

  * history: HISTTIMEFORMAT によるタイムスタンプが記録されない (reported by rux616) [#D1351]
    https://github.com/akinomyoga/ble.sh/issues/50

    まずは bash の振る舞いについて調べる必要がある。

    | というかそもそも HISTTIMEFORMAT がどの様に動作するか理解していない…。
    | 後、自分で HISTTIMEFORMAT を実装するとしてもコマンドの時刻をどの様に取得すれば良いのだろうか。
    |
    | HISTTIMEFORMAT を設定している時には history コマンドで表示する時に timestamp が表示されるそうだ。
    | それとは別に HISTTIMEFORMAT が表示される様だ。
    |
    | というか今気づいたが history -s で読み込ませた場合は時刻情報が欠落してしまうのではないか。
    | と思ったがそもそもファイルに出力された時刻情報を bash は読み取るのだろうか?
    | 何だか変な time format で記録した場合には復元できないし、
    | そもそもデフォルトでは出力していないので時刻情報は復元できない。
    |
    | ? ファイルに保存された時刻を読み取るのか?
    |   ファイルに記録されるのは unixtime 値である。
    |   そしてちゃんと読み取る様になっている様だ。
    |
    | ? 時刻が記録されていない場合には時刻はどうなるのか。
    |   history -w で書き出すとどうなるのか。
    |
    |   →何と HISTTIMEFORMAT が設定されているかどうかによって、
    |   bash の複数行履歴の記録の on/off が変化する様である。
    |   うーん。つまり? どうすれば良いのかというと?
    |
    |   例えば、ble.sh が使う場合には常に HISTTIMEFORMAT=%s を指定する?
    |   そうすれば常に複数行履歴が有効になった状態で
    |   履歴に対して特別な処理をせずにファイルを読み取る事ができる。
    |
    |   もう少し振る舞いは異なる様である。
    |
    |   HISTTIMEFORMAT が設定されていてかつ
    |   読み取るファイルの一番最初の行が #%s の形式である場合に、
    |   bash は複数行履歴モードに移行する。
    |   この時 #%s の形式の行が現れるまでを次のコマンドとする。
    |
    |   それ以外の場合にはそれぞれの行を履歴項目として取り扱う。
    |
    |   どちらの振る舞いの場合でも履歴の時刻は読み取られる。
    |   HISTTIMEFORMAT が設定されていてもされていなくても。
    |   直前に時刻が記録されていないコマンドに関しては、
    |   bash を起動した時の時刻が用いられる。
    |
    | ? HISTTIMEFORMAT は空かどうかで判定されるのか、
    |   それとも変数が存在しているかしていないかで判定されるのか?
    |
    |   ファイルの書き出し、ファイルの読み取り(複数行モード)、
    |   history による出力のそれぞれに対する影響を調べる必要がある。
    |
    |   ファイルの読み取りに関しては変数が存在していれば複数行モードに為る (bash 5.0)。
    |   ファイルの書き出しに関しても変数が存在していれば書き出される。
    |   history による出力に関しては空文字列と変数が存在していないという状況は
    |   動作に違いを与えないので調べても仕方がない。
    |
    | ? HISTTIMEFORMAT が設定されていない時でもコマンドの時刻は記録されているか。
    |   確認したがちゃんと記録されている様に見える。
    |   後で HISTTIMEFORMAT を設定しても history コマンドで時刻が表示されるし、
    |   ファイルにもちゃんと時刻が書き出される様になる。
    |
    | ? HISTTIMEFORMAT が設定されていない時でも #%s の行は読み取られるか?
    |   →ちゃんと読み取られている。
    |
    | ? HISTTIMEFORMAT が設定されている時に ble.sh の履歴の初期化が壊れるのではないか。
    |   つまり、全ての履歴が結合した状態で初期化されてしまうのではないだろうか。
    |   これは動作を後で確認する必要がある。
    |
    |   →履歴ファイルの先頭行 #%s が存在しているとこれが発生する。
    |   ble.sh の初期化で読み取る際に使うファイルは ble.sh が生成する物なので、
    |   #%s を全てに出力するか、或いは一個も出力しないかは自分で決められる。
    |
    | ? #%s の形式以外のコメント行はどう取り扱われるのか。
    |
    |   "#%s hello" でも認識された。"#X%s" だと駄目で "#%sX" だと認識される。
    |   " #%s" だと駄目。"# %s" でも駄目。"#1.5..." としたら 1 と読み取られた。
    |   という事は、bash は行が "#数字" で始まっているかどうかを見ている。
    |   もし当てはまれば整数を読み取る。読み取れない部分が残っていても無視する。
    |   "#-1" としても時刻行とは認識されなかった。
    |
    |   "#001" とすると 1 になった。 "#010" にすると 10 になった。8進数表記にはならない。
    |
    |   "#0x10" としてみたら "0x10: 無効なタイムスタンプです" になった。
    |   どうやら文字列として記録している? そして history コマンドで出力しようとすると、
    |   標準出力にこれが出力される。つまり、history の出力に混入する。
    |   HISTTIMEFORMAT= の時にはエラーメッセージは出力されない。
    |   HISTTIMEFORMAT=A の時にはエラーメッセージが出力される。
    |   恐らく HISTTIMEFORMAT が非空の文字列の時にのみ文字列を整数に変換して
    |   strftime を呼び出す等しているのだろう。
    |
    |   更に、"#0x10hello" とするとエラーメッセージも "0x10hello" に変わる。
    |   つまり、16進数表記の場合には文字列全体を時刻として読み取るという事?
    |
    |   どうやら試してみると先頭が 0 の時だけ振る舞いが異なる様である。
    |   なにか特別な解釈なのかもしれないと考えて 00:11:11 や 00-09-20 等として見たが
    |   別に時刻や日付として読み取ってくれそうな気配はない。
    |
    | ? 時刻行の先頭の # は常に # だろうか。或いはユーザの設定で変わりうる?
    |   何だかそういう設定が bash に存在した気がする。と思って調べたがなかった。
    |   恐らく記憶にあったのは readline variable comment-begin '#' であろう。
    |   然しこれは履歴ファイルに使われるものではなくて insert-command rlfunc
    |   で使われる物である。
    |
    | ? history -s で $'#123\necho hello' とすると何が起こるか?
    |   →そのまま "#12345 改行 echo WORLD" 等の様なコマンドが登録された。
    |   つまり「自動的に切り離して時刻として解釈する」というような機能は実装されていない。

    Bash の HISTTIMEFORMAT についてまとめた結果は #M0017 に書いた。

    ここで、何に対応しなければならないか。
    __ble_ext__ に unixtime 値を含める様に拡張するのは簡単である。
    然し、どういう風に振る舞うべきかというのについて考える必要がある。

    * done: 履歴ファイルに時刻を記録するという事。
      それから履歴ファイルに記録された時刻を読み取るという事。

      取り敢えず順番に対応する事にする。
      取り敢えず対応してみたがそもそも振る舞いは bash-3.2 でも同じなのだろうか。
      確認する必要がある→OK bash-3.2 でも HISTTIMEFORMAT= で出力される。
      bash-3.0 でも同様に振る舞う事を確認した。
      bash-3.0 でも HISTTIMEFORMAT='__ble_time_%s__' は有効である。

      試しに多少動かしてみたら動かなかった。修正した。
      取り敢えず書き出しはできている様子である。
      但し、時刻の読み取りはできていないので起動時の時刻になっている。

    * done: 履歴ファイルに書き込まれた時刻を正しく読み取るようにしたい。

      history -r とそれから最初の履歴の初期化について。
      そもそも最初の履歴の初期化はどの様に行っているか。確認する。

      ble/history:bash/load で実行しているのは
      Bash のコマンド履歴を ble.sh の配列に読み出す作業である。
      Bash のコマンド履歴自体には何も手を加えていないので此処では時刻について考えなくて良い。

      ble/history:bash/resolve-multiline に関しては実装の方法について再考しなければならない。
      先ず、古い bash の version でも先頭行が #%s である時に複数行モードが有効になるのかという事。
      →どうもこれは bash-4.4 以降の機能の様である。従って、#%s を利用して複数行読み取りに対応したとしても、
      その実装は bash-4.4 以降でしか使えない。history -s による実装は依然として削除できない。

      1. 取り敢えず現在の方針としては history -s 及び history -r による実装を修正する。
        ファイルに出力してそれを読み取らせる場合には、
        #%s という行を出力する様にすれば良いだけの気がする。
        history -s で複数行を読み込ませている部分に関してはどうしようもないので諦める。

      2. その後で bash-4.4 以降で #%s を用いて複数行を読み取らせる実装を用意する。
        これは後で実装する。

      取り敢えず実装した。意図通りに動くかを試す必要がある。
      取り敢えずは動いている様な気がする。

    x fixed: mlfix.0.part の1行目に空白行が出力されている。
      元のファイルには存在しない筈だし、builtin history もこれを出力しているとは考えにくい。
      これは一体何だろうか→分かった。
      存在していなかった変数 scalar_array[scalar_count] = ... と代入していた。
      以前は scalar_array[scalar_count++] としていたので 0 に評価されてちゃんと 0 番目の要素に代入されていた。
      今回 ++ を独立した行で実行する様に変更したので本来 0 に格納されるべきデータが "" に格納されていた。
      scalar_count を明示的に初期化する様に変更して修正した。

    * done: builtin history -a file で履歴をファイルに書き出している箇所では、
      意図せず #%s が出力されない様に HISTTIMEFORMAT を unset しておく。

      * local && unset でちゃんと出力されなく為るという事を確認する必要がある。
        →確認した所駄目だった。どうも HISTTIMEFORMAT の変数の place holder
        が存在するだけで有効になるという事の様である。

      どうも local で unset しても変数が存在している限りは #%s が出力される様だ。
      仕方がないので後の処理で削除するという事にする。

      これに関しては builtin history -aw 等の出力を ble.sh が利用している箇所は
      一箇所しかなかったので其処を修正するだけで済んだ。

    * done: 残っている __ble_ext__ があればそれについて対応が必要か確認する。
      残っているのは load だけである。そしてこれは
      _ble_history etc にデータをロードするのに使っているだけなので、
      日付の情報は関係ない。此処も修正するかどうか?
      不要といえば不要であるが、複数の箇所で異なる方法を用いているのも変な気がする。
      一方で使いもしない出力をさせるとそれはそれでややこしい。
      取り敢えずここは __ble_ext__ のまま残して置く事にする。

    * done: mlfix で bash-4.4 以降では #%s を用いて複数行を読み取らせる様にする。
      ファイルの最初の行に '#%s' を指定すれば複数行として読み取ってくれる筈である。

      | history -s の代わりに HISTTIMEFORMAT=%s history -r file として、
      | 複数行モードで履歴を読み取らせるという手がある気がする。
      | その場合には自分で $'' を decode してファイルに書き込む必要がある。
      |
      | この振る舞いは bash のどの version でも同じだろうか。
      | またどの shopt の集合でも同じだろうか。
      | これについては確認する必要がある。
      | →bash-4.4 以降で複数行として読み取る様になった様である。
      |
      | 何れにしても awk で #%s を出力する様に加工すれば良いという事の気がする。

      その他の箇所で複数行コマンドを初期化するのに
      history -s を使っている箇所はあっただろうか。ない気がする。

      うーん。これは実装してしまう事にする。

      と思ったが eval -- $'...' の形式を復号しなければならない。
      どうやって復号するのが良いだろうか。
      実際にこの形に加工している部分を探す。awk で加工している。
      以下のコードである。

        gsub(/['$apos'\\]/, "\\\\&", text);
        gsub(/\n/, "\\n", text);
        gsub(/\t/, "\\t", text);
        text = "eval -- $'$apos'" text "'$apos'"

      基本的にはこの操作の逆手順を実行すれば良い筈。だが。
      ユーザがこれと同様のコマンドを実行していて、
      其処に \e 等の別の種類のコマンドを混入させていたらどうなるのか。
      すると復号しきれない文字が残ってしまう。

      或いは全種類のエスケープシーケンスに対応する?
      と思ったが上記のエスケープで生成できない様な
      コマンド文字列の場合には復号しない様に修正すれば良いのである。
      そしてその検出は正規表現で十分にできる。

      実装した。ちゃんと動いている気がする。

    * ok: 特定の条件で history のHISTTIMESTAMPの出力は ?? になってしまった筈。
      この場合にどの様に振る舞うかはちゃんと考えておく必要がある。

      bash 4.0 以降では履歴の初期化は idle で実行しているので問題はない筈。
      つまり、もし問題が起こるとしたら bash-3.2 である。
      →うーん。複数行コマンドの日時が起動時に置き換わってしまっているという事以外は大丈夫。
      prompt attach を採用しているからだろうか→特に問題は起こっていない。

      元々 \?\? は何処で導入されたのか。調べると ble-0.1 の時点で __ble_ext__ がある。blame した。
      4e97b41a (Koichi Murase 2015-02-19 00:41:20 +0900 3327)     /^ *[0-9]+\*? +(__ble_ext__|\?\?)/{
      e7606868 (Koichi Murase 2015-02-12 02:55:39 +0900 2131)       /^ *[0-9]+\*? +(__ble_ext__|\?\?)/{

      | commit e7606868bbbb04ed7087a180317bd56446460304
      | Author: Koichi Murase <myoga.murase@gmail.com>
      | Date:   Thu Feb 12 02:55:39 2015 +0900
      |
      |     - ble-decode.sh, ble-edit.sh: ble の detach 機能の実装
      |     - ble-decode.sh: exit 後に stty が壊れているのを修正
      |     - ble-color.sh: 色の付け方を修正・追加

      うーん。大した記録は残っていない。
      一応 #D0129 が対応する項目の様だが単に rcfile 内部での履歴の読み取りに対応したというだけ。
      或いはサブシェルで実行していたりすると発生するのだろうか。
      そもそも bash-3.2 で ble-attach した時に mlfix は呼び出されているのだろうか。
      見ると複数行の履歴項目が復元されているのでちゃんと処理はされている筈。
      と思ったが、よく考えたら初めて必要になった時まで遅延させているのだった。

    * fixed: bash-3.2 で history_lazyload= にして初期化時に読み込ませると、
      '#%s' の行もコマンドの行として読み込まれてしまっている。
      何が起こっているのだろうか。つまり、builtin history が '#%s' もコマンドとして出力している?

      % これはその後の bash の初期化で修正される様だ。
      →修正されるというよりは、サブシェルで builtin history -n で履歴を読み込んだ結果であり、
      本体のシェルには影響を与えない様になっているという事の様だ。
      一方で直接に bashrc に history -n を書き込んで実行してみると、
      確かに履歴に #%s の行が混入して面倒な事になってしまっている。

      と思ったら ble/history:bash/load/.generate-source のコメントに rcfile として
      実行すると HISTTIMEFORMAT を指定しても ?? になるという旨が書かれている。
      然し、現在ではこれは再現していない。うーん。
      親シェルで実行していた時にだけ発生していたのだろうか。
      然し、実際に history -n history を直接実行した場合でも問題は発生していなかった。謎。

    * ok: bash-3.2 で mlfix が実行されているのは確かの様に思われるが、
      一体何処で実行されているのだろうか。そもそも本当に実行されているのか。
      実際にソースコードを観察するとどこでも呼び出していない気がする。
      然し、実際に複数行 escape が外されている。
      Bash が勝手にコマンドの内容を書き換えるのは不可能である。
      或いは load で書き換えられているのか、と思ったが、load は
      _ble_history シェル変数にロードするだけで Bash のコマンド履歴を編集したりはしない。

      結局、ble-stackdump して分かった事は、
      コマンドを実行するタイミングで history -p が呼び出されて、
      その結果として resolve-multiline が呼び出されるという事らしい。
      というか実際に ble/builtin/history/option:p のコメントにその様に書かれていた。

      @ out/ble.sh:4 (ble/history:bash/resolve-multiline/.worker)
      @ out/ble.sh:13084 (ble/history:bash/resolve-multiline.impl)
      @ out/ble.sh:660 (ble/history:bash/resolve-multiline)
      @ out/ble.sh:7 (ble/builtin/history/option:p)
      @ out/ble.sh:1 (ble/edit/hist_expanded/.core)
      @ out/ble.sh:1 (ble-edit/hist_expanded/.expand)
      @ out/ble.sh:-2169 (ble/util/assign)
      @ out/ble.sh:5 (ble-edit/hist_expanded.update)
      @ out/ble.sh:3433 (ble/widget/accept-line)
      @ /home/murase/.mwg/src/ble.sh/out/keymap/vi.sh:7352 (ble/widget/vi_imap/accept-single-line-or)
      @ out/ble.sh:5089 (ble-decode/widget/.call-keyseq)
      @ out/ble.sh:48 (ble-decode-key)
      @ out/ble.sh:51 (ble-decode-char/.send-modified-key)
      @ out/ble.sh:156 (ble-decode-char)
      @ out/ble.sh:11 (ble/encoding:UTF-8/decode)
      @ out/ble.sh:4927 (ble-decode/.hook)

      という事はつまり、bashrc の中で history -p を呼び出すと変な事になる?
      一応履歴が空の時には mlfix を呼び出さない様に修正した。

      確かにこの様に history -p に伴って遅延して mlfix を実行する様にすれば、
      HISTTIMEFORMAT が変な値になる事もないし、
      また時刻が history -n によって読み込んだ変な値になっているという事もない。
      特に問題はないだろうという気がする。

2020-05-06

  * bash-4.4 trap return の work around はあるか [#D1350]

    現在の Bash の振る舞いでは関数内でも無引数 return なら
    外側の終了ステータスになってしまうが、もしこれは解釈Aに修正してもらうと、
    ユーザートラップが無引数 return を実行したのか有引数 return を実行したのかを
    正しく判定しなければならなく為る。

    a 実は return() { builtin return $?; } とすれば問題を解決できる?
      と一瞬思ったがこれだと return できなくなるので駄目である。

      a 或いは alias return='ble/builtin/return; return' とでもして
        何とかなる? と思ったが、引数は結局取れない。

      b RETURN トラップで何とか検出できないか。
        つまり function return を実行したらなにか変数に記録して、
        次の RETURN で実際に RETURN を実行させる事にする。

        そして検出したらその場で RETURN する。
        と思ったが trap を実行している途中には RETURN トラップは無効なのでは。
        trap の中で trap を呼び出せるのかについて確認する必要がある。

        →確認した所、RETURN trap の中では RETURN は発火しない。
        DEBUG trap の中では RETURN が発火する。
        つまり RETURN 以外の trap handler の中では RETURN が発火するという事。

    % 例えば RETURN と return() { _return_status=${1:-$?}; } を組み合わせて何とかする。
    % もし呼び出されたフレームが trap のフレームであれば
    %
    % return() {
    %   local status=$?
    %   _return_arg=$1
    %   if ((_trap_level==${#FUNCNAME[@]}+1)); then
    %     _return_status=${1:-$status}
    %   else
    %     _return_status=${1:-$_trap_preceding_status}
    %   fi
    % }
    % builtin trap '[[ $_return_status ]] || builtin return' RETURN
    %
    % ? trap の中で RETURN trap は有効か?
    %
    % うーん。色々面倒である。取り敢えず ble/builtin/trap で
    % return を実行できる様に修正してから調整するべきである。

    →そもそもの問題として RETURN は関数の内部で実行される様なので、
    return() { ... } で return の機能を再現する事はできない。

    或いは DEBUG/RETURN の両方を trap してどちらか最初に呼び出された方を用いて
    "return xxx" を実行するという手がある。何れにしても込み入った方法になる。

    これは困難である。取り敢えず保留という事にする。

  * trap: bash handler の継承が一体どうなっているのかは謎 [#D1349]
    bash の場合サブシェルの中で見ると handler が継承されていたりいなかったりするのでは。
    どういう規則になっているのか。どのハンドラーが継承されてどのハンドラーが継承されないのか。
    RETURN DEBUG と -o functrace, declare -tf との関係。
    ERR と -o errtrace の関係。RETURN, DEBUG では今から実行しようとしているコマンドを知る事ができるのか。
    ソースコードと行番号は知ることができそうな気がする。実行が eval string で定義された関数の場合には、
    行番号を知ったとしてもよく分からないのでは。そもそも BASH_SOURCE は何になるのか。

    →取り敢えず #M0016 にまとめた。

  * trap: 現在の実装だとユーザが INT に何か設定していても無視されてしまうのでは [#D1348]
    というより何が起こるのか不明である。
    然し、C-c を禁止するというのも変な気がする。
    後で可能な設計について考える。

    →これは取り敢えず新しい枠組みを使ってユーザの設定した物を実行し、
    ユーザが return/break/continue を実行した場合にはそれを実行する様にした。
    然し、ble.sh 自体が設定している DEBUG trap による中止もそのままである。

  * trap: ユーザ trap handler 内部で return を実行した時の振る舞い [#D1347]
    ユーザが DEBUG トラップに return を設定した場合には何が起こるのか
    というより全般にユーザが return を設定した時にその場で関数を抜ける、
    という振る舞いが再現できていない。

    全ての hook は 'hook; if [[ $_ble_trap_return ]]; then return; fi'
    の様な形にするか或いは 'hook; builtin eval -- "$_ble_util_trap_hook"'
    の様な形にする必要があるのである。

    因みにユーザが return で抜けたかどうかを判定するのは簡単である。
    というのも eval ''; _ble_builtin_trap_done=$? 的な感じにすれば良い為。
    もし _ble_builtin_trap_done が設定されていなければ return で抜けたという事。

    (取り敢えずは Bash 4.4 無引数 return の問題は後回しにする。)

    * 現状の設計について確認する。

      _ble_builtin_trap_reserved に登録されているシグナルは特別な処理を実行する。
      それ以外のシグナルについては Bash の builtin trap をそのまま使う。
      reserved への登録は必ず ble/builtin/trap/reserve で行う。
      EXIT, INT, WINCH, DEBUG, USR1 を reserve している。

      その他のシグナルについては大丈夫だが
      これらのシグナルについてはちゃんと処理する必要がある。

      問題は reserve したシグナルに対する本当の trap を何処で設置しているのかという事。

    取り敢えず先に DEBUG から対応しようと考えたが微妙である。
    現在の実装では DEBUG は INT を受信した時にだけ ble.sh で設定する事になっている。
    そしてユーザーが設定したとしても取り消される仕組みになっている。

    DEBUG は特に全てのコマンドの前で設定されるので不要であれば外しておきたい。
    ユーザの設定した trap か ble.sh の設定した trap のどちらかがある時に有効になる様に実装したい。
    取り敢えず USR2 辺りで試験的に実装してみて枠組みを確定させるのが良い気がする。
    →取り敢えず USR2 で実験してみた結果は成功である。
      trap handler 内部での return も再現できている。
      勿論 FUNCNAME 等は異なる値になっているがそれは仕方ない。
      その他に振る舞いを左右する別の物があったりするだろうか。

      実は、continue や break 等も本来は正しく処理したいのである。

    | * DEBUG trap の性質について調べる事にする。
    |
    |   * 取り敢えず return, continue, break は DEBUG trap で検出できる。
    |     →実は bash-3.0 では BASH_COMMAND には trap handler
    |     の文字列自体が入ってしまっているので、
    |     この方法では return/continue/break は検出できない。
    |
    |     continue, break に引数が指定された時にどのように検出するかに関係する。
    |
    |   ? declare -ft を設定した関数では DEBUG が継承されるというが、
    |     間に普通の関数が挟まっていても活性化するのか?
    |     →駄目。活性化しない。やはり飽くまでも "継承" という事の様である。
    |     つまり、signal handler を呼び出す際に改めて trap DEBUG し直す必要がある。
    |
    |   ? debug trap が有効でない関数の中で trap を呼び出して出力した時に、
    |     DEBUG trap は列挙されないのか、それとも列挙されるけれども不活性という事なのか。
    |     →列挙されない。
    |
    |   ? 関数内部で trap DEBUG した時に、外側の trap が破壊されたりしないか。
    |     →trap DEBUG で削除した場合には外側の trap DEBUG に影響はない。
    |     →trap cmd DEBUG で登録した場合には、bash-4.3 以下では外側の trap DEBUG に影響はない。
    |     然し、bash-4.4 以降では外側の trap DEBUG も書き換わってしまう。
    |
    |     ユーザの設定した trap DEBUG の有効・無効を管理するのは実は大変である。
    |     現在の関数の位置と一緒に覚えておく必要がある。
    |     関数の終端で解除するという事をしなければならない。
    |     その為には RETURN 等にも仕掛けなければならないだろうか。
    |
    |   ? 関数内部で trap DEBUG した時に、
    |     全く同じ trap DEBUG の内容でもちゃんと有効になるだろうか。
    |
    |     →全く同じ内容で定義した時にそれが有効になったかどうかをどうやって判定するのか。
    |     もし判定する事ができないのだとすればそれは実質動作に変化がないという事なので、
    |     有効になっても有効にならなくても何の問題もない。
    |
    |     或いは、関数内部で無効にになっている状態で改めて trap DEBUG を設定した時に
    |     有効になるのかどうかという疑問だとすれば、それは当然有効になる筈である。
    |     念の為に確かめる事にする→ちゃんと無効から有効に変化するという事を確認した。
    |
    |   うーん。色々考えるとやはり別の trap を使うというのは
    |   その trap の元々の機能も保持しなければならないので大変である。
    |   更に RETURN や DEBUG 自体の return/continue/break はどうやって検出するのか等、
    |   色々複雑になってしまう。
    |
    |   ? DEBUG trap の中で DEBUG trap は有効か?
    |     実際に試してみると trap で設定する事はできるが発火しない。
    |     BASH_COMMAND は書き換わらない。
    |
    |     つまり DEBUG trap 自体を再現する為に DEBUG は使えないという事。
    |
    | * RETURN trap の性質について調べる。
    |
    |   ? declare -ft, set -T の効果について。
    |     これは DEBUG と同様に継承が決まる。
    |
    |   ? 関数を抜けるコマンドが実行された後に呼び出される。
    |     BASH_COMMAND は一番最後に実行したコマンドが入っている。
    |     return を使った時には return コマンドである。
    |
    |   ? 関数内で発火するのか、それとも関数外で発火するのか。
    |     関数内で発火する気がする→実際に試してみたらそうだった。
    |     内部で更に return を実行すると無限ループになる。
    |     勿論、条件付きで return すれば無限ループにはならない。
    |     その場合には終了ステータスを書き換える事が可能になる。
    |
    |   さて、この RETURN トラップの性質を考えると、
    |   continue/break を関数で上書きするという作戦は使えない事になる。

    a もしくは DEBUG trap を使えば面倒な事をしなくても
      実際に実行したコマンド (continue/break 等) を検出できるだろうか。
      実はその方が良いという気がする。

    うーん。結構面倒な気がするので DEBUG trap による continue/break の
    引数の検出は実装しなくても良いという気がする。これは制限である。
    或いは完全に異なる方法で検出する方法はあるだろうか。

    b 行番号とファイル名からソースコードを割り出してそこから読み取る?
      然し、continue break の引数に指定されている単語が複雑な物の場合、
      特に副作用がある物やコマンド置換等の場合にはそれを実行する訳には行かない。

    c やはり RETURN trap を犠牲にして continue, break を emulate する方法を考える?
      因みに builtin continue, builtin break をユーザが使っている場合には不可能。

    ? continue/break で実際に抜けられるのよりも大きな値を指定した時にどうなるか。
      →全てのループを抜ける。失敗するという事はない。
      呼び出し元関数のループには影響を与えない。

    色々の事を考えると continue/break の引数に対応するのは複雑になりすぎる。
    そもそも trap を ble.sh の枠組みの上で完全に再現するのは難しそうである。

    取り敢えずの実装 (break/continue の引数には対応しない) については
    以下のコマンドを用いてちゃんと動くかを確認した。

    $ ble/builtin/trap/.set-signal-handler USR2
    $ trap 'echo world; return 123' USR2
    $ f1() { local i; echo BEGIN; while :; do sleep 0.01; done; echo END; }
    $ (sleep 1; kill -USR2 $$) & { f1; echo $?; }
    $ trap 'echo world; break' USR2
    $ (sleep 1; kill -USR2 $$) & { f1; echo $?; }

2020-05-02

  * .s AAA と入力すると表示が乱れる [#D1346]

    | 更にシグナルハンドラ関連の配列添字エラーが発生する。
    | これは一体どういう事だろうか。eba9b92 で再現している。
    | bash --rcfile out/ble.sh では発生しない。
    |
    | →どうやらこれは PS1= を internal_suppress_bash_output=1
    | の時に実行しない様に変更した事と関係している。この PS1 の出力は
    | bash によって出力されている物だろうか。
    | suppress してリダイレクトしているのに表示されてしまっている理由は何だろう。
    | stdout.on, stdout.off がちゃんと動いていないという事なのだろうか。
    |
    | PS1 と _ble_edit_PS1 に別の値を設定して確かめた所、
    | 確かに bash が勝手にプロンプトを出力しているのだという事が判明した。
    | 特に文字が先頭に移動するという事から、bash はプロンプトを出力した後に
    | \r 等を出力しているという事だろうか。或いは、ble.sh の枠組みに於いて、
    | \r を出力するタイミングと文字を出力するタイミングの間に
    | bash が介入してしまうという事だろうか。
    |
    | 或いは、bash-5.0 では実は suppress の効果がないという可能性。
    | 確かめてみた所 bash-4.1 以降で問題が発生する様子である。
    | どのタイミングで bash のプロンプトが表示されるのか確かめる。
    | うーん。どうも .s が含まれる場合に処理がクラッシュして off が呼び出されていない?
    | →その様だ。stdout.off が消滅している。何故? bashrc の設定と何か関係ある?
    | failglob で終了してしまっている可能性が濃厚である。
    | と思って shopt -u failglob で試してみたが問題は解決しない。
    |
    | 調べると idle.do の中で起こっている。更に auto-complete.idle の中で起こっている。
    | どんどん掘っていくと ble/complete/source:argument の中で発生している。
    |
    | →結局これは bash-completion の __load_completion の実装で
    | xspecs[$cmd] の $cmd に .s 等を渡すとエラーになってその場で実行が終わる為の様だ。
    | eval で囲んでみたがそれでも実行が停止してしまう様だ。
    |
    | もし仮にクラッシュを防げたとしても根本的な問題として
    | xspecs の定義が消滅してしまうという問題は関数内で source している限り残る。
    | 然し、これはどうしようもない。うーん。或いは xspecs が連想配列でない場合には
    | __load_completion を呼び出さないという事にする?
    |
    | 然し問題はそもそも bash-completion の呼び出し方にある。
    | その時点で何が起こっても仕方がないと諦めるしかないのではないか。

    * まとめるとこれは bash_completion が内部で declare -A _xspecs で連想配列を宣言しているが
      関数内で bash_completion を source している為にこの宣言が環境に残らない。
      連想配列以外について _xspecs[.s] の様な参照を行うとエラーになってその場で色々の実行が終了してしまう。
      internal_suppress_bash_output の設定の処理についても行われずに終了してしまう。

    * ok: 然し、直接 source する様にしても問題が解決しない
      何故だろうと思っていたら、実は . と source で振る舞いが違う?
      と思ったらこれは function#advice で remove しても関数として残留する事が原因だった。

      つまり、関数内で実行しているので source 内の declare の類は
      その関数のスコープの中に作成されてしまう。
      同様の問題が function#advice remove unset でも起こるのではないか。
      常に dynamic unset になってしまう。
      従って、advice する物がなくなったら元に戻すというのが正しい筈。

      →これはその様に修正した。OK

    bash-completion については自分で直接 source してもらうしか解決方法はない。
    従ってこれについては諦める事にする。

    或いは bind -x の exec 経由で bash-completion を
    実行するという手がない訳ではない。
    然し、何れにしてもその他の枠組みを用いた場合でも autoload すると、
    bash-completion は正しく初期化する事ができないという事になる。
    まあ取り敢えずは気にしない事にする。

2020-04-27

  * SIGWINCH でちゃんとプロンプトの計算が更新されていない [#D1345]

    要約: builtin trap WINCH 後に readline でコマンドを実行しないと、
      readline が COLUMNS/LINES の更新に使っている handler が設置されない。

    というより、空コマンドで RET を押しても更新されない。
    そもそもプロンプトのキャッシュで COLUMNS:LINES を参照していなかったのか。
    →うーん。確認すると COLUMNS が入っている。

    という事はつまりそもそも ble-edit/prompt/update まで到達していない?
    然し、それも変な気がする。何しろ RET を押しても更新されないのだから。
    →実は更にその次の部分でのキャッシュにより更新が抑えられている?

    うーん。trace_hash にもちゃんと COLUMNS が記録されている。
    というか rps1 ですら再計算されていない。という事は、やはり
    ble-edit/prompt/update にまで到達していないと見るべきか。

    不思議だ。手許で新しく実行してみると症状が再現しない。
    然し、ble-reload した場合には再現している。
    何らかの条件で発生したりしなかったりするのだろうか。
    振る舞いを調べるとやはりそもそも SIGWINCH を受信していない?
    と思ったがそれも変である。そうだとしたら再描画されていない筈。

    取り敢えず reload では再現するので其処を手がかりに調べていく事にする。
    →分かった。新しいセッションでも reload すると再現する様になる。
    然し、cygwin では常に再現する。
    →分かった。COLUMNS, LINES が更新されていない様だ。
      それから SIGWINCH もその場では実行されなくなっている。
      ユーザが何かを入力したタイミングで初めて SIGWINCH が発火する。

    問題は何故最初は動いていたのに reload すると動かなくなるのかという事。
    何らかの操作が関係しているのだろうか。或いは、二回以上 SIGWINCH すると
    振る舞いが変わってしまうという事なのだろうか。

    更に stty の状態やリダイレクトの構造も関係してくるのかもしれない。
    確認したがリダイレクトの構造については変化はない。
    stty についても stty 自体が悪さをしているという事はないだろう。
    何かあるとしても特定の stty の時に何かをすると再現するという事だろう。

    →再現した。或いは builtin trap を実行する環境に問題があるのかもしれない。
      ble-detach して builtin trap して ble-attach しても問題は発生しない。
      問題が発生している時に ble-detach; ble-attach すると直る。

    今までの振る舞いを整理すると。

    * ble-reload すると問題が発生する様になる。
    * builtin trap -- ...　WINCH するだけで発生する。
    * ble-attach; ble-detach すると直る。
    ? 他の bash version は?
      bash-4.1 以下では常に問題が発生している。
      bash-4.2 以降は bash-5.0 と同じ振る舞いである。
      つまり、この振る舞いは特に最近導入された物ではないし、
      寧ろ古い bash の方が振る舞いが酷いという事である。
    ? WINCH 以外の builtin trap でも問題は発生するか?
      →しない。WINCH を設定したときにだけ振る舞いが変化する。

    問題は何処に在るのか。そしてどの様に避ける事ができるのか。
    ble-attach; ble-detach で直るのは何故なのか。
    一旦 readline に戻すと良くなるという事なのか、
    或いは、何らかの設定 (stty) 等が変更されてしまうという事なのか。
    然し、stty の問題であれば何か一つでもコマンドを実行すれば
    変な振る舞いにはならずに元と同じ様になる筈である。

    ? bleopt_internal_suppress_bash_output= bash でも再現するのか。
      →bleopt_internal_suppress_bash_output= では発生しない。
      つまり勝手に標準入出力を繋ぎ変えているつけである。
      これは単純なスクリプトで再現するのは難しそうだし、
      再現できたとしてもそんな変な事をしているのが悪いという事になる。

      然し、それでは何故普通に attach した時には問題がなくて、
      biltin trap -- し直した時にだけ問題が発生するのだろうか。

    ? ble-detach; ble-attach をその場で実行したら直るだろうか。
      (振る舞いを見ると治らない様な気もする。
      一回通常の状態で bind -x から抜ける必要がある気がする。)

      ble-detach/impl と ble-attach を呼び出せば良いだろうか。
      →これだと直らない。

      或いは、edit.sh の ble/widget/.change-editing-mode では
      次の操作を実行している。
      ble/decode/reset-default-keymap
      ble/decode/detach
      ble/decode/attach
      →これでも直らない (reset-default-keymap は試していないが関係ないだろう)。

    % と思ったら builtin trap しても再現しなくなってしまった。
    % と思ったら分かった。 WINCH ではなくて USR2 に対して実行していた。

    ? 子bashで問題が発生している状態で終了したら、
      親bashでも問題が発生したままだろうか。
      →親bashでは問題は発生していない。
      つまり、これは tty の状態というよりは
      やはり bash のプロセスの中で起こっている問題である。
      bash のプロセスの側で修正されるべき物である。

    ? internal_suppress_bash_outputを一瞬だけ有効にするという手もなくはない?

      追記: 原因は別の所にあったのでこの方法では何も解決しない。

      % 本当に可能だろうか。そしてそれで本当に解決するのか。
      %
      % builtin trap で上書きが実行される瞬間、または、
      % ble-reload が行われた後に対策を実行する必要がある。
      % そもそも ble-reload はどのタイミングで再ロードを実施しているのか。
      % 現在の実装だと prompt で再ロードを実行している。
      %
      % * 棄却: Bash の PROMPT_COMMAND で ble-attach すれば問題は解決するのでは?
      %   この prompt command の表示は何処で実行されるのか。
      %   Bash による物なのか或いは ble.sh 自身による物なのか。
      %   →確認した所、ble.sh 自身の eval-prompt の中から実行されている。
      %   --attach=prompt と同様の状態に持っていく事はできないのだろうか。
      %
      %   ここでの問題は PROMPT_COMMAND が実際に呼び出されるのかという事。
      %   →試してみたが bind -x の関数の呼び出しの直後には呼び出されない。
      %   WINCH の後でも呼び出されない。
      %   PROMPT_COMMAND から ble-attach するのはできない。
      %
      % ここでの問題は其処ではない。suppress_bash_output を無効にするという事。
      % 一時的に無効にすることは果たして可能だろうか。
      % 確認してみた所、internal_suppress_bash_output は元々有効なのを
      % 一時的に無効にするのは可能である様に見える。有効な時にだけ行う初期化がある。
      % 無効な時には何も初期化はしない。
      %
      % と思ったが無効な時の stdout.on stdout.off を上書きしていた。
      % stdout.on と stdout.off に internal_suppress_bash_output= の時に
      % 処理を動的に切り替える様にすれば良い様な気がする。
      %
      % 然し一時的に切り替えたとして誰が復元するのか。
      % うーん。それよりは internal_suppress_bash_output=tmpoff 等の様に
      % 特別な値を設定して、その特別な値の時にだけ対策を実行する?
      % そして一回特別な処理をしたら後はまた普通の値 (1) に戻す。
      %
      % * PS1 の保存・復元方法の変更
      %
      %   | ここで問題になる可能性があるのは PS1= にする対処を
      %   | bash_completion の為に諦めた事である。
      %   | PS1= に有限の文字列が含まれている為、初期化スクリプトが勘違いする。
      %   | 実際の所 bash_completion は二度以上初期化しないのでここでは関係ない。
      %   | 然し、その他のスクリプトで二度以上実行する必要のあるものがあるかもしれない。
      %   | そして、最初のプロンプトを表示してユーザ待ち状態になっている時に
      %   | ble-import を実行する可能性は高い。
      %   |
      %   | というより、本当に PS1= を諦める必要があったのだろうか、という疑問が残る。
      %   | PS1= のタイミングを本当に一番最後にしていれば問題は起こらなかったのではないか。
      %   | →調べると PS1 は殆ど常に待避した状態になっていて
      %   | コマンドを実行する直前と直後にだけ復元するという事になっている。
      %   | 実は単に stdout.{on,off} のタイミングで保存・復元すれば良いのでは。
      %
      %   もし一時的に internal_suppress_bash_output を無効化するのであれば、
      %   同時に PS1 の待避の方法も変更する必要がある。現在はユーザコマンドを実行する度に
      %   PS1 を復元するという方策を取っているが、実は stdout.{on,off} を呼び出す度に
      %   保存・復元を実行するという形にすれば良い。その場合には _ble_edit_PS1 の代わりに
      %   PS1 を直接編集する様に変更する必要がある。もしくは PS1 を _ble_edit_PS1 にコピーする。
      %   read 等を実行する際に一時的に _ble_edit_PS1 を変更しているが、
      %   これはどうなのだろう。。と思ったが、これは save/restore-vars で復元されるのだった。
      %   なので実は PS1 を直接上書きする方法でも良い気がして来た。

    原因について調べればもっと良い回避方法が見つかる可能性もある。

    * そもそも RET でコマンドを実行すると一時的に直るのは何故だろうか。

      要約: stty を実行するとその場で COLUMNS/LINES が更新される。
        WINCH によって更新される訳ではないし、WINCH handler が修正される訳でもない。

      | 特に echo を実行しただけで直るというのは不思議である。
      | 或いは、もっと早くに COLUMNS が修正されているが、
      | 単にプロンプトが更新されていないだけ?
      |
      | →確認すると確かに echo を実行した直後に初めて COLUMNS が更新されている。
      | これが意味する所は何だろうか。epilogue/prologue で何かが起こっている?
      |
      | →分かった。term/enter,leave を省略すると
      | コマンドを実行しても COLUMNS が更新されない。
      | これは stty を実行すると直るという事だろうか。
      | →その様だ。特に stty sane でも良いので実行すると COLUMNS が更新される。
      |
      | 或いは bash で何か操作したら直るかもしれない。
      | shopt -u checkwinsize; shopt -s checkwinsize を stdout.on に入れてみたが
      | 特に何も変化はない。COLUMNS も更新されない。

    * bind -x で再現する事は可能だろうか。
      例えば。trap WINSIZE を実行してから一度でも
      stdout.on で制御を bash に戻せば状態は元に戻るのである。

      逆に言えば、生の bash でこの状態を再現する為には
      全ての bind -x に bind しなければならない?
      と思ったがユーザが特定のキーしか押さないという事にすれば十分再現できる?

      取り敢えず C-t で bash suppress に入って C-y で抜ける様な bashrc を作った。
      更にここで builtin trap -- WINCH を実行するのである。
      取り敢えず手許のスクリプトでは問題を再現する事ができた。

      不思議なのはこのスクリプトだと最初から winch を trap していたとしても、
      suppress している時に WINCH が呼び出されず、COLUMNS も更新されない事。
      ble.sh の場合には bash-4.2 以降では既定では suppress していても
      ちゃんと WINCH が更新されているという事なのである。

      ここでの疑問は何故 "bind -x" 外で trap を設定した時に
      ble.sh でちゃんと動いている様に見えるのかという事である。

    [問題]

    * bash-4.2 以降では reload すると問題が発生する。
    * bash-4.1 では常に問題が発生している。
    * Cygwin でも常に問題が発生している。

    bash-4.2 以降の初期状態の様に振る舞わせる事が可能であればそれで良いが、
    現状の様子を見ると bash-4.1, Cygwin では問題が発生している。
    従って可能であれば bash-4.1, Cygwin でも常に動くような対策が欲しい。

    a 一つの可能性は毎 bind -x で stty sane を実行するという事。これは
      重い。或いは空コマンドを実行する場合 (newline) でも stty sane を
      実行するという事。これもある程度の重さが残ってしまう気がする。

      stty sane 以外の方法で COLUMNS を更新させる事は可能だろうか。

    b 例えば winsize の通知を要求する terminal sequence はあるのだろう
      か。端末エミュレータ側では termios で端末サイズなど設定してしま
      うので、端末自体がこれに対応しているという話は効いたことがない。
      端末ハンドラ経由で要求するしかないのだろうか。簡単な terminal
      sequence でサイズを要求できないのか。

    c 或いは現在の端末のサイズを変更するシーケンスを送れば強制的に
      WINCH をその場で発生させる事ができるだろうか。然し、その為には端
      末のサイズを知っていなければならない。或いは端末のサイズを実質的
      に変更しないシーケンスを送る事ができたとしても、端末側がサイズが
      変更なかった場合に termios に設定しないのだとしたら、或いは端末
      ハンドラが変更チェックを行っていたとしたらこれは効果がない。

    bash のソースを確認すると値の設定を行っているのは恐らく
    sh_set_lines_and_columns である。そして呼び出し元は lib/sh/winsize と
    readline である。lib/sh/winsize は get_new_window_size を提供している。
    get_new_window_size は第一引数に from_sig というのがあるが、
    これは使われていないし、また、呼び出し元でも 0 しか指定していない。
    readline 側での呼び出し元は _rl_get_screen_size である。
    また readline 内部にも sh_set_lines_and_columns の実装がある。
    lib/readline/shell.c である。でもこれは readline を standalone で
    コンパイルした時に使われる物ではないかとの疑惑がある。

    [未解決の謎]

    * 何故 bash-4.2 以降 / linux では WINCH を検出できているのか。
      というかそのまま bash を抜けると親 bash はちゃんと動くので、
      端末ハンドラの設定ではない。やはり bash 自体が何だか変な事になっている。

    Bash の実装について確認する

    | bash の振る舞いについて調べている。どうも biltin trap で WINCH に登録すると
    | bash は別のシグナルハンドラを signal で登録し直す様である。
    | builtin trap -- WINCH していると sig.c sigwinch_sighandler が呼び出されない。
    | 何も実行していないと呼び出される。他に検索してみたが直接に trap handler を
    | 設定している箇所は見つからなかった。だとすると普通の siginal の一つとして
    | signal handler が登録されているという事になる。本当だろうか??
    | signal 関数の呼び出しを検索してみると readline の他には sig.c しか存在しない。
    | 結局 set_signal_handler 関数で全て設定しているという事だろうか。
    |
    | 実装を見るとどうも sigaction という sycall を使っている。
    | 直接に signal を使っているという訳ではない様である。
    | 一応、実際にこの関数が本当に呼び出されているか確認する。
    | →何と物凄い勢いで呼び出されている。SIGWINCH だけを拾う。
    | →調べてみると fork する度に呼び出されている様である。
    |   サブシェルの起動時にも呼び出されている。
    |   これだと余り参考にならない気がする。
    |
    | うーん。0x480040 というアドレスの関数を設定している。
    | それ以外の関数は設定していない様だ。
    | そしてこの 0x480040 とは何だろう。
    | どうやら sigwinch_sighandler の様である。
    | 然しこれは呼び出されていなかった筈である。
    |
    | どうやら trap_handler が登録されてはいるけれども、
    | サブシェルを起動する時にはそれをキャンセルする為に
    | sigwinch_sighandler が登録されているということの様である。
    |
    | | なのでここで観察するべきは trap_handler の方である気がする。
    | | 調べてみると変な状態になった後でもちゃんと trap_handler は起動されている。
    | | という事はその後の処理の流れが変だという事になる。
    | | trap_handler の中では実はシグナルハンドラは処理しない。
    | | 単に pending_traps 配列に情報を記録するだけである。
    | | interrupt_immediately は試した範囲では 0 である。
    | | すると run_pending_traps の中で何か変な事が起こっている?
    | |
    | | run_pending_traps が呼ばれるタイミングを調べようとしたが呼び出されない。。。
    | | 一度 run_pending_traps が呼び出されれば大量に run_pending_traps が呼び出される。
    | | 然し、trap -- を実行した後だと何も実行されない。不思議である。
    | | run_pending_traps の呼び出し元は沢山ある。builtin trap を実行すると
    | | 何処かの呼び出し元で何かが変化するという事。
    | |
    | | run_pending_trapsの振る舞いを調べる必要がある。
    | | 正常に動作している時に run_pending_traps が一回だけ処理される。
    | | 呼び出し元は check_signals_and_traps で更に
    | | 呼び出し元は bash_event_hook である。
    | | この関数は実は rl_signal_event_hook に対して関数ポインタとして設定される。
    | | 有効・無効が bashline_{set,reset}_event_hook で切り替えられる様になっている。
    | |
    | | 振る舞いを見ると以下の様になっている。
    | |
    | |   - trap_handler
    | |     - bashline_set_event_hook
    | |     - (interrupt が設定されていないので
    | |       その場では run_pending_traps は実行しない)
    | |   - _rl_signal_handler
    | |     - bashline_reset_event_hook
    | |     - bash_event_hook
    | |       - check_signals_and_traps
    | |         - run_pending_traps
    | |
    | | bashline_{set,reset}_event_hook は毎回設定・解除する様である。
    | | 一方で builtin trap した場合にも bashline_set_event_hook が呼び出されている。
    | | 2回目以降には呼び出される事は無いようである。
    | |
    | | そして、問題が起こっている時にはそもそも
    | | _rl_signal_handler も呼び出されない様だ。
    | | RL_CHECK_SIGNALS というマクロの中で呼び出されている。
    | | そしてこのマクロは色々なところから呼び出されている。
    | | 取り敢えず一番怪しい signals.c から見る。
    | | rl_check_signals という関数から呼び出されている。
    | | 然しこの関数は誰も使っていない様に見える。
    | | RL_CHECK_SIGNALS マクロ自体に __FILE__, __LINE__ を出力する様に細工を入れた。
    | | 結果として呼び出し元は input.c:625 である様だ。
    | |
    | | _rl_caught_signal と errno == EINTR をチェックしている。
    | |
    | | 漸く違いを見つけた。getc で EINTR を受け取った時に、
    | | 問題が発生していない時には _rl_caught_signal = 28 (WINCH) なのに、
    | | 問題が起こっている時には _rl_caught_signal = 0 になっている。
    | | これを強制的に 28 に書き換えたらどうなるだろうか。
    | | →うーん。一段階深くまで行くようにはなったが結局止まっている。
    | | bashline_set_event_hook が呼び出されていないからの気がする。
    | |
    | | 先に bashline_set_event_hook の呼び出し箇所について確認するのが良い気がする。
    | | 確認すると trap_handler の中に説明が書かれている。
    | | EINTR で反応をする事ができる、とその様に書かれている。
    | | 此処で bashline_set_event_hook を呼び出している。
    | | その様にする条件は RL_ISSTATE (RL_STATE_SIGHANDLER) だそうである。
    | | これは何だろうか。
    | | #define RL_ISSTATE(x) (rl_readline_state & (x)) のように定義されている。
    | | rl_readline_state の状態が異なるという事なのだろう。
    | | 実際に rl_readline_state を出力してみると 4800e が 4000e に変化している。
    | | この 8 というのが丁度 している。
    | | その様にする条件は RL_STATE_SIGHANDLER なのだろう。
    | | ではこの RL_STATE_SIGHANDLER というのは何処で設定or解除されるのか?
    |
    | ここで問題が2種類ある (1) SIGWINCH までは受信している。
    | しかし trap handler が何故か実行されない。(2) COLUMNS が更新されない。
    | それぞれ何故なのだろうか。
    |
    | うーん。どうやらやはり rl_sigwinch_handler が呼び出されるか
    | trap_handler が呼び出されるかの違いらしい?
    | 両方とも trap_handler が呼び出されている様に見えたが、
    | 実際には通常時は rl_sigwinch_handler 経由で trap_handler が呼び出されて、
    | それ以外の場合には rl_sigwinch_handler が呼び出されるという仕組みになっている様だ。
    |
    | そして builtin trap を実行すると sigwinch_handler が消滅する。
    | 何らかのタイミングで再度設置されるというだけの様な気がする。
    |
    | うーん。sig.c の set_signal_handler を見る限りでは trap_handler しか設定していない。
    | 実は他に rl_set_sighandler という関数が存在して其処で rl_sigwinch_handler が設定される様だ。
    | また、普通の readline 環境で builtin trap -- WINCH を実行するとこの
    | trap_handler の呼び出しと rl_set_sighandler の呼び出しが両方実行される。
    |
    | [set_signal_handler (sig.c)] SIGWINCH trap_handler (25353)
    | [rl_set_sighandler (signals.c)] SIGWINCH rl_sigwinch_handler (25353)
    |
    | $ builtin trap -- 'ble-edit/attach/TRAPWINCH' WINCH; sleep 5
    | を実行してみて判明したのは rl_set_sighandler は builtin trap に対して発生しているのではなくて、
    | readline に制御が戻ってきた時に改めて設定する物である様だ。
    |
    | うーん。rl_maybe_set_sighandler という関数から呼び出されていて、
    | この関数自体は普通の readline で毎回コマンドを呼び出す度に呼び出される。
    | そしてこの関数は rl_set_signals という関数から呼び出される。
    |
    | rl_set_signals という関数がコマンドを呼び出す度に呼び出されるという事の様だ。
    | 然し不思議なのは ble/term/enter, leave を実行すると回復するという事である。何故?
    | 実は WINCH は呼び出されていないけれども何らかの理由で COLUMNS, LINES が更新されるという事だろう。
    | →実際に WINCH handler が呼び出されていないという事を確認した。

    今までに分かった Bash の振る舞いについて以下にまとめる。

    1. builtin trap は trap_handler という関数を登録する。
      これは SIGWINCH に対しても同様である。

    2. readline はユーザがコマンドを実行し終わったタイミングで
      rl_set_signals - rl_maybe_set_sighandler - rl_set_sighandler(SIGWINCH) として、
      rl_sigwinch_handler を SIGWINCH に登録し直す。
      この rl_sigwinch_handler が COLUMNS, LINES を更新してくれるのである。
      そして元々登録されていた関数も呼び出してくれる。

    然し、ble.sh では bind -x でユーザのコマンドを処理しているので、
    readline の rl_set_signals が呼び出される機会がない。
    そうすると壊れたままという事になる。

    # * なので PROMPT_COMMAND で attach したとしても解決はしない。
    #
    # * ble-detach してから ble-attach すると問題が解決して見えたのは、
    #   単に readline としてコマンドを実行したからであった。
    #   つまり、コマンドであれば何でも良かった。
    #
    # * ble/term/enter, leave で解決した様に見えたのも少し違った。
    #   ble/term/enter, leave を実行すると stty が呼び出されて
    #   その場で COLUMNS, LINES は修正されるが、
    #   実はもう一度 winsize を変更するとまた変な状態になる。
    #   これは一時的に COLUMNS の状態が正しくなるというだけで、
    #   trap 関連で変な状態になっているというのを修正する事にはなっていない。
    #
    # ? ok: suppress をしていないと問題が起こらないのは何故か。
    #   →問題が起こっていない様に見えたのは勘違いだった。
    #   今試してみると suppress しない場合でもちゃんと問題が発生している。
    #
    # * Cygwin で bash-4.2 以降でも問題が起こっている原因は分からない。
    #   Cygwin ではまた別のタイミングで rl_set_signals 等を実行しているのかもしれない。
    #   或いは、単に trap_handler が別の理由で中断しているというだけかもしれない。
    #   これはまた別の機会に考える事にする。
    #
    # ? 保留: bashline_set_event_hook が builtin trap で呼び出されているのは何故か。
    #   これについては未だ調べていないが、全体について大体分かったし、
    #   この部分は余り関係無さそうなので今は調べなくて良い。


    ここで考えるべき事は何か。

    a rl_set_signals を誘起する別の手法について考える。
    b builtin trap を二度としない様にする。

    b の方が現実的かもしれない。が、ble-update で違う値になる場合に為る時は
    もう一度実行せざるを得ない。しかし、そういう事はめったに起きないし、
    そもそもこの問題はそんなに大きな問題ではない。一時的に表示が乱れる程度なのだ。
    という事を考えると、取り敢えずは b の方で良い気がする。

    * [棄却] rl_set_signals を誘起させる方法について
      少し試してみたがうまく行かないので諦める事にする。

      もし a が可能であればそちらの方が良いので少し確認しておく事にする。
      rl_reset_after_signal という関数が呼び出している。
      _rl_callback_newline, rl_callback_read_char という関数も特定の条件の元で呼び出している。
      後は readline 関数が一番最初の最初の初期化で呼び出している。
      可能性があるとすれば rl_reset_after_signal である。

      →然し、これが呼び出されるのは INT, TSTP, TTIN, TTOU, TERM, HUP, ALRM, QUIT である。
      例えば INT を上書きして invoke するというのもありなのかもしれない。
      試しに実装してみる事にする。

      TSTP, TTIN, TTOU, INT, TERM, HUP, QUIT, WINCH は全て再設定の対象の様である。
      という事は INT を上書きするのも問題が発生するという事。うーん。

      もっと具体的に見る事にする。rl_reset_after_signal は _rl_handle_signal から呼び出される。
      更にこれは _rl_signal_handler から呼び出される。更に SIGHANDLER_RETURN から呼び出され、
      これは rl_signal_handler から呼び出される。つまり。rl_signal_handler が設定されている
      シグナルを使わなければならない。その場で trap すると trap_handler が設定されてしまうので、
      その様な handler をその場で生成する事はできない。とすれば。うーん。分からない。
      原理的にはどれか一つに何か無害な物が設定されていれば特に問題は起こらない筈。

      取り敢えず TSTP, TTIN, TTOU は特に何も起こらない様である。
      これらに特に何も設定されていなかったらそれを使うという事で良いのだろうか。
      取り敢えず試してみる事にする。
      →実際に試してみた所全く呼び出されない。どういう事だろう。
      何か trap に登録していないと駄目という事だろうか。

      # Induce "rl_reset_after_signal" to set up rlhook
      for sig in TTOU TERM QUIT; do
        ble/util/assign trap "builtin trap -p $sig" || continue
        [[ ! $trap ]] || continue
        kill -"$sig" "$$"
        return 0
      done

      うーん。駄目だ。動かない。諦める事にする。

      調べてみると TTOU に確かにハンドラが設定されている気がするが実際には呼び出されない。
      もっと別の仕組みによってもみ消されているのか、或いは、
      単に別の場所で handler が上書きされてしまっているのか。
      どうしたら上書きされているか分かるだろうか。
      signal を2回呼び出す? 或いはもしそもそも全く呼び出されないのだとすれば。
      signal SIG_DFL を呼び出して中身を出力して抜ければ良い気もする。

      うーん。やはり呼び出されない。そして TTOU を再設定する時に確認したが、
      やはり rl_signal_handler が設定されている。別のものは設定されていない。
      どうも自分で kill を呼び出すと何も起こらない様だ。
      子プロセスから呼び出しても何も起こらない。
      別の通信方法を使っているとしても不思議である。
      時間の無駄なので深追いするのはやめる事にする。

2020-04-26

  * bash-completion が有効になっていない→ PS1= の影響だった [#D1344]
    何かと思っていたが、分かった。
    bash-completion は PS1='' かどうかで対話シェルかどうかを判定している。
    本来対話シェルかどうかの判定には $- を使うべきである。

    * bash-completion が何故 PS1 を使っているのか

      良く分からない。

      * bash の振る舞い
        動作を調べてみると (PS1= bash) として起動すると PS1 は空になる。
        (unset -v PS1; bash) として起動すると PS1 にはデフォルト値が設定される。
        bash-1.14 の時点でその様に振る舞っている。
        然し、bash-completion はその様に実装されていない気がする。

        また $- についても bash-1.14 の時点でちゃんと i を含んでいる。

        うーん。改めてソースコードを見ると shellcheck=sh としているので、
        その他のシェルの場合を考慮に入れていると解釈できる。
        BASH_VERSION をチェックしている時点で bash と確定しているので、
        $- を使わない理由は "${-%%i*}" != "$-" が構文エラーになる処理系があるという事か。
        少なくとも dash は対応している。

      * The Bourne sh で試してみたら ${var%i*} に対応していない様だ。
        結局 $- に i が含まれているかどうかを判定する為には case..esac が必要という事?
        →と思ったが [ -n "$BASH_VERSION" ] && [ $- == ${-%i*} ] で普通に動いている。

      多分、the Bourne sh などどのシェルでもエラーにならなくて、
      簡単で分かりやすいからである。

    何れにしても PS1 を使って対話環境かどうかを判定しているスクリプトは他にもありそうである。

    a という事を考えると PS1= の上書きはしない様にしても良いのかもしれない。
      元々 PS1= にしているのは Bash の出力を抑制する為だった。
      然し、現在の stdout.on, off を実装してからは実は必要ないはず。

      記録を辿ったが PS1= にする理由については殆ど書かれていない。
      一番最初のメモである #D0002 によると C-d を受け取る為に必要らしい。
      当初は stty を実行していなかったからそれと関係するかもしれない。
      現在は stty で調整しているが bash-3.2 ではそれも動かない。

      取り敢えず bash-3.2 で PS1= にしなくても動くか確認する。
      →問題なく動いている。internal_suppress_bash_output を有効にしていない
      時に PS1 が空になって設定が誤作動するのは仕方がない。
      そもそも internal_suppress_bash_output はデバグ用の設定だから気にしなくて良い。

    b 或いは或る程度はシェルの状態を復元して ble-import する方が良いのかもしれないと考えたが、
      ble-import の中で実行している以上は set -e だとかのユーザ環境に対して適用する
      事を意図した様な設定は off にしておきたい気もする。

      飽くまで ble-import は blesh 空間で実行するという仕様という事にする。
      但し PS1 等の変数は多くのスクリプトが使う物という事で空欄にするのはやめる。

    取り敢えず a の方針で変更した。

    結局これは外部のスクリプトを ble-import で初期化した時に起こる問題なので
    影響範囲は少ないだろう。唯一 fzf は ble-import で読み取る設定を紹介しているが、
    fzf は $- を使って判定していた筈なので影響はないのである。

  * OK: preexec の振る舞いについての調査 [#D1343]
    preexec は全てのコマンドの前に実行する物なのか、
    或いは、ユーザコマンドの開始前に実行する物なのか。
    zsh での振る舞いと bash-exec での振る舞いを調べる必要がある。

    * zsh で試してみた所、ユーザのコマンドを実行しようとした時に実行される。
      各コマンドの前で毎回実行するという事はない。

      % autoload -Uz add-zsh-hook
      % preexec_func1() { echo "[$LINENO]"; }
      % add-zsh-hook preexec preexec_func1
      % echo
      % for i in {0..10}; do echo hello; done

    * 一方で Bash の DEBUG は全てのコマンドの前に実行される。
      特に "for i in {0..10}" という部分に対しても毎回呼び出される様だ。

      $ trap 'echo "[DEBUG] $BASH_COMMAND"' DEBUG
      [DEBUG]
      $ for i in {0..10}; do echo hello; done
      [DEBUG] for i in {0..10}
      [DEBUG] echo hello
      hello
      ...

    * bash-preexec はどうだろうか。試してみた所、
      ちゃんとユーザコマンドの実行前に一回だけ実行される。

      $ bash --norc
      $ . bash-preexec.sh
      $ preexec() { echo "[preexec] $BASH_COMMAND"; }
      $ echo hello
      [preexec] echo hello
      hello
      $ for i in {0..10}; do echo hello; done
      [preexec] for i in {0..10}
      hello
      hello
      ...

    従って、現状の動作で問題ない。

2020-04-24

  * [棄却] LC_ALL= LC_COLLATE=C 等の指定をしているが、 [#D1342]
    もしユーザーが LC_ALL に自分の言語情報を指定していた時にはどうなるのか。
    そういう事を考えると LANG に LC_ALL:LANG から導出した値を指定する必要があるのではないか。

    うーん。然し勝手に LC_ALL を空にしてそれから LANG に値を設定すると、
    LC_ALL で上書きしていた他の locale (LC_CTYPE) は一体どうなるのだろうか。
    例えば LC_CTYPE を LC_ALL で上書きしていたとする。
    ここで LC_ALL をクリアしてそれを LANG に設定したとする。
    LANG よりも LC_CTYPE の方が優先される事から、
    上書きされていた筈の LC_CTYPE が有効になってしまう。

    x そういう事を考えると完全に対応する為には
      全ての locale 項目に対して値を再計算する必要がある。非効率である。
    x 更に locale 項目に値を設定する度に内部で locale の構築が行われる。
      locale の構築はファイルの読み取りなども発生し重い処理になるので、
      できるだけ少なくしたい。
    x 更に、ユーザが LC_CTYPE などを指定したとしてもそれが有効になってはならない。
      LC_ALL で強制している筈だからである。
      然し個別に locale を指定する場合にその振る舞いは再現できない。

    などなどという事を考えるとユーザが指定した LC_ALL の効果を正しく保持するというのは難しい。
    飽くまで LC_ALL は特別な場合の回避方法であるという事を考えると、
    ble.sh の特別の関数の中では LC_ALL の効果がなかった事にしても良い様に思う。

  * util: LANG=en_US.utf8 の時の bash-3.2 の振る舞いが変である [#D1341]
    ref memo/D1341.locale-and-casematch.sh

    c2s のテストで見つかった。ble/string#toupper で問題が発生していた。
    調べると LC_ALL= LC_COLLATE=C func と指定しても bash-4.1 以下では効果が出ない。

      local LC_ALL= LC_COLLATE=C
      func

    等の様にして実行しないと駄目の様である。

    LC_ALL= LC_CTYPE=C については大丈夫なのだろうか。
    と思って試すと大丈夫に見えたが良く見たら既に対策されていた。
    つまりこの問題は或る意味で既知の問題だったのである。

  * test: ble.sh --test でテストを実行する? [#D1340]
    interactive session に入らずに色々実行する機能?

    * というより複数の bash version でテストする機能も作りたい気がする。
      然し、毎回全ての version でテストするのも大変である。
      →と思ったがユーザの環境によって異なるし、

      呼び出す時には結局何れかの version の bash から
      更に様々な bash の version に ble.sh を読み込ませなければならない。
      親の bash では実は ble.sh を読み込む必要は全く無い。
      という事を考えると、実は make_command.sh 辺りに実装するべきなのではないか。

      m check には既にソースコードのパターン検出によるチェックがある。
      然し、m check と言えば普通はテストである。
      現在の check は別の名前に変更したい。名前は何が良いか。
      lint という程でもないし、check-pattern は長い。
      check-all で全部チェックするというのでも良いのかもしれない。

      うーん。取り敢えず scan という事にする。

    * test を実行する時に version を表示したい。
      表示する様に変更した。

2020-04-19

  * 後、READLINE_MARK に対応したがちゃんと範囲チェックを忘れていないか確認する [#D1339]
    →確認した所、これについては READLINE_POINT ですらチェックしていなかった。
    チェックする様に修正した。

  * PROMPT_COMMANDS の判定を declare -p で行っているが、 [#D1338]
    これだと "配列として宣言したが unset である" という状況で
    PROMPT_COMMAND に fallback しないという問題があるのではないか。
    というより bash ではどの様に振る舞っているか確認する必要がある。
    →bash-dev で振る舞いを確認した所、配列要素が 1 つ以上あるかどうかで決まっている様だ。

    →然し bash-3.2 以下では declare a123 としただけで要素が 1 になってしまう。
    という事を考えると set/unset も一緒に使って判定するのが良い?
    と思ったが a123[1]=hello 等の時に判定できなくなってしまう。
    或いは declare a123 は a123=('') と等価なのだからその様に取り扱うというので良い気もする。
    というか本質的に declare a123 は declare a123= と等価なので区別してはならない。OK

  * ble-stackdump の開始フレームがずれている [#D1337]
    ble/util/stackdump という内部実装に分けた為である。
    分ける必要があっただろうか。或いは、開始フレームを外から変更できる様にする?
    後、BASH_LINENO の参照を誤っている。取り敢えず修正した。

  * syntax: 変数展開で bash-5.1 で UuLK という operator が追加されている [#D1336]
    というより、bash-4.3 では operator は無効にするべきでは。
    →確かめてみた所ちゃんとその様な実装になっていた。

2020-04-16

  * fzf で複数行モードに入ってしまうという報告 (reported by Brendonk13) [#D1335]
    https://github.com/akinomyoga/ble.sh/issues/49

    もっと再現を簡単になるまで絞ってから報告して欲しい。
    fzf を入れた。再現しない。bfs を今度は入れる必要がある。
    或いは find でも再現するかどうか事前に確かめるべきなのではないか。
    というか FZF_ALT_C_COMMAND の中に tr -d だとか C-j だとか記入している時点でおかしい。
    確認してみると始めての issue 報告という事である。初心者である。
    初めての issue 報告をする人というのは結構いるようである。

    bfs を入れようとしたがコンパイルできない。
    README を参照したが各 distribution のパッケージが並んでいるだけで
    実際のコンパイル方法は make しか書かれていない。
    必要なライブラリが -lacl -lcap -lattr である。
    検索すると libacl libcap libattr で入りそうである。
    駄目だった。全て元から入っていた。
    sudo dnf install lib{acl,cap,attr}-devel としたら入った。

    取り敢えず動作は確認した。然し問題は発生していない。
    どうやらディレクトリ名を選択させて cd を実行する様だ。
    予想できるのは fzf は "cd ディレクトリ名" を入力して
    続いて決定を押しているのだろうという事。
    というか、これは bfs は関係ないのでは。

    さて、現在再現しないのは ble.sh に特別に調整した
    key-binding を実行しているからである。
    普通の fzf の bind でどう動作するのか確認する必要がある。
    うーん。fzf の設定 .fzf.bash を dotfiles に追加してしまうか。
    或いは ble.sh のディレクトリに追加してしまうというのも手である。
    何しろ ble.sh の対応の為に追加した物なのだから。

    →特別の調整を外したら再現した。絞り込みに入る。
    先ず bfs を外す。bfs の設定がなくても再現した。
    fzf の key-bindings.bash を確認すると以下の様になっている。
    確かに C-m の後に沢山の文字列が設定されている。
    恐らくこれは編集文字列とカーソル位置を保存して
    それからカーソル位置を復元する為の物であろう。
    bind -m emacs-standard '"\ec": " \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d"'


    [contrib を整備する]

    うーん。毎回この様に説明を書くのは面倒である。

    a reject: 一つの方法は fzf に修正を入れてもらうという事。
      然し、こちらは 115 star の小さなライブラリである。
      一方であちらは 28.5k star の巨大なリポジトリである。
      このような小さなライブラリの要求をいちいち飲んでいたら大変である。
      という訳でどう考えても PR を出しても対応してくれるとは思えない。
      幾らインターフェイスが綺麗だとしても。

      もし可能性があるとしたら key-bindings.blesh 等のようなファイルを作るのが良いか。
      然し、そうすると同じ bash でも .fzf.bash と .fzf.blesh を使い分ける必要が出てくる。
      それよりは key-bindings.bash の中で自動的に振り分ける方が良いのではないか。

    b もう一つの方法は ble.sh で ble-import -d lib/fzf-key-bindings とできる様にする事。
      この方法の問題点は fzf の場所を事前に指定する必要があるという事。
      一番簡単なのは .fzf.bash を source するという事。
      然しそうすると結局 fzf の変な key-bindings が登録されてしまう。

      或いは "fzf" だけインストールしてもらって、
      fzf のパスから辿るという方法。これはユーザに特別の指定をしてもらう必要がある。

    c reject: 或いは .fzf.bash -> fzf/shell/key-bindings.bash を検出して、
      その中で実行される bind は自動的に無効にして、
      代わりに blesh の特別の binding をその場で実行するという方針?

      これは何が問題かというといざユーザが key-bindings.bash を編集しても反映されないという事。
      更にユーザが何が起こっているのか理解するのに時間がかかるという事。
      というか何が起こっているのかを解明するのは物凄く難しいという気がする。
      これはかなり大変な書き換えである。

    d 或いは、.fzf.bash の中で source "..." となっている部分を自分で書き換えてもらう。
      然し、沢山設定を書くのは面倒なので設定に関しては以下のファイルを用意する。

      lib/fzf-key-bindings.sh
      lib/fzf-completions.sh
      lib/fzf-git.sh

    まあ、これぐらいが妥当な気がする。然し、問題はどうやって _fzf_base を伝えるかという事。
    .fzf.bash にこれを設定する項目はあるだろうか→うーん。無いような気がする。
    結局何かは source しなければならない。まあ、自分で source すれば良いという気がする。

    うーん。contrib というディレクトリでも作る事にしようか。
    或いは、blesh-contrib というリポジトリを作る事にする?
    そうした方が他の人が設定を追加しやすくなるという気がするのである。
    contrib の中に theme 等のサブディレクトリを更に作る?
    或いは単に contrib/theme-*.sh 等の様にするか。
    その方が良い気がする。
    blesh-contrib というリポジトリを作成する事に決めた。

    * 作成した設定をテストする。

    * ble.sh からどの様にリンクするのが良いだろうか。

      # さて、問題はどの様に git submodule を追加するかという事。
      # 相対パスで設定できるという話だった気がする。
      # うーん。該当する記事が見つからないが試してみる事にする。
      # と思ったら空の repository は追加できないそうだ。
      # 仕方がないので取り敢えず簡単な内容で作成する。

      submodule contrib を使う?
      というより他に思い浮かばない。
      或いは、別 repository として管理するのは OK としても
      明示的に link はしないという様にする?
      だとしても結局何処かで download しなければならないのだから、
      submodule を使ってしまっても問題ないという気がするのである。

      x ok: submodule を使った時の問題は同期が面倒という事。
        然し、install 先に直接 repository を作成するとしても同期が面倒なのは変わりない。
        寧ろその方が ble-update 等の処理が複雑になって面倒である。
        という事を考えると、やはり中で submodule を管理するのが良い。

      * submodule の同期をする必要があるという観点に関しては、
        contrib/.git が存在しない時には
        git submodule update --init --recursive を make の中で呼び出せば良い。
        ble-update に対してもこれを実行する。

    * done: 試しに相対パスでもちゃんと GitHub から同期できるか確認した。
      →できた。これで大丈夫。

    * done: Makefile の設定も行った。
      2回実行しなければならない気がするが、まあ大丈夫だろう。
      と思ったが make して out/ble.sh を source している場合は微妙。

    * done: ble-update で更新する様にする。これは pull --recursive で良いのでは。
      と思ったが実際にそういう物はあるのだろうか。
      $ git pull --recurse-submodules という物があるらしいが、
      これを実行すると .gitmodules を書き換えて最新の物に更新してしまうらしい。
      という事で必要なのは以下のコマンドの様である。
      $ git submodule update --recursive --remote
      --remote の意味はよく分からない。うーん。--help で観察すると、
      sha1 hash ではなくて branch に基づいて同期する様である。
      考え直してみるとその方が都合が良い。という訳で取り敢えずこれを使う事にする。
      不整合が起こるのではないかという心配もあるが、まあ使ってみて問題が起こってから考える。

    * done: 次に追加した fzf-*.sh がちゃんと動くかをテストする必要がある。
      動作確認した。

    * done: 次は contrib の README に説明を書く事にする。説明を書いた。

  * resize で hang するとの事 (reported by killermoehre) [#D1334]
    https://github.com/akinomyoga/ble.sh/issues/48

    PS1 について尋ねたら以下の結果になった。

    > ^A^[]133;D;0^G^B^A^[]0;cXXXXXXX@apfelkuchen:~^G^B^A^[]133;A^G^B$ ^A^[]133;B^G^B

    これは以下の設定に対応する。

    PS1='\[\e]133;D;0\a\]\[\e]0;cXXXXXXX@apfelkuchen:~\a\]\[\e]133;A\a\]$ \[\e]133;B\a\]'

    | Additional questions.
    |
    | **Question 3**: Does the problem reproduce with `PROMPT_COMMAND=''`?
    | For example, please add the line `PROMPT_COMMAND=` before the line of
    | `ble-attach` in `.bashrc` as follows:
    |
    | ```bash
    | # bashrc
    |
    | [[ $- == *i* ]] && source /path/to/blesh/ble.sh --noattach
    |
    | # ...
    |
    | PROMPT_COMMAND= # <-- This line
    | ((_ble_bash)) && ble-attach
    | ```
    |
    | **Question 4**: Does the problem reproduce with `source ble.sh` in
    | interactive sessions? To try this, please follow the following steps:
    |
    | 1. Open terminal
    | 2. Type the following commands
    |
    | ```bash
    | $ bash --norc
    | $ PS1='\$ '
    | $ PROMPT_COMMAND=
    | $ source /path/to/ble.sh
    | ```
    |
    | 3. Resize before input anything
    |
    |
    |  --attach=attach
    |
    | $ trap 'ble-stackdump > /dev/tty' USR1


    再現できたので原因を解明する。
    結局、read -r aaa bbb を builtin read -r aaa bbb に変更したら動く様になった。
    或いは以下の変更で治る。おかしい。これは bash のバグなのではあるまいか。

    | +++ b/src/edit.sh
    | @@ -6998,8 +6998,8 @@ function ble/builtin/read {
    |    [[ $__ble_command ]] || return "$__ble_ext"
    |
    |    # 局所変数により被覆されないように外側で評価
    | -  builtin eval -- "$__ble_command"
    | -  return
    | +  builtin eval -- "$__ble_command"; local ext=$?
    | +  return "$ext"
    |  }
    |  function read { ble/builtin/read "$@"; }

    return "$ext" の代わりに 'ble/util/setexit "$ext"; return' としても問題が発生する。
    %または return を完全に削除しても問題が発生する
    →勘違いだった。return を実行した場合には問題は発生しない。
    他の version でも発生するのかを確かめてみた。

    [Bash 用最小再現コード]

    Bash のバグの可能性があるので Bash だけで再現できるか試みる。

    | bash-4.4 でも再現する。
    |
    | * bash-4.3 だと別のエラーが発生する。
    |   このエラーは iterm2 を読み込まない場合には発生していない気がする。
    |
    |   $ bash-4.3: history: 書き込みエラー: Broken pipe
    |   bash-4.3: history: 書き込みエラー: Broken pipe
    |   Segmentation fault (コアダンプ)
    |
    |   うーん。これは何だろうか。iterm2 の読み込みと関係がある?
    |   不思議である。history がどう関係してくるのか謎である。
    |   一応 __bp_preexec_invoke_exec が history を内部で呼び出している様だが、
    |   実際にこれが問題の原因なのかどうかについては不明である。
    |
    | * bash-4.2 では問題は発生しない。
    |   bash-4.0 でも問題は発生しない。
    |
    | * ok: bash-3.2 だと変なエラーが発生して無限ループする。
    |   これは precmd の問題の気がする。
    |
    |   | bash-3.2: branch.ab: syntax error: invalid arithmetic operator (error token is ".ab")
    |   | bash-3.2: branch.ab: syntax error: invalid arithmetic operator (error token is ".ab")
    |   | bash-3.2: branch.ab: syntax error: invalid arithmetic operator (error token is ".ab")
    |   |
    |   | stackdump は以下の通り
    |   | @ iterm2_shell_integration_local.sh:13 (iterm2_print_user_vars)
    |   | @ iterm2_shell_integration.sh:374 (iterm2_print_state_data)
    |   | @ iterm2_shell_integration.sh:-8 (__iterm2_precmd)
    |   | @ iterm2_shell_integration.sh:-471 (__bp_precmd_invoke_cmd)
    |   | ...
    |   | @ iterm2_shell_integration_local.sh:13 (iterm2_print_user_vars)
    |   | @ iterm2_shell_integration.sh:374 (iterm2_print_state_data)
    |   | @ iterm2_shell_integration.sh:-8 (__iterm2_precmd)
    |   | @ iterm2_shell_integration.sh:-471 (__bp_precmd_invoke_cmd)
    |   | @ iterm2_shell_integration.sh:-16230 (__bp_install)
    |   | @ /home/murase/.local/share/blesh/ble.sh:7 (ble-edit/prompt/update/.eval-prompt_command.1)
    |   | @ /home/murase/.local/share/blesh/ble.sh:-429 (ble-edit/prompt/update/.eval-prompt_command)
    |   | @ /home/murase/.local/share/blesh/ble.sh:33 (ble-edit/prompt/update)
    |   | @ /home/murase/.local/share/blesh/ble.sh:308 (ble/textarea#render)
    |   | @ /home/murase/.local/share/blesh/ble.sh:14091 (ble/textarea#redraw)
    |   | @ /home/murase/.local/share/blesh/ble.sh:3 (ble-attach)
    |   | @ zzz-attach-ble.sh:28 (source)
    |   | @ .bashrc:0 (source)
    |
    |   iterm2_print_user_vars の中を調べると確かに branch.ab という文字列が使われている。
    |   連想配列は bash 3.2 で存在しないのでそれが原因で問題が起きているのだろう。
    |   然し、__bp_precmd_invoke_cmd は呼び出されていない。
    |   よく考えたら bp_precmd は trap DEBUG を使っている。
    |   つまり、branch.ab によって構文エラーが発生して DEBUG か何かが発生し、
    |   その結果として無限ループが発生しているという事だろうか。
    |   まあ、bash3.2 に関しては考えない事にする。
    |
    | 取り敢えず最小再現を作成する事にする。
    | 恐らく WINCH の中では return が思うように動かないという事?
    |
    | $ function f1 { false; return; }; function f2 { f1; }
    | $ trap 'while f1; do echo hello; break; done' WINCH

    再現した。最小化する。

    $ f1() { false; return; }; trap 'f1; echo exit=$?' WINCH

    実は別のシグナルでも問題ないのではないか。

    $ f1() { false; return; }; trap 'f1; echo exit=$?' USR1; kill -USR1 0

    うーん。もしこれが Bash のバグだとしても、Bash 4.4, 5.0 が世の中に現れてしまった以上は、
    これに対する対策を ble.sh の側で実行する必要がある。もしくは、return を上書きするか…。
    と思ったが return を関数で上書きすると setexit と同じ意味になってしまって、
    元々の return の意味を失ってしまうので駄目である。という訳でやはり return を
    修正しなければならないのであった。

    取り敢えず行末にある return を全て修正していく事にする。
    修正した。これで恐らく全ての return に明示的に終了ステータスが指定されている。

2020-04-14

  * 2020-01-23 stackdump [#D1333]

    以下の様な内容。再現しない。編集手順を記録する? 後、その場で ble_debug=1 にする機能が欲しい。

    | echo 1 2 3 4 5 8 9 10 | ( read numbers; set -- $numbers; i=0 i1=0; for n; do if ((n!=i)); then if ((i==i0)); then echo $i0-$i; ; ((i++)); done )
    |
    | ble/syntax/tree-enumerate/.initialize/FATAL1
    |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:26 (ble/util/assert)
    |   @ /home/murase/.mwg/src/ble.sh/out/lib/core-syntax.sh:4 (ble/syntax/tree-enumerate/.initialize)
    |   @ /home/murase/.mwg/src/ble.sh/out/lib/core-syntax.sh:6 (ble/syntax/tree-enumerate)
    |   @ /home/murase/.mwg/src/ble.sh/out/lib/core-syntax.sh:6 (ble/syntax/parse/shift.method2)
    |   @ /home/murase/.mwg/src/ble.sh/out/lib/core-syntax.sh:19 (ble/syntax/parse/shift)
    |   @ /home/murase/.mwg/src/ble.sh/out/lib/core-syntax.sh:7 (ble/syntax/parse)
    |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:73 (ble-edit/content/update-syntax)
    |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:3 (ble/textarea#render)
    |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:16 (ble-edit/bind/.tail)
    |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:50 (ble-decode/EPILOGUE)
    |
    | 取り敢えず f11 で ble_debug を toggle して f12 で編集履歴を出力する様にした @ blerc
    | 本質的にはそんなに複雑な構造はしていないのだからすぐに再現しそうな気がしたが再現しない。
    | 或いは一時的な物で既に直ってしまった可能性もなくはない。
    | echo 1 | ( echo; for n; do if ((n!=i)); then if ((i==i0)); then echo $i0-$i; ; ((i++)); done )

    [再現] 2020-04-14 再現した。

    | echo {1..9}|(read numbers;set -- $numbers;i=0;i0=0;for n;do if((n!=i));then echo $i0-$i;i=$n;done)
    |
    | ble_debug 構造を入手した。然し何処から手をつけたら良いのか分からない。
    | 取り敢えず diff を取ってみる事にする。本質的な違いは以下の様になる。
    |
    | --- D0000.a.expected-1.txt^I2020-04-14 11:57:31.268375794 +0900
    | +++ D0000.a.error-1.txt^I2020-04-14 12:01:30.567636568 +0900
    | @@ -86,24 +86,21 @@
    |  14 a    083 '$' || stat=(ARGX w=- n=@14 t=$82:$11)
    |   7 a    084 'i' ||
    |   | a    085 '0' ||
    | - 4 a    086 '-' || stat=(ARGI w=ARGX:83- n=@14 t=-:$82)
    | -14 a    087 '$' || stat=(ARGI w=ARGX:83- n=@14 t=-:$82)
    | + 4 a    086 '-' || stat=(ARGI w=ARGX:83- n=@24 t=-:$82)
    | +14 a    087 '$' || stat=(ARGI w=ARGX:83- n=@24 t=-:$82)
    |   7 a    088 'i' |+ word=ARGI:@81>83-89/(wattr=d)
    | -12 a    089 ';' |  stat=(ARGX w=- n=@14 t=$89:$11)
    | - 7 a    090 'i' || stat=(CMDX w=- n=@14 t=$89:$11)
    | +12 a    089 ';' |  stat=(ARGX w=- n=@24 t=$89:$24)
    | + 7 a    090 'i' || stat=(CMDX w=- n=@24 t=$89:$24)
    |   8 a    091 '=' ||
    | -14 a    092 '$' || stat=(VRHS w=_ble_attr_VAR:90- n=@14 t=-:$89)
    | +14 a    092 '$' || stat=(VRHS w=_ble_attr_VAR:90- n=@24 t=-:$89)
    |  26 a    093 'n' |+ word=_ble_attr_VAR:@88>90-94/(wattr=m2:d,$:d)
    | -12 a    094 ';' |  stat=(CMDXV w=- n=@14 t=$94:$11)
    | -19 a    095 'd' || stat=(CMDX w=- n=@14 t=$94:$11)
    | +12 a    094 ';' |  stat=(CMDXV w=- n=@24 t=$94:$24)
    | +19 a    095 'd' || stat=(CMDX w=- n=@24 t=$94:$24)
    |   | a    096 'o' ||
    |   | a    097 'n' ||
    |   | a    098 'e' |+ word=CMDI:@93>95-99/(wattr=d)
    | -12 a    099 ')' +  word="(":@10>14-100>@98 stat=(CMDXE w=- n=@14 t=$99:$11)
    | - |    s 100 ^@    stat=(CMDXE w=- n=- t=$100:-)
    | + 6 a e  099 ')'    stat=(CMDXE w=- n=@24 t=$99:$24)
    | + |      100 ^@    stat=(CMDXE w=- n=@24 t=$99:$24)
    |
    | 確認すると $i0-$i の - の時点で nest の座標がずれている。
    | どうも read numbers; set -- は関係ない気がする。
    | 編集履歴を dump する機能はあっただろうか。
    | この通りに編集したら再現するかどうかを先ず確認する必要がある。
    |
    | 13:echo {1..9} |
    | 16:echo {1..9} | ()
    | 22:echo {1..9} | (read --)
    | 21:echo {1..9} | (read -)
    | 20:echo {1..9} | (read )
    | 45:echo {1..9} | (read numbers; set -- $numbers;)
    | 28:echo {1..9} | (read numbers;set -- $numbers;)
    | 57:echo {1..9} | (read numbers;set -- $numbers;for n;do done)
    | 54:echo {1..9} | (read numbers;set -- $numbers;for n;do ;done)
    | 58:echo {1..9} | (read numbers;set -- $numbers;for n;do echo ;done)
    | 48:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do echo ;done)
    | 57:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do cho ;done)
    | 57:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do ho ;done)
    | 57:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do o ;done)
    | 57:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do  ;done)
    | 74:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==0));then\;done)
    | 73:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==0));then;done)
    | 72:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==0));the;done)
    | 71:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==0));th;done)
    | 70:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==0));t;done)
    | 69:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==0));;done)
    | 68:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==0));done)
    | 67:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==0);done)
    | 66:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==0;done)
    | 65:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==;done)
    | 69:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==n));;done)
    | 68:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==n));done)
    | 67:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==n);done)
    | 66:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==n;done)
    | 65:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i==;done)
    | 64:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i=;done)
    | 63:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((i;done)
    | 62:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ((;done)
    | 61:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if (;done)
    | 60:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if ;done)
    | 59:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if;done)
    | 63:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if(());done)
    | 65:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if((n==i));done)
    | 62:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if((n=i));done)
    | 63:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if((n!=i));done)
    | 80:echo {1..9} | (read numbers;set -- $numbers;i=0;for n;do if((n!=i));echo $i0-$i;done)
    | 53:echo {1..9} | (read numbers;set -- $numbers;i=0;i0=0;for n;do if((n!=i));echo $i0-$i;done)
    | 78:echo {1..9} | (read numbers;set -- $numbers;i=0;i0=0;for n;do if((n!=i));then echo $i0-$i;done)
    | 94:echo {1..9} | (read numbers;set -- $numbers;i=0;i0=0;for n;do if((n!=i));then echo $i0-$i;i=$n;done)
    | 56:echo {1..9} | (read numbers;set -- $numbers;i=0;i0=0;for if((n!=i));then echo $i0-$i;i=$n;done)
    |
    | 駄目だ。再現しない。微妙な操作の違いですぐに再現しなくなるという事か、
    | 或いは、より前の履歴編集によって種が仕込まれている必要があるのか、
    | もっと別の際限条件が存在するのか。文字列の挿入位置にも関係がありそう。
    | また、paste 等を実行すると incremental な解析にならずに一気に解析するので問題が起こらないという可能性も。
    |
    | 直感としては read/set の部分は関係ない気がする。for の辺りが怪しい。
    | 再現できた。だいぶ短くできた気がする。これは実は最初の :| も関係ないのでは。
    | 内部で ;; が発生すると起こる問題ではないだろうか。
    |
    | 4::|()
    | 18::|(:;for n;do done)
    | 15::|(:;for n;do ;done)
    | 9::|(:;i=0;for n;do ;done)
    | 34::|(:;i=0;for n;do if((i==0));then\;done)
    | 33::|(:;i=0;for n;do if((i==0));then;done)
    | 32::|(:;i=0;for n;do if((i==0));the;done)
    | 31::|(:;i=0;for n;do if((i==0));th;done)
    | 30::|(:;i=0;for n;do if((i==0));t;done)
    | 29::|(:;i=0;for n;do if((i==0));;done)
    | 28::|(:;i=0;for n;do if((i==0));done)
    | 27::|(:;i=0;for n;do if((i==0);done)
    | 26::|(:;i=0;for n;do if((i==0;done)
    | 25::|(:;i=0;for n;do if((i==;done)
    | 24::|(:;i=0;for n;do if((i=;done)
    | 23::|(:;i=0;for n;do if((i;done)
    | 22::|(:;i=0;for n;do if((;done)
    | 28::|(:;i=0;for n;do if((n!=i));done)
    | 41::|(:;i=0;for n;do if((n!=i));echo $i0-$i;done)
    | 14::|(:;i=0;i0=0;for n;do if((n!=i));echo $i0-$i;done)
    | 39::|(:;i=0;i0=0;for n;do if((n!=i));then echo $i0-$i;done)
    | 55::|(:;i=0;i0=0;for n;do if((n!=i));then echo $i0-$i;i=$n;done)
    |
    | 短縮した。
    |
    | 2:()
    | 16:(:;for n;do done)
    | 12:(:;for n;do;done)
    | 7:(:;i=0;for n;do;done)
    | 34:(:;i=0;for n;do if((i));echo $i-$j;done)
    | 11:(:;i=0;i=1;for n;do if((i));echo $i-$j;done)
    | 33:(:;i=0;i=1;for n;do if((i));then echo $i-$j;done)
    | 45:(:;i=0;i=1;for n;do if((i));then echo $i-$j;i;done)
    |
    | 実は直前の状態まで大丈夫だったのではないか?
    | と思って試してみたが駄目だった。やはり編集履歴が必要。
    | 2つ前から始めたら再現した。
    |
    | 44:(:;i=0;i=1;for n;do if((i));echo $i-$j;done)
    | 33:(:;i=0;i=1;for n;do if((i));then echo $i-$j;done)
    | 45:(:;i=0;i=1;for n;do if((i));then echo $i-$j;i;done)
    |
    | 初期状態を少しずつ小さくしてみる。
    |
    | (:;for n;do if((i));echo $i-$j;done)  再現する
    | (:;for n;do if((i));echo;done)        再現しない
    | (:;for n;do if((i));: $i;done)        再現しない
    | (:;for n;do if((i));: $i-$j;done)     再現する
    | (for n;do if((i));: $i-;done)         再現する
    | (if((i));: $i-;:)                     再現する
    | (:;$i-;:)                             再現しない
    | (:;: $i-;:)                           再現する
    |
    | 結局以下で発生するという所までは突き止めた。
    |
    | 11:(:;: $i-;:)
    | 8:(:;then : $i-;:)
    | 14:(:;then : $i-;;:)
    |
    | (: $i-;:) でも再現する。更に then でなくても良い様だ。
    |
    | 9:(: $i-;:)
    | 6:(echo : $i-;:)
    | 13:(echo : $i-;i;:)

    更に (:: $i-;:) から始めても再現する。
    最初の空白挿入操作で既に変な状態になっていると考えられる。

    10:(:: $i-;:)
    3:(: : $i-;:)
    10:(: : $i-;i;:)

    初期状態
    _ble_syntax_attr/tree/nest/stat?
    12*a    000 '(' |  nest=(CMDXE w=- n=- t=-:-) stat=(CMDX w=- n=- t=-:-)
     2*aw   001 ':' || stat=(CMDX1 w=- n=@0 t=-:-)
     2*aw   002 ':' |+ word=CMDI:1-3/(wattr=216173653992204032) stat=(CMDI w=CMDX1:1- n=@0 t=-:-)
     3*a    003 ' ' |
    14*a    004 '$' || stat=(ARGX w=- n=@0 t=$3:-)
     7*a    005 'i' ||
     4*a    006 '-' |+ word=ARGI:@2>4-7/(wattr=d) stat=(ARGI w=ARGX:4- n=@0 t=-:$3)
    12*a    007 ';' |  stat=(ARGX w=- n=@0 t=$7:-)
     2*aw   008 ':' |+ word=CMDI:@6>8-9/(wattr=72057594037930241) stat=(CMDX w=- n=@0 t=$7:-)
    12*a    009 ')' +  word="(":0-10>@8 stat=(ARGX w=- n=@0 t=$9:-)
     |    s 010 ^@    stat=(CMDXE w=- n=- t=$10:-)


    空白挿入後の状態 (yが正しい状態でxが異常になった状態)
    --- D0000.b.y.txt^I2020-04-14 12:58:01.259916873 +0900
    +++ D0000.b.x.txt^I2020-04-14 12:56:49.470879943 +0900
    @@ -2,12 +2,12 @@
     12 a    000 '(' |  nest=(CMDXE w=- n=- t=-:-) stat=(CMDX w=- n=- t=-:-)
      2 aw   001 ':' |+ word=CMDI:1-2/(wattr=72057594037930241) stat=(CMDX1 w=- n=@0 t=-:-)
      3 a    002 ' ' |
    - 4 a    003 ':' |+ word=ARGI:@1>3-4/(wattr=m1:d,$:d) stat=(ARGX w=- n=@0 t=$2:-)
    - 3 a    004 ' ' |  stat=(ARGX w=- n=@0 t=$4:-)
    -14 a    005 '$' || stat=(ARGX w=- n=@0 t=$4:-)
    + 4 a  s 003 ':' |+ word=ARGI:@1>3-4/(wattr=m1:d,$:d) stat=(ARGX w=- n=@0 t=$2:-)
    + 3 a  s 004 ' ' |  stat=(ARGX w=- n=@0 t=$4:-)
    +14 a  s 005 '$' || stat=(ARGX w=- n=@0 t=$4:-)
      7 a    006 'i' ||
    - 4 a    007 '-' |+ word=ARGI:@3>5-8/(wattr=d) stat=(ARGI w=ARGX:5- n=@0 t=-:$4)
    -12 a    008 ';' |  stat=(ARGX w=- n=@0 t=$8:-)
    - 2 aw   009 ':' |+ word=CMDI:@7>9-10/(wattr=72057594037930241) stat=(CMDX w=- n=@0 t=$8:-)
    -12 a    010 ')' +  word="(":0-11>@9 stat=(ARGX w=- n=@0 t=$10:-)
    + 4 a    007 '-' |+ word=ARGI:@3>5-8/(wattr=d) stat=(ARGI w=ARGX:5- n=@1 t=-:$4)
    +12 a  s 008 ';' |  stat=(ARGX w=- n=@0 t=$8:-)
    + 2 aw s 009 ':' |+ word=CMDI:@7>9-10/(wattr=72057594037930241) stat=(CMDX w=- n=@0 t=$8:-)
    +12 a  s 010 ')' +  word="(":0-11>@9 stat=(ARGX w=- n=@0 t=$10:-)
      |    s 011 ^@    stat=(CMDXE w=- n=- t=$11:-)


    [原因]

    | 更新範囲を見てみると ": : " の4文字だけなので、
    | これは shift の失敗によって起こっている不整合である。
    | では何故 shift に失敗するのか。shift のバグは流石にもうないと思っていたのに。
    | 而も、shift が起こる条件が良くわからない。他の場合には起こっていなかった筈である。
    | 不思議なのはその他の nest の shift はちゃんとできているという事。
    | "-" に設置されている stat の nest だけ shift できていない。
    |
    | shift.stat を観察してみた。ここで stat の中にある nlen を更新している。
    | 然し、何か変である。というか shift を実行する前から既に shift 済みの気がする。
    | 一体どういう事だろうか。或いは j=7 というのは shift 前のインデックスという事か。
    | だとすると j=6 に対して shift.stat が呼び出されていないという事になる。
    | j=7:nlen=7:beg=2:end0=2:shift=1
    |
    | →確認してみた所配列の再配置は shift の後だった。つまり j は shift 前の位置である。
    | そして shift.stat が呼び出されていないという事なのだろうと思われる。
    | というのも shift.stat は全体に対して実行しているのではなくて、
    | 必要のありそうな物を tree-enumerate で列挙するという形になっている様だから。
    |
    | * shift.method2 の実装に関する記録を探す。
    |   要するにこの shift.method2 が悪いというのは明らかであるが、
    |   そもそも何故この様な複雑な事をしているのだったか。
    |   done.txt を method2 で検索しても見つからない。
    |   blame を確認すると e74c1163 と書かれている。
    |   日付は 2016-04-07 になっている。#D0321 に議論が残っている。
    |   結構複雑な変更だったのだろうか。議論がごちゃごちゃとしていて分からない。
    |   どうも tplen と tclen に関しては単語内部に対する探索を実行しているが、
    |   nlen に対しては何らかの仮定の下にスキップを行っている。
    |   そしてその仮定が崩れているのではないかというのが今回の問題点。
    |
    |   また別の shift.impl2 に関する議論は #D0223 にある。
    |   然し、こちらは単純なバグ修正なので深い事は何も書かれていない。
    |
    |   結局見つからない。結局改めて何が行われているかコードを読まなければない。
    |
    |   shift として何が必要かについて考える。
    |   wlen, nlen, tplen, tclen 等は全て相対位置で記録しているので、
    |   基本的には shift は必要ないはずである。shift が必要になるのは、
    |   wlen, nlen, tplen, tclen が変更領域に跨っている場合と考えられる。
    |   shift 対象としては stat / tree / nest の3種類がある。
    |
    | shift.stat では stat 内の情報と beg/end0 の情報だけで更新している。
    | 変更領域を超えた参照についてはそのまま shift して、
    | 変更領域内部 (inclusive) に対する参照については消滅した物として、
    | 参照点を変更領域末端まで移動する。
    | shift.tree も実質同様である。shift.nest も同様であった。
    |
    | shift.stat, nest に関しては j2 まで全て呼び出す形になっている?
    | 但し、変更領域の後の nest の内部にある物に関してはスキップできる。
    | 何故ならば参照はその中で閉じている筈だから。
    |
    | * 或いは最近の TE_nofs に関係する修正でバグが埋め込まれた可能性もあるだろうか?
    |   TE_nofs etc の様に変数名を書き換えたのは 9cb35832 である。
    |   試しに 9cb35832~ を checkout して見たが同じ問題が発生している。
    |   v0.2-master でも発生した。v0.1-master では発生していない気がする。
    |   どうやら #D0321 の e74c1163 の段階では発生していなかった様である。
    |
    |   犯人は分かった 035ad68 この commit で問題が発生する様になっている。
    |   2017-02-25 の事である。#D0364 が該当する項目である。
    |   さて、実際に修正した内容を確認すると…。うーん。
    |   _shift2_j=j の位置を変更しただけである。
    |   という事は元からあったバグがこれで発現しただけという事なのだろうか。

    但し単語内部の場合には外側の nest に対して参照がある可能性がある。
    そう考えるとスキップできる tree というのは nest に限られるのでは。
    →やはりこれが悪い様に思われる。

    取り敢えず、スキップするのは nest の時だけにする事にした。問題は発生しなくなった。

    ? 単語ごとに nest を設置しないのは何故か。
      というよりそもそも何故 nest を単語の時に更新していなかったのか。

      * nest を辿る事によって文法の解釈を変えたりという事に nest を使っている。
        然しこれは主に単語の内部での解釈についてなので
        実は単語ごとに nest を作っても大した影響はないのではないか。
        →nest-type を呼び出している箇所を確認したが、
          やはり単語でも nest を作る様にして問題は発生しない様に感じる。
      * また解析状態一致の判定にも使っている。実は解析状態一致の判定に関しては、
        寧ろ単語ごとに nest を作った方が都合が良いのかもしれない。
      * そもそも "単語" という概念と "nest" という概念を独立に管理する必要はあるのだったか。
        解析状態に wlen と nlen の両方があるがその必要は本当にあったのだろうか。
      * 解析状態の一致判定に時間がかかる様になるかもしれない。
        というのも一致を判定する為に毎回 nest 配列の中身を辿る必要が出てくるから。
        単語に対しても nest を作る様にしてしまうと毎回辿る nest が多くなってしまう。

      始めから再設計するのだとしたら nlen と wlen は統合した気がするが、
      現在の実装でそうなっている以上は敢えて変える必要もないように感じている。
      wlen/nlen をくっつけると多少効率が下がるかもしれないし、
      また解析器の部分を全体的に書き換えなければならなくなる可能性がある。
      別に其処までしなくても良いという様に感じている。


    ? 単語の場合でもその文脈に於ける nest が空であればスキップできるのではないか。
      * tree 構造に nlen は記録していただろうか。ble_debug で観察すると記録していない気がする。
        実際に確認したが記録はしていない様だ。単語の場合には wlen を nest の場合には nlen を記録している。
        つまり、単語の場合に外側の nlen を記録するという事はしていないのである。
        寧ろ、nlen は stat の側にしか記録していない。

      或いは単語と同じ位置に記録してある stat の中にある nlen を参照するという手もある。
      然し、単語の終端に必ず stat が設置されているかどうかは非自明である、
      少なくともそういう要求を意識して実装はしていない。
      見た感じは一致している様にも見えるが際どい。

      * 然し、よく考えてみればこれでスキップできる様にしたとしても、
        結局 $() 等の構造の内部では余り意味がない。
        結局 ${} 等の nest を作る構造単位で飛ばすという処理だけでしか
        本質的には高速にする事ができない。
        その様に考えると単語の時にわざわざ nest が空かどうかを判定しても仕方がない気がする。
        一方で、設計の綺麗さよりも効率を考えるのであれば、やはりトップレベルで沢山コマンドを
        入力する場合が大半であるから、そう考えると nest をチェックしても良い。

      色々考えると、単語の場合に nest の情報を無理して取得してスキップをするのは
      現在の実装を考えると余り綺麗ではない上にそんなに効率化する訳でもない気がする。
      という事から対応しない事にする。
      スキップはネストの時にだけ行う事とする。

  * edit: set +H としても次のコマンドの実行の時には履歴展開が有効になってしまう [#D1332]
    set -H についても記録・復元するべきである。

    というよりもそもそも何故 set -H が設定されているのだったか。
    D0110 によるとそもそも履歴展開が実行されないということの様だ。
    確かに自前で history -p を呼び出して履歴展開を実行している。
    という事は eval では履歴展開は発生しないという事を意味する。
    set -H は履歴展開を起こす為に念の為に設定した物であって、
    特にいま history -p を使って自前で展開しているので不要である。
    単に削除する事にする。

  * 棄却 2020-04-02 highlight: hello! () { echo; } として hello! としても関数名着色にならない [#D1331]
    と思ったがこれは履歴展開を含む単語は単純単語ではないと判断される為である。
    更に、単語の境界が必ず履歴展開の終端とも限らない。
    例えば echo hello!; は !; で履歴展開になっている。
    従って hello! の部分だけ見て ! が末端にあるからと言って、
    それが履歴展開にならないという事は保証できないのである。
    これは対応しない。

  * syntax: ${#@a} の着色 [#D1330]
    どうも $@ に修飾 # とごみ a がついていると解析している気がする。
    然し、実際には $# に修飾 @a がついていると解釈するべきである。
    他に ${##0} もエラー着色になっている。
    これは ${##} に 0 がついているという具合に解釈されている気がするが
    実際には $# に #0 という修飾がついているという様に
    解釈しなければならないのである。

    関連して現在の実装では ${-[@]} の様な物も許容されているが、
    これは実際の bash では許容されない組み合わせである。
    これらについて正しく判定する事は可能だろうか。

    可能な組み合わせについて全て列挙すれば良いのだろうか。
    特に一文字特別パラメータについては別に取り扱えば良い気がする。

    * 現在の実装では先ず初めに普通の変数名の場合には
      ${var} ${!var} ${#var} ${!var@} ${!var[@]} ${var[@]} ${var@flags} 等が存在する。
      うーん。整理すると以下の 9 の組み合わせが存在して、 ${#var@} だけが定義されていない。
      因みに ${var[0]} 等の場合の取り扱いは ${var} の時と全く同様である。

        ${var}    ${var[@]}   ${var@}   ${var[@]@}
        ${!var}   ${!var[@]}  ${!var@}  ${!var[@]@}
        ${#var}   ${#var[@]}  ${#var@}  ${#var[@]@}

      それぞれ以下の意味を持つ。
        普通の展開  配列一覧      フラグ   配列フラグ
        間接参照    配列キー一覧  変数名   間接参照*2
        文字数      配列要素数    <Error>  <Error>

        *1: 3列目に関してはフラグはなくて良いが4列目に関してはフラグ文字は1文字以上必要?
          と思ったがそうではなくて変数が定義されていない場合はフラグがなくても良い。
          変数が定義されている場合にはフラグがないとエラーになってしまう。
        *2: 何故か全要素を結合した文字列を一つの変数として扱おうとする。

      うーん。振る舞いを見ていると @Flag に関しては寧ろ [-+^,?] と同じ取扱の気がする。
      特に # の後には続けられないという点はそれに同じである。
      但し、${!var@} は特別に取り扱わなければならない。${!var@F} とするとエラーになる。

    * またパラメータの場合にはどうなっているだろうか。
      試してみると色々の気がする。取り敢えず数字パラメータから調べる。
      基本的には普通の変数と同じだが配列添字の形式が存在しない、という事が違う。

        ${1}  ${1@}
        ${!1} ${!1@}
        ${#1} ${#1@}=err

    * 特殊パラメータの場合はどうか。先ず - や ? の場合にはどうか。
      これらは特に迷う事もなく、位置パラメータと同じ取扱の気がする。

    * @ や * の場合は何だか良くわからない。
        ${@}  ... これは位置パラメータ一覧
        ${!@} ... これは "\${$*}" と取り扱われる様だ。
        ${#@} ... これは $# に等価の様である。
                  $# に @Flag がついているのかと思いきや ${#*} でも同様に動く。
                  然し ${#@Q} とすると $# に @Q という動作になる。
        ${@@} ... これはちゃんとフラグとして取り扱われる。
        ${!@@} ... これも ${!@} に対するフラグになっている様だ。
        ${#@@} ... これはエラーである。

    * # の場合
        $# ... これは位置パラメータの数
        ${!#} ... これは $# の間接参照である。つまり "\$$#" という事で最後の引数を取るのに使える。
        ${##} ... これは $# の文字数を数えている。
        ${#@} ... これは上述の解釈が優先される? そして ${#@Q} だと $# + @Q になる。
        ${!#@} ... これはエラーになるが ${!#@Q} は ${!#} + @Q という解釈に為る。
        ${##@} ... これはエラーにならない。恐らく $# + #@ という解釈になっている。

    * ! の場合
        $! ... PID
        ${!!} ... これは履歴展開になってしまう。履歴展開を off にするとエラー。
        ${#!} ... これは 0 に展開された。どういう事だろうか。
                  →sleep 1 & してからだとちゃんと有限の値、文字数に展開された。
                  つまり $! の文字数を数えている。
        ${!@} ... (上記) これは $@ の間接参照という取り扱いになっている。
        ${!!@} ... これはどうやってもエラーである。
        ${#!@} ... これもどうやってもエラーになってしまう。

    * 取り扱いを纏めると、パラメータ展開の内容は

      (1) 前置詞: !, #
      (2) パラメータ名: var var[0] var[@] 1 - @ # ! の何れかに分類できる。
      (3) 後置修飾: #... %... //... @... -... +... ?... など色々。
          但し、前置詞 # がついている時にはパラメータ名の直後で終了しなければならない。
          空白が入る事もない。

      * 例外的な形式として ${!var@} という物がある。
        これは var@ というパラメータ名という訳でもない。
        後置修飾できないし、! の前置修飾という解釈も難しい。
        つまり特別に許された形であるという様に解釈できる。
        既に現在の実装で特別に取り扱って実装する様になっているのでこれはそのまま。

      * 前置詞 # と本体 # と 後置修飾 # は紛らわしいが、
        1. 一番はじめの文字が # だった時には ${#ParamName} に一致するか確認。
        2. もしその形式で解釈できない時は 1 文字目をパラメータ名として解釈。
        という順番で処理されている様に見える。少なくともそうすれば一致する。

    ble.sh の実装ではどの様に取り扱うべきか。
    取り敢えず、@... に関しては別に取り扱う事にする。
    \[ に関しては var の形式のときにだけ許容する様に変更する。
    先に ${#param} を試して、それで駄目だった時に ${param...} 及び ${!param...} を試す。

    x fixed: ${var@} がエラー着色になっている。
      これは空のフラグとして処理されているのだろうか。
      →bash 4.3 で駄目で bash 4.4 から許容される様になっているので空のフラグという事である。

    実装した。実際に動かして試してみる事にする。

    x fixed: ${!var@Q} の着色が異なっている。${!var@} の特別扱いはすぐに } で閉じている時だけでは。
    x ${!1} がエラー着色になる。${!-} もエラー着色になる。
    - ok: ${#var[@]@Q} は実際にはエラーだが許容している。
    - ok: ${!!@} も bash ではエラーだが許容する様になっている。

2020-04-12

  * util (conditional-sync): サブシェルで実行しているのは何故か [#D1329]
    テストを書いていて気づいたが check 用のコマンドで親環境を参照・変更する事ができない。
    考えてみれば同期的なサブシェルなので
    親環境の変数は変化しないので直接親に取りに行く必要はない。
    そして cancel-check のコマンドが副作用を持つというのも変である。
    然し、変更できないというのは不便な気もする。

    * そもそもサブシェルで実行する必要はあったのだろうか。
      記録を探すと #D1080 である。然し、議論には詳しいことは何も書かれていない。
      一行 "遅くならないように修正した" としか書かれていない。
      うーん。特に問題もなかったのではないかという気がしてきた。
      サブシェルを除いてみる事にする。
      →特に変化は見られない様である。

      と思ったが分かった気がする。内部で & を使ってコマンドを起動している。
      直接対話シェルでこれを実行すると jobs の変なメッセージが表示されて邪魔になる。
      丁度 ble/util/visible-bell で同様にサブシェルの中から & を使ってコマンドを起動している。
      少し試してみた限りでは conditional-sync では問題は発生していないが、
      何らかの条件で表示される可能性がある。という事なので現状のままサブシェルで実行する事にする。

    * というか現在の実装でこれが功を奏している様に見えない。
      相変わらず c と打つと処理に時間がかかっている様な気がする?
      →実際に試してみると実は conditional-sync が使われていない様だ。
      実装を確認してみた所、補完文字列が空の時にのみ conditional-sync
      が使われるということの様である。

      一文字cだけの時でもかなり時間がかかっている。5.8s-6s かかっている。
      cに対する候補の数はそんなに多くない。279件である。
      因みに0文字の時には 20s かかっている様だ。
      2文字 'cd' の時には、0.074sである。
      総合するに、何か時間のかかるコマンドが存在している?
      →調べると cy で 4.9s かかっている。

      もっと全体的に調べてみる事にする。
      function measure-compgen { { time compgen -A command -- "$1" | wc -l >&3; } 2>&1 | head -2; } 3>&1

      a   216 real 0m0.750s  k 105 real 0m0.535s  u 150 real 0m0.614s   4 1 real 0m0.118s
      b  2270 real 0m0.518s  l 250 real 0m0.929s  v  54 real 0m0.293s   5 1 real 0m0.129s
      c   297 real 0m5.649s  m 323 real 0m0.853s  w 178 real 0m0.567s   6 1 real 0m0.116s
      d   252 real 0m0.826s  n  81 real 0m0.292s  x 336 real 0m1.249s   7 1 real 0m0.116s
      e   108 real 0m0.384s  o  53 real 0m0.299s  y   9 real 0m0.156s   8 1 real 0m0.118s
      f   178 real 0m0.669s  p 396 real 0m1.173s  z  46 real 0m0.261s   9 1 real 0m0.127s
      g   291 real 0m1.144s  q  42 real 0m0.260s  0   0 real 0m0.140s
      h    80 real 0m0.341s  r 155 real 0m0.540s  1  11 real 0m0.114s
      i   248 real 0m1.071s  s 298 real 0m0.817s  2  11 real 0m0.114s
      j    18 real 0m0.165s  t 297 real 0m1.039s  3   1 real 0m0.118s

      A  15 real 0m0.165s  K   3 real 0m0.184s  U  10 real 0m0.141s  [   4 real 0m0.141s
      B  15 real 0m0.143s  L  16 real 0m0.153s  V   6 real 0m0.137s  ]   1 real 0m0.128s
      C 134 real 0m0.204s  M  41 real 0m0.189s  W  75 real 0m0.256s  {   1 real 0m0.128s
      D  59 real 0m0.185s  N  23 real 0m0.151s  X  24 real 0m0.186s  }   1 real 0m0.127s
      E  11 real 0m0.131s  O   8 real 0m0.132s  Y   0 real 0m0.119s
      F  15 real 0m0.141s  P  34 real 0m0.159s  Z   1 real 0m0.128s
      G   7 real 0m0.125s  Q   0 real 0m0.137s  !   1 real 0m0.114s
      H  12 real 0m0.144s  R  40 real 0m0.157s  .   2 real 0m0.166s
      I  12 real 0m0.137s  S  61 real 0m0.200s  :   1 real 0m0.125s
      J   0 real 0m0.120s  T  17 real 0m0.156s  @  18 real 0m0.125s

      この結果を見ると 1 文字の時は全般に遅い。

      ca 18 real 0m0.191s ck 2  real 0m0.126s cu 5  real 0m0.140s c4 0 real 0m0.116s
      cb 0  real 0m0.125s cl 43 real 0m0.203s cv 0  real 0m0.120s c5 0 real 0m0.115s
      cc 4  real 0m0.138s cm 9  real 0m0.156s cw 2  real 0m0.125s c6 0 real 0m0.122s
      cd 2  real 0m0.163s cn 0  real 0m0.127s cx 0  real 0m0.115s c7 0 real 0m0.142s
      ce 23 real 0m0.185s co 61 real 0m0.262s cy 16 real 0m4.925s c8 2 real 0m0.120s
      cf 2  real 0m0.135s cp 12 real 0m0.145s cz 2  real 0m0.134s c9 2 real 0m0.118s
      cg 2  real 0m0.126s cq 0  real 0m0.136s c0 0  real 0m0.123s
      ch 35 real 0m0.285s cr 12 real 0m0.163s c1 0  real 0m0.150s
      ci 3  real 0m0.143s cs 9  real 0m0.144s c2 0  real 0m0.116s
      cj 2  real 0m0.119s ct 21 real 0m0.187s c3 0  real 0m0.120s

      ga   7 real 0m0.151s  gk   2 real 0m0.141s  gu   2 real 0m0.160s  g4   0 real 0m0.130s
      gb   5 real 0m0.139s  gl  18 real 0m0.203s  gv  40 real 0m0.283s  g5   0 real 0m0.120s
      gc  20 real 0m0.179s  gm   0 real 0m0.144s  gw   0 real 0m0.117s  g6   0 real 0m0.116s
      gd  22 real 0m0.229s  gn  14 real 0m0.187s  gx   0 real 0m0.130s  g7   1 real 0m0.129s
      ge  33 real 0m0.218s  go   2 real 0m0.124s  gy   0 real 0m0.137s  g8   0 real 0m0.117s
      gf   6 real 0m0.145s  gp  14 real 0m0.176s  gz   4 real 0m0.141s  g9   0 real 0m0.132s
      gg   0 real 0m0.119s  gq   0 real 0m0.141s  g0   0 real 0m0.118s
      gh   0 real 0m0.147s  gr  30 real 0m0.249s  g1   0 real 0m0.130s
      gi  14 real 0m0.221s  gs  22 real 0m0.183s  g2   0 real 0m0.113s
      gj   0 real 0m0.119s  gt  32 real 0m0.278s  g3   0 real 0m0.125s

      ia   0 real 0m0.129s  ik   0 real 0m0.126s  iu   0 real 0m0.130s  i4   0 real 0m0.131s
      ib  11 real 0m0.154s  il   0 real 0m0.117s  iv   0 real 0m0.117s  i5   0 real 0m0.116s
      ic  10 real 0m0.153s  im  19 real 0m0.196s  iw   2 real 0m0.116s  i6 126 real 0m0.722s
      id   5 real 0m0.141s  in  33 real 0m0.225s  ix   0 real 0m0.117s  i7   0 real 0m0.125s
      ie   5 real 0m0.126s  io   0 real 0m0.129s  iy   0 real 0m0.134s  i8   0 real 0m0.127s
      if   8 real 0m0.149s  ip  11 real 0m0.156s  iz   0 real 0m0.116s  i9   0 real 0m0.114s
      ig   1 real 0m0.114s  iq   0 real 0m0.116s  i0   0 real 0m0.128s
      ih   0 real 0m0.128s  ir   3 real 0m0.121s  i1   0 real 0m0.115s
      ii   0 real 0m0.118s  is  13 real 0m0.142s  i2   0 real 0m0.117s
      ij   0 real 0m0.148s  it   0 real 0m0.129s  i3   0 real 0m0.118s

      la  32 real 0m0.198s  lk   2 real 0m0.127s  lu  17 real 0m0.194s  l4   2 real 0m0.138s
      lb   0 real 0m0.150s  ll   3 real 0m0.129s  lv   0 real 0m0.125s  l5   0 real 0m0.114s
      lc   4 real 0m0.123s  lm   0 real 0m0.128s  lw  10 real 0m0.131s  l6   0 real 0m0.119s
      ld   8 real 0m0.149s  ln   4 real 0m0.142s  lx  60 real 0m0.380s  l7   0 real 0m0.115s
      le  10 real 0m0.146s  lo  22 real 0m0.197s  ly  10 real 0m0.132s  l8   0 real 0m0.126s
      lf   0 real 0m0.128s  lp   7 real 0m0.140s  lz  22 real 0m0.204s  l9   0 real 0m0.133s
      lg   0 real 0m0.133s  lq   0 real 0m0.137s  l0   0 real 0m0.123s
      lh   0 real 0m0.115s  lr   2 real 0m0.129s  l1   0 real 0m0.118s
      li  16 real 0m0.197s  ls   9 real 0m0.137s  l2   0 real 0m0.124s
      lj   0 real 0m0.132s  lt   6 real 0m0.126s  l3   2 real 0m0.117s

      pa  21 real 0m0.195s  pk  16 real 0m0.182s  pu  11 real 0m0.160s  p4   0 real 0m0.117s
      pb   2 real 0m0.138s  pl  11 real 0m0.161s  pv   0 real 0m0.124s  p5   0 real 0m0.119s
      pc  11 real 0m0.138s  pm   6 real 0m0.144s  pw   4 real 0m0.128s  p6   0 real 0m0.120s
      pd  62 real 0m0.301s  pn   3 real 0m0.125s  px   0 real 0m0.117s  p7   0 real 0m0.115s
      pe  28 real 0m0.168s  po  38 real 0m0.194s  py  38 real 0m0.248s  p8   0 real 0m0.115s
      pf  10 real 0m0.144s  pp   6 real 0m0.131s  pz   0 real 0m0.117s  p9   0 real 0m0.123s
      pg   4 real 0m0.140s  pq   0 real 0m0.116s  p0   0 real 0m0.130s
      ph   1 real 0m0.119s  pr  44 real 0m0.227s  p1   2 real 0m0.128s
      pi  12 real 0m0.185s  ps  43 real 0m0.244s  p2   2 real 0m0.126s
      pj   0 real 0m0.115s  pt  20 real 0m0.181s  p3   0 real 0m0.129s

      ta  20 real 0m0.188s  tk   2 real 0m0.126s  tu   2 real 0m0.143s  t4   2 real 0m0.135s
      tb   2 real 0m0.130s  tl   6 real 0m0.137s  tv   0 real 0m0.130s  t5   0 real 0m0.134s
      tc  23 real 0m0.201s  tm   2 real 0m0.119s  tw   2 real 0m0.125s  t6   0 real 0m0.126s
      td   5 real 0m0.135s  tn   0 real 0m0.121s  tx   0 real 0m0.115s  t7   0 real 0m0.121s
      te  92 real 0m0.390s  to   6 real 0m0.151s  ty   7 real 0m0.122s  t8   0 real 0m0.127s
      tf  12 real 0m0.187s  tp   9 real 0m0.151s  tz   6 real 0m0.147s  t9   0 real 0m0.117s
      tg   6 real 0m0.136s  tq   0 real 0m0.132s  t0   0 real 0m0.122s
      th   3 real 0m0.134s  tr  25 real 0m0.194s  t1  22 real 0m0.226s
      ti  10 real 0m0.146s  ts  14 real 0m0.164s  t2   0 real 0m0.116s
      tj   0 real 0m0.120s  tt  19 real 0m0.188s  t3   0 real 0m0.115s

      xa   6 real 0m0.143s  xk  14 real 0m0.188s  xu   0 real 0m0.119s  x4   0 real 0m0.136s
      xb   0 real 0m0.131s  xl  14 real 0m0.163s  xv   4 real 0m0.143s  x5   0 real 0m0.116s
      xc  23 real 0m0.185s  xm  28 real 0m0.215s  xw  13 real 0m0.141s  x6   0 real 0m0.129s
      xd  36 real 0m0.239s  xn   0 real 0m0.125s  xx   2 real 0m0.134s  x7   0 real 0m0.115s
      xe   8 real 0m0.153s  xo   4 real 0m0.141s  xy   0 real 0m0.126s  x8  80 real 0m0.464s
      xf  14 real 0m0.179s  xp  14 real 0m0.155s  xz  20 real 0m0.198s  x9   0 real 0m0.115s
      xg   2 real 0m0.141s  xq   0 real 0m0.119s  x0   2 real 0m0.129s
      xh   4 real 0m0.124s  xr   6 real 0m0.137s  x1   6 real 0m0.144s
      xi  10 real 0m0.147s  xs  21 real 0m0.186s  x2   0 real 0m0.128s
      xj   0 real 0m0.118s  xt   4 real 0m0.135s  x3   0 real 0m0.116s

      cy i6 lx te x8 辺りの組み合わせが重い。cy は cygwin だろう。
      i6 と x8 は i686 と x86 であろう。te は tex で lx は lx の様だ。
      3文字だと i68 0.7s x86 0.4s cyg 4.9s が重い。
      4文字だと cygg 0.7s cygc 0.5s cygp,cygf,cygk 0.4s が重い。

  * edit: bash-5.1 PROMPT_COMMANDS 及び READLINE_MARK [#D1328]
    bash 5.1 のこれらの機能にはいずれ対応しなければならない。
    簡単に対応できるのでもう対応してしまう事にする。

  * decode: ble-0.3 を使うと二回目以降の起動で ble/widget/ が見つからない [#D1327]
    というエラーが沢山発生してまともに操作する事ができなくなる。
    調べると decode table が変な事になっている。
    複数の要素からなる項目が全て分割されてしまっている。
    初期化した直後は配列の内容はちゃんとしているが、すぐに変な状態になる。
    何処か別の場所で書き換えているとは考えがたい。

    と思って書き換わっている場所を探っていった所、
    cmap/initialize の中で壊れていた。そこで分かった。
    cmap のキャッシュを記録する時に keymap のキャッシュもダンプしている。
    それによって keymap が上書きされてしまうのであった。
    特に容量を減らす為に cmap のダンプの出力から引用符を削除していたので
    cmap を再ロードした時に複数の単語からなる binding が全て分割されてしまっていたのだった。

    これについては ble-bind を実行する前に cmap/initialize を
    実行する様にして、更に cmap/initialize の中のキャッシュの記録についても
    cmap に関係のある行だけを選別して保存する様に修正した。
    取り敢えずこれで直った様である。
    0.4 の方でも安全の為に cmap に関係のある行だけを選別して記録する事にした。

  * util: has-glob-pattern の判定がサブシェルの中ではできない [#D1326]
    failglob を使って判定しているがサブシェルの中だと
    eval を用いて評価していたとしてもその場で終了してしまう。

    サブシェルの中でも failglob が発生しない様にする方法はあるのか。
    例えば nullglob を用いるという手があるのではないか?

  * util: ble/util/print-global-definitions で未定義変数と配列に対応する [#D1325]

    ble/util/print-global-definitions で定義されていない変数が
    空の変数名として抽出される様になっている。
    unset という事を検出する事は可能だろうか。

    そもそも宣言されていないという事と宣言されているけれども unset である
    という事は今回は区別しない事にする。そもそも途中でローカル変数が定義されている時、
    "宣言されていない" という状態にするのは不可能なので、
    状態を再現するとしても "宣言しているが unset" という状態にするしかない。

    unset であるという事を検出する事はできるか。試してみた所できる様子である。

    * 配列に対応できていないという事が判明した。実は現在の用途では配列要素を指定する
      という事は無いような気がするけれども、関数の設計としては配列名であっても
      正しくグローバルに於ける配列を取得できる様にしておくべきである。

      配列かどうかの判定はどうするか。配列かどうかの判定は。
      is-array を用いているが、実はこの関数は、普通の配列と連想配列を判定できない。
      is-array の実装を見直すべきだろうか。改めて is-array の実装を計測してみた。
      compgen による方法は遅い。実は ble/util/assign declare -p した方が速いのでは。
      と思って実測してみたらそうだった。これは declare -p による方法に切り替える必要がある。

      配列の場合には実装はどの様にするべきだろうか。
      値を value=("${name[@]}") でコピーする方式だと飛びの在る配列の時に中身が変化する。
      一つずつ key を抽出して保存するのも大変である。
      ということであれば declare -p の出力をそのまま使う?
      然し、declare -p の出力には様々なバグが有るという事が判明している。
      そうすると declare-print-definiitions を呼び出す事にするか。
      それはそれで計算量が大きい。然し他に手段はないのである。
      或いは新しい bash の場合には declare -p を呼び出して、
      古い問題のある bash の場合には declare-print-definitions を呼び出す?

      調べると修正が必要になるのは bash-3.2 以下の様である。

    * fixed: さて値を unset にする為には declare && unset すれば良いだろうと思っていたら
      何と思うように動いてくれないという事が判明した。変だ。
      localvar_unset が実装されたために振る舞いが変わったという事なのだろうか。

      | →何と a=1 f として呼び出した時と、a=1; f として
      | 呼び出したときで a の振る舞いが異なる? どうも a=1 f として呼び出すと、
      | f のローカル変数として定義される? いや何だか変である。よく分からない。
      |
      | 以下は全ての bash 3.0..5.0 で declare -x a=1 が表示される。
      | $ bash -c 'f1() { local a; declare -p a; }; a=1 f1'
      |
      | 以下は 4.1 以下では declare -x a= であり、
      | 4.3 では変数が見つからず、他は declare -x a である。
      | $ bash -c 'f1() { local a; declare -p a; }; export a=1; f1'
      |
      | 以下は 4.3 以下では変数が見つからず 4.4 以降では declare a である。
      | $ bash -c 'f1() { local a; unset -v; declare -p a; }; export a=1; f1'
      |
      | 以下を試しても特に振る舞いの違いは見えない。
      | bash -c 'f1(){ local a;unset -v a;declare -p a;};f2(){ local a=1;f1;};f2'
      |
      | では何故テスト環境でだけ上の変数が再び見える様になってしまっているのか。
      | 或いは対話環境では別の振る舞いをするなどの違いが在るのだろうか。試してみる。
      | →対話環境でも振る舞いは同じである。然し ble.sh をロードしていると振る舞いが違う。
      |
      | eval の中で実行すると振る舞いが変わる? →そうではなかった。
      | $ eval 'f1(){ local a;unset -v a;declare -p a;};f2(){ local a=1;f1;};f2'
      |
      | bind -x の中で実行すると振る舞いが変わる? →そうでもなかった。
      | $ text='f1(){ local a;unset -v a;declare -p a;};f2(){ local a=1;f1;};f2'
      | $ bind -x '"\C-t": eval "$text"'
      |
      | shopt の違いが効いているのだろうかと思って確かめてみたが、
      | 違いは failglob と histappend histreedit, hostcomplete しかない。
      | これらは振る舞いには関係ないだろう。
      |
      | NOBLE=1 で起動しても再現しない。其処から source ble.sh すると再現する様になる。
      | 更にその後で ble-detach しても再現したままである。不思議だ。bash-4.4 でも再現する。
      | うーん。何らかの変数が効いているのか或いは、builtin の上書きが関係しているのか、
      | それとも何らかの操作をすると不可逆的に bash の振る舞いが変化してしまうのか。
      | というか一度はテストに通過していた気もする。
      |
      | bash-3.0..5.0 の全てでこの現象が再現している。謎である。

      状況をまとめると ble.sh をロードすると current-scope unset が
      dynamic に動作する様になってしまう。と此処まで書いて分かった。
      最近 unset を関数で上書きしてユーザが変更できない様にしたのだった。
      然し、そうすると unset の振る舞いが変化してしまう事になる。

      やはり unset を関数で上書きするのは悪手である。修正する。

    * fixed: 現在の ble/variable#has-attr の実装だと変数 attr に対して正しく取得できない。
      get-attr の場合にはインターフェイスから attr が取得できないというのは分かる。
      然し、has-attr の場合には attr について動作しないというのは不自然である。
      単に真偽値を終了ステータスで変え雨だけなのであるから。
      これは実際に ble/util/print-global-definition で使いたいので対応する事にした。


    * 実は bash-4.2 未満でも現在見ている変数がグローバルかどうか判定できるのではないか。
      というのもグローバル変数に対して -r を設定すると、
      ローカル変数としても定義する事が不可能になるから。
      ローカル変数に対して -r を設定した場合には新しく上書きする変数を定義できる。

      問題はグローバル変数に対して -r 属性を関数内から付加する事ができるのかという事。
      →readonly を使うとちゃんとグローバル変数に対して -r 属性を付加できた。
      →typeset -r を使った時には同じスコープに変数が作成される。

2020-04-11

  * 解消 2019-04-29 bashbug: #D1078 の bash-5.0 のバグを報告する? [#D1324]
    一応最新版で確認はしておいた方が良いかもしれない。
    と思ったが、どうせパッチを作るのであればその時に気づく筈である。

    2020-04-11 これは既に PATCH を報告済みである。

  * decode: bind --help の終了ステータスは 2 の様だ [#D1323]
    その他の buitlin も全て --help に対しては 2 で終了する様だ。

    exit unset bind read history trap を上書きしている。
    その内で正しく 2 を返しているのは unset, history のみである。
    確認した所、何れも本来の builtin は 2 を返している。
    bind exit read trap は修正する必要がある。

2020-04-10

  * complete: bash-dev で 10# のエラーが出ている [#D1322]
    "0>10#: invalid integer constant (エラーのあるトークンは "10#")"
    →これは簡単に修正できた。一箇所しか 10# はなかった。

  * failglob: bash-4.3 で $? を入力するとエラーメッセージが出る [#D1321]
    syntax highlighting が効いているのに違いないという気がする。
    特に変数の内容を調べるコードが怪しい気がする。
    うーん。get-attr だろうか→正にそれである。
    これは直った。

  * _ble_decode_input_buffer で不正な添字というエラーが発生する [#D1320]
    bash-4.1 以下で発生する様である。
    うーん。((i=-1,i>=0&&a[i--])) が bash-4.1 以下で駄目の様である。
    うーん。これは算術式のバグである。今まで知らなかったバグだ。
    →と思って確認したら既に分岐内の配列参照は実行されるという事が書かれている。
    唯、それが配列添字の中でも起こるという事は新たな発見であった。

    一応類似の物が存在しないか確認する。
    grc '(\|\||\?|&&)[[:alnum:]_]+\['
    取り敢えずは問題無さそうである。

2020-04-09

  * ble/util/openat は関数名を変更するべきでは [#D1319]
    openat という unix の関数が存在して、
    これは指定した fd からの相対パスでファイルを開くという物である。
    恐らく readlink で読みだしたリンク先を開くようなそういう関数なのだろう。

    名前が同じで機能が全く異なるのは良くないので名称を変えたい。
    また、ble/util/is-fd-open という関数も作成した。
    そういう事を考えると、以下の様な感じに改名すると良さそうな気がする。
      ble/fd#is-open
      ble/fd#alloc
      ble/fd#close

    うーん。この際なので解明する。

  * util: 実は openat で行っている fd の生死判定は : >&fd でできるのでは [#D1318]
    現在の実装では bash 4.0 以下では自分で適当な場所に fd を開いている。
    然し、既存の fd と被る場合には 3.0 では先に fd を閉じて置かなければならない。
    また 3.1 では fd を閉じても変な事になってしまう。
    仕方がないので 3.1 の時にだけ特別に fd が開いているかどうかを
    /dev/fd/.. または /proc/self/fd/.. で判定している。

    然し、実は : >&fd で判定できるのではないかという事。
    これならば環境依存せずに高速に判定する事ができる。
    内部的には dup2 を 3 回程度実行するだけの気がする。

    * ok: fdが再利用できない?
      然し、これによって今までは再利用していた fd が再利用されなくなって
      fd を無駄に使う様になってしまうのではないか。と思ったが、
      よく考えたら bash-4.1 以降では {fd}<> を使うので何れにしても再利用されない。
      bash 4.0 以下でだけ再利用する理由もないので、毎回判定する事にする。

      或いは、O_CLOEXEC を設定する方法があれば良い。。
      が少し考えてみたがその様な裏技の様な物はない気がする。
      或いは、export _ble_util_cloexec=10:11:12 等として上書き可能な
      fd を export して知らせるという手もあるが其処までする必要があるのかは謎である。

      総じて fd は再利用しなくても良いという様に結論づける。

    * ok: これによって openat_base は不要になったのではないか、と一瞬思ったが、
      ble.sh の側で重複判定をしていたとしても別のシェルプログラムが同じ領域を
      勝手に上書きして使うという事態になっていると結局問題が起こる。
      従って wiki の openat_base の説明は更新しなくても良い。

2020-04-08

  * test: テストフレームワークの整理 [#D1317]
    幾らか実装したので実装済みのものはこちらに移動する。

    * 単体テストの機能
      * done: 複数行 stdout を指定しやすくする?
      * done: stderr のチェック
      * done: テストのタイトル→これは '# title' の形式の単語で指定する。

    * その他の細かい動作について
      * done: start-section で自動的に end-section を呼び出す
      * done: start-section で開いた fd を閉じる
      * done: 並列テストに向けて一時ファイルが被らない様に BASHPID をファイル名に含める
      * done: diff のファイル名を分かりやすくする。

    * テストに BASHPID を使っているが bash-3 で使えない。
      bash-3 以下では sh -c $PPID を使って BASHPID を更新する事にした。
      と思ったが、これだと feature-test を使っている環境で変な事になるのでは?
      まあ、テストだけで使う様にすれば問題はない様な気がする。
      それ以外の場所では version を分けて local BASHPID 等とする事にする。

  * 2020-03-11 test: oilshell に Travis でテストを自動化せよと (suggested by andychu) [#D1316]
    実のところテストらしいテストは何もないのだが。
    自動化テストについて思うところ。

    →取り敢えずのテストの枠組みは形が見えてきたのでこれは考察済みという事にする。

    # そもそも何故そういう GitHub 上のテストを設定する気が余りしないのかというと、
    #
    # 1 先ず interactive session でないと ble.sh をロードしない様になっているので、
    #   其処を弄って特別に起動できる様にしなければならないという事。
    #   つまり、そもそもローカルでテストが自動化出来ていないのである。
    #
    # 2 GitHub 上でやるという事は不完全な形で push するという事を想定しているようで嫌だ。
    #   テストを自動化するぐらいであればローカルでちゃんとテストを通してから
    #   GitHub 上でテストを通すという事にするのが良い気がする。
    #   そもそも Travis は発火するまでに時間がかかる。それぐらいならば手許である。
    #
    #   然し、手許で毎回テストを実行する訳ではないし、
    #   複雑な事を実装している時に関係のない部分が火を吹いたりすると
    #   頭が混乱するのでテストは一括で行いたい様な気もしたり。
    #   色々考えるとやはり最低限は手許でテストしつつも
    #   自動化して GitHub 上での自動化されたテストにも頼るというので良いという気がする。
    #
    # 3 そして十分な数のテストが存在していないという事。
    #   これはテストを準備しなければならない。。
    #
    # 4 対話的なプログラムのテストを書くのは面倒だという事。
    #   特にテストケースの "正解" をどう記述するのかという事、
    #   どうやってそれを確認するのかという事。
    #
    #   然し、よく考えてみればそういうのはどのプログラムでも同じである。
    #   従って、結局どのプログラムでもテストという物は
    #   一般的なユーティリティの部分だけに留まって
    #   本質的な処理に近い部分のテストはおろそかになる物ではないかという気がする。
    #   なので余り気にせずにコア部分に近い部分だけテストしておけば良いという事なのかもしれない。
    #
    # というかよく考えてみると regression という物を殆ど経験していない。
    # それも大体作ったらそのままで変更する頻度はそんなにないという事。
    # それから変更する場合には実際に使っている箇所を大体ちゃんと確認するので、
    # regression が起こりにくいという事。
    # まあ全くないという訳ではないので多少は役に立つかもしれないというぐらい。
    # 自動化テストというのは一回通せば済むものではなくて、
    # 毎回テストする事に利点があるのである。つまり regression。
    # そういう意味では ble.sh の開発の形態自体が
    # 自動化テストをしなくても大丈夫な形に適合してしまっている。
    #
    # 一方で自動化する事によって新しいテストを書くという動機にはなって、
    # それによって得られる物は大きい気がする。
    # ただ毎回テストするという事には余り意味はないのかもしれないが。
    # 然しそれを言い出すとどのプロジェクトも結局同じ気もする。

2020-04-07

  * menu: menu が表示されている状態で確定すると [#D1315]
    INSERT の行が消える。というより座標計算もずれている気がする。
    今まで status がすぐに消えて何だろうと思っていたがこれで
    再現する事ができるのである。

    | 扨、何故これが起こるのだろうか。menu が表示されているというだけで、
    | 別に menu に入っているという訳ではない。うーん。不思議だ。
    |
    | clear-content の段階では特に問題は生じていない。
    | menu が表示されていない場合でも表示されている場合でもちゃんと初期ょしているし、
    | panel の高さの情報もちゃんと更新できている。
    |
    | そうすると ble-edit/info/reveal の方で問題が発生しているのだろうか。
    | うーん。不思議だ。ちゃんと動作している様に見える。
    |
    | 或いは _ble_canvas_x, _ble_canvas_y の座標がずれている?
    | →別に違いは見られない。
    |
    | うーん。どうも一瞬表示されてそれから消滅している様に見える。
    | 少なくとも高さの確保に失敗している事は確かである。表示している位置がずれている。
    | 追加されるべき行が追加されていない。

    →なんか変だと思ったら分かった。コマンドが実行される前に表示を実行している。
    menu/clear 経由で再描画されているのだった。これは #D1290 の変更が原因である。
    うーん。menu#clear で immediate-clear ではなくて単なる clear にしたら直った。
    clear の時には reveal が呼び出される迄は info の更新は行われないのである。

  * history: 履歴が倍加する現象が再度発生している [#D1314]

    [原因]

    遡ると 8cf17f7 で発生する様になっている。大分前である。
    前回の倍加問題の修正のすぐ後に再度発生する様になっている。
    然し、今まで倍加する問題は観測されなかった。
    という事は何か別の設定と相互作用を起こしてこれが発生している。

    どうやら /etc/bashrc の中に history -a が存在しているのが行けない様だ。
    この時に一体何が起こるのだろうか。というか、ble と関係在るのだろうか。
    と思ったが ble で古い version を使った場合には発生していないので、
    やはり ble との相互作用が原因になっているのは確かである。

    最近変わった事は何かというと /etc/bashrc の読み込みを
    source ble.sh よりも後に移動した事である。うーん。
    もしかしてこれはどのユーザでも同様に発生するのではないだろうか。
    全然駄目である。良くない。
    何れにしても source ble.sh を実行した後に history -a する事で
    何か ble.sh の想定が崩れてしまっているという事が考えられる。
    というか、/etc/bashrc が history -a を実行する時に履歴が空である事を想定している可能性?

    サブシェルの中で history -a を実行しても問題は発生しない。
    という事は history -a を実行した事によって何らかの計算がずれて、
    それによって何か変な事が発生しているという事。

    特に終了時に全体が書き込まれてしまっている。
    うーん。これはつまり、initialize に於いて 0 が初期位置として記録されてしまっている?
    _ble_builtin_history_wskip の値が変になっているのではないか。
    調べると空になっている。辿るとこれは ble/builtin/history/.get-max
    の結果を使っている。そしてこれの結果が空になっている。
    実装を確認すると builtin history 1 の最初の単語を使っている。
    つまり、履歴が読み込まれていない時にこれを呼び出すと空になる。

    うーん。履歴を強制的に読み出すにはどうしたら良いか?

    [現状の振る舞い]

    どうも記憶によると bashrc で履歴を history -r すると、
    その時点で history が倍加してしまうという事だった気がする。

    * history -a
      さて bashrc で history -a を実行した時の振る舞いが分からない。
      見てみると別に何も変化は起こらない気がする。
      或いは手で source した時にその場でそれまでの履歴を保存するのが目的なのだろうか。
      もしそうだとすると履歴が読み込まれていない時には history -a は実行しない、
      という具合に変更する事ができる。或いは履歴が読み込まれていなくても、
      history -a によって何らかの変化が発生する可能性はあるのだろうか。うーん。

      うーん。履歴が読み込まれていない時は history -a は無視するというのが正しい気がする。

    * history -r
      ble.sh をロードしている時に bashrc で history -r を実行するとどうなるか。
      ble.sh がない場合にはこれによって履歴が倍加するのではないかと危惧したが、
      実際に試してみるとそのような事は発生していない様だ。何故?
      或いは古い bash の version だけでの問題だったのだろうか。

    * history -n
      コメントを参照してみると履歴倍加が発生するのは history -n を実行した時の様だ。
      →実際に試してみると確かに再現する。

    [対策]

    うーん。どう対策するのが良いのか。或いは、.initialize の時に
    history -r を実行してしまえば問題が発生しない可能性?
    と思って実行してみたら倍加している。h とした時点で倍加している。
    単に history -r しただけではそうならないのに、
    何故 ble.sh の中から history -r を呼び出すと倍加しているのか。。

    然し、bash で history -a 及び history -w を実行しても何も起こらないのだとすれば、
    history -aw を bashrc の中で呼び出した時には何も実行しないというのが正しいのではないか。
    然しそれでも問題はある。history -s で履歴項目を追加した後に history -a を実行したらどうなるのか。
    そうすると結局履歴を読み込む前の状態で wskip が記録されてしまい、
    終了時に結局履歴が倍加してしまう。

    そもそも bash の振る舞い自体がおかしいのが行けないのではある。
    もし bash の制限がなかったとしたらどの様に振る舞いのが自然だろうか。
    要するに bash の初回 load の後に wskip を設定するべきという事なのである。
    現在の実装ではどうなっているか。bash が内部的に load するのを検出する事はできない。
    一方で、それ以外の history の動きについては追跡する事ができる。

    →bashの振る舞いを確認すると bashrc の中で history -s で履歴を追加した時には、
    実は HISTFILE の読み込みが抑制される様である。
    history -n では抑制されないのに変な事である。

    ble.sh ではどの様に振る舞うべきだろうか。

    | 寧ろ初回にロードした時に history を読み込んでしまう?
    | と思ったがそれだと HISTFILE を設定する前に読み込みが実行されてしまい、
    | 意図しない事になる。最終的な HISTFILE で読み込みをしたいという事を考えると、
    | できるだけ履歴の読み込みは遅延しなければならないのである。
    | そしてそれを実現する為には結局 bash に読み込ませるというのが現実的なのである。
    |
    | * その場合 history -aw は無視で良い。
    |
    | * bash では history -s は実行すると履歴が初期化されなくなる。
    |   これは ble.sh でもそのまま実行すれば良い気がする。
    |   と思ったが本当だろうか。実際に読み込んでいないのに、
    |   rskip の値がファイルの末端に設定される。
    |
    | * history -r をするとその場で読み込んで rskip が設定されるが、
    |   然し、bash によって勝手に追加で読み込みが実施されて履歴が倍加する。
    |   と思ったが実際に試してみるとそういう現象は起こっていない様だ。
    |   これに関しては現状のままで良い?
    |
    |   うーん。微妙である。history -r で明示的にファイルを指定して読み込む事もある。
    |   或いは何も指定せずに history -r を実行した時にのみ読み込みを initialize で実行しない。
    |   それ以外の場合には history -r に先立って明示的に履歴ファイルを読み取る?
    |
    |   或いは history -r の時にはわざわざ履歴を読み出さなくても良いのではという気もする。
    |   但し、これをすると bash による後の読み込みも抑制されてしまう。
    |
    | * history -n を実行してみると…。ble.sh の枠組みの中では何も発生しない様だ。
    |   少なくとも history 1 をしても何も出力されない。
    |   そして履歴の倍加も起こっていない。
    |   本当に何もしていないのだとすれば倍加が起こらないのは当然である。
    |   実装を確認してみる事にする。
    |
    |   →rskip が最初にファイルの長さに初期化される為に読み取りが実施されないという事の様だ。
    |   うーん。これは本来は未だ読み取りが実行されていないのだから rskip は 0 に設定しておいて、
    |   bash が勝手に新しく読みだした時に改めて更新するべきという事の気がする。
    |
    |   うーん。或いは history 1 をして空だったら history -r を実行するという事?

    なかなか仕様が定まらない。

    | どういう振る舞いが自然なのかという方針を明確にしなければならない。
    | 元の bash の振る舞いを多少変更しても構わない。
    | 然し元の bash の上で実現可能でなければならない。
    | 実現可能性に関しては実は頑張ればどうにでもなる気がする。
    |
    | 問題はやはり履歴が未初期化の時にどういう振る舞いが自然なのかという事である。
    |
    | * history -aw に関しては何も実行しない。
    |
    | * history -c に関しては後の履歴読み込みを無効化する。
    |   これは取り敢えず一旦読み取ってしまってその後で -c すれば良い。
    |
    |   →その様に実装したら bash が勝手に履歴を読み取って、
    |   それによって履歴が倍加してしまった。うーん。
    |   一筋縄では行かない。bash が履歴読み取りをするかしないかの条件に
    |   現在空であるかどうかというのも関わってくるという事?
    |
    |   そもそも元の bash ではどの様に振る舞うのだったか。
    |   →history -c をしても bash が履歴ファイルを読み取る。
    |   つまり、history -c の場合も未初期化の場合には何もしない事にすれば良い。
    |
    | * history -s に関してはやはり履歴を読み取ってから、
    |   その後にデータを追記する様にするのが良い気がする。
    |
    |   実際に ble.sh で動かしてみた所、読み取れていない。何故?
    |   と思ったら decode attach していない時には単純に history -s
    |   を呼び出すだけという実装になっていた。これは修正する。
    |   別に初期化はどのタイミングで実行しても問題ない筈なので。
    |
    | * history -r に間しては微妙である。
    |   履歴の読み取りを抑制してしまって良いのか。
    |   元の bash の振る舞いを見ると history -r file でファイルから読み込んで、
    |   更にその後で履歴ファイルからも読み取るという振る舞いになっている。
    |
    |   もう少し色々試してみても良いという気がする。
    |   →試してみた所 bash は history -r を実行すると、
    |   履歴を二重に読み取ってしまう。
    |   実はこれは現在の ble.sh の振る舞いと同じである。
    |   history -r によって履歴が倍加するのは許容する。
    |
    | * history -n に関しては履歴をその場で読み取って、
    |   追加で読み取るという事はしない。
    |
    | 後、単に履歴が空なのと実際に見初期化であるのをどのように区別するのか、
    | という問題が在る。history -c; source ble.sh とした場合に履歴が
    | ファイルから読み込まれてしまうのは果たして自然なのかという事である。
    | その他の方法で見初期化である事を判定する方法は存在するだろうか。
    | →これはどうしようもない。空ならばみ初期化と見做す事にする。


    まとめると、履歴が未初期化かどうかは現在履歴が空かどうかで行う。
    (Bash も履歴が空かどうかで履歴読み出しを実行するかしないかを決める様である。)
    未初期化の時の history の各操作の振る舞いは以下の様に決める。

    * history -awcd は何も実行しない。
    * history -snr は HISTFILE を読み取った後に実行する。
      これは bash の振る舞いとは異なるがこの振る舞いの方が現実的である。
    * history -p に関しては何も対処せず普通に実行する
      履歴の倍加は起こらないという事を確認した。

    この仕様の下で履歴が倍加するのは history -r を実行した時である。
    但し、保存される履歴に関しては倍加されず飽くまでも実行時に倍加するのみである。
    因みに元の bash でも history -r を実行すると履歴が倍加する。
    意図的に履歴を追加で読み取るという操作と区別がつかないのでこの振る舞いで問題ない。

    x fixed: __ble_edit__ が付加される?
      これは何だろう。というよりそもそも __ble_edit__ を付加するのは何故だったか。
      →調べたらこれは __ble_ext__ の間違いであった。
      61f4bd1 で __ble_edt__ を __ble_edit__ に直したが、直し方が違った。
      これは ble-0.3 にはない問題なので commit を分ける必要もない。
      今回、一緒にこれも直してしまう。

2020-04-06

  * global: builtin declare は oil が対応しないと言っている [#D1313]
    そもそも ble.sh でも declare の上書きは削除しているので、
    ここで builtin を指定する必要はない気がする。
    何より他の declare -p だとか local では builtin は指定していない。

    削除している物についての無駄な builtin は消す事にする。
    使われている箇所を確認すると以下の通り。

    | $ grc --exclude=\*.md -Wg,--color=none -o 'builtin [[:alpha:]]+' |
    |     grep --color=none -Eo 'builtin [[:alpha:]]+' |
    |     sort | uniq -c | sort -rn
    | 179 builtin eval
    |  65 builtin history
    |  42 builtin bind
    |  28 builtin read
    |  28 builtin printf
    |  23 builtin trap
    |  13 builtin exit
    |  10 builtin unset
    |  10 builtin echo
    |   8 builtin kill
    |   8 builtin compgen
    |   6 builtin complete
    |   3 builtin cd
    |   2 builtin unalias
    |   2 builtin type
    |   2 builtin sleep
    |   2 builtin mapfile
    |   2 builtin compopt
    |   1 builtin return

    この内で unset によって上書きをキャンセルしているのは以下の3種類だけである。
    eval, unset, unalias

    % * eval: うーん。eval は 179 箇所で builtin eval している。
    %   然し、eval に関してはユーザが勝手に削除すると悲惨な事になると予想されるので、
    %   まあ、取り敢えずそのままにしておく事にするのが良い気がする。
    %   →と思って確認した所 builtin なしで eval している箇所も沢山ある。
    %     数えたら 149 箇所である。これは取り敢えず後で修正する。
    %
    % * ok: builtin unset に関しては調べると unlocal で使っている。
    %   これは確かに関数などに置き換えられていると意図した様に動かない可能性が高いので、
    %   明示的に builtin unset を指定する事にする。Note を追記しておいた。
    %
    %   →やはり全て builtin を記述する事にしたので Note は削除した。
    %   # Note #D1313: unset は上書きできない様にしているので基本的にはbuiltin をつけな
    %   #   くて良いが、unlocal に用いる時だけはローカル変数のスコープの兼ね合いから明
    %   #   示的に builtin unset として置きたい。
    %
    % * unalias については上書き削除の目的だけでしか builtin unalias はない。
    %   そのままで良いという事にする?
    %   うーん。或いは全て builtin で呼び出す事にしようか。

    readonly だけ抜けているのは妙なのでこれも上書きをキャンセルする事にする。
    export, alias, unalias についてはそのままという事にする。

    * done: builtin をつけるかつけないかの一貫性は保って置きたい。
      やはり eval/unset/unalias はすべて builtin をつける事にした。
      eval についてはつけ終わった。unset についても終わった。
      unalias は少ししか無い。

    * done: builtin eval の後に -- を付ける必要のある箇所について確認する。

    * done: unset を自分で定義して readonly にしてしまえば良いのでは?
      →試しにその様にしてみる事にした。

  * util (bleopt): 未定義の設定が name:= で定義されない [#D1312]
    値が同じであると判定されて代入がスキップされていた。修正した。

  * decode (ble-bind): エラーメッセージ修正 [#D1311]
    keymap が見つからない時のエラーメッセージで keymap 名が出力されていない。

  * global: local -i 仕様の削除 [#D1310]
    oil が対応していない。元々排除しようと思っていた。
    良い機会なので削除する事にする。

    g2sgr 及び layer/update が引数を受けるのに使っている。
    使用箇所を確認したが何れの場所も整数しか入らない様に見える。単に削除する。
    ble-measure は内部的に使っていたが意味のない物だったので単に削除する。

  * test: テストフレームワーク [#D1309]

    既存のフレームワークについて確認する。

    * bats
      これは自分で 成功・失敗 を判定しなければならない。
      例えば期待する出力と実際の出力を比較するという様な機能はない?
      唯単に集計するだけの枠組みの様に思われる。

    * oil/test
      これは期待する出力と実際の出力を比較する機能がある。
      終了ステータスを確認する機能もある。
      様々なシェルで同時にテストする機能もある。
      シェル毎に期待する結果を比較する事もできる。

      * 様々なシェルで同時にテストする事ができたのは、
        oil のテストはシェルに対するテストで、
        個別のテストが独立した小さなプログラムだからである。
        通常のシェルスクリプトのテストの場合には、
        シェルスクリプト全体を読み込んだ上で実行しなければならないので、
        ble.sh の様な巨大なスクリプトの場合には向かない。

        対応するとしても、一つのシェルで一気にテストを実行して、
        それを後で集計するという形式にする必要がある。
        その様な実装であれば実は後で実装すれば良いので余り気にしなくても良い。

    * shellspec
      https://qiita.com/ko1nksm/items/9053e9c1e42a2ae9033e
      並列でテストする機能がある。
      coverage を計測する機能がある。
      期待する出力と実際の出力を比較する機能もある。

    既存フレームワークを眺めた結果の考察

    * 実際の所、oil/test 的な仕組みが最も使いやすいのではないかという気がする。
      但し、テストに要する時間に関しては微妙かもしれない。

    * 何れのフレームワークも何らかの DSL を作っている。
      bats 及び shellspec は特に奇を衒った事をしている。
      然し、正直な感想を言えば DSL を作ることで便利になっているのかは微妙である。
      余り DSL を作った事による利点を活かせていない気がする。

      それに DSL にするとその DSL のデザインに気を取られてしまう。
      できるだけシェルとして自然な形にまとめられないか。

      例えば、テストのタイトルは変数に入れる。
      テストのスクリプトは関数として定義する。
      それでも、期待する出力及び終了ステータスは直に書きたい。
      heredoc で定義するしか無いだろうか。

      | TITLE='hello world'
      | test() {
      |   コマンド
      | }
      | ble/test <<EOF
      | ## COMMENT
      | 何らかのコメント
      | ## EXPECT
      | 通常の期待出力
      | ## EXPECT 0 BUG bash-3.0
      | bash-3.0 における出力
      | EOF

      もしくは

      | title='hello world'
      | test() {
      |   ...
      | }
      | ble/test/expect <<EOF
      | ...
      | EOF
      | ble/test/expect -x0 -tBUG -sbash-3.0 <<EOF
      | ...
      | EOF
      | ble/test test

      うーん。或いは、alias を使ってしまう?
      →然し、試してみて思ったのは heredoc だと
      インデントが TAB しか使えないという制限がある。
      そしてそれを意識しなければならないのは辛い。

      heredoc 以外だと oil, shellspec の様にコメントを使う手があるが、
      それだと結局ひとつ上の枠組みで何らかの処理をする必要があり、
      結局 DSL を構築するのと大差ないという気がする。

      そういう事であれば ble.sh の場合には
      mwg_pp を使ってスクリプトを生成するのが自然である。
      と思ったが mwg_pp の枠組みでもインデントを検出するのは難しい。
      そうすると結局新しい DSL を作る事になってしまうのか。

    うーん。取り敢えずすべて忘れて実装してみたが、
    これで良い気がしてきた。取り敢えずはこれでやって行く事にする。

2020-04-01

  * bash-5 で heredoc を failglob で使うと駄目 [#D1308]
    変数に含まれる \ がパス名展開を誘起してそれにより失敗する。
    これも今実行してみると再現しない。但し、これに関しては原因を探れば
    再現する方法も自然に分かるという気がする。

    調べると nparam に問題の文字列を格納している。
    然し、nparam 自体はパス名展開の対象となる様な文脈では用いられていない。
    だとすると stat の方が怪しいだろうか。
    と思って眺めていると ble/syntax:bash/is-complete に怪しい所がある。
    というかこの is-complete とは何だろうか。うーん。

    ble-edit/is-single-complete-line から参照されている。
    複数行でかつ貼り付けでない時に呼び出される。未だ再現しない。
    →分かった。echo <<$(echo EOF) で再現した。
    そして見つけた箇所を修正したらちゃんと再現しなくなった。OK

  * OK: history: "history -d 負の数" にちゃんと対応していたか? [#D1307]
    bash-5.0 changes を見ていて気付いたが対応した記憶がない。
    と思って実装を確認してみたらちゃんと実装していた。OK

  * global: TMOUT が設定されているとあらゆる read が timeout して [#D1306]
    変なことになってしまうのではないだろうか。

    先ず初めに TMOUT の振る舞いについて調べる事にする。
    * -t が指定されている時には TMOUT の影響は無いようである。
    * TMOUT に不正な値を指定してもエラーになる訳ではなく単に無視される。
      '1 2' などの数値の後に何かごみがある場合でも無視される。
    * 算術式展開は実行されない。
    * 負の値を指定しても無視されるだけである。
    * 十六進数リテラルは無視される。

    m check で read があるので基本的に builtin read だけ確認すれば良い。

    * read の TMOUT に対応した。
      と思ったがわざわざ自分で -t を指定する必要はあっただろうか。
      実は builtin read が自動的に TMOUT を読むから不要なのではないか。
      と思ったが、-e を指定している時には自分で処理しなければならない。
      →確認した。この実装で問題ない。

  * global: shopt -s assoc_expand_once という設定は丁度 extra subscript expansions [#D1305]
    を off にする為の設定の様である。然し、これは連想配列に対してしか有効でない様だ。
    以下の例では、連想配列にした途端に添字展開が行われなくなる例。

    $ shopt -s assoc_expand_once
    $ expr='x[$(echo hello >/dev/tty)]'
    $ ((expr))
    hello
    $ declare -A x
    $ ((expr))
    $

    うーん。これを考えると実は連想配列の添字について再度確認しなければならないのでは。

    $ shopt -s assoc_expand_once
    $ declare -A A
    $ key=123; A[$key]=1234
    $ declare -p A
    declare -A A=([123]="1234" )
    $ echo ${A[$key]}
    1234
    $ A["x$key"]=321
    $ declare -p A
    declare -A A=([x123]="321" )

    まとめると、A[...]=... 及び ${A[...]} は影響を受けない。
    算術式の中の配列添字の展開は影響を受ける。
    history.sh の [\$file] は shopt を変更して対応するか、
    或いは shopt の設定に依存しない形に書き換える必要がある。
    これは書き換える方向で調整する事にする。

  * global: OK: shopt -u expand_aliases という設定がある事に気付いた [#D1304]
    現在の ble.sh ではこの設定に関係なく alias を展開している気がする。
    と思って確かめてみたが最初に type で種類をチェックしている。
    どうやら -u expand_aliases の時には type で見つからない様なので、
    現在の実装でちゃんと expand_aliases に応じた振る舞いになっている。
    以下の二つともその様な実装になっている。
    - ble/util/expand-alias
    - ble/widget/command-help/.type

2020-03-29

  * syntax: [!...] が履歴展開文字を含む為に単純単語ではなくなっている (reported by cmplstofB) [#D1303]
    https://github.com/akinomyoga/ble.sh/issues/47

    [!...] に関しては unquoted [! の場合には必ず履歴展開は無効になる様だ。
    例えば [echo!echo] だと履歴展開が有効だが
    [echo[!echo] だと履歴展開は無効である。
    という事なので [! の組み合わせを無条件に単純単語に含めて良い様にしてOK?
    と思ったら [echo[!echo だと履歴展開は有効になる様である。よく分からない。

    [!echo]   無効
    [a!echo]  有効
    [a[!echo] 無効
    [a[!echo  有効

    * reject: 逆に履歴展開を許容するという案はあるだろうか?
      然し、s/aaa/bbb/ は副作用を持つ。
      これが問題になるケースがあるのではないだろうか。
      うーん。やはりある気がする。サブシェルで実行するという手もあるが面倒である。
      何より単語が沢山ある時に速度が低下してしまう。履歴展開の文字が含む場合だけ
      特別扱いしても良いがそれはそれで面倒な事になる。

    ? no: というかそもそも simple-word/eval で履歴展開は実施されるのだったか。
      取り敢えず [! を許容しても eval の内部で履歴展開が発生しない事は確認した。
      少なくともこの変更によって副作用が発生したりおかしな事が発生することはない。

      | $ ble/syntax:bash/simple-word/eval '[A[!echo'; echo $ret
      | [![!echo
      | $ ble/syntax:bash/simple-word/eval '[A[!echo]'; echo $ret
      |
      | $ ble/syntax:bash/simple-word/eval '[a[!echo]'; echo $ret
      | a

    eval で履歴展開が実施されるとしてもされないとしても下手に一致して着色されると
    履歴展開の着色が単語着色で上書きされてしまってそれはそれで分かりにくい。
    やはり履歴展開が起こる場合には履歴展開の着色が有効になっていて欲しい。
    履歴展開は時に破滅的な結果を齎すのでこれが上書きされるのは避けたい。
    [a[! のパターンに関しては現在構文レベルでも判定できていないし、
    閉じる ] を見るまで分からないのでこれは相当先読みしないと判定できない。
    従って将来的に構文的にも対応することはないと思われる。
    従って [a[! のパターンで履歴展開が有効になるケースは取り敢えず無視して良い。

2020-03-27

  * decode: 大量貼り付け高速化に関連する問題の修正 [#D1302]

    * fixed: bash-4.1 で日本語を入力すると謎の空白が入ってしまう。
      以前はこの現象はなかった筈。UTF-8 decode を調べたが特に問題はない。
      ble-decode-key で受信しているキーの列にも問題は見られない。
      どうも batch-insert で変な空白が追加されている様子である。
      →ble/util/chars2s の問題であるという事が判明した。
      →分かった。join する所のエスケープを間違えていた。修正した。

    * fixed: bash-4.3 で途中までしか入力できない。
      nonblocking-read の結果が空になっている。
      うーん。何とそもそも builtin read で一文字も読めていない?
      →builtin read を実行したら 142 になって何も入っていない。
      そして実際にはデータを読み終わっている様子である。

      →実際に試してみると bash-4.3 以下では
      timeout した時には読み取ったデータは失われてしまう様だ。
      これの回避方法は存在するだろうか。うーん。取り敢えず…
      1 byte ずつ読み取る方法で実装してみる事にした。
      →実装した。動作している。まとめて読み取るのよりは遅いが、
      bind -x 経由よりも格段に高速である。

    * fixed: bash-4.3 で .check-abort に失敗している。
      何故か無引数で ble-decode/.hook が呼び出されている様である。何故?
      先ず FUNCNAME を調べる。

        @ /home/murase/.mwg/src/ble.sh/out/ble.sh:1073 (ble-stackdump)
        @ /home/murase/.mwg/src/ble.sh/out/ble.sh:4634 (ble-decode/.hook )
        @ /home/murase/.mwg/src/ble.sh/out/ble.sh:1 (ble-decode/.hook 54)

      つまり再帰的な ble-decode/.hook の時に引数を渡すのを忘れている?
      % 調べるとどうやら ble/array#pop が動作していない様である。
      % 手で実行すると動作しているように見える。
      % と思ったら ble/array#pop の使い方を誤っていただけだった。動いている。
      違った、その前に既に _ble_decode_input_buffer に大量の空文字列が登録されている。

      →分かった。これは書き換えた時に split-words が split になってしまっていた。

    * fixed: bash-4.3 nonblocking の読み取りで空白が全て消滅している。どういう事だろう。
      と思ったら分かった。これは IFS である。一文字しか読み取らない場合でも IFS= は必要だ。
      IFS= を設定したら直った。
      bash-4.0 で 10k 文字入力したら遅いが動かない事はない。

    * resolved: bash-4.4 で試したら先ず nonblocking-read でブロックしている気がする。
      少なくとも progress-bar が止まってしまっている。
      動作確認する必要がある。それから nonblocking-read は bash 3.* では使えない。
      少数の read -t に対応していないので。

      local time1=$EPOCHREALTIME
      local time2=$EPOCHREALTIME
      bc -l <<< $time2-$time1; echo N=$N

      確認してみた所、先ず ble/array#push に 1.0s かかっている。
      うーん。これは後で対策を考える必要がある。
      更に、decoding... が表示されるまでに時間がかかる。
      然し、一応待っていれば動作はする様である。
      因みに2回目の貼り付けではそんなに時間がかかっていない?
      不思議である。これは何だろうか…。

      * ble-decode/.hook 内のボトルネック
        array#pop は一瞬で終わっている。
        chars=("${...[@]}" "$@") が 13 秒もかかっている。何故?
        更に分割すると chars=("${input_buffer[@]}") だけでも13秒かかっている。
        うーん。関数経由で chars に代入する様に変更したら 0.4s に減少した。
        然し、push の方は 0.9s からこれ以上縮まりそうにない。
        これは諦める事にする。

      * ble-decode/.hook 内の progress bar (nonblocking-read) が全く動かない
        と思ったがこれは上と全く同じ原因だった。0.9s の push を縮めるしかない。

    * resolved: bash-4.4: 更に processing input が開始するまでにも時間がかかる。
      これも配列のコピーが原因だった。91s かかっていたのが 0.86s にまで短くなった。

    * resolved: bash-4.0: constructing text が終わった後が長い。止まっている。
      もしかしてそもそも editor 起動が有効になっていない可能性?
      CPUはずっと走っている。→ずっと経ってから確認したら editor が起動していた。
      後でCPU時間を確認すると13m走り続けていた様だ。
      何が起こっていたのだろうか。

      と思ったら char2s の中でとんでもない事をしていた。
      毎文字 join していた。ループの外に出した。
      然し、それを修正しても大分時間がかかっている。何故。

      うーん。どうも配列に格納したデータを読み取ると物凄く時間がかかる様だ。
      文字列に 0x80 未満の文字を格納してそれを引く様にしたら一瞬で起動した。
      14s かかっていたのが 0.245s である。

      % debug1=$' \x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F'
      % debug1=$debug1$'\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F'
      % debug1=$debug1$'\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2A\x2B\x2C\x2D\x2E\x2F'
      % debug1=$debug1$'\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3A\x3B\x3C\x3D\x3E\x3F'
      % debug1=$debug1$'\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4A\x4B\x4C\x4D\x4E\x4F'
      % debug1=$debug1$'\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5A\x5B\x5C\x5D\x5E\x5F'
      % debug1=$debug1$'\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6A\x6B\x6C\x6D\x6E\x6F'
      % debug1=$debug1$'\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7A\x7B\x7C\x7D\x7E\x7F'
      % function ble/util/chars2s.impl {
      %   local -a buff=()
      %   local c i=0
      %   for c; do
      %     if ((c<0x80)); then
      %       ret=${debug1:c:1}
      %     else
      %       ble/util/c2s.cached "$c"
      %     fi
      %     buff[i++]=$ret
      %   done
      %   IFS= builtin eval 'ret="${buff[*]}"'
      % }

      色々 benchmark して調べたがどうも遅い原因の一つは大量の引数を抱えた関数から
      子供の関数を呼び出すのが思いという事のようである。上で改善したのは純粋に
      文字列にした事で高速化したのではなくて関数呼び出しが減った事による効果である。
      再度計測し直してみた所、寧ろ文字列の index を用いて参照すると遅くなる様である。
      文字列の長さを工夫すればもう少し高速化できるのかもしれないが面倒なので考えない。

2020-03-24

  * ble-bind: Unknown widget `-'. という表示が出る (reported by dylankb) [#D1301]
    https://github.com/akinomyoga/ble.sh/issues/46

    調べてみると未対応の rlfunc があるとこれが必ず出る様だ。
    取り敢えず修正する必要がある。未対応です、という表示が出るのが望ましい。

    或いは無害な物に関しては nop を出して無視する。
    調べたが skip-csi-sequence については nop では駄目である。
    そもそも bind しては行けない。
    無害な物に関しては nop に束縛するのではなくて何にも束縛しない。

    * arrow-key-prefix は何かと思って bash のソースを確認したら、
      次の文字を読み取って ABCD だったらカーソルキーの既定動作に
      dispatch するという感じの物だった。
      恐らく SS3 A/B/C/D だとか ESC A/B/C/D だとか、
      そう言った物に一括で束縛する為の物なのだろうと思われる。
      これは無視ではなくて未対応とするべき。
      というより新しく widget を作っても良いのかもしれない。

    * tty-status は ioctl(TIOCSTAT) を呼び出すらしい。
      これは何かと思って検索したら /* generate status message */
      /* simulate ^T status message */ 等という説明が見られる。
      FreeBSD/OpenBSD にはあるが Linux にはない機能の雰囲気である。
      これは適当に模倣して実装しても良いのかもしれない。
      これも取り敢えず未対応という事で良いだろう。

    取り敢えずちゃんとエラーメッセージは出るようにした。
    次の報告が来た。恐らく emacs-editing-mode と vi-editing-mode
    を bind しようとしている /etc/profiles.d/? があるという事だろう。
    勝手に変な設定をしようとするものがあるのも考えようだが、
    然し、bash 互換を考える上では避けようがないという事なのだろう。
    何処かには ble.sh の様に bash の細かい動作に依存する設定があるはずで、
    つまり ble.sh の上で他の ble.sh 実装が動くかどうかというレベルの話になる。
    少しでも穴があれば動かなくなるという事なのである。

    emacs-editing-mode / vi-editing-mode の動作について確認する。
    bash で試してみた所によるとこれらは set -o emacs / set -o vi
    の設定まで変更する様である。ble.sh ではどの様に対応するべきか。
    set -o emacs を変更せずに実行するか。或いは、実際に set -o emacs
    を実行する事によって対処するか。もし set -o emacs を使って実装すると
    したら実は結構簡単な気がする。然し、default_keymap=emacs 等としていた
    場合には set -o vi をしても振る舞いに変化がないという事になってしまう。
    そういう意味では default_keymap も一緒に弄ってしまうというのが手なのだろうか。

    取り敢えず、ble.sh edit.sh で set -o が変化した時にどう振る舞っているか確認する。
    確認した所、set -o emacs/vi が変わった場合には単に ble.sh が動作の基準としている
    keymap を切り替えるだけであって、その上で何が動いているかに関しては関知していない雰囲気だ。

    * bleopt default_keymap=... を設定した時に reset-default-keymap を実行する様にする。
      現在だとこれを実行してもその場では keymap は変化しない様である。
      →対応した。何事もなく動作している。意外と呆気ない事だ。
    * set -o emacs/vi をどの様に実行するか。
      確認したが .check-detach は gexec の後に呼び出されている。
      つまり、set -o emacs/vi をコマンドとして実行するか、
      或いは、.check-detach で行っているのと同様の操作をその場で実行するか。
      後者で実装するのが自然である。

      うーん。単純に set -o ... してから以下を実行すれば良いだけ?
      ble/decode/reset-default-keymap
      ble/decode/detach
      ble/decode/attach

  * decode: 大量の貼り付けの高速化3 (report by dylankb) [#D1300]

    * うーん。ble/util/c2s が遅いのだと考えて高速化してみた。
      大分高速化した気がする。然し、緑が 99% になってから、
      赤色が表示されるまでの時間は変化していない。

      | # A. NUL を unset してから実行
      | local index0=$index ret ins
      | for ((;index<N;index++)); do
      |   ((chars[index])) || unset -v 'chars[index]'
      |   ble/widget/batch-insert.progress 2357
      | done
      | ble/util/chars2s "${chars[@]:index0}"; ins=$ret
      |
      | # B. 連続する非零のコード毎に変換を実行
      | local p q=$index ret ins=
      | for ((p=q;q<N;q++)); do
      |   if ((!chars[q])); then
      |     if ((p<q)); then
      |       ble/util/chars2s "${chars[@]:p:q-p}"; ins=$ins$ret
      |     fi
      |     ((p=q+1))
      |   fi
      |   ble/widget/batch-insert.progress
      | done
      |
      | # C. 一文字ずつ変換
      | local ret ins=
      | while ((index<N)); do
      |   ble/util/c2s "${chars[index]}"; ins=$ins$ret
      |   ((index++))
      |   ble/widget/batch-insert.progress
      | done

    * decode phase も実は簡略化できる筈。
      receive + decode を read & printf ' に変換するのである。
      と思ったが本当だろうか。整数に変換する必要があるが、
      それを高速に実行する事は可能だろうか。

    もうひとつ気になるのは screen 越しだと
    bracketed paste mode が有効になっていない気がする。
    或いは bracketed paste の終了がちゃんと受信されていない?
    まあ、これに関しては別に考える事にすれば良い気がする。

    * そうすると processing input... の部分が気になる。
      うーん。これは _ble_decode_char__hook を使ってループを回しているのが悪い。
      というか bracketed paste に関しては decode の側で特別に取り扱ってしまって良いのでは?
      但し、それによってどれだけ高速化するのかについては疑問が残るが…。

      見ていて気付いたが progress bar は 50 文字毎に表示している。
      53kB に入力に対しては 1000 回update する事になる。
      これが実はボトルネックなのでは。。と思って確かめてみた。
      50 から 200 にしたら 10s だったのが 6s に縮んだ。
      計算するに 5s 弱が実質の計算時間だったという事。
      逆に言えば 5s よりも早くはならない。

      さて、decode の側で key の解釈の時に一括で処理する事を考えてみたが、
      よく考えてみたら現在は _ble_decode_char__hook に介入しているので、
      key の解釈よりも前の段階での介入である。つまり、key の解釈で
      一括処理する様に変更しても対して意味がないのである。

      _ble_decode_char__hook で本質的に関係する部分だけ抜き出すと。

      * ((_ble_debug_keylog_enabled)) の時は一括処理を諦める。
      * [[ $_ble_decode_keylog_chars_enabled ]] のときも諦める。
      * 次の文字が _ble_decode_Erro の時には処理しない。

      これらの元でループ構造は以下の様に単純化される。

      | while
      |   ((ble_decode_char_rest))
      | do
      |   char=${chars[ichar]}
      |   ((ble_decode_char_rest--,ichar++))
      |
      |   ((char&=~_ble_decode_Macr))
      |
      |   # decode error character
      |   # if ((char&_ble_decode_Erro))
      |
      |   if [[ $_ble_decode_char__hook ]]; then
      |     ((char==_ble_decode_IsolatedESC)) && char=27 # isolated ESC -> ESC
      |     char を処理する
      |   fi
      | done

      うーん。decode.sh の側で "次の文字を読む" という操作を提供しても良い気がしてきた。
      その様に実装した。大分高速になった気がする。

    * さて、緑から赤に移る時の沈黙は何だろうか。
      引数を大量に渡すのに時間がかかっているという事だろうか。
      と思ったらそうではないようだ。

      文字列の置換処理に時間がかかっている?

      X:1584874227.928681
      Y:1584874227.929155
      Z:1584874227.936170
      W:1584874227.942291
      N:1584874231.373286

      と思ったら違う。この処理に時間がかかっている: chars=(${chars//:/' '})
      もしかしてパス名展開が試みられているという事だろうか。
      3秒もかかっている。ble/string#split を使ったら 0.03 にまで短縮した。

      X:1584874420.330993
      Y:1584874420.367348

    * 残っているのは byte を読み取る部分…。
      UTF-8 safe な byte を読み取ったらその次の瞬間に一気に読み取って良いのではないか。
      然し、UTF-8 safe な byte かどうかの判定で余計に時間がかかってはいけないし、
      よく考えたら日本語主体の文章の場合には UTF-8 safe な値はなかなか期待できない。
      一応改行は大丈夫だが改行のない文章が大量にやってきた場合はどうするのか。

      或いは、LC_CTYPE=C にして一気に読み取ってしまえば良いのかもしれない。
      decode に関しても余り深く考えずに一気に実行する?
      うーん。システムのエンコーディングと受信のエンコーディングが一致している
      時に限るが、そのまま組み立ててしまって良いのではないか。

      うーん。取り敢えず実験的に実装してみる事を考える事にする。

      受信をする時に問題になるのは NUL を含む文字列は受信できないという事。
      中途半端なバイトが含まれる時に ${str::x} の様な処理ができないという事。
      mapfile には timeout がないので read に頼るしかない。

    * decode は結構時間がかかっている。
      というか今思ったが現在の decode の処理は改善できる気がする。

      先ず初めに現在の変換時間を計測する。約12.7s
      X:1584885577.441244
      Y:1584885590.163676

      約12.2s 先ず配列に代入してから ble-decode-char を呼び出しているのを、
      直接一つずつ ble-decode-char を呼び出す様に変更してみる。殆ど違いはない。
      X:1584885521.873851
      Y:1584885534.093266

      約11.8s 算術式の不要な空白を全て潰してしまうとどうなるか。
      これも微妙に短くはなるが本質的な違いではない様に思われる。
      X:1584885811.187881
      Y:1584885822.967141

      約11.0s byte<0x80 だけ特別扱いしたらこう。
      X:1584886104.316627
      Y:1584886115.267994
      | ((byte&=0xFF))
      | ((mode)) && (((byte&0xC0)!=0x80&&(cha0=_ble_decode_Erro|code,mode=0)))
      | if ((byte<0x80)); then
      |   char=$byte
      | else
      |   ((byte<0xF0?(byte<0xC0?(byte<0x80?(char=byte):(
      |     mode==0?(char=_ble_decode_Erro|byte):(code=code<<6|byte&0x3F,--mode==0&&(char=code)))
      |     ):(byte<0xE0?(code=byte&0x1F,mode=1):(code=byte&0x0F,mode=2))):(byte<0xFC?(byte<0xF8?(
      |     code=byte&0x07,mode=3):(code=byte&0x03,mode=4)):(byte<0xFE?(code=byte&0x01,mode=5):(
      |     char=_ble_decode_Erro|byte)))))
      | fi

      約11.0s テーブルに入れて見たが速度は変わらない。
      よく考えてみたら byte<0x80 だけ特別扱いするのと対して変わらない。
      X:1584886995.051122
      Y:1584887006.049388
      | ((byte&=0xFF))
      | ((mode)) && (((byte&0xC0)!=0x80&&(cha0=_ble_decode_Erro|code,mode=0)))
      | ((_ble_encoding_utf8_decode_table[byte]))

      約11.0s 完全にテーブルに入れてみても対して変わらない。
      X:1584887425.167250
      Y:1584887436.189649
      | function ble/encoding:UTF-8/decode {
      |   local code=$_ble_encoding_utf8_decode_code
      |   local mode=$_ble_encoding_utf8_decode_mode
      |   local byte=$1
      |   local cha0= char=
      |   local stray='cha0=_ble_decode_Erro|code,mode=0'
      |   ((_ble_encoding_utf8_decode_table[$1&0xFF]))
      |   _ble_encoding_utf8_decode_code=$code
      |   _ble_encoding_utf8_decode_mode=$mode
      |   [[ $cha0 ]] && ble-decode-char "$cha0"
      |   [[ $char ]] && ble-decode-char "$char"
      | }

      約10.9s うーん。変数名を少し短くしてみたら微妙に改善した。
      X:1584887850.303309
      Y:1584887861.235152

      約9.9s decode を複数の引数を受け取るように変更したら改善した。
      X:1584915662.010331
      Y:1584915671.917756

      約4.2s 何と ble/array#push を A[i++]= に書き換えたら物凄く高速になった。
      結局全体で 5s ぐらいしかかかっていない。40s からの劇的な改善である。
      X:1584916592.860743
      Y:1584916597.017316

      大分改善した。取り敢えずはスクリプト上での
      decoder はこれで良しとする。

    * もっと巨大なデータを受信した時に外部プログラムを起動して
      decode する可能性?

      awk を使うか。或いは od を使って上手にできないか。
      或いは、printf $'' してから "${str::}" で読み取る手法?
      これは UTF-8 依存になるので、UTF-8 の側で処理する?

      というか現在の実装だって UTF-8 の側で処理して良い気がする。

      例えばこう。
      ble/util/printf ret '\x%02x' "$@"
      eval "ret=\$'$ret'"

      * 問題は 0 をどうするのかという事。
        0 は 0 に翻訳するという事で良い。

        →0の処理方法について確認しようとしたら微妙。
          \xC0\x80 にしたら実は表現できるかもしれないと考えたが、
          実際にやってみると二文字に分割されて解釈されている。
          文字数のカウントも2文字になっている。

        これが意味する所は、bind 経由で受信した 2B 表現も、
        bash の中で直接にバイトに変換すると破壊されてしまうという事。
        C0,C1 はその意味で特別に処理しなければならないのである。

      * そもそも本当に高速になるのか?
        これは実験してみないと分からない。
        実際に実装してみたが 5.2s である。
        寧ろ遅くなっている気がする。
        X:1584923880.134245
        Y:1584923885.336910

        うーん。何だか振る舞いが変である。
        わかった。修正した。変数 M を上書きしていた。

        改めて計測する。やはり 5.2s である。
        X:1584937548.825580
        Y:1584937554.059262

        その場で printf -v するようにした。
        % 5.7s, 5.6s である。計測ミスだった。
        % X:1584937775.759084
        % Y:1584937781.359048
        % X:1584937714.687243
        % Y:1584937720.327925
        約4.6s になった。高速化している。
        X:1584937868.273119
        Y:1584937872.934848

        元々の s2c の場合の速度を見ると 5.22s だった。
        printf の中で index 指定をするのを避けたら 4.85s になった。
        ${s:k:1} ではなく ${s:k} を渡すと 5.17s に遅くなる。
        長い文字列を渡しているのが遅い原因だろうか。
        %d を '%d' に quote したら 4.86s である。誤差の範囲内。

      さて、元の実装の速度が 4.1s であったから、
      これは寧ろ遅くなっている。
      printf -v で数値を取り出すのは自前で計算するよりも遅いという事。

      そもそも何故この実装を考えたのかというと、
      文字コードを抽出する事を想定していなかったから。
      そのまま文字列を構築してそれをファイルに出力するという想定だった。

      取り敢えず実装は此処に残して置く事にする。

      | function ble/encoding:UTF-8/decode2 {
      |   local C=$_ble_encoding_utf8_decode_code
      |   local M=$_ble_encoding_utf8_decode_mode
      |   local S='e=_ble_decode_Erro|C,M=0'
      |
      |   local -a B; B=("$@")
      |   local -a A=()
      |   local a=0 e= c=
      |
      |   local -a stop=(); stop[0]=1 stop[192]=1 stop[193]=1
      |   local i N=$#
      |   for ((i=0;i<N;)); do
      |     while ((i<N)) && ((stop[B[i]]||M)); do
      |       e= c=
      |       ((_ble_encoding_utf8_decode_table[B[i]&255]))
      |       [[ $e ]] && A[a++]=$e
      |       [[ $c ]] && A[a++]=$c
      |       ((i++))
      |     done
      |
      |     ((i<N)) || break
      |
      |     j=$i
      |     while ((j<N)) && [[ ! ${stop[B[j]]} ]]; do ((j++)); done
      |
      |     local ret
      |     ble/util/sprintf ret '\\x%02x' "${B[@]:i:j-i}"
      |     eval "local s=\$'$ret'"
      |     if [[ $s ]]; then
      |       local k K=${#s}
      |       for ((k=0;k<K;k++)); do
      |         ble/util/s2c "${s:k:1}"
      |         A[a++]=$ret
      |       done
      |     fi
      |     i=$j
      |   done
      |   _ble_encoding_utf8_decode_code=$C
      |   _ble_encoding_utf8_decode_mode=$M
      |   ((a)) && ble-decode-char "${A[@]}"
      | }

    * done: s2c の実装を見直す。

    * done: うーん。bind で -s を経由して受信している時には、
      read を直接実行すると変な事になるのではないか。
      つまり、read を実行するのは通常文字の直後である必要があるのでは。
      取り敢えず、-s 経由で受信される可能性のある文字について init-bind で確認する必要あり。
      -s 経由の受信で一番最後の文字以外の文字については read-nonblock を実行してはならない。

      取り敢えず対応した。また今後の変更の為に init-bind.sh に説明を書いた。
      本当は init-bind.sh の側で変数などを提供するのが良いのかもしれないが、
      面倒だし、今後マクロが追加される事があるのかも不明なので取り敢えず放置する。
      本当は他の人が将来的に編集する可能性なども考えると良くないのかもしれないが。

2020-03-14

  * rps を設定している時に変な文字で右余白が埋められている…。 [#D1299]
    一体これは何だろうか。後で調べる必要がある。

    これは screen-4.99 のバグである。

    | うーん。怪しいと思ったのは ble/textmap#update の中の
    | eraser の生成部分であるが確認してみると変な事は起こりそうにない。
    | というより場合分けが ech があるかないかで決まっている。
    | うーん。端末の方の ECH が壊れている可能性?
    |
    | mintty でも再現するからこれは screen/contra の問題ではない。
    | mintty の場合には空白の様に見えるが実際に選択しようとすると
    | 普通の空白と違って選択する事ができるのでこれはやはり何か変だ。
    | 単に ech しただけではやはりこの変な現象は起こらない。
    | とすると改行がある場合のセル内容を書き換えている別の箇所で問題が起きている?
    |
    | →うーん。空白を挿入した場合には特に問題は起こらない様だ。
    | やっぱり何かが ECH で変? 然し、空白挿入+ECH の場合や、
    | ECH+空白挿入 の場合には問題は発生しない。
    | だとすると問題の謎の文字はこれらの直前に描画されていて、
    | ECH では消えないけれども空白によっては上書きされる、という事?
    |
    | ble/textmap#update では _ble_textmap_glyph に値を代入している。
    | これを参照している箇所は edit.sh ble/textarea#update-text-buffer
    | の変更文字の置き換えだけである。
    | layer:plain/update はどうしているのかと思ったら独自に値を設定している。
    | ここでは改行は _ble_term_el を直接使っている。
    | うーん。調べたがやはり変な事は起こっていない気がする。
    |
    | screen の外では再現しない。と思ったら実は以下で再現すると分かった。
    | printf 'A\e[107m\e[X\n'
    |
    | これは ble.sh のバグではないという事になる。contra のバグであろうか。
    | 取り敢えず screen-4.7.0 では発生しないという事を確認した。
    | mintty x screen-4.99 でも再現する事を確かめた。
    | mintty だけでは再現しない。

  * complete: menu-filter を off にすると変な事になる [#D1298]
    https://oilshell.zulipchat.com/#narrow/stream/121540-oil-discuss/topic/.23257.20typing.20past.20the.20last.20column.20(interactive.20features)

    menu-filter が無効の時は 1. menu filter 着色はしない。
    2. menu から候補を拾う機能は off にしておくべき?
    或いは、前回の menu を表示した時からカーソル位置が変化していない時にのみ使う。
    これは後で対応しなければならない。

    というより menu から候補を拾う時に menu-filter を実行すれば良いのではないか。
    と思っていざ修正しようとしたら既にそういう実装になっていた。
    但し、menu-filter が有効になっているかの判定が足りていなかったのだ。
    2行修正(complete_menu_filter の判定追加)しただけで治ってしまった。

2020-03-13

  * decode: 大量の貼り付けの高速化2 (report by dylankb) [#D1297]
    Ref #D1296 #D1293

    やはり未だ遅い。具体的に計測してみた。dylankb の報告によると
    最初に decode が始まるまでが長いという事であるが。
    手許で計測している範囲では以下の様な構成である。

      recv    9sec
      decode  10sec
      process 50sec
      show    70sec

    別に受信にはそんなに時間はかかっていない。
    show に関しては editor に置き換えればそんなに時間はかからない。
    つまり目下の所のボトルネックは process である。
    色々弄って計測してみる事にする。

    o (20sec短縮) 文字列に追記する様にしていたが配列に変更してみた。
      この時 process は 30sec だった。受信バイト数は 53184 bytes であった。
      もう一度貼り付けてみて process の間に速度低下が見られるか確認する。

    process の間の速度を観察すると実は寧ろ高速化していく。
    つまり残りのバイトを管理している構造がボトルネックになっている気がする。
    $1==126 (~) のチェックをできるだけ早く行って見る事にしたが、
    30sec だった。全然速度は変わっていない。
    batch-insert の時間は 8sec だった。これは殆ど無視できる。

    o (3sec短縮) 配列の容量を時々縮める様にしたら 27sec になった。
      多少は効果があるのかもしれないが誤差の範囲内である。

    o (17sec短縮) ble-decode-char で set -- 及び shift ではなくて
      を使う様に変更したら一気に 10sec にまで縮んだ。
      コードを整理した。今後はこれを使う事にする。

    現在は以下の様になっている。

      recv    9sec
      decode  10sec
      process 10sec (bracketed-paste)
      insert  10sec (batch-insert)
      show    70sec

    * done: recv の過程を表示する様にする。
      特に大量のデータを受信した時に表示すると良い。
      decode_abort_char によるチェックはどのタイミングでするか?
      input_buffer に対する検査を行っている。

      と思ったが recv の途中では decode_abort_char を受信できない。
      パイプに流し込まれた全てのデータを取り出さないと
      ユーザが中止の為に入力した文字は受信できないのである。

      実装してみたが何だか変だ。
      →色々修正した。動く様になった。こんな所だろう。

    * fixed: 何故か2回目以降の貼り付けが物凄く遅い。
      と思ったら editor を起動する時に term/leave,
      enter を実行しなければならないのだった。
      直した。

    * done: batch-insert に関しても大容量の場合には
      progress を表示する事にした。

2020-03-12

  * bracketed-paste: やはり貼り付けに N^2 の時間がかかるのは何だか変な気がする [#D1296]

    1 先ず batch-insert は改行を含んでいるのだろうか。
      →調べてみた所、どうも batch-insert が全く呼び出されていない。

      うーん。has-input の判定が間違っている。
      恐らく input_buffer, char_buffer がある前は動いていたが、
      buffer する様になってから動かなくなったのだろう。
      然し、ble_decode_char_rest があればちゃんと has-input になる筈。
      ということはそもそもこの判定にすら達していない?

      →一文字ずつ入力している時にはちゃんと到達しているが、
      貼り付けをした時には全然達していない。
      と思ったが分かった気がする。bracketed paste である。

      * fixed: どうも bracketed paste で受信した文字列を貯める所が遅い様だ。
        実際に文字を挿入する所ではそんなに時間はかかっていない。
        →どうも paste_end の判定部分の気がする。
        と思って判定を追加してみたら大分高速化した。

      * fixed: 然し、今度は self-insert にかかる時間の方が気になる。
        試してみると emacs の方では大分高速である。
        うーん。改めて vi でやってみるとやはり遅い。
        emacs の方では一文字ずつ挿入するのを諦めている?
        ちょっと調べてみる事にする。emacs は batch-insert を用いている。
        vi_imap が self-insert を使っているのが遅いのである。
        文字数が多い場合には vi_imap でも batch-insert を使う様にするか。
        というか何で始めから batch-insert では駄目だったのだろうか?

        うーん。始めの実装は #D0639 にある。特に記述はない。
        この議論 #D0683 は余り関係ない。
        何故か #D0720 LASTWIDGET の実装時に何か修正している?
        ここの議論を読むと self-insert を拡張して同時に文字を挿入等と書いているので、
        実はこの時点では batch-insert が存在していなかった?
        調べてみると batch-insert が実装されたのは #D0849 である。
        という事は、恐らく batch-insert に対応した時に更新を忘れていたか、
        そのまま置き換えても問題ないか判断がつかなかったから放置された。

        取り敢えず vi_imap でも batch-insert を使う様に変更してみる。
        またテストとして imap repeat が batch-insert でも意図通りになるか確認する。
        →ちゃんと \C-c3a<paste>\C-[ で意図した通りに繰り返される。OK
        vi_nmap での実装も vi_imap の実装を最終的に呼び出している。OK

    2 改行がある度に構文解析をしているという可能性はないか?
      上の対処でかなり高速になったので、構文解析を無駄に実行しているという可能性はない。OK

    報告者の様子を見るとそもそも decoding というのが表示されるまでに時間がかかる?
    多分、結構遅いホストを使っているという事なのだろうと思われる。
    そうだとしても多少は高速化出来ないものだろうか。
    decoding というのが表示されるまでに実行するのは単に input buffer に貯めるだけの筈。

    3 うーん。input_buffer に貯めるという部分はこれ以上の高速化のしようはない気がする。
      律速はスクリプトの側ではなくて readline の側にあると考えてよいのではないか。
      分からないが取り敢えずそう想定して良い気がする。

      すると高速化の余地があるのは結局 bracketed-paste における終了条件だけである。

  * 大量のテキストを貼り付けた時の動作 (suggested by dylankb) [#D1295]
    https://github.com/akinomyoga/ble.sh/issues/45

    * 幾つか確認をしたが結局 C-x C-e を自動で呼び出す様に変更する事になる気がする。
      edit-and-execute をそのまま呼び出してしまって良いのだろうか。。
      然し、よく考えると edit-and-execute を実行するとしても、
      受信したバイト列を使って内容を編集してその後でエディタを起動する必要があるのでは。

      或いはそれ自体を別のプログラムで実行するという可能性?
      例えば awk の方が多少高速に実行できるかもしれない。
      と思ったがどうだろう。微妙である。

      何れにしても batch-insert に介入を行う。
      →と思ったが batch-insert で全て処理されると保証できるのか?
      batch-insert よりも後のユーザ入力が失われてしまう事になる。
      それらも全て処理した上でエディタを起動しなければならない。

      うーん。取り敢えず batch_insert_limit という設定名は変える。
      挿入操作の所々で batch_insert_limit の制限をチェックする事にする。
      →取り敢えず暫定的に edit_capacity, edit_overflow としている。

    x fixed: insert-word が曖昧候補に対して動作していない。
      確認してみたがどうも曖昧の種類を a から amA に拡張した時に
      変更を忘れていたという事の気がする。
      恐らく意図的に mA に対しては実行しないという事ではないと思われる。
      実際に self-insert に於いてはちゃんと ramA に対してテストしている。
      insert-word でも ramA に対して適用する様に書き換えた。

    * done: 取り敢えず discard については実装したと思う。
    * done: rename replace-limited
    * done: replace-limited と adjust 云々はくっつける。

    x fixed: edit-and-execute ではコマンドを灰色にして表示するべき。
      或いはコマンドを表示しない様に隠すべき。
      取り敢えず灰色にして表示する方向。

    * done: edit_overflow=truncate も実装したい。
      それから edit_overflow=editor も実装したい。
      然し、このチェックは一体何処で実行すれば良いだろうか。
      というか edit-and-execute は編集内容を表示したのだったか。

      先ず初めは truncate を実装する事にする。
      何処でチェックを入れるべきだろうか。
      batch-insert の直後でチェックする?
      然し、それだと通常の操作で truncate した時に適用されない。

      全ての入力の後に処理するのは非効率的だ。
      なので描画のタイミングの直前ぐらいでチェックするのが良い気がする。

    * done: 処理が重くなるのを防ぐ為には batch-insert
      でも適宜 truncate するのが良い。
      →その様にした。

    o ok: truncate をテストする必要がある。
      truncate は何となく動いている気がする。

    x fixed: discard に関しては挿入できる所までは挿入する筈なのに
      限界に達する時には何も挿入されないという事態になっている。
      何故だろうか。.replace-range が動いていない気がする。
      → inslimit を使って制限する所を iend-ibeg で制限していた。
      元々 inslimit を inslimit = max(inslimit, iend-ibeg) と書こうとして、
      そのまま次の操作と融合して変な記述になっていた。修正した。

    * done: 次に実装するのは editor である。
      簡単に実装した。これで本当に動くのだろうか。

    * ok: editor をテストする
      取り敢えず動いている気がする。
      コマンドラインに何も表示しないのは寂しいので
      コメントで範囲を超過したというメッセージを残す事にした。

    * done: 設定変数 editor を追加する
      blerc / wiki.ja / wiki.en

    * done: 設定変数 x 2
    * done: 設定変数 x 2 in wiki ja
    * done: 設定変数 x 2 in blerc
    * done: 設定変数 x 2 in wiki en

    * done: 後、履歴に巨大なデータが残るのも困る。
      history_limit_length という設定変数も追加したい。
      実装した。説明も追加した。

    * done: エディタの起動に失敗した場合はどうなるのか。
      truncate した方が良いのではないか?
      →その様に実装した。

    * done: truncate 等する時に特殊モードを抜ける。
      truncate する時にも mark や ind などがずれるので
      auto_complete や nsearch 等の様々なモードで変な事が起こりそうである。
      それを避ける為には特別のキーを発行してそれで truncate を処理するという手もある?
      例えば content_truncate もしくは content_editor 等の様に。
      →或いは truncate が起こったら truncate を実行してから
        content_truncate または content_editor を呼出して通知するという事にする。

      これは後で実装する事にする。
      →実装する。実装した。動いている。
      と思ったが何か変な気がする。

      isearch の途中にこれが発生したら何が起こるのか。
      うーん。isearch が強制終了する? それだけなら良いが、
      isearch の途中で editor が起動するというのは変である。
      editor が起動する条件を変更するべきなのではないか。
      というか edit-and-execute だって、vi_nmap では違う振る舞いをするべきなのでは。
      色々考えると、line limit というキーではなくて "キャンセル" 的なキーを実装して、
      更に元のモードによっては edit-and-execute は実行しないという様にする必要があるのでは。

      % と思ったが、その場でそれを実行することはできるのだろうか。
      % つまり queue に溜まっているキー入力に先立って処理する事は可能だろうか。
      % あと描画のタイミングで処理するというのも変である。
      % と思ったが decode.sh の中に直接チェックを書き込むのも変だし、
      % EPILOGUE 辺りに書き加えるのが正しい気がする。
      % →実装を確認してみたが ble-decode-key を呼び出せば
      %   その場で実行する様になっている。
      %   つまりこれに関しては気にしなくても良い。

      改めて keymap を観察する。うーん。read 等でも
      edit-and-execute が発生すると困る。
      色々考えるにこの edit-and-execute の呼び出しは、
      寧ろ keymap の上で実行するべきの気がする。

      safe, emacs, read, vi_imap, vi_cmap, vi_nmap で対応した。
      isearch, nsearch, lastarg, yankpop では握り潰すのが良い気がする。
      vi_smap, vi_xmap, vi_omap, vi_digraph では何も処理しない (エラー)。
      menu menu_complete auto_complete dabbrev でも握り潰す。
      取り敢えず全ての keymap に対して処理は書いた。

      結構書き換えてしまったので改めてテストする必要がある。

    o vi_imap, emacs では動いた。
    x fixed: read で動いていない。何故?
      と思ったが EPILOGUE を呼び出していないので当然といえば当然。追加した。
    x fixed: 今度は syntax で assertion が火を吹いている。何故。
      _ble_edit_str を直接編集すると起こる種類の問題である。
      然しその様な事はしていない様に見える。
      →と思ったら _ble_edit_str に直接代入していた。修正した。
    x fixed: vi operator が全く動かなくなっている何故?
      つい直前までは動いている。という事はまた何かを破壊した?
      不思議だ。何も破壊していない気がする。
      →これは vi_omap の __default__ が line_limit を受信して、
      それによって omap を抜けているのが問題だった。
      __line_limit__ は無視する事にした。
    x fixed: vi_nmap では一応動いているが truncate の時に
      vi_imap に落ちるのは分かりにくい。
      edit-and-execute を実際に行う場所で vi_imap に落ちる様に変更した。
    x fixed: 2文字以上の組み合わせの keyseq が使えなくなっている。
      これは全然駄目だ。その様に考えると __line_limit__ は、
      mouse と同様に keyseq には関与するべきではないのでは。
      と思ったが、処理が重くなるのも嫌なので長さの検査をしてから
      __line_limit__ を呼び出す方が良い気がしてきた。
      →その様に変更した。
    o ok: 取り敢えず read, vi_nmap は確認した。
    x fixed: vi_cmap で表示が変になっている。うーん。
      これはどうしたら良いのか。
      →分かった。 .newline していたのが行けない。修正した。
    x fixed: vi_digraph では無視する様にしないといけない気がする。
      (実際に呼び出される事があるのかどうかは不明だが)

    今の所、emacs, vi_[inc]map, read は動作確認した。
    isearch, vi_omap でも問題ないことを確認した。
    safe は emacs と本質的に同じなので気にしなくて良い。
    vi_digraph にも対応した。vi_[sx]map はまあ大丈夫だろう。
    握りつぶしている物に関しては基本的に問題ない筈。

    * done: 既定値は editor で良いのだろうか…。
      いきなり editor が起動すると混乱の元なのではないか。
      或いは none の方が良いのでは? うーん。取り敢えず none にする。

  * test: test-core.sh がエラーを吐いている (reported by andychu) [#D1294]
    https://oilshell.zulipchat.com/#narrow/stream/121540-oil-discuss/topic/.23257.20typing.20past.20the.20last.20column.20(interactive.20features)

    調べたら ble/string#escape-for-bash-specialchars の仕様変更による物である。
    3番目の引数に flags を受け取る様になって、そこに b を指定した時にだけ
    brace の quote を行うという様に変更されている。反映した。
    更に言うと test-core.sh という名前も古い。test-util.sh でなければならない。

  * decode: modifyOtherKeys の時の abort [#D1293]
    C-\ で abort するという話を書いたが。
    よく考えてみると modifyOtherKeys にしている時には動かないのでは。

    さて、modifyOtherKeys にしていると C-c を押しても 3 は決して入って来ない。
    ble-decode-key の直前で待ち伏せしなければならない。
    然し、現在の実装だと ble-decode-key の結果はキャッシュされていないので、
    其処で待ち伏せする事にするとそれより前の処理は全て実行された後になる。
    それだとキャンセルした事にならない。
    或いは key の計算と実行を切り離して key を検査してから実行を行うべきか。

    然し、確認してみて思ったが検査はやはり byte のレベルで実行しなければならない。
    実際に char のキャッシュも byte のレベルでしかキャンセルしない様になっている
    (唯、制御文字に関しては decode を通しても変化しないという前提はある気がする)。

    その様に考えると、decode_abort_char に複数のバイトから為るシーケンスを
    登録できる様にしなければ動く様にはならないという気がする。

    うーん。decode_abort_seq なる物を定義して byte を受け取った時に判定する。
    然し、それだとユーザが端末ごとに正しい値を設定しなければならない。
    更に modifyOtherKeys なので理解するのが難しい。
    やはり自動的に検出する様にしなければならない。

    うーん。可能なシーケンスは実は有限個しかない。
    と思ったが本当だろうか。chars と bytes に跨って記録される事もあるのでは。
    然し、シーケンスの到着のタイミング等を考えるとそれが起こるとは考えにくい。
    取り敢えずは bytes に全て含まれている場合を考える事にする。

    CSI の表現で 2 種類ある。> の有無で 2 種類ある。CSI >? 27 ; 5 ; code
    27~ 形式 と u 形式で 2 種類ある。

    →これについては実装した。

2020-03-08

  * vi: vi-commandn/nth-column の算術式がおかしい (reported by andychu) [#D1292]
    https://github.com/oilshell/oil/issues/620#issuecomment-596189684

    osh -n で見つかったバグである。後で全体的に確認する必要があるという気がする。
    多分、osh -n は一番最初に見つかった物しか報告していない。
    →やはりそうだった。もう一つバグを見つけた。
    然し殆どは ((${prefix}xx=...)) の形式だった。

2020-02-27

  * 2020-02-06 quoted-insert で制御文字を入力できる様にする [#D1291]
    mintty で modifyOtherKeys を有効にしているので
    quoted-insert で C-t 等の基本的なキーですら修飾されている。
    つまり、制御文字を入力する事ができない。

    然し、本当に modifyOtherKeys を入力したい場合や、
    或いは、本当に端末が送ってくる内容を知りたい場合もある。
    その場合には勝手にキー入力をいい感じに翻訳されると困る。
    然し、やはり制御文字を入力したいという事がある気がする。

    C-q と C-v で二種類あるのだから片方に別の物を割り当てるという手もある。
    やはり特殊なキーシーケンスを取得するという場合よりも、
    C-q 等の特殊文字を入力する場合の方が多い。C-x に対しては、
    やはり C-x が挿入される様にするべきである。しかしそれを実行するには
    key を decode しなければならない。するとその他の key に関しては
    それを発生させたシーケンスを復元するか記録するかしないといけない。
    記録するとしても Meta が関わってきた場合には更に複雑になってしまう。
    或いはキーを完全にデコードする前に判定する事は可能だろうか、
    と思ったが CSI u で送られてくる以上は最後まで見ないと分からない。

    a 或いは寧ろ予め用意したシーケンスをそのまま返す様にしてしまう?
      然し、それはそれで混乱の元である。特別なキーに対して実際の端末と異なる物を挿入すると、
      ユーザが端末のテストなどをする際に変な事になってしまう。
    b 或いは各キーに対してどのシーケンスが使われたかという情報を decoder 側で全て記録する?
      然し、それをするぐらいであれば現在のキーに対応するシーケンスだけ取得できる様にすれば良い。

    結局現在のキーを構築するに至ったキーの列を記録する事にした。
    取り敢えず動いているので満足である。

    RLogin は ! 等に対して S-1 等を送信して来る。単に S- を除去するだけでは駄目。
    S-数字の時には日本語キーボード配列を想定して適当に記号に変換する事にした。
    但し、S-数字 にしか対応していない。純粋は記号キーについては補正していないが、
    実は RLogin は既定では記号キーは修飾しない設定になっている。
    うーん。端末識別をもう少し詳しくしてみる事にした。

  * complete: clear menu on discard-line (reported by animecyc) [#D1290]
    https://github.com/akinomyoga/ble.sh/issues/44
    これは意図した振る舞いである、と書こうとしたが振る舞いが変である。
    ソースコードを見ると history.onleave 経由で menu/clear 呼び出される筈である。
    実際に確かめてみると呼び出されてはいるが既に menu が非アクティブになっている。
    最初からアクティブになっていない可能性? と思ったがちゃんとアクティブになる
    コードパスを通過している。

    と思ったら edit.sh 側に active を解除するコードがある。
    というより正に .newline の中で明示的に clear している。
    確認するとこれが追加されたのは aae8b264 である。
    これは menu-filter 着色を解除して最後に行内容を表示する為の処置である。
    insert-newline を呼び出す時に内部で再描画を行うので。

2020-02-19

  * term: menu が正しく消去されないとの事 (reported by killermoehre) [#D1289]
    https://github.com/akinomyoga/ble.sh/issues/42

    これは terminfo と termcap で同じ名前の項目 dl があった所為だった。
    二文字の terminfo で termcap と異なる物は注意して調べた方が良い。

    ri: OK, el: OK, il: OK, ed: 駄目, dl: 駄目
    一方で ed, dl に対応する termcap 側の cd 及び DL は曖昧ではない。
    これらに関しては terminfo/termcap 両方対応している環境では
    cd, DL を確認する事にする。

    % もし ed, dl で terminfo 側を優先させる環境があったとすれば
    % それはそれで問題になる気がするが仕方がない。
    % と思ったが、DL 及び cd を使っている限りは問題が発生しないので、
    % これでちゃんと解決できている。OK

  * term: support contra SPD [#D1288]
    contra で SPD(3) 等を実行してもカーソル移動が破壊しない為に
    terminfo cache の書き換え。CU[UDFB] の代わりに [HV]P[RB] を使う。

  * 2020-02-14 時々 bind が壊れる現象があって何かと思っていたら [#D1287]
    TERM を変更すると Bash は inputrc を再読込するらしい。
    TERM=xterm infocmp 等とするだけで壊れるのである。

    これを検出する方法はあるだろうか。或いは阻止する方法。
    厄介なのは変更してまた元に戻しても壊れるという事。

    a reject: 或いは typeset -r TERM してしまうという手は?
      →そうすると全く変更できなくなるので駄目。

    b reject: 或いは拾えなかった時に rebind する?
      と思ったが拾えないのだから検出できない。

    c reject: INPUTRC=/dev/null に設定する?
      と思ったが問題が発生するのはユーザ環境なので、
      ユーザ環境で一時的に INPUTRC を復元している時に問題が起こる。
      INPUTRC を上書きした状態でユーザ環境に戻すと、
      今度はユーザが bash 等を起動した時に inputrc が読み込まれなくなってしまう。

      →気付いたのはこれは inputrc とは関係ないという事。
      inputrc 読み込みを阻止しても readline 自体の初期化によって
      terminfo を元にして bind が実行される。

    d 実行が完了する度に全 bind を実行する手
      然し、全 bind の時には unbind もしなければならない。
      inputrc が編集された場合には前回の unbind スクリプトは使えない。
      すると unbind を自動的に生成しなければならない?

    e 或いは、実行が完了する度に builtin bind -ps をチェックする手

      a 後者は bind -s の出力結果が ble.sh 自身の物なのか判定が必要。
        結局完全に対応する為には awk を起動するなどする必要がある。
      b 或いは前回の呼び出しと状態を比較するというので十分の気がする。
      c bind -p だけチェック。
        確認した所 inputrc と関係なく書き換えられる様である。
        そして beginning-of-line 等が必ず書き換わる様に見えるので、
        取り敢えず bind -p だけチェックすれば十分だろうか。
        そして # 以外で始まる行が含まれていれば検出したとする。
        単に builtin bind -p | grep -v ^# でも良いのかもしれない。

    | またチェックするのと全 bind を実行するのとどちらの方が重いのかという話。
    |
    |   以下を実行すると 1.6ms である。Cygwin では 33ms
    |   $ check1() { ble/util/assign hello 'builtin bind -sp'; [[ $hello == "$value2" ]]; }
    |   $ ble-measure check1
    |
    |   以下は 2.86ms (Cygwin 77.5ms) だった。
    |   $ ble-measure 'builtin bind -p | grep -v ^#'
    |
    |   以下は 4.5ms である。Cygwin では 31ms
    |   $ ble-measure ble/decode/rebind
    |
    |   以下は 19.2ms である。Cygwin では 247ms
    |   $ ble-measure 'ble/decode/detach; ble/decode/attach'
    |   変な設定に shadow されない為にはこちらを実行する必要がある。
    |
    |   % Cygwin は何れにしても遅い様だ。ファイルに書き込むからだろうか。
    |   % どうも ble/util/assign の中で出力する内容の量に比例して時間がかかっている。
    |   % 取り敢えず Cygwin の事は考えなくて良いという事にする。
    |   %
    |   % うーん。今 ble/decode/bind/unbind の実装を確認して気付いたが、
    |   % 実は昔にキャッシュした結果を使って unbind している。
    |   % つまり、キャッシュした時から変化があったりすると unbind できない。
    |   % 指示通りに設定していれば bashrc の先頭で実行するので
    |   % ユーザの設定に左右される可能性は低いが、
    |   % inputrc の設定には左右されてしまう。
    |   %
    |   % と思ったが何か変だ。このキャッシュしている内容は
    |   % ble.sh による binding の設定・削除である。
    |   % 元々の binding の復元・削除ではない。
    |   % 確認するべきなのは
    |   % ble/decode/detach と ble/decode/attach なのだった。
    |
    | コマンド実行の時間と比べれば 4.5ms や 31ms は短いので
    | そんなには気にならない様にも思う。或いはもっと別のタイミングで再チェックを行う?
    | と思ったが、コマンドの実行以外にもっと疎らなチェックのタイミングはない気がする。
    | もしコマンドの実行でチェックしないとその後の編集の何れかのタイミングで再度
    | binding を実行しなければならないので面倒である。
    |
    | ? TERM を書き換えると勝手に初期化される振る舞いは妥当なのだろうか。
    |   例えばユーザが明示的に home になにか割り当てていた時に、
    |   TERM が書き換わる度にそれが上書きされてしまうという事にならないのか。
    |   と思って振る舞いを確認した所、既にその binding が存在している場合には、
    |   勝手に上書きしてしまう等の事は発生しない様だ。
    |   ちゃんとできている。
    |
    |   prefix の \e や O を単体で取り出したい等という変な事をしない限りは
    |   これでちゃんと動く様になっているのである。うーん。これには文句はつけづらい。

    コマンドを実行する度に bind をチェックするのが一番速い。
    対応としては bind -p の出力を記録して比較する。
    特に Cygwin で遅いが stty が 55ms なのでそれに比べれば小さい。
    bind -p だけならば 21ms で比較できている。

    取り敢えず実装する。

    * ok: 初回はコマンドを実行する前に記録するべきの気がする。
      →これは decode/bind/bind の側で記録する事にした。
    * done: TERM を記録しておいてそれが変更したらチェックしなくても再読み込みを実施する。
    * ok: 動作確認

    追記: ble-reload の時に変なメッセージが出る様になったと思ったら
    これが原因だった。bind している状態の時に限り rebind を実行する様に変更した。

    # エラーメッセージは emacs mode ではないのに keymap 'emacs' is empty となっていて、
    # これは source ble.sh した時に default keymap が emacs に取り敢えずなって、
    # 本来は attach の時に正しいものに決定されるはずが、attach の前に ble/decode/attach
    # を呼び出してしまってエラーになっていたという事である。

2020-02-12

  * 2020-01-17 syntax: ${var/#} ${var/%} も特別に着色する [#D1286]

  * decode: ble-import -d (--delay) [#D1285]
    * ble-import の guard は常に絶対パスで行う様に変更した。

  * decode: macro 無限ループ防止? [#D1284]
    macro 再帰に条件を設けても良いのでは? と思ったが、
    現在の仕組みだと一旦一番上に抜けてから実行する様になっているので、
    macro の階層は簡単には分からない様になっている。
    macro の階層ではなくて文字数で判定するのでも良いかもしれない。
    然し、問題は階層・文字数で制限したとしても一つのマクロから呼び出される
    マクロが2以上だと鼠算式に増えるので容易に実質止まらないループを作れる事。

    要するに一つのマクロ呼び出しから起こるマクロ呼び出しの総数に制限を掛ければ良い。
    マクロの中ではないマクロ呼び出しでカウンタをクリアして、
    マクロの中でのマクロ呼び出しではカウンタをインクリメントしながら回数に制限を掛ける。
    マクロの中なのかそうでないのかはどう判定すれば良いか?
    これは ble-decode-key 辺りで変数を定義する事にすれば良い?

    →実装した。

  * decode: ble-bind -L が BSD sed でエラーを出す (reported by dylankb) [#D1283]
    https://github.com/akinomyoga/ble.sh/issues/41#issuecomment-585068803
    何と sed -r を使っていた。恐らく ble-bind -L は元々自分のデバグの為に作った
    関数を ble-bind の機能として転用した為に環境依存の実装が残っていたのだろう。

  * ble-sabbrev は complete 経由でなくても呼び出せる様に改良する [#D1282]
    対応した。

  * complete: auto_complete で failglob の時 ^? が直接挿入される問題 [#D1281]
    及び fzf で auto-complete の時に complete -D を使うと
    fzf の設定が bash-completion で上書きされてしまう問題。

    fzf completion を試していた時に auto-complete で ^? が self-insert される状態になった
    これは何かのバグだろうか。

    fzf で最初の候補を選択した直後に auto-complete 状態になるが、
    その時に backspace を押すと ^? が self-insert される。何故?
    その他の場合にはそういう事にはならない。

    →これも auto-complete では fzf を起動しない事にしたので、
    余り気にしなくても良いのかもしれない。しかし、
    何故こういう事になってしまうのかについては調べる必要がある?

    そもそも self-insert されるというのが不思議である。
    →これは vi_imap/__default__ であろう。
      問題は何故元々の C-? が働かずに __default__ が呼び出されているのかという事。
      然し、C-? が bind されていない map があったろうか。。

    というかどの様に再現したら良いのか。。改めて設定を変えて試す必要がある。
    駄目だ再現できない。最近の変更で変わったとは思えない。
    最近の変更はコメントの編集と reconstruct-user-settings だけである。
    或いは reconstruct-user-settings で bind が上書きされた可能性もなくはないが、
    そうだとしたら ^? が挿入されるという振る舞いにはならない筈。

    再現した。vim ** <TAB> で再現した。と思ったら再現しなくなった。

    * fixed: 然し一度 vim ** で fzf を実行して確定すると以降は二度と fzf が起動しなくなる。
      補完設定を確認してみると _filedir_xspec に置き換わっている。
      fzf が内部で dynamic loading を実行しているのが原因だろう。
      然し、これは ble.sh なしでも再現するのではないか?
      →試してみたが ble.sh なしでも勝手に置き換わるという事は無い様だ。

      そもそも ble.sh の上で vim ** が動いていない。
      メニューは出るがその後で置換が発生していない。
      詳しく何が起こっているのか確認する必要がある。

      最初に fzf の completer はロードされている。
      誰かが上書きしている。
      ble.sh による __load_completion の呼び出しは行われていない。
      fzf が自身で書き換えている可能性も見たがそうでもない。
      外側で書き換わってしまっている。

      complete を hook して調べる必要がある。
      うーん。_python_argcomplete_global というのが勝手にロードしている。
      そして _python_argcomplete_global は complete -p -D に登録されている。
      そもそもの話、何故 complete -p -D が呼び出されているのかという話でもある。
      あー。分かった。auto-complete で default にフォールバックしているからだ。。
      これの work around はどうすれば良いか。

      元々意図した事は default の fzf でない補完設定を実行するという事。
      然し、fzf でない補完設定の -D は complete を呼び出してしまう。
      或いは fzf に既定の補完を呼び出させるのが良いのではないだろうか。

      うーん。取り敢えず -o default を指定するのではなくて別の方法で
      default の呼び出しを抑止してみる事にした。然し駄目だ。何故だろう。
      と思ったら -o default を fzf が指定しているのだった。
      -o default が指定された時には complete -D
      を呼び出すのではなくて組み込みの補完を呼び出さなければならない。
      というか実は初めからそのような実装になっていた。
      従って前回の変更で付け加えた機能は不要だったのである。
      削除した。この問題は発生しなくなった。

    * ^? が挿入される問題は未だ解決していない気がする。
      然し再現できない。再現の条件が良くわからない。

      auto-complete が表示されているという事は auto-complete の中にいると仮定して良い?
      この時に ^? を受信するとどうなるかというと auto-complete を一旦抜けて外で
      処理を行ってその後でまた auto-complete に入る。もしくは auto-complete の中にいる儘で
      ^? を挿入する。

      ble/widget/auto_complete/self-insert の実装を見ると 0x7F が直接入って来た場合には
      そのまま挿入される事になる。恐らく __defchar__ もその様になっているのだろうと想像される。
      然し、何処で 0x7F が発生するのだろうか。
      ble/widget/vi_imap/__default__ が変換している?
      そしてそれを auto-complete が受け取っている可能性?

      再現する気配がないので昔の状態に戻して改めて再現を試みる。

      $ touch a\*\*b
      $ vim a**

      この状態で \C-i\C-g\C-? とすると再現する。
      もう一回試した。やはり再現する。
      うーん。最新の commit にすると再現しなくなる。

      この変な状態を調べる。
      取り敢えず self-insert に stackdump をしかける。
      →どうやら self-insert は引っ掛かっていない様だ。
        という事は auto_complete/self-insert に引っ掛かっている?
      引っ掛かっていた。stackdump の引数の機能が欲しい。cherry-pick する事にする。
      →git checkout 1f14571 src/util.sh で取り出した。

      @ /home/murase/.mwg/src/ble.sh/out/ble.sh:1 (ble/widget/auto_complete/self-insert )
      @ /home/murase/.mwg/src/ble.sh/out/ble.sh:46 (ble-decode/widget/.call-keyseq )
      @ /home/murase/.mwg/src/ble.sh/out/ble.sh:58 (ble-decode-key/.invoke-partial-match 127)
      @ /home/murase/.mwg/src/ble.sh/out/ble.sh:45 (ble-decode-key 127)
      @ /home/murase/.mwg/src/ble.sh/out/ble.sh:79 (ble-decode-char/.send-modified-key 127)
      @ /home/murase/.mwg/src/ble.sh/out/ble.sh:51 (ble-decode-char 127)
      @ /home/murase/.mwg/src/ble.sh/out/ble.sh:45 (ble/encoding:UTF-8/decode 127)
      @ /home/murase/.mwg/src/ble.sh/out/ble.sh:1 (ble-decode/.hook 127)

      どうも 127 がそのまま変換されずに到達している様だ。
      よく考えてみれば確かに 127 は DEL として取り扱っているので、
      そのまま変換されずに到達するというのは今迄の意図した取り扱いである気がしてきた。
      * 他の keymap で問題が起こらなかったのは DEL が明示的に bind されている為。
      * auto-complete でも問題が起こらなかったのは ^? で始まる補完候補がなかった為。
        然し、何故か今回の判定では ^? が続きにあるという勘違いをしてそのまま挿入してしまう。

      具体的にどういう事になっているのか調べる。と思ったら…。成る程。

      comp_filter_type='head' compv_new='' _ble_complete_ac_cand='.git'

      failglob になって、その結果として compv_new='' になって、
      空文字列が入力されている状態という事になって、
      結果として何でも受け入れてしまうという状態になっているという事。

      [修正]

      対処方法としては (1) done: 先ず DEL を直接送信する設計は止める事にする。
      (2) done: 展開に失敗したら素直に諦める。
      DEL に対する bind は改めて確認してみたが特に問題になりそうにはない。

2020-02-10

  * [bash-completion] failglob: 以下のエラーメッセージが補完で出る [#D1280]
    "[murase@hp2019 0 bin]$ ln -s ~/.mwgbash: 一致しません: \~/.mwg"

    →これはbash-completion の問題だった。
    そもそも bash-completion は failglob に対応できていない。

    | 何故? そもそもグロブパターンですらないのに
    | →調べたらエラーが出た。うーん。
    | どうも \ が含まれているだけでパターンとして取り扱われる様だ。
    |   value='\~/.mwg'
    |   echo $value
    |
    | 何処でこのエラーメッセージが発生しているのだろうか。
    | と思ったら再現しなくなった。うーん。これは fzf の方のバグだろうか。
    | →再現した。ln コマンドで再現する。ln _fzf_path_completion である。
    |
    | 辿って行くと _longopt (bash-completion) がエラーを発生させている。
    | _longopt に対して bash-completion は ln ~/.mwg -s という引数を渡している。
    | うーん。ble.sh なしで bash-completion を使った時にも failglob で同じエラーが発生する。
    | つまり、これは bash-completion の問題である。

  * util: ble/util/stackdump は >&1 に出力するべきなのでは [#D1279]
    使う側が目的に応じて出力を変更するべき。
    後 ble/util/stackdump を直接使っている箇所を ble-assert
    もしくは ble/util/assert に置き換えられないか。
    →ble/util/assert で書き直した。

  * [棄却] edit: 既定で bind している fg は builtin fg の方が良い? [#D1278]
    或いは fg のままの方が良い?
    もしユーザが fg を上書きしているのだとすればそれなりに機能を追加している
    という事の気がするので fg の儘の方が良いのではないかという気がする。

  * complete: BSD sed? が bind -p の解析で misencoded char のエラーを出す (reported by dylankb) [#D1277]
    https://github.com/akinomyoga/ble.sh/issues/41#issuecomment-583892006
    これは最近追加したコードが悪いのに違いない。分かった。修正した。

    →実際に FreeBSD 試してみた所エラーメッセージはでていない。
    つまり、これは BSD sed ではない? どの sed がエラーメッセージを出しているのだろう。
    然し、検索するとどの頁も macOS の sed は BSD sed だと言っている。
    BSD sed にも色々亜種が有って FreeBSD の物と macOS の物では振る舞いが違うという事なのか?

2020-02-09

  * edit: PS1, PROMPT_COMMAND, PRECMD に於いて BASH_COMMAND, _ を復元 [#D1276]
    cygwin 問題報告の例を作る上で BASH_COMMAND を用いる use case が
    ある事に気付いたが、これが ble.sh では動かない。修正した。

  * complete: fzf complete cd が動かない (reported by dylankb) [#D1275]
    https://github.com/akinomyoga/ble.sh/issues/41
    fzf が動かないという話。これは既に解決済みの話。彼は古い version を使っている。
    然し、二つ目の項目に関しては前の修正とは関係ない。
    先ず再現を試みたがそもそも fzf の振る舞いを再現する事ができない。

    [原因]

    少なくとも cd の補完に関しては ble/cmdinfo/complete:cd で処理しているので、
    fzf が幾ら設定を追加しようとも関係ない筈だ。そして ble/cmdinfo/complete:cd
    が報告されたエラーを出力している筈である。しかし、そうだとしても、

      -bash: cd: too many arguments
      [ble: exit 1]

    というのはどういう事であろうか。まるで cd ** でコマンドを実行したかの様である。
    というか [ble: exit 1] と表示されるという事は実際に
    cd ** でコマンドを実行したということであろう。
    fzf をロードしていると同じ事が起こるのだろうか?

    少し fzf だけをロードして試してみる事にする。
    先ず cd **TAB とするとちゃんと fzf が起動する。そして置き換わる。
    また cd ** で直接実行すると報告されたのと同じエラーメッセージが出る。
    恐らく dylankb は TAB で fzf を起動してそのまま一番最初の物で確定する癖になっているのだ。
    その想定で、先ず fzf がちゃんと起動する様に修正する必要がある。

    取り敢えず ble/cmdinfo/complete:cd を取り除く。
    それから fzf が呼び出されているかの確認を行う。

    分かった。二種類の問題がある。

    x ble/cmdinfo/complete:cd
      これは unset するしかない。

    x < /dev/null にしているという事。
      うーん。< /dev/null に関しては
      ユーザの側で </dev/tty を開く様にお願いすれば良い。
      (しかし、こういう微妙な仕様の違いでひっかかるのは注意を要する。)
      →これも /dev/tty に繋ぐようにして試してみたが直らない。

    x '**' を ble.sh が独自に最初の単語に展開している事
      と思ったがそうでもない。
      fzf にはちゃんと '**' という文字列が渡っている。
      どうした理由かは分からないが。

    x 分かった。原因は COMP_WORDS である。

      これの解決方法は。どの様にして COMP_WORDS を調整するか。

    [解決方法]

    a ユーザに comopt を指定してもらう。指定がある場合に振る舞いの変更を行う。
      complete の設定に予め含めるというのはできない。非標準のオプションだから。

      "" 等の quote の事も考えると pathname expansion だけ実行しない
      という様にするのか、或いは展開そのものを全くしないという事にするのか。
      中途半端に展開しても今度は '**' と指定した時に困るのだから、
      展開そのものを全く実行しないという様にするのが自然である。

      その為には _fzf_dir_completion という関数を上書きしなければならない。
      % 然し、_fzf_dir_completion 側の実装と合わせなければならない。
      % そう言えば以前デバグの為に関数に処理を付け加える advice 云々という関数を定義した様な気がする。
      % しかし今簡単に探してみると見つからない。
      % そもそもどういう関数名だったかなど。うーん。 '"function' で探して見つからないので、
      % その関数は恐らく全然別の所で定義した物の気がする。
      % →分かった。song526 の ble.sh の中に measure.sh という commit していないスクリプトがあった。
      %   中を覗いてみたが advice の様な汎用性を持たせた実装にはなっていなかった。

      何れにしても新しく関数を追加する必要があるという事なのである。

      →結局他にも問題が沢山あるという事が分かった。
      オプションを指定するだけで解決できる様な問題ではない。

    b 或いは ble/cmdinfo/complete:cd を上書きしてもらう?
      こちらの方が手軽である。然し comp_reply を読む必要がある。
      と思ったが、nospace だとか色々のオプションをどの様に処理するのか?
      これまでの方法だと compgen が色々何とかしてくれた。

      function ble/cmdinfo/complete:cd {
        local COMP_LINE=$comp_line
        local -a COMP_WORDS=("${comp_words[@]}")
        local COMP_CWORD=$comp_cword
        local COMP_POINT=$comp_point
        local -a COMP_REPLY=()
        _fzf_dir_completion "${comp_words[0]}" "${comp_words[comp_cword]}" "${comp_words[comp_cword-1]}" >/dev/pts/7
        compopt() { echo "compopt $*"; }
        comp_opts+=:nospace:
        local cand
        for cand in "${COMPREPLY[@]}"; do
          ble/complete/cand/yield word "$cand" ""
        done
        ble/textarea#invalidate
        return 0
      }

      うーん。結構長い関数になってしまう。

      実際にこれを動かして試してみると無限ループになっている。何故?
      未だ再現していない。うーん。再現しない。何だったのだろうか。

      x fixed: 更にもう一つの問題点は fzf が表示を書き換えてしまっているので、
        表示が乱れてしまっているという事。これは invalidate を呼び出せば良い。
        実際に試してみて解決する事を確かめた。

      x もう一つの問題点はこれが interactive な補完を呼び出すという事。
        現状の実装では auto_complete も同じ枠組みを使っているので、
        auto_complete によって fzf が呼び出されてしまってこれは面倒。

      更に色々試してみた結果 compopt の処理もしなければならないし、
      色々面倒である。結局やはり ble.sh の progcomp 経由で実行した方が良い気がする。

    c 結局 fzf の側の関数を動的に書き換えて振る舞いを変更する事にした。

    * 一旦適当に reply しておく。

      % ## 3. ble.sh closes stdin/stdout while `fzf` is used
      %
      % Sometimes a user-provided completer consumes or flushes stdin
      % unintentionally. But this causes the problem for
      % auto-complete. Because auto-complete is performed in the
      % background, the user inputs will be lost if the background
      % user-provided completer flushes stdin. For this reason, ble.sh
      % by default closes the standard streams of user-provided
      % completers. If user-provided completers really want to do
      % something with stdin/stdout, the completer need to open
      % `/dev/tty` for itself. But `fzf` does not do that.

      調べながら書いていたら時間を食ってしまった。
      後、上の内容は結局本当か分からない。
      実際に fzf のソースを見てみると /dev/tty を開いている箇所がある。
      従って、試している時に発生した hang はこれとは関係ないのかもしれない。

      →実際に試してみたらやはり fzf は /dev/tty を開かずに実行しようとして、
      それで hang してしまっている。やはり /dev/tty の対策はしなければならない。

    [実装]

    取り敢えずおおまかな実装をしてから細かい振る舞いの調整を行えば良い。
    以下の二つを上書きすれば良い気がする。

      __fzf_generic_path_completion
      _fzf_complete
      追加: _fzf_complete_kill

    * 無限ループになっている原因は分かった。auto-complete である。
      auto-complete の中では fzf を起動しない様にした所、動いている。

    * 今度の問題は ble.sh が勝手に変換結果をフィルタしてしまうという事。
      ** のまま変化しない。
      うーん。候補の生成まではちゃんとできている。
      しかし再度の候補生成が試みられてそれで何も生成されずに終わっている。

      →あー。何が起こっているのか分かった。補完がキャンセルされている。
      何故かと言うと fzf が DSR(5) を要求してその返答が届いているから。
      ble.sh は補完の計算中にユーザ入力が来たと思って補完処理を中断する。
      これによって何も起こらないという事が発生している。

    * ESC [ 0 n が not found というエラーメッセージが出ている。
      % bind していても処理されないという事。
      % というか bind '"\e[0n":...' はどのレベルで処理されるのだろう?
      % →確認してみた所、以下の様に登録されていた。うーん。
      % ble-bind -m 'vi_imap' -f 'M-[ 0 n' 'redraw-line'
      %
      % これはどうしたら良いか。blesh では認識できない
      % escape sequences は無視する様にしている。
      % それは terminal が不意に何か変な response をした時に
      % ユーザの入力と勘違いして変な振る舞いをしないようにする為。
      % なのでこの設計を変更するつもりはない。
      %
      % ならば正しい設定は一体何か?
      % 結局これを正しいシーケンスとして登録する事である。
      % ble-bind -k 'ESC [ 0 n' DSR

      うーん。結局 fzf の DSR(5) による hack を封じる事にしたので
      これの対策はしなくても良いのである。

2020-02-08

  * proghl の中で行った fix を ble-0.3 にも適用しなければならない [#D1274]
    続いて patch を適用していく必要がある。適用した。

  * msys1: C-d の受信について [#D1273]

    mkfifo がエラーになっている。Function not implemented と表示される。
    sleep に関しては cygwin 用の実装を使っている。
    stderr.pipe に関してエラーになっている様だ。これの所為で C-d も受信できていない。

    C-d の受信に関しては bind 'set bind-tty-spacial-chars off' にしたら
    受信できるかもしれないと考えたが実際に試してみるとできない。
    やはり駄目の様だ。

    もしかして msys2 も駄目なのかもしれないと思って msys2 で mkfifo を試したら動いた。
    つまりやはり msys1.0 に fifo (pipe) が実装されていないという事なのだ。
    因みに coproc も 3.2 以下には存在しない。

    そうすると、pipe を使わない代替実装を考えなければならない。
    実は以前は pipe を使わない実装だったような気もする。

    | a pipe を単に普通のファイルに置き換える実装を考えてみたが駄目そう。
    |   > stderr.pipe としても一度 exec したものをそのまま使っていると、
    |   以前の末尾の位置の続きに書き込まれてしまう。
    |   毎回 exec する必要があるのではという気がする。
    | b プロセス置換で実装してみようとしたがプロセス置換も
    |   Function not implemented になった。
    | c そうすると何度も sleep しながら待つ実装になるだろうか。。
    |   試しに tail -f を実行してみたら良い感じに動く。
    |   更にファイルを truncate した事もちゃんと検出してくれる。
    |   tail は優秀なのではないか。然し、遅延があるのが気になる。
    |   内部的に sleep して実装しているのだろうか。
    |   自分で細かく sleep コマンドを呼び出すよりは良い。
    |   取り敢えずこれで実装する事にする。
    |
    |   →実装してみたが微妙。遅いし消滅している入力もある気がする。
    |   後、親 Bash が死んだ後も生き続けている気がする。
    |   もっと別の実装方法を考える?
    |
    |   入力が消滅するのは stderr.off の瞬間にファイルをクリアするからだった。
    |   クリアしないで追記する様にしたら入力は消滅しない様になった。
    |   但し、エラーを沢山出すとディスクに際限なく書き出してしまう。
    |
    |   sleep を使うにしてももっと実装を工夫しなければならない。
    |
    |   解決しなければならない問題が幾つか在る。
    |   x いつ誰がファイルをクリアするのか。
    |     書き込み元がクリアする事にすると
    |     読み取りする前に消えてしまう行が出てくる。
    |     読み取り側がクリアする事にすると、
    |     書き込み元はそれを知らないので、
    |     いきなりファイルの途中から続きを書き出してしまう。
    |
    |     或いは2つのファイルを交互に使う等してこの制限を回避する事は可能だろうか。
    |     然し、読み取り側は書き込み元がどちらのファイルを使っているのか検出する術がない。
    |     ファイルAとファイルBのどちらの内容の方が先に読み取るべき物なのか分からない。
    |
    | d 思いついた。これは書き込み元が新しくファイルを開く時に、
    |   データの出力先が有限のサイズを持っている場合には、
    |   新しく別名でファイルを開く事にすれば良いのである。
    |   そして読み取り側がファイルをクリアする事にする。
    |
    |   書き込み元がファイルサイズをチェックしてから
    |   実際にファイルを開く間に何か変化があるという事はない。
    |   読み取り側はファイルを短くする事はあっても長くする事はないので、
    |   一旦空のファイルであると判定が出たらそれが他の要因で変化する事はない。
    |
    |   実装してみる事にする。と思ったが駄目だ。
    |   x 読み取り側がどれを読み取ったら良いのかが分からない。
    |     若い番号から順に読み取れば良いと考えていたが、
    |     考えてみるとファイルをクリアしてしまうと、
    |     親がまた若い番号から書き込み始めてしまうので、
    |     一概に若い番号から順に読み取れば良いという訳ではない気がする。
    |     →クリアは大きい番号のファイルから順番にするという規則にする。
    |       x それでも駄目。順番に消していっている途中に書き込み側が
    |         有限の番号で開くとその後でそれより若い番号を消去する事になる。
    |   x それに読み取り側がどのタイミングでファイルの末端が来たと
    |     判断すれば良いのかも分からない。
    |     未だ書き込み中かもしれないからである。
    |     或いは、特別な信号を書き込む事にする?
    |
    |   色々バグがあったりして動かなかったりしたが動く様になった。
    |   と思ったら C-c で子プロセスが勝手に終了してしまう。
    |   うーん。trap -- '' INT QUIT としたら終了しなくなったが、
    |   今度は遅延が生じる様になってしまった。どうして trap が遅延に影響するのだろう?
    |   良くわからない。
    |
    |   更に sleep を高頻度で回しているのでやはり HDD のアクセスが気になるのである。
    |   うーん。tail -f の方が現実的なのかもしれない等と考える。
    |
    | e うーん。或いは lastpipe 等を弄って何か上手にできないのか。
    |   cat | exec 5<&0 みたいな事をする等…。
    |   然し、これはデータの流れが逆である。寧ろ first pipe 的な物が必要である。
    |
    |   試しに cat README.md | exec 5<&0; read line <&5 として見たが
    |   ディスクリプタは開いてなかった。と思ったが last pipe するのを忘れていた。
    |   然し shopt -s lastpipe を実行した後でも <&5 しようとすると
    |   bad file descriptor と出て、fd がそもそもない場合と同じエラーメッセージ。
    |   Bash が色々の fd を閉じてしまっているという事の気がする。
    |   或いは元の状態を復元している。
    |   なので、lastpipe を使って何とかする事はできない。

    最初に試したのは c の実装

    | : >| "$_ble_edit_io_fname2.pipe"
    | {
    |   tail -f "$_ble_edit_io_fname2.pipe" 2>/dev/null | ble-edit/stdout/check-ignoreeof-loop tail & disown
    | } &>/dev/null
    | function ble-edit/bind/stdout.off {
    |   ble/util/buffer.flush >&2
    |   ble-edit/bind/stdout/check-stderr
    |   exec 1>>$_ble_edit_io_fname1 2>"$_ble_edit_io_fname2.pipe"
    | }

    x どうも消滅している入力がある気がする。
      更にユーザの入力が前後してしまって UTF-8 を破壊したり
      色々遅延に関係して変な事が起こっている。

    x この実装だと無限に読み取り続けようとしてしまう。
      親を定期的にチェックして親がいなくなったら終了する様に書き換えてみたが、
      それでも tail の方が終了しないで残ってしまう様だ。
      tail -f は誰かが kill しなければならないのである。

    結局、d の複数のファイルに分散して書き込む方向性で実装して
    以下の様なコードができたが思い通りに動かない。

    | {
    |   builtin trap -- '' INT QUIT
    |   while kill -0 $$ &>/dev/null; do
    |     declare index=0 processed=
    |     while file=$_ble_edit_io_fname2.$((index++)); [[ -e $file ]]; do
    |       [[ -s $file ]] || continue
    |       processed=1
    |       while :; do
    |         if ! IFS= builtin read -r line && [[ ! $line ]]; then
    |           kill -0 $$ &>/dev/null || exit
    |           ble/util/msleep 100
    |           continue
    |         fi
    |
    |         [[ $line == __BLE_STDERR_EOF__ ]] && break
    |
    |         [[ $line == *[^$_ble_term_IFS]* ]] &&
    |           ble/util/print "$line" >> "$_ble_edit_io_fname2"
    |
    |         if ble-edit/stdout/check-ignoreeof-message "$line"; then
    |           ble/util/print eof >> "$_ble_edit_io_fname2.proc"
    |           kill -USR1 $$
    |           ble/util/msleep 100
    |         fi
    |       done < "$file"
    |       : >| "$file"
    |     done
    |     [[ $processed ]] || ble/util/msleep 100
    |   done & disown
    | } &>/dev/null
    |
    | _ble_edit_io_fname2_write=
    | function ble-edit/bind/stdout.on {
    |   exec 1>&$_ble_edit_io_stdout 2>&$_ble_edit_io_stderr
    |   [[ -s $_ble_edit_io_fname2_write ]] &&
    |     ble/util/print __BLE_STDERR_EOF__ >> "$_ble_edit_io_fname2_write"
    |   return 0
    | }
    | function ble-edit/bind/stdout.off {
    |   ble/util/buffer.flush >&2
    |   ble-edit/bind/stdout/check-stderr
    |   local index=0 highest=-1
    |   while [[ -e $_ble_edit_io_fname2.$index ]]; do
    |     [[ -s $_ble_edit_io_fname2.$index ]] && highest=$index
    |     ((index++))
    |   done
    |   _ble_edit_io_fname2_write=$_ble_edit_io_fname2.$((highest+1))
    |   exec 1>>$_ble_edit_io_fname1 2>"$_ble_edit_io_fname2_write"
    | }

    問題点は以下の通り

    x trap -- '' INT QUIT をして置かないと C-c 等を入力した時に
      この補助プロセスが終了してしまう。

      一連の一時ファイルを削除する補助プロセスがないと、
      一時ファイルがどんどん増えて親シェルの動作がどんどん重くなる。
      これについては補助プロセスがいなくなった事を検出して
      適宜再起動する様にすれば良い気もする。

    x trap -- '' INT QUIT をすると今度は謎の遅延が発生する様になる。
      次の入力を受け取らないとシグナルが受信されないという事になる。

    x また sleep を頻繁に呼び出すので常にディスクがアクセス状態になる。
      command sleep 以外の待ち時間の費やし方を考える必要がある。
      適当に /dev/udp/127.0.0.1/0 等を開いて誤魔化す? にしても、
      read が小数に対応していないので timeout できない。

    % 今の所は単純に C-d を諦めるという実装にするしかない気がしている。

    もしこのシステムが msys1 なのだとしたら、
    gcc があると期待して良い。
    そして gcc があるという事は C プログラムが使える?
    g++ は使えないかもしれない。
    何れにしても gcc が使えるならば Sleep も使える。
    そして tail -f の代替をコンパイルする事もできる。

    然し tail -f 方式はタイミングの問題で
    出力が失われてしまうのが問題なのだった。
    やはり複数ファイルを使う必要があるのか。
    或いは、一つのファイルで頑張る方法があるだろうか。

    複数ファイルを使う方法に頼ると子プロセスが消えた時に
    無限にファイルが増えていく事になる。これは避けたい。
    とするとファイル数に上限を定める事になる。
    それぐらいならば 2 つのファイルで頑張る方法を考えるべきでは?

    gcc が使えるのであればファイル名を変更する事が可能である。
    ファイル名を変更できるという事は、可能性が増えるという事。
    改めて考え直す事にする。

    親プロセスを A としてバックグラウンドプロセスを B とする。
    A は既存のファイル F に只管追記する事にする。
    B は mv F G してから G を読み続ける。
    新しく F が生成される迄は G の読み取りを試み続ける。
    これで行ける気がする。

    ? yes: 問題は今書き込んでいる途中のファイルを読み取れるのか。
      そして読み取れたとして一旦 EOF に達した後に続きが書き込まれた時に、
      再度続きの読み取りを再開する事ができるのかという事。
      試してみた所できる様だ。

      1文字ずつ読み取るのはできた。まとめて読み出すのもできた。

    ? 次の問題は親プロセスが存在しているかどうかをチェックする事ができるのかという事。
      これは WINPID を知っていればできる筈。然し、WINPID を取得することは可能か?
      或いは普通に親プロセス? と思ったが親プロセスなのか親の親プロセスなのか分からない。
      うーん。msys には /dev も /proc もない。

      少なくとも cygwin PID から WINPID に変換できれば Win API が使える。
      https://stackoverflow.com/questions/1679337/convert-a-cygwin-pid-to-a-windows-pid

      cygwin の場合には include <sys/cygwin.h> とすれば良い様だ。
      msys の場合にはそんな簡単な訳ではない様だ。
      或いは msys の dll を見たら行けるのかもしれないが面倒なので止める。
      結局 ps コマンドを実行してその結果を解析するしか無いのだろうか。

      取り敢えず WINPID は取得できる。次にするべき事は。
      Windows でのプロセス存在確認は GetExitCodeProcess で行うそうだ。
      https://stackoverflow.com/questions/1591342/c-how-to-determine-if-a-windows-process-is-running
      その為に PROCESS_QUERY_INFORMATION を指定して OpenProcess する。

      % 実装して動かそうとしたら駄目。
      % unlink に失敗している。unlink せずに真面目に rename する事にしてみたが、
      % それも失敗した。どういう事だろうか。開いていると rename できないのか、
      % 或いは tmp に作成しているから rename できないのか。。色々試す必要がある。
      %
      % HOME に作ったファイルは rename で移動できる。
      % tmp の下の $_ble_base_run に作ったファイルも rename で移動できる。
      % うーん。変だファイルを開きっぱなしにしていてもちゃんと移動できる。
      % 更に移動した後も続きが書き込まれているという事を確認した。
      % →これは結局 is_file の実装のバグだった。return FALSE するのを忘れていた。
      %
      % それならば rename せずに unlink でも行けるかもしれないと思ったが駄目だった。

      取り敢えず何となく動く様にはなったが、
      沢山入力すると permission denied のエラーが発生する。うーん。
      そもそも入力を受け取る度にファイルを作成するというのも効率が悪い。
      特定の回数毎に開き直すという実装でも問題ないのではないかという気がする。
      ファイルを開き直すのは時々にするという手もあるのかもしれない。
      →と思って試してみた所駄目だった。どうも dup するともう使えなくなる様だ。。

      ではエラーメッセージを封じるのか? というと難しい。
      エラーメッセージを封じる為には 2 をリダイレクトしなければならないが、
      今は 2 の接続先を変更したいので 2 をリダイレクトする訳には行かないのである。
      うーん。最初に適当なファイルに繋いで、それから 2 をリダイレクトする?

    [関連項目]

    * fixed: この bleopt_internal_ignoreeof_trap という変数は意味があるのか?
      サブシェルの中で見ているので親シェルで設定が変化しても追随できない。
      寧ろ、受信する側で bleopt_internal_ignoreeof_trap に応じて無視するべきでは。
      或いは、bleopt_internal_ignoreeof_trap が空ならそもそも対策コードを実行しない。
      →これは抑もの bleopt_internal_ignoreeof_trap の使い方が間違っていた気がする。直した。

2020-02-07

  * MSYS 1.0 を使ってみたら全然動かない [#D1272]

    * msys の version 判定は uname -r を実行すれば良い。
      というか _ble_term_CR が空かどうかで判定できる気がする。

    * MSYS1.0 に至っては _ble_term_CR=$'\r' ですら効かない様だ。
      仕方がないので _ble_term_cr=$'\e[G' で代用すれば良い。

    ? check $_ble_base_cache/cygwin.term
      cygwin.term を確認してみると cr, ich, dch, ech, Ss が空欄になっている。
      重要なのは cr だけである。それなのに _ble_term_cr=$'\e[G' しても未だ変だ。
      他に実装されてはいるが振る舞いが変な制御機能があるという事なのだろう。
      例えば RI や IND が実装されていないという事だろうか。

    ? yes: これは cygwin console か?
      というより TERM を cygwin にしているがこれは本当に cygwin console か?
      実は cygwin pseudo console の気がする。と思ったが実際に実行してみると
      256色対応もちゃんとできていないのでこれは pseudo console ではない。
      やはり cygwin console なのである。
      pcon に切り替える機能は実装されていないだろうから当然である。
      丁度 cygwin-3.0.7 と同様に特別な事をしていなければ cygwin console なのである。

    * fixed: _ble_term_xenl と _ble_term_ind を修正したら何となく動く様になった。

    ? ok: xenl が効いていない?
      % しかしよく見てみると _ble_term_xenl=1 にすると無条件に eol mark が表示される。
      % _ble_term_xenl=0 にすると無条件に eol mark が表示されない。
      % と思ったがこれは勘違いである。echo hello として eol mark が表示されないと勘違いした。

    * fixed: getent が無いというエラーメッセージが出る。
      →検査している気になっていたが実は bash 3.1 では、
      type a b c の中で一つでも存在していれば成功するという事なのか?
      →どうもその様である。つまり ble.pp にあるコードは修正する必要がある。
      調べた所 Bash 4.0 以上で全てのコマンドが見つかった時に真になる様だ。
      修正した。

    * fixed: よく考えたら構文解析で bash version をチェックするのを忘れていた。

  * MSYS2 では paste-from-clipboard という readline 関数が追加されている様だ? [#D1271]
    確認するとやはり paste-from-clipboard は cygwin 版の bash にはない。
    何れにしても新しく対応する事にする。これは /dev/clipboard を見れば良い。
    →実装した。動作確認した。動いている。OK

  * msys2: 端末の座標計算が時々おかしい。 [#D1270]
    https://github.com/akinomyoga/ble.sh/issues/40#issuecomment-582941178

    DA2R を見ると mintty 30000 の気がする。
    実際に Options... を開いてみると mintty 3.1.0 is available
    という感じの内容が表示される。

    或いは何か msys の terminfo か tput が壊れているという事だろうか。
    うーん。これについてもちゃんと調べる必要がある。
    取り敢えず cygwin の term cache と比較してみる?

    → xterm-256color.term (Cygwin) と xterm.term (MSYS2) を比較してみたが、
    着色と DECSCUSR しか違いは見られなかった。これらは配置には関係ない。
    従って、やはり MSYS2 の mintty の振る舞いが変なのだという気がする。
    もしそうだとしたらどの様にして変な振る舞いの原因を特定するのか。
    そしてどの様にして workaround をすれば良いのか。
    結構面倒な問題である。そもそも他の端末で異常は発生していない。
    もし純粋に mintty のバグであるのであれば、これは ble.sh で対処しなくても良い。

    これは CR が効いていないという事? 或いは stty の状態が変?
    以下は stty -a の diff である。微妙な違いはあるが関係ない気がする。
    実際に cygwin を msys 側に合わせてみたが問題は再現しない。
    | --- stty -a (cygwin)^I2020-02-07 07:21:43.088892300 +0800
    | +++ stty -a (msys)^I2020-02-07 07:21:47.549238700 +0800
    | @@ -4,7 +4,7 @@
    |  werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0;
    |  -parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts
    |  -ignbrk brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl -ixon -ixoff
    | --iuclc ixany imaxbel iutf8
    | +-iuclc -ixany imaxbel -iutf8
    |  opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
    |  isig icanon iexten echo echoe echok -echonl -noflsh -tostop echoctl echoke
    |  -flusho
    次に CR の振る舞いを確認する。特に問題なく動いている様に見える。
    何と ${#_ble_term_cr} を出力してみたら中身が空である。。

    分かった。_ble_term_cr='^M' を実行すると中身が空になる。
    _ble_term_cr=$'\r' だと大丈夫。
    その他の駄目なパターンはあるだろうか。
    変数に入っている _ble_term_cr の場合は大丈夫の様だ。

    うーん。これの対策方法は不明である。
    a 一つの方法は _ble_term_cr で CR を使わないという方法。
      別の制御機能 (hpa) 等を用いて _ble_term_cr を模倣する。
      これの問題は本当に CR が欲しい所で _ble_term_cr を使っている箇所がないかという事。
      確認してみた所そういう場所はないようである。
    b もう一つの方法は _ble_term_cr=$'\r' という形式で記録するという事。
      うーん。前者の方が楽だが、こちらの方が妥当の気がする。
      declare-print-definitions を修正する?
      修正したほうが良い気がする。もし MSYS2 でこれが一般に問題になるのであれば、
      その他の場所で記録した CR も消滅するという事である。
      という事であれば declare-print-definition 等で根本から修正する必要がある。

    declare -p の振る舞いについて確認しておく。

      bash-3.1 declare -- a="\$"  bash-3.1 declare -a a='([0]="\$")'  ")'h-3.1 declare -a a='([0]="
      bash-3.2 declare -- a="\$"  bash-3.2 declare -a a='([0]="\$")'  ")'h-3.2 declare -a a='([0]="
      bash-4.0 declare -- a="\$"  bash-4.0 declare -a a='([0]="\$")'  ")'h-4.0 declare -a a='([0]="
      bash-4.2 declare -- a="\$"  bash-4.2 declare -a a='([0]="\$")'  ")'h-4.2 declare -a a='([0]="
      bash-3.0 declare -- a="\$"  bash-3.0 declare -a a='([0]="\$")'  ")'h-3.0 declare -a a='([0]="
      bash-4.1 declare -- a="\$"  bash-4.1 declare -a a='([0]="\$")'  ")'h-4.1 declare -a a='([0]="
      bash-4.3 declare -- a="\$"  bash-4.3 declare -a a='([0]="\$")'  ")'h-4.3 declare -a a='([0]="
      bash-4.4 declare -- a="\$"  bash-4.4 declare -a a=([0]="\$")    bash-4.4 declare -a a=([0]=$'\r')
      bash-5.0 declare -- a="\$"  bash-5.0 declare -a a=([0]="\$")    bash-5.0 declare -a a=([0]=$'\r')

      どうも declare -p は一貫して ".." に囲んで出力する様だ。
      但し、Bash 4.4, 5.0 で制御文字が含まれている場合を除く。
      Bash 4.4, 5.0 の場合にはそもそも ^M が含まれないという事だから、
      ^M が含まれる場合には "" の中にあると仮定して良いだろう。
      従って ^M を $_ble_term_CR に変換する。
      _ble_term_CR は本体の方で直接 $'\r' を代入すれば良いだろう。

      固定文字列とそうでない物は大文字と小文字で区別する事にする。
      * _ble_term_{soh,del,fs} も変更する?
      * 然しそうすると _ble_term_nl も変更しなければならず面倒だ。
        取り敢えず _ble_term_nl は出力に使っているから変更は保留。
        他は特殊用途でしか使っていないのである。

    取り敢えず動いている気がする。これで良い。
    ble-0.3 に移植した。動いている。OK

  * ble-decode/has-input [#D1269]
    →これはマージのミスだった。修正した。

2020-02-06

  * [勘違い] msys2: inputrc の `$if` が正しく解析されていない [#D1268]
    https://github.com/akinomyoga/ble.sh/issues/40#issuecomment-582941178

    うーん。これはシェルコマンドに変換している筈なので、
    そんなに問題になる事はない筈。
    一旦どの様なシェルコマンドに変換されているのか確認する必要がある。

    →これは実はちゃんと処理できていた。勘違いだった。
    paste-from-clipboard という関数が定義されている特別な状況に対する
    $if なのかと思ったが、実は MSYS bash は拡張機能として
    paste-from-clipboard という機能が用意されているのだった。

  * inputrc のコメントが正しく除去されていない [#D1267]
    https://github.com/akinomyoga/ble.sh/issues/40#issuecomment-582941178

    元々の実装の時にコメントは実は行頭から始まらなければならない
    という事を確認したのではなかったのか。
    これについても実際に試して調べる必要がある。

    "\C-t": end-of-line
    "\C-t": end-of-line # hello   ->comment
    "\C-t": end-of-line# hello    ->not-comment
    "\C-t": "end-of-line # hello" ->not-comment

    うーん。ちゃんと quote も考えた上での処理になっている様だ。
    そして # は単語の先頭でなければならない。
    更に、bind '...' に指定した時でもちゃんと # をコメントとして認識している。
    bind -x '"\C-t": echo hello # world' の場合には # world 以降もコマンドの一部になっている。
    bind '"\C-t": "echo" # world' の場合にはコメントとして取り扱われている。
    single quote でも実はマクロとして取り扱われ、
    中にある # はコメントとして取り扱われてしまう事はない。
    $ bind '"\C-t":'\''echo\'\'' # \'\''world test'\'
    で試してみた所 echo' # 'world test という文字列が登録できたので、
    single quote の中でも \' は有効なのだと思われる。

    取り敢えず実装した。未だ見落としがあるかもしれないが取り敢えずこれで良い気がする。

  * ble-0.3 に於ける ble-reload は未だにおかしい [#D1266]
    https://github.com/akinomyoga/ble.sh/issues/40#issuecomment-582941178

    Ref: #D1223 #D1199 #D1130

    ble-update を ble-0.3.2 に対して実行してみたら
    PS1 等の環境変数が失われている。というかコマンド実行されている?
    直した筈の問題が直っていない。
    取り敢えず一番最初に修正するべきなのはこれの気がする。

    commit d35682a で導入した .prologue 呼び出しを
    commit 59c1ce4 で別の場所に移動している。
    これは ble-0.3 ではどの様に適用されているだろうか。
    ble-0.3 に適用したのは ce93c08 である。
    別に prologue が消滅する等の事は起こっていない。

    うーん。実際に症状を確認してみると [ble: detached] と表示されている。
    改めて cygwin で確認してみると再現する。やはり MSYS2 特有の問題ではない。
    ble-0.4 では再現しないので ble-0.3 特有の問題である。
    取り敢えず [ble: detached] を手がかりに調べる。

    どうも。ble-reload を --attach=prompt にしたのにも拘らず、
    check-detach において prompt-attach の時の処理を省略したのが原因の様だ。
    改めて色々ちゃんと動くか確かめる事にする。
    * ble-detach
    * ble-attach
    * ble-detach && ble-attach
    * ble-reload
    * source ble.sh --noattach && ble-attach
    * source ble.sh --noattach
    * source ble.sh --attach=prompt
    * source ble.sh --attach=attach

    一応何れも問題なく動いている様な気がする。

    * ble-reload && PROMPT_COMMAND=

    これは駄目だった。。。どの様にするのが良いだろうか。
    修正した。PROMPT_COMMAND を再度上書きする方式で良かった。
    改めて上記のテストも行った。全て大丈夫である。

  * msys2: root 権限があるかどうかの判定ができない [#D1265]
    https://github.com/akinomyoga/ble.sh/issues/40#issuecomment-582941178

    cygwin の手法を流用しようとしたら常に root 権限がある事になってしまう。
    調べてみると全てのユーザを msys を起動したユーザと見せかけている。
    然し、実際には異なるので何か書き込もうとすると permission denied で失敗する。
    というか Windows の標準のコマンドで管理者権限が在るかどうか
    判定できる物はないのだろうか。

    或いは EUID もしくは UID を見たら分かったりするだろうか。

    と思ったら実際に起動してみると何故かちゃんと判定できている。
    判定には EUID を用いているが実際に EUID を実行してみても 0 ではない。
    しかも $_ble_edit_prompt__string_root を出力してみると '$' である。
    何処で入れ替わっているのか?? 或いはもしかして元の bash の PS1 が表示されている?

    と思ったら分かった。そもそも PS1 に # がハードコードされている。
    逆に言えば何処かに判定するコードが存在しているという事である。
    探せば良い。

    今これが作業中なのでこれについて調べる事にする。
    /etc/bash.bashrc に検出コードがある。
    if [[ -n "$(command -v getent)" ]] && id -G | grep -q "$(getent -w group 'S-1-16-12288' | cut -d: -f2)"
      then _ps1_symbol='\[\e[1m\]#\[\e[0m\]'
      else _ps1_symbol='\$'
    fi

    これを見ると、_ps1_symbol が定義されていて # を含んでいたら privileged と思って良い。
    と思ったが、その直後に unset しているので駄目だ。役に立たない。
    自分で改めて同様のコードを走らせる必要があるだろうか。
    上を参考にして実装した。動作確認した。OK

  * msys2 で動かない [#D1264]
    https://github.com/akinomyoga/ble.sh/issues/40

    見た所 sleep の実装が火を吹いている。cygwin と同じ取扱で良いだろう。
    取り敢えず動くには動く様になった。

    その他調べると色々と振る舞いがおかしい。
    これらは別項目で処理する事にする。

    うーん。面倒なので proghl を merge してしまう事にしよう。

2020-02-05

  * decode: fix error message "command=${[key]-}" for mouse input [#D1263]
    マウスは正式対応していないが contra のテストで有効にして
    試していたらエラーメッセージが出る。
    確認してみると、思い切り未初期化の変数を参照している。修正した。

2020-02-03

  * 2020-01-17 Minix における問題 [#D1262]

    x resolved: ble-reload の後に固まる問題ももしかしてこれだろうか?
      と思ったが症状的に独立な問題だろう。
      →これは別項目で修正した。

    x ok: minix を試していると固まる。と思ったら core.784 として巨大な
      ファイルができている。1.7GB である。道理で固まる訳である。
      ファイルシステムが固まるので他のプロセスもブロックされる。
      検索すると以下の頁が見つかるが余り参考にはならない。
      https://wiki.minix3.org/doku.php?id=soc:2011:debugger

      而もこれは ble-detach した状態であった。但し CPU は 100% ではなくて
      50% になっていた。何らかの別の原因で segfault して、
      その結果として core を dump するのに忙しくて 50% になっていたと
      考えるのが自然である。

      これは恐らくまた別の問題である。これに関しては気にしない事にする。

    x ok: set: tabcomplete というオプションはありませんというエラーになる。
      /etc/profile に set -o tabcomplete というのが記述されている。
      bash にはその様なオプションはない (或いは過去のバージョンにはあったのだろうか)。
      →これは minix の問題であって ble.sh の問題ではない。

    * TERM=minix support
      x fixed: 起動時に c という文字が現れる事について。
      x fixed: コマンドを実行する度に 200404;1 等と表示される。
        これは明らかに bracketed paste mode と modifyOtherKeys である。
        どうやら CSI ? h ですら minix は対応していない様だ。
        取り敢えず対応した。他にも CSI ? を使っている箇所は在る気がする。
      x fixed: eof 判定が動いていない。xenl cap が誤っている?
        xenl=0 にしてみても変化はなかった。
        取り敢えず行末での振る舞いがどうなっているか調べる必要がある。
        →一応 xenl の様な気がする。今の実装はどうなっているのだったか。
        →どうやら SC,RC を使っている様だ。SC,RC を使わない実装?
        →使わない実装に切り替えて見た。多分大丈夫。
      x fixed: SCOSC,RC が動いていない。tput sc / tput rc は失敗する。
        \e7\e8 も動かない。恐らく minix にはないのだろう。
        これの対策は何? 先ず離れた場所に移動しない。
        一行上か或いは panel 3 を利用する。
        一行上を利用するのが自然の気がする。

        ? 然し、delay 後のカーソル位置を取得する方法が分からない。
          特に delay は別プロセスで実行しているので、
          そのプロセスは fork 時の _ble_canvas_x しか知らない。
          メッセージを消去するのは諦める?
          →諦める事にした。
        - canvas.sh 未ロード時の vbell も rc を使っているが、
          対応はしない事にする。実際、使われていない気がする。
          使っているとしても稀なので気にしない事にする。
      x fixed: delete が ^? になっている。
        これは tput kD || tput kdch1 を参照して決める事にした。
      x fixed: C-r が効かない ... reprint undef にしたら直った。
        これも対策を加えた。

    * locale: 例によって locale を切り替えられないというエラーが出ている。
      何処から発生しているのだろうか。一つずつ確認していくしかない?

      取り敢えず補完で沢山メッセージが出るので source:argument を塞いで見たが沢山出る。
      どうも関係ない様だ。そもそも起動した時にエラーメッセージが出る。

      これらは単体で実行しても特に変なメッセージは出ない。
      done: ble/util/.has-bashbug-printf-uffff
      done: ble/util/is-stdin-ready
      done: ble/util/msleep/.check-sleep-decimal-support

      以下の関数は対策が必要な気がする。
      done: ble/widget/.locate-forward-byte
      ok: ble/decode/bind/.generate-source-to-unbind-default
      done: ble/builtin/bind/.parse-keyname
      done: ble/builtin/bind/.reconstruct-user-settings
      done: ble/widget/vi-command/nth-byte

      % どうも ble/util/is-stdin-ready が怪しい気がする。
      % と思って色々変更してみたがどうも関係ない様だ。

      改めて補完の振る舞いを調べるとメニューを表示する時に、
      メニューの項目と同じ数だけメッセージが表示される様だ。
      trace が悪いという事だろうか?
      ble/canvas/trace-tex を手で実行してみたら再現した。
      こういう関数で再現する事が分かった。
      どうもローカル変数の始末は 2>/dev/null がなくなってから?

        fun() { local LC_COLLATE=C; } 2>/dev/null

      trace-text を修正したらメッセージは出なくなった。

  * 2020-01-17 Haiku における問題 [#D1261]

    x ok: Haiku で ble-reload 時に変なメッセージが出る。
      まあこれは bash-4.4 の問題かもしれない。
      →CentOSでやると日本語でエラーメッセージが表示されていて、
      その長さなどが一致している気がするので Haiku のエラーメッセージは
      やはり bind 回りの Bash のバグだろう。

    x ok: また、sleep を呼び出すと Terminal のタイトルバーに
      それが一々表示されて面倒である。別の実現方法を考えた方が良い?
      もし /dev/zero があるならば /dev/zero を読み出そうとするとどうなるか確認してもよい。
      CPU を食わないのであればそれで行く。

      →read -t 1.0 でも同様に Terminal のタイトルが変更される。
      どうも何のプログラムであってもブロックされていると何か出る様だ。
      短い read -t 0.01 をループで回しても同じだった。
      なのでこれはどうしようもない。

2020-02-02

  * decode: 遅延 bind で正しい key に割り当てられていない [#D1260]
    これは cmap が初期化されていないのに ble-bind を呼び出したからである。
    bashrc の中から ble-bind も bind も呼び出される可能性がある事を考えると、
    cmap/initialize 及び decode/initialize はそれぞれ ble-bind, bind から
    呼び出す様にしておかなければならない。もしくは初めから呼び出しておく。
    ble-bind がある度に初期化済みかどうかを確認するのは非効率的だろうか。
    余り考えない事にする。そもそも ble-bind は重いので気にしない。

    序でに blerc を遅延で読み込む事も考えてみたが、
    ble.sh による PS1 等を待避した特別な環境で評価すると変な事になるので、
    やはり今まで通り最初にロードする事にする。

    一連の変更により ble-bind は自動的に遅延される様になったので、
    eval-after-load により手で遅延させる必要がなくなった。
    これに伴い wiki の記述も変更して良いのでは→更新した。

  * 2019-02-09 bind: `bind -XpPS` 等から現在の設定を読み取る? [#D1259]

    現状で bind -X が信用出来ないので、完全な対応は不可能である。
    その様に考えるとやはり builtin bind を上書きして設定を読み取る方が現実的である。
    なので、現在の bashrc の冒頭でロードして、末尾で attach するという形式は当面変わらない。

    * Note: 2019-12-14 bind -X については bash に修正が入った。
      https://lists.gnu.org/archive/html/bug-bash/2019-12/msg00053.html

    * Note: 2019-12-30 detach 時の復元に関して。
      現状では bind -X の設定を読み込んでから
      bind -ps の設定を読み込む様にしている。
      これで古い bind -x の設定によって bind -ps の設定が上書きされてしまう事はなく、
      逆に bind -x の設定を bind -ps で上書きした後には ble.sh の復元でも上書きされる。
      問題が起こるのは bind -x した後にそれを bind -r して、
      それ以降に何も bind していない場合である。
      試してみたが何にも bind していないキーは列挙されない。

    * Note: 2019-12-30 特にこの項目が意図しているのは
      detach 時の復元ではなくて attach 時に ble.sh keymap に反映させるという話である。
      一方で bind -Xps の出力は \C-\ の振る舞いが微妙なので色々面倒である。

    2020-02-01 やはり README を読まずにいきなり bashrc の末尾で source して
    ble.sh が key binding を上書きしている。unbind が設定できるようにするべき、
    等と言いがかりをつけて来る人が現れた。やはり bind -Xps から設定を読み取れる様にしたい。

    ? Bash \C-\ vs \C-\\ Bug の処理
      さて、その時に問題になるのが C-\ をどう解釈するのかという事。
      取り敢えず \C-\M または \M-\C 以外の時は単独で解釈する事にする?
      否、\C-\\ も特別扱いしなければならない。うーん。
      →これは ble/builtin/bind の実装の問題なので別に考えるべき事?
      或いは ble.sh では \C-\\ に対応する事にして、
      但し、bind の出力は補正して記録する様にする。という事?
      そもそも補正する事は可能なのだろうか。

    先ず、既定の設定との差分を取りたい。
    取り敢えず既定の設定は以下の様な感じにして取得できる。
    bash-$a --norc -i -c 'bind -p' | sed '/^#/d;s/"\\M-/"\\e/'
    既定の設定との差分はどの様にして取るのが良いか。
    diff を呼び出してその結果を解析するのは面倒である。
    それならば awk で複雑になるかもしれないがちゃんと処理する方が良い気がする。
    →取り敢えず awk を使って検出できる様にはなった。
      然し、検出した物をどのタイミングで評価すれば良いのか。

    inputrc を読み取る作戦にしていた時はどのようにしていたか。
    うーん。inputrc の読み取り自体を遅延して、
    最初に bind を呼び出した時に読み出す様にしていた気がする。
    →やはりそうなっている。

    ? では何故その場で bind を評価する様にしていたのか。

      | 何故 bind 自体を遅延する様にしていなかったのか。
      | これには何か理由があった様な気がするが思い出せない。
      | →inputrc の読み取りに最初に対応したのは #D1038 であった。
      | inputrc の読み取りのタイミングについて議論があるのは #D1127 である。
      | ここでの議論によると、bind をした順序によってどちらが上書きされて
      | どちらが残るのかが変わるので順序は変更できない。
      | なので、bind を実行する前に inputrc は読み込んでおかなければならない、
      | という話になっている。

      bind の順序を保持する為に bind 前に inputrc を読んでおく必要があるという話

    それならば全ての bind を遅延させる事にしておけば問題ないという気がする。

    [実装]

    * done: bind の評価は keymap 初期化迄遅延する様にする #D1258
    * done: readline 既定の設定をキャッシュする
      これは簡単。
    * done: ユーザ設定を読んでそれを反映させる。
      これも実装した。特に問題なく動いている気がする。

    * done: \C-\, \C-\\ の補正の可能性
      https://lists.gnu.org/archive/html/bug-bash/2020-01/msg00037.html
      そもそも ble/builtin/bind ではどの様に解釈していたのだったか?
      と思って確認してみると ble/util/keyseq2chars で解釈している。

      ble/util/keyseq2chars の解釈は微妙に間違っている気がするので、
      新しい Bash-5.1 の解釈に合わせて更新することにした。
      取り敢えず動いている様である。

      更に、bind の出力結果をこの形式に合うように補正する事を考える。
      どの様に補正するか? 取り敢えず \C-\ の次に \ が来て文字列が終わっている場合は OK
      それ以外の場合には \C-\ は C-\\ に修正するべきなのである。
      →修正するコードを書いた。

    取り敢えず動いている。良いのではないだろうか。
    但し、bind -X は Bash 4.3 以降でしか使えないので、
    Bash-4.3 以降でしか "何処でも source ble.sh できる" とは書けない。

  * decode: bind の評価を keymap 初期化迄遅延 [#D1258]

    どの keymap に記録する様にするのが良いのか。
    1. bind に直接 -m が指定されている時はそれを使う。
    2. bleopt で keymap が指定されている場合にはそれを使う。
      inputrc の中ではそれは無視する? うーん。
      inputrc の中で keymap を指定している時にはそれを使う。
      或いは bind 経由の時には ble の keymap は無視して、
      その時の vi/emacs の keymap で処理してしまって問題ない?
      取り敢えず default_keymap は考えずに実装する。
      そもそも今迄もその様に実装していたのではなかったのか。

    実装を辿っていくと
    ble-decode-key/{bind,unbind} 辺りが最終的には呼び出されている。
    ble/builtin/bind の枠組みよりは更にその上の枠組に於いて、
    bind の呼び出しを遅延させる方が実装として自然である。
    その様に修正する事にする。

    現在の実装では ble-decode/DEFAULT_KEYMAP を呼び出した時に
    keymap も完全にロードしてしまう仕組みになっている。
    うーん。完全にロードする必要がない時には別の関数を呼び出す?

    * done: ble-decode-key/bind の引数に kmap を指定する様に変更する
    * done: DEFAULT_KEYMAP は INITIALIZE_DEFMAP に改名した

    うーん。遅延させる様にしようとしたが、
    これだとあらゆる keymap が遅延されてしまう。
    どのタイミングで具体的に keymap を生成するのか。
    遅延させるのは default-keymap だけで良いのではないのか。

    そもそも現在の keymap の初期化順序としてどのような可能性があるのか分からない。
    ? INITIALIZE_DEFMAP は必ず通過するのか? 調べてみたがそうでもない気がする。
    以下の様な構成になっている。

      | ble-decode/keymap/load
      |   <del>ble/util/import "keymap/$1.sh"</del>
      |   ble-decode/keymap:$1/define
      |   ble-decode/keymap/register "$1"
      |
      | ble-decode/keymap/push
      |   ble-decode/keymap/load 同上
      |
      | ble/builtin/bind/.initialize-kmap
      |   ble-bind/load-keymap
      |     ble-decode/keymap/load 同上
      | ble-bind
      |   ble-bind/load-keymap
      |     ble-decode/keymap/load 同上
      |
      | ble-edit/bind/load-keymap-definition
      |   ble-edit/bind/load-keymap-definition:"$name"
      |   source "$_ble_base/keymap/$name.sh"
      |   ここでは /define までは必ずしも呼び出さない。呼び出す場合もある。

    * done: ble-decode/keymap:$1/define の中で regiter, onload を呼び出す。
      と思ったが /define の呼び出し元が限られているのだとすれば、
      呼び出し元を本当に制限して、呼び出し元の側で必要な処理を実行すれば良い気がする。

      /define の呼び出し元を列挙する。結局本質的に一箇所しか無い様なのでOK

      と思って修正したが、よく考えると各 editing-mode でのキャッシュは
      onload でユーザの指定した修正を適用する前の物を dump しなければならない。
      うーん。opts=raw とした時には onload は実行しない様にする?
      或いは opts=dump とした時に特定の fd に対して raw の定義を出力する?
      後者を採用する事にした。

    * done: ble-decode/keymap:$1/define に関しては keymap/$1.sh は参照しない。
      これは本当にそれで良いのだろうか。
      将来的にはこちらの方を keymap/$1.sh にして、editing mode の方を別名にするべきでは。
      と思ったが現状で利用していないのでそれで良い。
      それにその keymap を利用する機能がロードされた時に
      ble-decode/keymap:$1/define が定義される様に計らうべきである。
      よって、 ble-decode/keymap/load からは keymap/$1.sh のロードは削除する。
    * done: ble-edit/bind/load-keymap-definition の中の source は import に置き換える。
    * done: ble-edit/bind/load-{keymap-definition -> editing-mode}
    x fixed: 見事に起動しなくなった。駄目だ。うーん。ble-bind が動いていない様だ。
      →これは簡単なミスだった。修正した。
    * done: /define の中で自分で ble_bind_keymap 等を設定しなくても良くなった。削除する。
      削除した。動いている。

    | 結局、以下の様な仕組みになっている様だ。
    |
    | 1. 先ず初めに編集モード全体の読み込みを行う
    |   ble-decode/INITIALIZE_DEFMAP
    |     ble-edit/bind/load-editing-mode
    |       ble-decode/keymap:$1/define の存在を保証
    | 2. 次に必要になった時に各 keymap を初期化する

    * done: ble/builtin/bind/.initialize-kmap, ble-bind/load-keymap の呼び出しを省略する
      取り敢えずこれらの関数では basemap 名の取得に留める事にした。
    * ble-decode/INITIALIZE_DEFMAP の呼び出しを削減する。(初期化を遅延する)
      * done: ble/builtin/read で ble-decode/keymap/push read する前に
        ble-decode/INITIALIZE_DEFMAP を呼び出していたが無駄な気がするので削除する。
        これは本当に大丈夫だろうか? keymap/pop した後に固まる可能性は?
        →やはり keymap/pop した後も _ble_edit_read_accept=1 経由で停止するので、
        元々設定されていた keymap が使われるという事は起こらない。
        やはりなくて良い気がする。
    * ok: ble-decode/INITIALIZE_DEFMAP を適切な名前に変更
      これは現状のままで良さそうな気がする。
    * done: .onload で遅延させた設定を読み込む様にした

    * ok: keymap:*/define に対して軒並み autoload しているが
      % これは今でも必要だろうか。今回の改修で不要になった可能性は?
      % 元々の動機を調べて不要になったのであれば削除する。
      →これはやはり ble-bind で変な keymap に誤って登録しない為に、
      どの様な keymap が存在するかを事前に分かる様にする為に残す事にする。

    [動作確認]

    本当に遅延されているのだろうか? 初期化のタイミングを調べれば良い。
    x fixed: bind.delay.$keymap の中を覗くと引数が全く保存されていない。
      これは ble/util/pritn-quoted-command のバグだった。修正した。
    取り敢えず遅延はされている様である。
    しかし、widget が見つからないというエラーメッセージが出る。
    うーん。widget のチェックも遅延させるべきだろうか?

2020-02-01

  * syntax: ((1))a と入力するとエラーメッセージが出る [#D1257]
    これは恐らく着色のコードが悪い。修正した。
    coproc 対応の時の抜けだった。

  * Bash Readline 束縛との互換性 [#D1256]
    fzf の様な既定の bash の binding を想定する様な枠組みの場合、
    ble.sh 側の binding が少しでも違うと動かなくなる。
    その意味でちゃんと何れの機能もそれなりに同じ振る舞いをする様になっているか?

    * emacs mode に関しては全ての widget に対応している。
      binding に関しては完全に一致させているか確認していないが、
      だいたい大丈夫だろうという気がする。問題が出てから対処すれば良い。

    * vi に関しては未だ対応していない機能が幾らかある。
      しかしこれらは default の binding を持つものだろうか?

      vi-back-to-indent
      vi-complete
      vi-eof-maybe
      vi-overstrike
      vi-overstrike-delete
      vi-tilde-expand
      vi-yank-arg
      vi-yank-pop

    確認する必要がある。

    * vi_nmap:
      * done: backward-word (C-left, M-left) forward-word
        実はこれらに関しては既に登録されている。
        vi-command/forward-vword (C-left)
        更に M-left, M-right にも対応する?
        特に vi_nmap ならば M- を設定しても問題ない気がする。
        然し本当に問題ないだろうか。

        isolated ESC 関係の判定は ble-decode/uses-isolated-esc で行っている。
        中を確認すると vi の時には問答無用で isolated ESC は ESC として処理される。
        M- 束縛があっても M- 修飾にはならない様である。
        なので M-... を束縛しても問題は起こらない。

        然し、一方で他に何も M- が束縛されていない状態でこれを束縛するのは
        統一性にかけるのではないかとも思う。そもそも vi-command には他に
        M- は登録されていなかったのだろうか。或いは積極的に登録されている?
        →調べてみた所他には登録されていない。M-left, M-right だけが登録されている。

        もう一つの問題として実際に CSI 1 ; 3 D や CSI 1 : 3 C を送る端末があるのか、という事。
        もしそのような端末が存在しないのであればわざわざここで対応する必要もないのではとも思う。
        然し、世の中には絶対はない。設定して問題ないのであれば設定しておいて問題もなかろう。
        という訳で設定する事にした。

      * done: kill-word (C-delete)
        これに関しては新しく widget を作成する必要がある気がする。
        作成した vi-rlfunc/kill-word

      * done: insert-comment (#)
        うーん。これに関してはどの様に対応するのが良いか。
        これは編集行に対する編集を伴う。
        その様なコマンドの実装例があるとやりやすい。

        確認すると replace-char, undo ぐらいである。
        中を見ると両方とも
        ble/keymap:vi/mark/{start,end}-edit-area を使っている。

        ble/keymap:vi/repeat/record はどのように呼び出せばよいのか?
        と思ったが insert-comment は実行を伴うので . で繰り返せるというのは変である。
        なのでこれは完全に無視して問題ない。

      * done: quoted-insert (C-q, C-v: batting している)
        これは仕方がない。無視する。
        唯、widget は準備しても良いのかもしれない。

        うーん。これはどうやって実装したら良いのだろうか。
        →丁度 vi-command/replce-char と quoted-insert を組み合わせれば良い。

      * done: unix-line-discard (C-u: batting)
        これは現状では vi_nmap/backward-line-scroll になっている。
        難しい。unix-line-discard の方がシェルとしては自然な気がする。
        backward-line-scroll を実際に使っている人がどれだけいるのか?
        特にシェルでは複数行の操作をする事は余りない。
        という事を考えると unix-line-discard にした方が良い?
        然し、unix-line-discard が破壊的操作であると考えると現状の方が安全である。
        うーん。これも保留という事にする。

        但し、明示的に unix-line-discard を bind した時に対応できるようにはするべき。

      * done: vi-eof-maybe (C-d: batting)
        これは現在 bind されている機能とは違う物だろうか。
        →振る舞いを調べてみると vi-eof-maybe は現在のコマンドを実行する様だ。
        もし空の場合には終了する。
        →新しく widget だけ実装した。

      * done: vi-tilde-expand (&)
        これは新しく実装しようとしたが @edit tilde-expand で良い気がする。

      * vi-yank-arg (_)
        うーん。これの対応は面倒である。
        →readline の振る舞いを調べた所、一旦 insert-mode に入ってから
        挿入を行う様である。という事であれば対応はそんなに大変ではない。
        引数は認識していない気がする。

        うーん。D と似たような感じに実装すれば良い?
        と思ったけれども違う。
        面倒なので append-mode を呼び出して self-insert, insert-last-argument
        を順番に呼び出すという安直な実装にした。多分これで大丈夫なのではないか。
        と思ったが irepeat による記録が行われていない…。うーん。

        然し、insert-last-argument の様な複雑なモードの後も
        imap repeat が有効というのも変な気がするので、
        いっその事 imap repeat はキャンセルする事にする。

        取り敢えず動いている様な気がするのでもう気にしない。

    * ok: vi_imap に関しては対応できていない物はない気がする。

    * ok: bash の s, S vi-subst は一体何?
      →これは s と S を共通の rlfunc から呼び出せる様にしたというだけの物だった。
      現状のままで振る舞いとしては一致しているので気にしなくて問題ない。

  * fzf が動かないという問題の報告 (reported by jpninanjohn) [#D1255]
    https://github.com/akinomyoga/ble.sh/issues/38
    これは fzf が shell-expand-line & history-expand を使っている為に起こった問題である。
    彼は README を読んでいない。

    ? 然し、何故 history-expand を実行する必要があるのだろうか。
      最初から展開結果の文字列を出力しては駄目だったのだろうか。
      末尾の改行の為? →試してみて分かった。shell-expand-line だと勝手に改行が削除される。

      然し、試した結果 "`command`" ならば改行がちゃんと保持される様である。
      確かに echo `...` で生成すると単語分割の対象になって、
      改行の類は効果としては空白と同じなので自然である。
      * 然し、だからと言って fzf に "`__fzf_history__`" を提案したとすると、
        今度は ble.sh の側で明示的に quote された状態になってしまって動かない。
        従って、fzf に "`...`" の形式を提供しても意味がない。

    * ble.sh の振る舞いを Bash の振る舞いに近づけるとしても。
      echo "echo hello" が echo echo hello に展開されたり、
      或いは "`...`" がコマンドの実行結果その物になったり、
      色々と振る舞いが異なるのである。

      近づけるというよりは破壊的に変更しなければならない気がする。
      然し、元々の機能が echo "echo hello" を echo echo hello
      に変換してしまうぐらい潔い物なのだとしたら、
      逆にそれに合わせても良いのかもしれない等とも考える。

    bash の振る舞いに合わせる事を考える。
    更に fzf の他の binding もちゃんと動くか確認する。

    * done: shell-expand-line の振る舞いを bash と同様の物に修正する事にした。
      その前に bash の振る舞いについて再度確認しておく。

      * 展開結果に含まれる quote は一切処理されない。
        ~$ function ff2 { echo '"echo hello"'; }
        ~$ echo `ff2`
        -> echo "echo hello"

      うーん。quote を実行している一行をコメントアウトしただけで
      bash と同じ振る舞いになった様な気がする。
      shell-expand-line に引数として quote を与えなければ、
      bash と同じ振る舞いになる様に変更した。

    o fzf の動作確認
      その他の binging (C-t, M-c) も試してみたがこれらは問題なく動いている。
      これでよしという事にする。

  * syntax: eval の引数のファイル名が着色されていない [#D1254]
    というか、eval の引数はコマンドとして解釈しつつ着色したい気がする。
    一方で。'...' としてコマンドを記述できる事を考えると、
    awk '...' や sh -c '...' で考えているのと同様に着色したい気もする。

    取り敢えずの所は引数として着色するのが妥当なのではないか?
    →確認してみると単語の種類は ARGEI になっている。
      補完はコマンド名になっている。
      着色はされていない。

    % 分かった気がする。コマンドとして補完されているのは、
    % 恐らくコマンドラインの一番最初の単語になっているから。
    % eval a=() echo としていたので a=() の手前でコマンドラインが途切れている。
    % →と思って確認してみたが eval echo g++ としても全てコマンドとして補完される。

    実装を確認すると CTX_ARGEI に variable:= command file が割り当てられていた。

    x fixed: CTX_ARGEI の補完でディレクトリ名が a/ と a になっていて
      絞り込みが出来ていない。コマンドの場合にもディレクトリ名には / を入れずに、
      suffix に / を指定するべきでは。と思ったが、その場合にはコマンド名と
      ディレクトリ名が重複していた場合に問題にならないか。

      更に言うと、異なる種類の見た目が同じ候補があった場合に
      どちらの action を採用するのかという問題が残る。
      結局、補完対象の文字列を合わせたとしても問題は解決しない。

      そもそもコマンド名でもファイル名でもどちらでも良い、
      という文脈が不自然なのである。どちらか限定できる様にならないか?

      →結局この文脈ではコマンド名の生成時にディレクトリを列挙しない様に修正した。
      source:command で引数を受け取る様にして、
      D が含まれている時にはディレクトリ名列挙を抑制する。

    さて、補完はこれで余り気にしなくて良い気がする。
    問題の着色が為されていない問題について。何故着色が為されていないのだろうか。
    コマンドの抽出はちゃんとできているだろうか?
    →分かった。肝心の progcolor/word:default で CTX_ARGEI を見るのを忘れていた。修正した。

  * OK: syntax: eval a=() echo helo=() の構文エラーを検出できていない [#D1253]
    →と思ったが、これは eval の時点で構文エラーになっているのではなくて、
    eval から呼び出されたコマンドの評価の場面で構文エラーになっているのではないか。
    実際に以下を試してみたら何もエラーは発生しなかった。
    $ bash -n -c 'eval a=() echo c=()'

  * syntax: 何と coproc に対応していない [#D1252]

    普通のコマンドと同様に処理しておけば取り敢えず問題ないと思っていたが、
    実際にやってみるとエラー着色になってしまっている。
    そもそも coproc のコマンド部分には特別なコマンドも指定できる。

    | 然し、coproc はどうやって [COPROC] の部分を変数名かコマンド名か判断しているのだろうか。
    | 試しに coproc hello echo としたら、hello がコマンド名と認識された。
    | というか coproc COPROC echo -e hello としても COPROC がコマンド名として解釈された。
    |
    | coproc var ((...))
    | coproc var { ... }
    | coproc var do
    |
    | どうも関数と同じ構文の様な気がする。つまり、後に複合コマンドを期待する。
    | もし複合コマンドが来なかったら通常のコマンドとして処理する。
    |
    | 1. coproc の後に普通のC単語以外の単語が来たらコマンドだと思う。後は通常処理。
    |   C単語が来たら取り敢えず変数の可能性を考える。
    | 2. C単語の後に複合コマンド (キーワード) が来たら受け付ける。
    |   (coproc var と複合コマンドの間には改行も入れられない様だ)
    |   それ以外の場合にはC単語をコマンドという事にして、新しい単語は普通の引数という事にする。

    [文法まとめ]

    a coproc の次の単語がキーワードなら、複合コマンドとして取り扱われる。
      因みに then, coproc, fi, ! 等の複合コマンドの開始でないキーワードでも、
      取り敢えず複合コマンドとして解釈をしようとし、後の文法エラーになる。
      但し、time は例外である。ここではキーワードとして扱われない。
      キーワードとして扱われる物を列挙する。
      - ( ((
      - { } ! [[
      - if then elif fi, while until do done, for select case esac
      - coproc, function
    b それ以外で、次の単語がC単語でない時は、通常のコマンドとして取り扱われる。
    c それ以外の時、次の単語はC単語である。更にその次の単語 word2 を調べる。
      c1 word2 がキーワードなら、word1 は変数名として取り扱い、
        word2 は複合コマンドとして取り扱われる。
      c2 それ以外の時は、word1 は通常コマンドとして取り扱われる。

    | どの様に実装するのが良いだろうか。
    |
    | a coproc が来たら取り敢えず特別な文脈にする。
    |   最初の単語の読み終時に単純な単語かどうかの判定を行い、
    |   もし単純な単語であるならば前方に先読みを実施する。
    |   [[:space:]]*(複合コマンド) の形式をしていたら、
    |   最初の単語は変数名であったと見做して着色・単語設定する。
    |   それ以外の場合にはコマンドとして着色・単語設定する。
    |
    | b 実は coproc を受け取った時点で先読みを実施してしまっても良いのでは?
    |   先読みを実施する時に何か問題が起こるだろうか。
    |
    |   % o 寧ろ無闇に文脈値を増やすよりは良いのではないだろうか。
    |   %   と思ったが、文脈値は結局増やさなければならない気がする。
    |   %   "変数名の後に複合コマンドを期待する文脈"
    |   %   というのを新しく追加しなければならない。
    |
    |   文脈値をどうせ増やすのであれば、a の方針で良い気がする。
    |
    | →a の方針で実装する。

    実装した。動いている。

    x fixed: progcolor が中途半端にしか動いていない?
      coproc hello world から単語を削除して coproc hello に
      すると progcolor ではない単語着色になっている。
      (単語着色がされていないという訳ではない。)

      どの様なコマンド抽出になっているのかを確認する必要がある。
      確認した所、以下の様になっていた。coproc が親コマンドになっている。
      うーん。自身が CTX_CMDI の時には親を抽出しない様にすれば良い?
      comp_cword='1' comp_line='coproc hello' comp_point='12' comp_words=('coproc' 'hello')

      確認した。自身が CTX_CMDI であっても兄を探索する様になっていた。修正した。

2020-01-31

  * 2020-01-23 Cygwin でテスト vi_test が失敗している [#D1251]

    | 操作を実行した後のカーソルの位置が一文字ずれている様だ。
    | コマンドラインで実行すると特に変な振る舞いをする事はない様だ。
    |
    | ble-0.3.1 でもテストが失敗している。こちらは linux でも再現する。
    | テスト自身のバグである可能性が高い様な予感がしている。
    |
    | うーん。そもそも何故 linux と結果が異なるのか。
    | Cygwin 特有の処理に問題があるとすればもっと広範に渡って影響が出るのではないか。
    | bash の version の違いかとも思ったが version を合わせても再現する。
    |
    | 実際に再生されている内容を確認してみると変な事になっている。
    | 65 32 104 101 108 108 111 0 0 0 0 0 0
    | C-[ と入力した物が 0 0 0 0 0 0 に変換されている。どういう事か?
    | 記録されているレジスタの中身は "A helloM-xM-^DM-^@M-^@M-^AM-^[" である。
    |
    | どうもレジスタの値に変換する時点で変な事になっている様だ。
    | 記録されたキー列は 65 32 104 101 108 108 111 67108955 であるが、
    | それを文字列に変換した結果が $'A hello\370\204\200\200\201\233' になっている。
    | これは変だ。ble/decode/charlog#encode の実装を確認してみると
    | 唯単に文字コードから文字列に変換しているだけ。linux で動いているという事は、
    | キー列の時点で修飾が外れているのか、或いは文字にエンコードしても
    | 巨大なコードポイントを持つ UTF-8 文字として取り扱われているのか。
    | →linux で動いているのを確認してみた所、ちゃんと一つの文字として扱われている。
    | →更に文字列に変換した結果も同じになっている。
    |
    | →うーん。記録された register の値を出力する時に表示が異なる。
    | 本質的にはバイナリとしての中身は同じであるのにも拘らず (本当か?)。
    | OSについている UTF-8 復号器が真面目に不正な文字を除去するか、
    | 或いは素朴な UTF-8 復号をそのまま用いるかの違いという事だろうか。
    | ? UTF-8 6byte 表現の各バイトを更に UTF-8 符号化している可能性?
    |   →バイト数を確認してみた所 13 であり、これは 'A hello' (7) + 6 に
    |   なっているので 6 byte 表現は 6byte 表現のままである。
    | ? そもそもこの記録された文字列の文字数はどう数えられている?
    |   →13になった。つまり、UTF-8 の不正な表現は1文字ではなくて、
    |   6文字と数えられているという事になる。うーん。
    |
    | つまり。。ここで考えなければならないのは、
    | charlog#encode, decode で巨大な数を保存・復元できる様にする事。
    | 特に復元の際に UTF-8 5,6バイト表現としての復元を試みる?
    |
    | (但し、bash 3.2 ではうまく変換できていない様にも見える)
    |
    | * そもそも何故 linux と cygwin で振る舞いが変わっているのか。
    |   これは bash の実装の問題なのかもっと下の枠組みの問題なのか。
    |
    | * 巨大な文字コードを無理やり文字に変換することの是非
    |   現在は UTF-8 を仮定しているから動いているが、
    |   例えば LANG=C の場合にはそもそも 256 以上のコードを表現できない。
    |   ESC seq に頼るしか無いのではないか。
    |
    |   これを実装した時にはどの考えていたのだったか。
    |   blame で確認する。commit は 06698a4f である。#D1026 に議論がある。
    |   うーん。大して考えていない様な気がする。
    |   他の文字コードに対応する時には、その文字コードで割当てられていない
    |   文字を用いて特別に処理するしかない。

    取り敢えず状況を整理する。
    * 修飾したキーを記録する為に巨大な数を UTF-8 encode している。
      結果として UTF-8 としては本来不正である様な表現に変換される。
    * Linux ではその文字の長さは 1 になるが Cygwin では 6 になる。
    * 復号する時に一文字ずつ復号するのでその時に
      Cygwin では元の文字が分解されてしまう。不正なバイトなので 0 になる。

    | 確認する。
    |
    |   linux$ ble/util/c2s 67108955; echo "${#ret}:$ret" | cat -A
    |   1:M-|M-^DM-^@M-^@M-^AM-^[$
    |   cygwin bash-4.4$ ble/util/c2s 67108955; echo "${#ret}:$ret" | cat -A
    |   6:M-xM-^DM-^@M-^@M-^AM-^[$
    |   cygwin bash-5.0$ ble/util/c2s 67108955; echo "${#ret}:$ret" | cat -A
    |   6:M-xM-^DM-^@M-^@M-^AM-^[$
    |
    | と思って出力された内容を見ると何だか変だ。
    | 最初の文字が M-x になっている。Linux では M-l である。
    |
    | 調べてみると printf \Uxxxxxxxx が駄目の様だ。
    | 以下のコマンドが linux と cygwin で異なる結果になる。
    | cat が勝手に変換している可能性も考えたが od -tx1 で見るとやはり違う。
    | $ printf '\U0400005b\n' | cat -A
    |
    | つまり、これは復号の問題ではなくて key -> s 符号化の問題?
    | 何故 cygwin と linux で振る舞いが変わるのかというと実際に使っている実装が異なるから?
    | printf の実装を確認してみると u32cconv という関数を呼び出している。
    |
    | うーん。u32cconv の実装を見ると早速変な所がある。
    | 取り敢えず wchar_t が 4B の環境では wctomb を使っている。
    | 2B の環境では surrogate pair に変換してから wcstombs にしている。
    | もし wcstombs がちゃんと surrogate pair に対応しているのであれば問題は起こらない。
    | さて、今回の場合はそもそも値が Unicode の範囲外である為、
    | この wcstombs も呼び出される事はない (そもそも surrogate pair で表せない)。
    |
    | さて結局 u32toutf8 という関数の返す結果が壊れているという事が分かった。
    | うーん。この最後の if の 1B 目が間違っている気がする? f8 ではなくて fc では。
    | そしてこれは最近報告に上がっていた物である気がする。
    | これだ https://lists.gnu.org/archive/html/bug-bash/2019-11/msg00042.html
    | そして patch の中身を見ると自分が思ったのと完全に同じ修正だった…。
    |
    | * 影響を受ける bash のバージョンは?
    |   さて、Bash のバグだと分かった所で。どうやって対処するべきか。
    |   因みにこのバグはいつからあるものだろうか。先ずそもそも printf が \U....
    |   に対応したのは bash 4.2 からで、最初から間違っていた様だ。
    |   → Bash 4.2 -- 5.0 の全て。
    |
    | * 果たして復号の方は問題ないのか確認が必要である。
    |   →駄目だった。
    |   $ ret=$'\xfc\x84\x80\x80\x81\x9b'; echo "${#ret}:$ret" | cat -A
    |   1:... linux
    |   6:... cygwin
    |
    |   $ ret=$'\xfc\x84\x80\x80\x81\x9b'; ble/util/s2c "$ret"; echo $ret
    |   67108955 linux
    |   0 cygwin
    |
    |   linux で動いている物が cygwin では動かない。
    |
    |   $ ret=$'\xfc\x84\x80\x80\x81\x9b'; printf %d "'$ret"
    |   67108955 linux
    |   0 cygwin
    |
    |   切り出しだけの問題かと思いきや、' を指定した場合でも駄目の様だ。
    |
    |   この printf %d 'c の実装を確認する。整数引数を読み取る時に、
    |   getintmax という関数を呼び出している。その中で ' を確認できたら、
    |   asciicode() という関数の結果を返している。
    |   というか ' の代わりに " でも良い様だ…。知らなかった。
    |
    |   うーん。asciicode の中を確認すると mbtowc という関数を呼び出していて、
    |   この関数が -1 を返している。つまり不正な UTF-8 である事を検出している。
    |   これは bash の側に無理やり変更を押し込む訳にも行かない。
    |   かと言って cygwin の mbtowc の実装事態に変更を押し込むのも変である。
    |   (linux では mbtowc が恐らく変な UTF-8 でもそれなりに解釈するのだろう)

    改めて整理する。
    * key値から文字列に変換する時、以下で報告されているバグによって誤った形式になる
      https://lists.gnu.org/archive/html/bug-bash/2019-11/msg00042.html
    * それとは別に Cygwin の mbtowc は範囲外 UTF-8 に対してエラーを検出する。
      恐らく Linux の mbtowc は範囲外 UTF-8 でも旧規格の通りに復号するのだろう。

    | そもそも現在の実装は UTF-8 を前提としている。
    | UTF-8 に依存しない実装に変換するべきなのではないか。
    | 文字列として埋め込む事ができるのは "文字" と制御文字だけである。
    |
    | 以前の実装ではエスケープシーケンスを用いていたが問題として長くなり過ぎる。
    | →今あらためて確認した所カーソルキーはエスケープシーケンスに変換されている。
    | 他にも様々な入力を試してみたが何れもちゃんとエスケープシーケンスになっている。
    | C-[ だけがエスケープシーケンスになっていないのであった。調べる。
    | vi.sh の側で加工しているのだろうか、と思ったがそうではなかった。
    | decode を通過する文字をそのまま記録している様だ。
    | ble-decode-char の中を通過する文字をそのまま計測している様だ。
    |
    | つまり更に上の ble-decode-byte が C-[ を処理している。
    | ble-decode-byte は各符号化方式で実装していて特に ESC について意識している訳ではない。
    | とすれば最終的には init-bind に行き着く? うーん。然し中を確認すると U+07FF を送信している様に見える。
    |
    | 何処で C-[ になるのか分からない。と思ったら分かった…。
    | これはテストが悪いのだった。
    |
    | _ble_keymap_vi_test_ble_decode=ble-decode-char で評価関数を ble-decode-char にしながら
    | C-[ という修飾キーを指定したのが悪かった。
    | これにより本来文字として受信しない筈の文字を受信させてテストを実行していたのだった。

    結論としては
    * vi_test が悪かった。テストのデコーダに ble-decode-char を指定しているのに
      テストの入力に key C-[ を指定していたのがいけなかった。
    * charlog#encode, decode は key の符号化・復号はそもそも想定していなかった。
      なので Unicode 範囲外の文字に対して対策はしなくて良い。

    kspec に IsolatedESC を指定できる様にする。
    或いは U+07FF の様な形式で文字を指定できる様にする。
    →@ESC @NUL U+xxxx の形式に対応した。

    x fixed: Linux 上でマクロが動かなくなった。と思ったら ble-decode-kbd の
      中のチェックで keyname は _alnum で構成されていなければならないというチェックが入っていた。
      _alnum に加えて @ も keyname を構成する文字として許す事にした。
    x fixed: U+07FF が動かない。と思ったら正規表現の誤りだった。修正した。

    テストが全て通る様になった。OK

2020-01-30

  * auto-complete: C-e でも補完確定にするべきなのでは? [#D1250]
    追加した。

  * highlight: pathname に含まれるディレクトリのシンボリックリンク [#D1249]
    ディレクトリとしての着色になっているが、シンボリックリンクの時には
    そうなる様に着色した方が親切である。
    →実装を見て気づいたが実は普通のディレクトリ名の判定の時点で
    シンボリックリンクのディレクトリ名であっても末尾に / がついていると、
    通常のディレクトリであるかの様に着色されていた。
    末尾に / がついている場合には [[ -h dir ]] は失敗するのだ。

    末尾に / がついていてもそれがシンボリックリンクかどうかを判定する様にした。
    実装した。確認した。

  * 履歴の上下で menu-filter が保持されている。これは変だ [#D1248]
    動作上の問題はないが設計として何だか変である。

    調べると menu-filter は menu がアクティブの時にしか有効にならない。
    更に、履歴を移動すると menu は消える筈だ。なので menu-filter は働かない筈。
    と思ったら、履歴を移動した時に menu が消えるのは menu-filter が消しているのだった。
    従って履歴を移動しても前の内容と一貫している場合には menu は消えない。
    履歴を移動した時に menu を消すようにして良い気がする。

    history_onleave に登録すれば良い。登録した。動作確認した。OK

2020-01-26

  * progcolor: / を含むコマンド着色が変だ [#D1247]
    パスを指定して呼び出すコマンドが全てディレクトリであるかの様に着色されている。
    / を含む関数名の場合には問題は起こっていない。
    最近の変更によって問題が起こる様になった→これは簡単だった。修正した。

  * global: 一箇所でしか使われていない識別子 [#D1246]
    一箇所でしか使われていない識別子は怪しい。
    ./make_command.sh check-words でそういう物を検索できる様にした。
    怪しい物を幾つか直した。結構バグが沢山ある様だという事。
    他に ./make_command.sh check-varnames も作った。

    * ret が leak している。alias 展開関連の様である。
    * 他に ch が漏れている。
      これの修正は簡単だった。すぐに見つかった。
      然し更に見ていると ble/builtin/bind/.parse-keyname で
      致命的に間違えている事を発見した。C-SPC や DEL や Rubout
      等が全く解釈できていなかった。修正した。
    * dist が漏れているがこれは mshex bashrc m/g だろう。
      →と思ったが dist という変数は使われていなかった。
      更に ble.sh の中も検索してみたが dist という変数は使われていない。
      問題のセッションで history | grep してみたがやはり見つからない。
      不思議な事だ。ble.sh のセッションでも確認するとやはり dist に値が入っている。
      →declare の出力を検索して分かった。mshex/cdhist/cd だった。
      直した。然し今まで気づいていなかった事が不思議である。

  * progcolor: コマンド毎の着色の設定を可能にする [#D1245]

    コマンド毎に引数の着色を実行するには。
    % * コマンド毎の着色を行う関数の名前について。
    %   現在 ble/cmdinfo/{help,complete}:command が使われている。
    %   ble/cmdinfo/highlight:command を使う事にする。
    % * と思ったが標準入力だとかヒアドキュメントだとかについての設定は?
    %   これは別の関数を用意するか或いは引数の振りをして渡すか。
    %   別の関数を用意するのが自然に思われる。
    →#D0581 の考察を確認した所 color, color-stdin が提案されている。
      #D0581 の名前を採用する事にする。

    現在着色を計算しているのは
    ble/highlight/layer:syntax/word/.update-attributes という関数である。
    この関数は木構造を使って色を決定している。
    単語毎に着色を計算しているので現在の実装ではコマンドが分からない。
    各単語毎にコマンドを抽出するのは如何にも非効率である。
    それとは別にやはり一回の highlight:command の呼び出しで全て着色したい。

    [仕様]

    * done: ble/cmdinfo/color:command を用いる。
    * done: comp_line 等一連の変数を提供する
    * comp_dirty 的な配列に各単語の着色を更新する必要があるかどうかを格納する。
      着色を更新したら comp_dirty に更新した事を表す値を書き込む。
      →comp_flags 的な変数に "d" という文字を入れる事にする。
      →これは現状では wattr に - が設定されているかどうかで判定している。
        実際に今迄の実装でもその様にしていた気がする。
        もし上書きするのであれば敢えて set-wattr を呼び出せば良い。

    [実装]

    問題が複雑化してきたので複数に分けて実装する事にする。

    * done: cmdinfo/color が存在している場合にはそれを呼び出す。
      cmdinfo/color の中で使いやすい様に関数名は変更する。
      また変数名も被らない様にする必要がある。
      うーん。特に i である。
      →これは取り敢えず TE_i TE_nofs という変数名を使う様に書き換えた。

    * done: 先ずコマンド毎に着色する様に修正する #D1242

    * done: コマンド名を使って着色設定を探索する。
      これは core-complete.sh の設定を参考にすれば良い。
      →着色設定を呼び出す所まで実装した。

      x fixed: コマンド名だけの時にカスタム着色が動いていない気がする。
        これは extract-command-by-noderef 関数が
        CTX_CMDI に対して動作していなかったのが原因だった。修正した。
      x fixed: 引数を入力して行くと着色が消えてしまう。
        これは umin,umax の範囲内にある属性は全て消去されるのが原因。
        その後で _ble_syntax_word_{umin,umax} の範囲内の単語が再着色される
        予定になっている。つまり、この範囲の外の単語について着色をすると
        その着色は全て消去されてしまうという事になる。
        →_ble_syntax_word_{umin,umax} も更新する様に変更した。


  * progcolor: proghl の名前を考える → progcolor に変更 [#D1244]

    proghl は余りにも分かりにくい。
    * proghilite, proghighlight 長い。
    * highlight (ble/syntax/highlight)
      単なる highlight は既に色々な所で使っている。
    * proglite, proglight, proglit
      何の事だか分からない。分かりにくい。
    * proghili もっと何が言いたいか分からない。
    * philite, philight: 変だ。
      何か既存の単語で良さそうな意味があって
      似た響きの物があれば使っても良いのかもしれない。
    * progcolor, progcol
      実の所、色だけではない。装飾も含まれる。
      然し、既存の枠組みで既に color という名前は使っている。

    後、これらに共通するのは単語単位の着色であるという事が
    名前に現れていない。prog があれば補完と同様に単語単位に
    動くという事が連想されるかもしれないというぐらい。

    * wordlite, wordcolor, wordgraphics, wordg
    * proggraph, progg, progface, wordface
      実際に設定するのは g 値であって実は face ではないのだ。

    うーん。この中では progcolor, proglight,
    wordface だろうか。或いは proglite。
    →progcolor or proglite
    うーん。余り奇を衒わずに progcolor で行くのが良い気がする。
