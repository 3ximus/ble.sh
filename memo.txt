# -*- coding:utf-8 -*-

設定項目

: ${ble_opt_input_encoding:=UTF-8}
: ${ble_opt_vbell_default_message=' Wuff, Wuff!! '}
: ${ble_opt_vbell_duration=2000}
: ${ble_opt_error_char_abell=}
: ${ble_opt_error_char_vbell=1}
: ${ble_opt_error_char_discard=}
: ${ble_opt_error_kseq_abell=1}
: ${ble_opt_error_kseq_vbell=1}
: ${ble_opt_error_kseq_discard=1}

制限

  * ble.sh を attach しているとき builtin read -e は動かない。
    代わりに ble.sh が定義したシェル関数 read (組み込みコマンドを上書き)
    を用いて read -e を呼び出す必要がある。

  * bash-3 C-d について

    今は何とか C-d を処理する事に成功しているが完全ではない。

    1 C-d を押した時に bash が出力するエラーメッセージを使って捕捉している。
      このエラーメッセージは言語や設定によって異なると思われる。
      現在は以下のメッセージを調べている。
      - 'Use "exit" to leave the shell.'
      - 'ログアウトする為には exit を入力して下さい'
      - 'シェルから脱出するには "exit" を使用してください。'
      自分の bash が異なるメッセージを出力する時は
      それを bleopt_ignoreeof_message に設定する。
    2 連続で沢山 C-d を押すと "^D" が echo されて表示が乱れるかもしれない。
      最悪の場合 C-d によって bash プロセスが落ちる可能性もあるかもしれない。
      (未だ落ちた事はないが)。
    3 C-d を処理する為に SIGUSR1 を使用している。
      その為 SIGUSR1 を別の目的で使用する事は出来ない。

  * 文字コードについて

    現在は基本的に UTF-8 を想定している。
    それ以外の環境のためには少なくとも以下の修正が必要になる。

    - ble.sh 自体を iconv で変換する事。或いは日本語を完全に排除する事。

      現在のところは日本語はコメント中にしか含まれていないはずである。
      コメントさえ削除すれば何処でも動くようになっていると良い。

    - 使いたい文字コード → unicode のデコーダを自分でかく事:
      これは "function ble-decode-byte+文字コード" を実装すれば良い。

    - Unicode → 文字のコードが正しく動作する様にする事:
      これは .ble-text.c2s (ble-core.sh) の辺りを直せばよい。
      "ble-text-c2b+文字コード"
      "ble-text-b2c+文字コード"
      も実装する必要がある。

    - ble/encoding:$bleopt_input_encoding/generate-binder

      現在 "C-@", "ESC" 及び "ESC *" を bind する為に、
      その符号化形式の非正規な符号に変換している。
      この変換はシェル関数 ble/encoding:$bleopt_input_encoding/generate-binder
      において文字符号化方式毎に (UTF-8 前提の設定を上書きする形で) 定義する。

      また bind を記録したキャッシュは $bleopt_input_encoding 毎に保持するが、
      このキャッシュの更新は bind.sh のタイムスタンプしか見ていない (ble-decode/bind 内)。
      新しい符号化方式を定義する時には、タイムスタンプを参照するファイル
      (ble/encoding:$bleopt_input_encoding/generate-binder を定義するファイル) を決める必要がある。


    他の文字コードは未だ一回も実装していないので上記以外にも必要な作業が出て来る可能性がある。

    + 2015-11-30 Note: ble-decode.sh (generate-source-to-unbind-default)

      文字コード実装時に問題があるかも。

      現在、bind -sp が出力する中途半端なバイトを解釈する為に、LANG=C で awk を起動している。
      UTF-8 の場合には複数バイト文字を構成するバイトは ASCII 文字と被らないので問題ないが、
      Shift_JIS 等の場合には ASCII 文字、特に \ や " を含む可能性がある。
      この場合には LANG=C にしていると問題が生じる。
      というか、bind -sp の出力する中途半端な文字と、複数バイト文字の一部を本質的に区別する方法はない様に思われる。

      ただし、救いは、もし ble.sh を plain な bash の上で起動するとすれば
      日本語で bind -sp に登録がなされていることはないだろうということである。
      つまり、ユーザが手で (或いは .inputrc に) bind '"日本語":"にほんご"' などとしない限りは問題は生じない。

  * bash-4.0, 4.1 において特殊シェル変数 FUNCNAME をユーザが unset した上で、
    関数内から ble.sh を source すると ble の使う連想配列がローカルに定義され問題になる。

    - bash-4.0 以降では連想配列を用いるが bash-4.2 未満では、
      連想配列を明示的にグローバルに配置することができない。

    - FUNCNAME がユーザによって削除されていなければ、
      この変数を用いて関数内から source されたことを検知できるので、
      その時には配列実装に fallback する。
      FUNCNAME が削除されていると fallback に正しく切り替わらずに問題になる。

  * bash-4.3 では C-x は、次の文字が来るまでは受信できない。
    bash-4.0 - 4.4 の他の version では遅延はないのでこれは bash-4.3 特有の問題である。

  * 構文に従った着色の中には bash の不自然な振る舞いや、
    複雑な振る舞いのために正確さを諦めた物がある。

    - bash の最初の [@()] の構文解析とパス名展開時の解析の齟齬

      echo [@(echo|[...])]

      恐らく bash は最初の単語の切り出しで @() を一単位として読み取り、
      ["@(echo|[...])"] の様に読み取る。その上で、改めてパス名展開を適用するが、
      その時には ["@(echo|[.."]")]" の様に解釈する。
      つまり、初めの構文解析とパス名展開の適用の間に齟齬がある。

      ble.sh では構文解析に従った解析・着色をすることにしたので、
      実際のパス名展開の適用結果が着色と異なることがあることに注意する。

    - bash echo {@(,)}

      これについても上と同様のことが起こる。
      単語の切り出しは {"@(,)"} となり、構文エラーは発生しない。
      後のブレース展開では {"@(",")"} と解釈されて分割される。
      単語が分断されてしまうのでパス名展開は起こらない。

    - bash のブレース展開時の ${var:-...}{,} の解析とパラメータ展開時の解析の齟齬

      echo ${var:-{a,b}{a,b}

      恐らく bash は最初にブレース展開を試みる時に、
      ${} の中については {} の入れ子を数えてスキップする。
      従って、上のコマンドの時は ${} が終端しないのでブレース展開は試みられない。
      しかし、パラメータ展開が実施される時には {} の入れ子は考慮に入れられず、
      最初に現れた "}" で終端するので、${var:-"{a,b"}"{a,b}" という解釈になる。

      [予定]
      ble.sh ではどの様に着色するか微妙である。
      理想的には最終的な解釈の ${var:-"{a,b"}"{a,b}" に応じた着色にしたいが、
      後半の {a,b} の部分が {} の入れ子のアンバランスによって
      無効化されている事を検出するのは困難である。
      仕方がないので、ブレース展開の {} の入れ子の勘定はバグとして無視する事にする。
      つまり、echo ${var:-"{a,b"}{a,b} という解釈で着色する。

    - bash のチルダ展開の時の echo a[]b]=~ の解析と、パス名展開の時の解析

      チルダ展開の時には a["]b"]=~ とはならず a[]"b]="~ という解釈になるので、チルダ展開は起こらない。
      一方で、パス名展開のときには a["]b"]"=~" という解釈になり、'ab=~' などのファイル名に一致する。
      ble.sh ではパス名展開の規則の方を優先させる。

    - ble.sh では [[ @({a,b}) ]] のブレース展開が有効であるかの様に着色される。

      実際には、条件コマンドの中ではブレース展開は無効になる。
      これに正確に対応する為には "条件コマンドの中の extglob"
      に対応する文脈値を定義する必要があるが、煩雑になるので対応していない。

    - ble.sh では echo [{@(a|b),[abc]}] の内部の extglob や [...] が有効であるかの様に着色される。

      しかし、実際にはブレース展開を実行したとしても [] の内部なので、
      extglob や [...] は不活性化しているはずである。
      しかし、これも解析が無意味に複雑になるので対応はしない。

    - ble.sh では echo {~user,~user} の内部のチルダ展開に反応しない。

      bash ではブレース展開された後にチルダ展開が実行されるので有効。

    - ble.sh はブレース展開が含まれる変数代入形式単語でも、
      ブレース展開より前のチルダ展開は有効である。

      bash では変数代入形式の単語の右辺でチルダ展開が起こる。
      しかし、ブレース展開が含まれている場合には例外としてチルダ展開が起こらない様だ。

      $ a=~:{a,b}:~:echo      → ブレース展開は起こらず、チルダ展開は起こる。
      $ echo a=~:{a,b}:~:echo → ブレース展開が起こり、チルダ展開は起こらない
                                 ble.sh では一つ目のチルダ展開の解析時点では、
                                 次にブレース展開が来ることを知らないので、
                                 一つ目の ~ はチルダ展開として着色する。

      規則がよく分からないが、取り敢えず ble.sh ではブレース展開が現れたら、
      それ以降はチルダ展開が無効になるようにしている。
      具体的には _ble_syntax_bash_command_IsAssign[ctx] の設定されている文脈は、
      ブレース展開が現れたときに、変数代入形式前の文脈値に戻すようにしている。

bash 実装上で注意するべき事

  * arr=(1 2 3) func の形式で配列をシェル関数に渡そうとすると、
    export arr='(1 2 3)' で渡されてしまう。

  * 既に配列変数になっている物に対して
    export var=value や typeset -x var=value をしても、
    呼び出された別コマンドからは環境変数として見えない。

    $ a=(1 2 3)
    $ (export a=1; bash -c 'declare -p a')
    bash: 0 行: declare: a: 見つかりません

    新しい変数として導入すれば良い。
    例えば関数内で新しく local -x var=value とするか、
    var=value command の形式で呼び出すようにすれば良い。

    $ (a=1 bash -c 'declare -p a')
    declare -x a="1"

  * 変数の代入は基本的に quote は必要ないが、

    1 チルダで始まる時はチルダ展開を防ぐ為に quote が必要。
      (変数展開の中にあるチルダは quote しなくても大丈夫)

    2 配列要素を空文字列で連結するときは quote が必要。
      つまり、IFS= eval 'declare var=${arr[*]}' とすると空白区切りになる。
      IFS= eval 'declare var="${arr[*]}"' とする必要がある。
      また IFS が中身のある場合には問題は起こらない。

      - bash-4.3 以降では IFS= eval 'var=${arr[*]}' なら OK

    関係あるか分からないが
    http://lists.gnu.org/archive/html/bug-bash/2017-04/msg00001.html
    において以下のような例が紹介されている。これは bash-4.5 で修正されるらしい。

    | bash-4.2$ unset IFS; set ' '; a=$*; printf '<%s>' "$a"
    | < >
    | bash-4.3$ unset IFS; set ' '; a=$*; printf '<%s>' "$a"
    | <>


  * コマンドをつなぐ && と || の優先順位は同じで左結合である
    但し、算術式や [[ ]] に登場する && と || はC言語と同じ優先順位である。

  [complete 仕様について]

  * compgen -f はクォート除去、チルダ展開を実行する
    理解できないのはクォート除去した後にチルダ展開をするという事。
    compgen -f "'~/'" としても '~' というディレクトリには決して一致しない。
    compgen -f "'\~/'" 等とクォートした上に backslash も指定しないと行けない。
    結局どういう規則なのか分からないので、寧ろ arr=('~/'*) 等の様にするべき。

  * $ complete -F foo -C bar command と登録すると foo, bar の両方が foo bar の順に実行される。
    $ complete -C bar -F foo command と登録すると bar foo の順に実行される。
    しかし、complete -p とすると両者とも
    complete -C 'bar' -F foo
    と表示され登録順・実行順についての情報を取り出す事ができない。

  * $ complete -F hoge1 -F hoge2 command とすると、-F hoge2 だけ有効になる
    (complete -p による表示もそうだし、実際に実行されるのも hoge2 だけであった)。
    -F オプションは後からものによって上書きされるという事の様だ。

  * shopt -q は通常の出力はやめてもエラーメッセージは出す。
    つまり未実装のオプション (compat* や autocd) について
    shopt -q をするとエラーメッセージが出力されるので
    結局 &>/dev/null にリダイレクトしなければならない。

  * locale の環境変数 LC_*/LANG を設定する時は &>/dev/null する必要がある。

    元々入っていた値が不正な値である場合、
    元の値を復元した時にエラーメッセージが意図されず出力される。

    ローカル変数として設定する場合は、
    - 値の復元はどうやら関数の本体を完全に実行し終わった後に起こる様なので、
      関数の本体自体を &>/dev/null で囲んでも意味はない。
    - 関数の中で unset を行っても意味はない。
    - 関数の中でもとの値を設定しても意味はない。
      関数が抜ける時に改めて設定される様だ。

    IFS= LC_ALL=C read -t 0 &>/dev/null
    としても復元時のメッセージは何故か抑制できなかった。

  * Bash 正規表現はシステムの <regex.h> を使用するので環境依存である。

    Linux においては bash 正規表現の POSIX 文字クラス ([[:alpha:]] など) は
    ロケールによって何にでも一致するので信用できない。
    例えば GNU/Linux (Fedora 25) では ja_JP.UTF-8 で [[:alpha:]] は漢字・仮名にも一致する。

  * bind 関数の中で set +o emacs などをして編集モードを無効にすると、

    編集関数の実行自体が中断されるようである。
    具体的には set +o emacs を含む行だけ実行されて、次の行以降は実行されない。
    set +o emacs が eval に含まれる場合は eval が終わると共に中断される。
    また関数内に set +o emacs がある場合は、その関数は最後まで実行されるようだ。

    従って set +o emacs が実行されたことを検知して適切な後処理を実行するのは難しい。
    更にその後で set -o emacs に戻ってくると変な状態になる。
    bind -p ではちゃんと hook された状態になっているが、
    実際に操作してみると keymap はリセットされているように見受けられる。
    この辺りはもう少し詳しく調べてみないと具体的に何が起こっているかはわからない。

    例: 以下の3行のコマンドを実行しようとすると途中で中断され元の状態には戻らなくなる。

    $ set +o emacs
    > echo hello
    > set -o emacs

    直接 readline で実行している場合にはこの問題は起こらない。



bashbug: 実装上で注意するべき事

  * bash-3.0 - 4.4 算術式:

    条件分岐で実行されない部分でも配列の添字は 0 以上でなければならない。
    例えば以下はエラーになる @ bash-3.0, 3.1, 3.2, 4.0, 4.2, 4.3
    ((a=-1,a>=0?b[a]:0))

    もっと調べてみると配列の添字に限らず分岐しない所で式が評価されている様だ:

    + 三項条件式で起こる。true/false branches のどちらでも起こる。&& や || では起こらない。

      $ echo 'x=a=1; ((a=0,0?x:0)); echo $a' | bash      1 (bash-3.0 - 4.3)
      $ echo 'x=a=1; ((a=0,1?0:x)); echo $a' | bash      1 (bash-3.0 - 4.3)
      $ echo 'x=a=1; ((a=0,0&&x)); echo $a' | bash       0 (bash-3.0 - 4.3)
      $ echo 'x=a=1; ((a=0,1||x)); echo $a' | bash       0 (bash-3.0 - 4.3)

      $ echo 'x=a=1; ((a=0,0?b[x]:0)); echo $a' | bash   1
      $ echo 'x=a=1; ((a=0,0&&b[x])); echo $a' | bash    0 (bash-3.0, 3.1, 4.2+ / bash-3.2, 4.0, 4.1 は別の bug で 1)

    + 括弧で囲めば何も起こらない様だ。

      $ echo 'x=a=1; ((a=0,0?(x):0)); echo $a' | bash    0 (bash-3.0 - 4.3)
      $ echo 'x=a=1; ((a=0,1?0:(x))); echo $a' | bash    0 (bash-3.0 - 4.3)

      $ echo 'x=a=1; ((a=0,0?(b[x]):0)); echo $a' | bash 0 (bash-3.0, 3.1, 4.2+ / bash-3.2, 4.0, 4.1 は別の bug で 1)

  * bash-4.3 \C-@ 関係に bind -x すると正しく動かない

    bash-4.4 での動作については未だ確認していない。
    → bash-4.4 でもやはり動かない。

  * bash-4.2 算術式 seg fault

    https://lists.gnu.org/archive/html/bug-bash-gnu/2013-01/msg00036.html
    https://lists.gnu.org/archive/html/bug-bash-gnu/2013-01/msg00042.html
    https://lists.gnu.org/archive/html/bug-bash-gnu/2013-01/msg00043.html

    算術式の中で配列要素の参照に関係して特定の式構造になると segfault する。
    多分、配列要素の読み出しの次の token が整数または代入式の左辺だと落ちる。
    配列要素を参照したら一旦算術式を閉じるのが良い。
    $ ((a=b[0],c=0))

    以下でも segmentation fault が起こった。
    $ (((klen=node[nofs+k])<0||(kbeg=j-klen)>end0))
    $ (((a=node[1])<2||(b=3)))
    $ (((a=node[1])||(b=3)))
    $ (((a=node[1])<2||b)) # OK
    $ (((a=node[1])||b))   # OK
    $ (((node[1])||(b=3))) # OK
    やはり起こる条件が良く分からない。
    代入式の右辺に配列が来て、
    その後に代入式の左辺に token があると駄目なのか?

  * bash-3.2 - 4.4, etc

    rex="^([^\$]|\\'[^\\']*\\')+\$" && [[ 'i$' =~ $rex ]] && echo hello

    が一致する。\' の解釈が謎である。単に ' とすれば問題ない。


  * bash-4.2 以下
    bash-4.2 ～ bash-3.0

    \C-x 単体に bind -x して C-x に続けて何か打つと segfault する。
    $ bind -x '"\C-x":echo' → 続けて C-x a 等と入力

  * bash-4.1 以下 (bash-3.0 ～ bash-4.1)

    配列要素に対して修飾付きのパラメータ展開を実行すると、
    配列添字に指定した算術式が2回評価される。
    例えば "${arr[i++]#a}" を実行すると i が 2 増える。

  * bash-4.0, 4.1 (local), bash-3.0 ～ 3.2 (declare)

    a[${#a[*}]=value もしくは ble/array#push a value するとき、
    その配列を事前に宣言したければ local -a a のように -a を指定する必要がある。

    [問題]

    bash-4.1 以下で関数内で local arr しただけで ${#arr[*]} が 1 になる。
    その後、要素 #1 を設定しても ${#arr[*]} は 1 のままである。
    これの所為で以下のコードが破綻する:
      arr[${#arr[*]}]=...
    常に要素 #1 にしか代入されない事になる。

    bash-3.2 以下では関数内に限らず declare arr しただけで ${#arr[*]} が 1 になる。
    但し、要素[1] に設定をすると ${#arr[*]} は 2 に増加する。
    従って余分な空要素があるものの ble/array#push は失敗しない。

    [解決]

    local -a arr とすれば問題は起きない。
    ※local arr=() としても問題は起きないがこの記述だと
      今度は bash-3.0 で文字列 '()' が代入されて問題である。

  * bash-4.0 ～ bash-3.0

    $'' 内に \' を入れていると履歴展開が '' の中で起こる?
    例えば rex='a'$'\'\'''!a' とすると !a の部分が展開される。

  * bash-4.0 他 算術式を使って値を計算する時の注意

    算術式の中に初期化されていない変数…例えば ret 等がある場合、
    ret の中身に不正な数式的な物が入っていたりコマンド置換が入っていたりすると、
    文法エラーになったりこれが eval されてしまう。
    実際に 4.0 では 'あ' という文字列が入っているだけでエラーになる。
    (より上の version では識別子名と解釈されているからなのかエラーにはならない。
    しかし、今迄は毎回「あ」等という変数を探していたのだろう。

  * bash-3.2, 4.0, 4.1: 算術式分岐内配列参照

    bash-3.2.48 で以下の評価に失敗する。
    bash-3.1 以下は大丈夫。bash-4.2, bash-4.3 も大丈夫。bash-4.0 は駄目。

    dbg=()
    ((a=0,b=0,0&&(a=1,x=dbg[0],b=1))) # NG
    配列添字で値を参照 (代入はOK) すると、その部分以降が必ず実行される。
    複合代入であっても駄目である。

    bash-4.0 bash-4.1 でも以下の式で必ず _pos[1]++ が実行されていた。
    ((_eoc[2]&&(_pos[0]=0,_pos[1]++)))


    $ ((a=0,b=0,0&&(a=1,x=dbg[0],b=1))); echo $a $b               → 0 1
    $ expr="a=1,x=dbg[0],b=1"; ((a=0,b=0,0&&expr)); echo $a $b    → 0 1
    $ expr="a=1,x=dbg[0],b=1"; ((a=0,b=0,0&&(expr))); echo $a $b  → 0 1

  * bash-3.2, bash-3.1 では source にプロセス置換を渡しても読み取ってくれない。
    つまり source <( ... ) としても何も起こらない。
    代わりに eval -- "$( ... )" すると良い。

  * bash-3.1 では declare -f funcname の funcname に + 等の文字を含める事ができない。
    一応 declare -F 等とすれば名前は列挙される様ではある。
    bash-3.2 未満では declare -f ではなく type -t で関数かどうかの確認を行う。

  * bash-3.1 での bind -r について
    bind -sp とすると "\M-[C" 等と表示されるがそれに従って bind -r '\M-[C'
    としても削除する事は出来ない。代わりに bind -r '\e[C' とすれば削除できる。

    eval -- "$(bind -sp | awk '/M-\[/{sub(/:$/,"",$1);gsub(/\\M-/,"\\e");print "bind -r " $1}')"

  * bash-3.1
    呼出先の関数で、呼出元で定義されているのと同名の配列を作っても、中が空になる。
    > $ function dbg/test2 { local -a hello=(1 2 3); echo "hello=(${hello[*]})";}
    > $ function dbg/test1 { local -a hello=(3 2 1); dbg/test2;}
    > $ dbg/test1
    > hello=()

    これは bash-3.1-patches/bash31-004 で修正されている様だ。

  * bash-3.1

    - ${#arr[n]} は文字数ではなくバイト数を返す様だ。

    - "${var//%d/123}" は動かない。"${var//'%d'/123}" 等とすればOK。

    - bash-3.0, bash-3.1: local GLOBIGNORE すると、
      関数を出てもパス名展開の時にその影響が残っている。
      (直接変数の中身を見ても何もない様に見えるが。)
      unset GLOBIGNORE などとすると直る。

  * bash-3.0

    - ${#param} は文字数ではなくバイト数を返す、という事になっているらしいが、
      実際に試してみると文字数になっている (bash-3.0.22)。
      何処かで patch が当たったのだろうか。まあいいか…。

      (※${param:ofs:len} は 3.0-beta1 以降であれば文字数でカウントされる)

    - local a=(...) や declare a=(...) とすると、a="(...)" と同じ事になる。
      a=() の形式ならば問題ない。

    - 今まで local -a a=() の形式ならば問題ないと信じてきたが、どうやら
      local -a a=('1 2') が local -a a=(1 2) と同じ意味になってしまうようだ。
      a="123 345"; declare -a arr=("$a"); このようにしても駄目だ。
      a="123 345"; declare -a arr; arr=("$a"); こうする必要がある。

    - declare -p A で改行を含む変数を出力すると改行が消える。
      例: 一見正しく出力されている様に錯覚するが "\ + 改行" は改行のエスケープではなく、
        長い文字列リテラルを二行に書く為の記法である。つまり、無視される。
      $ A=$'\n'; declare -p A
      | A="\
      | "

    - history -p を実行する度に history のリストの項目が削除される。

  * bash-4.0 segfault

    以下で segfault を起こすことが分かった。

    bash-4.0 -c 'function f1 { COMPREPLY=(alpha); }; compgen -F f1 2>/dev/null'

    但し、ble.sh の使用中に実際に compgen -F を通して segfault になることはなかった。
    もしかすると何らかの条件が整うと segfault するかもしれないので、
    念のためここに記録に残しておく。

  * bash-4.2
    declare -g -r var とした時に、
    グローバル変数が定義されていなければローカルに新しく変数を作る様だ。
    bash-4.3 で直っている。

bash_features

  * printf -v var %s value

    bash-3.1 以降で使える。
    bash-4.1 以降で var として配列要素 (arr[123] 等) を指定できる。

  * read -t timeout

    -t オプションの対応は 2.04 である。
    TMOUT 変数の対応は 2.05b-alpha1 以降である。
    小数を指定できる様になったのは 4.0-alpha 以降である。
    `-t 0' で次の文字を読み取り可能かどうかチェックできるのは 4.0 以降である。

  * ${!arr[@]} は bash-3.0 より

  * 連想配列 declare -A は bash-4.0 から

  * グローバル変数に対する属性指定 declare -g は bash-4.2 から

    更に bash-4.3 には declare -gA を二度行うとクラッシュするバグがあったらしい。
    現在の最新版ではそのような振る舞いは見られない?


tech

  * swap の仕方
    local a="$b" b="$a"
    local や declare などは必要である。

  * [[ ]] の中で =~ で設定された BASH_REMATCH は直後の式で参照できる。
    つまり [[ $text =~ $rex && $BASH_REMATCH == ... ]] の様にできる。

    bash-3.0 から bash-4.4 までで以下のコマンドで確かめた。

    [[ "" =~ ^ ]]; [[ $BASH_REMATCH ]]; [[ a =~ a && $BASH_REMATCH ]]

  * 構文関係でマニュアルに載っていないものが色々ある。

    * }, fi, done, esac の直後に }, fi, done, esac, do, else, elif, then が来る場合はセミコロンは省略できる。

    * for ((expr1; expr2; expr3)) [ ; ] { list; } は比較的有名だが、
      for name [in name]; { list; }
      select name [in name]; { list; } も使える様だ。

    * select name [ [ in word ... ] ; ] do ...; done
      ※in word ... がない場合、do の前のセミコロンは省略可能である。


*******************************************************************************
    Memo
-------------------------------------------------------------------------------

2017-10-31

  * 終了ステータスについて

    127 適切な widget が見つからなかった

    126 widget を呼び出すことができなかった
      未使用

    125 widget を呼び出したが適切な処理が見つからなかった
      __defchar__ に登録した widget がこれを返したとき
      次のハンドラを用いる。具体的には __default__ の呼び出しを試みる。

    148 ユーザの入力を非同期に待つ為に一時停止した
      vi-mode のオペレータが 148 を返したとき
      後処理を実行せずにそのまま抜ける

    124 プログラム補完において補完の再実行を要求する

    27 widget の動作がユーザによってキャンセルされた

2017-10-18

  * ble-decode: widget に関して

    __defchar__ および __default__ に登録された widget が 125 を返した時、
    その入力に対する適切な処理が見つからなかったことを表します。
    この時、次のハンドラの探索が行われます。
    次のハンドラがない場合には対応するものが見つからなかったというエラーになります。

2017-09-24

  * vi-mode 以下は現在のところ対応しない予定である [#M0006]

    * 2017-09-24 vi-mode: % で用いる matchpairs には現在対応しない

    * 2017-09-17 vi-mode (insert mode/newline):
      インデントを挿入するが何もしなかった時にそれを削除することには対応していない。

      これは実際の所、挿入モードにおける移動と抜ける時の処理において、
      細工を行えば対応できる。現在の挿入モードの操作の繰り返しの記録の仕組みも使えるが、
      もっと別の仕組みを用意しても良い気がする。

    * 2017-09-12 vi-mode: タブ文字上にカーソルがある時のカーソルの表示位置

      後、気付いたことはタブ文字に煎る時のカーソル位置は、
      ノーマルモードにいるときはタブ文字の最後の位置である。
      要するに p で挿入される位置を示しているとも言える。
      でも全角文字の場合にはちゃんと全角文字の先頭にカーソルが来る。
      この動作は分かりにくいし更に言うと現状の ble.sh の描画コードでは対応していない。
      これには取り敢えず対応しないことにする。

    以下は積極的に対応する予定はない。
    将来的に対応する場合の注意点がある場合も含む。

    * 2017-10-11 M ( ) [[ ]] { } :s :tag
      これらのコマンドは "ジャンプ" なので、$flag なしで実際にジャンプに成功する場合には
      set-local-mark 96 をする必要がある。

    * 2017-10-09 取り敢えず今の所はスクロール (C-b C-d C-e C-u C-y など) には対応しない

2017-09-08

  * vi-mode: 以下のリンクで重要そうなコマンドの一覧が見られる [#M0005]

    http://qiita.com/sfuta/items/0de4ead865c15e9e9b68 ?
    http://qiita.com/sfuta/items/2d646396a6117c8e53e5 g? z?
    http://qiita.com/sfuta/items/fd78f3ece8861f8142ee C-w? [? ]?
    http://vim-jp.org/vimdoc-ja/vimindex.html
    http://vim-jp.org/vimdoc-en/vimindex.html

2015-11-28

  * デモ画像の作り方 [#M0004]

    準備
    $ # PS1=$'[\e[4;38;5;202mfoo@bar\e[m \\j \\W]\\$ '
    $ TTYREC=1
    $ ttyrec demo.tty

    echo hello, world
    printf hello
    [[ a == b ]]
    echo "hello $(echo bash $(echo world))"
    C-r for
    echo 'select, copy and paste' コピーする
    echo insert mode -> overwrite mode
    ls
    echo complete ble-TABdTAB histexpand !#:2
    echo "$HIST[TAB]"

    $ seq2gif -f 0 -b 15 -h 14 --render-interval=10 -p rosa --play-speed=1.5 < demo.tty > demo2.gif

    gif のフォーマット的には 0.01s よりも小さな遅延は設定できない。
    また、現実のブラウザでは 0.02s (50fps) よりも小さな遅延にすると強制的に 0.10 になってしまう。
    更に、Safari や Internet Explorer では 0.06 (16.67fps) よりも小さな遅延は 0.10 になってしまう。
    更に、Windows に附属している viewer では 0.10 よりも小さな遅延は全部 0.10 になってしまう。

    [[Frame Delay Times for Animated GIFs by humpy77 on DeviantArt>http://humpy77.deviantart.com/journal/Frame-Delay-Times-for-Animated-GIFs-214150546]]
    [[How to match animation rate of gif files accross browsers (Fenrir Developer's Blog)>http://blog.fenrir-inc.com/us/2012/02/theyre-different-how-to-match-the-animation-rate-of-gif-files-accross-browsers.html]]
    [[Nullsleep | Jeremiah Johnson - Animated GIF Minimum Frame Delay Browser Compatibility Study>http://nullsleep.tumblr.com/post/16524517190/animated-gif-minimum-frame-delay-browser]]


2015-08-14

  * [memo] builtin check [#M0003]

    eval "grc --color --exclude=./test '\b(builtin[[:space:]]+)?$command\b' | grep -Ev '\bbuiltin[[:space:]]+$command\b'"

  * [memo] leak variables check [#M0002]

    set | sort | sed -e '/()[[:space:]]*$\|^_\{0,1\}\(BLE\|ble\)/d' -e '/^[[:alnum:]_]\{1,\}=/!d' > a.txt

  * [memo] 解析(ble-syntax/parse)の際の原則 [#M0001]

    データ配列とは _ble_syntax_stat, _ble_syntax_nest, _ble_syntax_tree を指すとする。
    或る点 p1 から或る点 p2 に解析を進める場合を考える。

    1 この時データ配列に対する変更は p1-p2 (exclusive) の間にだけ行われる。
      これは解析状態の復元と再開が適切に動作する為に必要である。

    2 解析の過程でデータ配列に格納されている情報は使用しない。
      これは解析状態の一致チェックの為に必要である。
      データ配列の内容に依存して動作が代わる場合、
      解析状態が一致しても解析結果が異なってしまう可能性があり、不整合を生む。

      但し、_ble_syntax_nest については専用の関数を通して 0-p2 の任意の場所を参照しうる。
      これ(専用の関数を通して得られる情報)については
      解析状態の一致チェックの対象に含まれているからである。
      (_ble_syntax_nest の任意の情報を参照して良いという意味ではない。)

    tree-append および nest-pop に対する制限

      tree-append は _ble_syntax_tree[i-1] に格納を行う。
      従って上記の条件1から p1<=i-1 つまり p1+1 <= i である必要がある。
      これは少なくとも 1 文字 i を進めてからでないと tree-append を呼び出せないという事である。
      nest-pop も内部的にそのまま tree-append を呼び出しているので同じ制限がある。


@todo
*******************************************************************************
    ToDo
-------------------------------------------------------------------------------

2018-01-19

  * 誤って PATH に変な値を設定してしまうと動かなくなる。

    呼び出している外部コマンドの一覧を作って、
    更にそれらのコマンドをフルパスで呼び出す様に修正する必要がある。
    その為には command -p 付きで呼び出すようにするか、
    或いは起動時にそれぞれのコマンドのパスを何処かに記録すれば良い。

    (実のところ command ... となっている物について修正を行えば良いだけかもしれない)

2017-12-04

  * keymap/vi (nmap u, U, C-r): 引き数に対応する。

  * keymap/emacs: 引き数: ble/widget/yank

    引き数の解釈がよく分からない。
    1 以外の引き数を指定すると rotate するのだろうか。
    どうもその様に思われる。
    しかし、現在の枠組みではそもそも kill_ring に対応していない。
    従って、急には対応できない。取り敢えずの所は clear-arg しておく。

  * keymap/emacs: 引き数: 単語関連

    todo: ble/widget/単語関連

    現状では取り敢えず clear-arg する。後で使用も含めて対応する。

  * todo: refactor getindex, getcount → get-index, get-count

2017-12-03

  * keymap/vi (mark): erasedup 等のときに履歴番号がずれるのではないか?

  * keymap/emacs: undo/redo に対応する。

    現在はそもそも記録を行っていない。
    後、各 widget について対応を行うとすると vi_imap とかち合うので注意が必要である。
    特に、今までの機能は全て safe キーマップの機能という事にして、
    新しく emacs.sh に実装を追加した方が良いのかもしれない。

2017-11-29

  * syntax: http://lists.gnu.org/archive/html/bug-bash/2017-11/msg00002.html

    "$(case *) ;; esac)" の問題が報告されて Chet が調べると言っている。
    もしかしてこれは将来的に修正されるのかもしれない。

  * syntax: function @() { ...; }
    https://stackoverflow.com/questions/43117707/bashs-strange-behavior-on-a-function-named/
    http://lists.gnu.org/archive/html/bug-bash/2017-03/msg00220.html

2017-11-26

  * complete: nocaseglob 的な補完に対応する?

    つまり、大文字小文字が違うファイルに一致した場合は、
    前方の文字列を書き換えてしまう。

  * complete: 変数代入の時は右辺でファイル名補完をするが、
    実は arr[$(...)]= の様な複雑な場合に右辺を正しく切り出せていない。

  * highlight: 配列代入の解析の不整合? [tmp0004]

    最初から arr[index まで入力した時の着色と
    arr[index] まで入力してから一文字削除した時の着色が異なる。

    | _ble_syntax_attr/tree/nest/stat?
    |  7 aw   000 'a'  stat=(CTX_CMDX w=- n=- t=-:-)
    |  8 a e  001 '['  nest=(CTX_VRHS w=ATTR_VAR:0- n=- t=-:-)
    |  8*a    002 'a'  stat=(CTX_EXPR w=- n=@1 t=-:-)
    |  6*a e  003 'b'
    |  |    s 004 ^@  stat=(CTX_EXPR w=- n=@1 t=-:-)
    | \_ 'a[ab'
    |     \_ '[ab'
    |
    | _ble_syntax_attr/tree/nest/stat?
    |  7 aw   000 'a' |  stat=(CTX_CMDX w=- n=- t=-:-)
    |  8 aw   001 '[' || nest=(CTX_VRHS w=ATTR_VAR:0- n=- t=-:-)
    |  8*aw   002 'a' || stat=(CTX_EXPR w=- n=@1 t=-:-)
    |  |*aw   003 'b' ||
    |  8*aw   004 ']' ++ word=CTX_CMDI:0-5>@4 word="a[":1-5 stat=(CTX_EXPR w=- n=@1 t=-:-)
    |  |    s 005 ^@    stat=(CTX_ARGX w=- n=- t=$5:-)
    | \_ 'a[ab]'
    |     \_ '[ab]'
    |
    | _ble_syntax_attr/tree/nest/stat?
    |  7 a    000 'a'  stat=(CTX_CMDX w=- n=- t=-:-)
    |  8 a e  001 '['  nest=(CTX_VRHS w=ATTR_VAR:0- n=- t=-:-)
    |  8*aw   002 'a'  stat=(CTX_EXPR w=- n=@1 t=-:-)
    |  6*awe  003 'b'
    |  |    s 004 ^@  stat=(CTX_EXPR w=- n=@1 t=-:-)
    | \_ 'a[ab'
    |     \_ '[ab'

    どうも構文の状態は同じだ。単語の着色が異なる。
    しかしそもそも何故単語着色が起こっているのだったか。
    単語着色は CTX_CMDI としての着色が残っているということ。
    これは単語着色の側の問題であって、解析の問題ではない。

2017-11-25

  * complete: 更新する度に complete.sh の不整合が問題になっている。

    やはり、遅延読み込みはやめた方が良いのでは。
    然し、それを言い出すと今後対応する予定である
    cmdinfo の類についても遅延読み込みできなくなる。
    もしくは、安定した API の下での実装という事になる。

    或いは別の方法として ble.sh の細かい version 毎に
    complete.sh をインストールするという手もある。
    version の管理は面倒なので ble.sh の日付をそのまま使っても良い。
    或いは、起動時にファイル一式を何処かにコピーする。

2017-11-22

  * syntax: 実は予約語も alias にできてしまう…

    $ alias end=fi
    $ if true; then if true; then echo; end end

    現状ではエラーとして検出してしまう。
    更に以下の様なこともできる。

    $ alias var=declare
    $ var arr=(echo 1 2 3)

    うーん。指定の単語が alias だった時は、
    毎回 alias を resolve するのだろうか。
    然し、alias の展開結果が複数の単語を含む場合に至っては、
    完全に追跡する事は不可能である。
    従って、alias までは考慮に入れなくて良いのではという気がする。
    寧ろ、中途半端に対応するよりは全然対応しない方が良いかもしれない。

    $ alias begin='{'
    $ for ((i=1;i<=2;i++)) { echo hello; }
    $ for ((i=1;i<=2;i++)) begin echo hello; }
    bash: 予期しないトークン `begin' 周辺に構文エラーがあります
    $ for ((i=1;i<=2;i++)); begin echo hello; }

    for (()) の直後などの文脈では alias の展開は起こらない様だ。

  * syntax: ${var##...} における check-glob の対応。
    ctx-bracket-expression に関しては、
    新しい nctx への対応が必要になる。

    実はこれに関しては文法の解釈には寄与しない。

    a つまり、CTX_PATN に対しても @( は } が来たら終了する。
      これだと CTX_PATN についても bashc を弄る必要が出てくる。
      実は親が CTX_PWORD の時に '}' を追加して、
      check-word-end で終了する様にすれば良いだけなのではないかという考え方もある。

    b そもそも CTX_PATN に入らずに @+?!(|) を全て着色するという手もある。
      しかしそれだと pattern ではない物まで着色されてしまう。
      それならそもそも色を付けない方が良い。

    c 或いは CTX_PATN を複製して CTX_PWORD から呼び出した時用の新しいものを作る。
      と思ったが現状の CTX_PATN と比べて殆ど違いはないので a の方が良さそうに思う。

    所で CTX_PWORD と言っても様々な文脈がある。
    文脈によってはパターンが無効になる場合もある。
    以下の xxx の場所では有効で yyy では無効である。
      ${a//xxx/yyy} ${a#xxx} ${a%xxx}
      ${a:-yyy} ${a:=yyy} ${a:+yyy}
      ${a,xxx} ${a^xxx}
    現状では何も考えず全て CTX_PWORD にしている。
    そもそも文法的に許されないものも全て許可している。
    パターンの着色に対応する前にこの様々なパラメータ展開の着色に対応するべきである。

    * 現状では CTX_PATN 内部でブレース展開が常に有効になっている。
      ${var#pattern} を解析しているとき
      CTX_PATN からブレース展開が呼び出されない様にする。
      これは CTX_PATN が "}" で終了することを許すかどうかと同じ条件判定を使えば良い。

2017-11-21

  * syntax: for^J で改行にエラーが設置されるが見えない。

    改行のエラーは何らかの方法で見える様にするか、
    或いは、改行位置にエラーがある様な時は、
    その前の文字でエラーが発生する様にチェックを行うべき。

2017-11-09

  * complete: 候補の優先順位? 例えば拡張子でフィルタすると絞りすぎることがある。
    拡張子の要件を満たすものを先に表示して、満たさないものを後に表示する。
    満たさないものに関してはサブ候補として、TAB による接頭辞挿入には寄与しない。

2017-11-05

  * vi-mode

    :help 関連の気になること:

    - v_p v_P: の Implementation details に書かれている処理の順序は実際は逆
    - exclusive-linewise: ここの inclusive/linewise になる条件の記述は曖昧だし全く合っていない
    - star: vim-jp の文書だと WORD と書いてあるが、振る舞いは word (しかも \<\> で囲まれる) に近い

    - i<C-o><C-c> とすると普通のノーマルモードに移行したように見えるのに、
      モード表示は -- (挿入) -- のままである。これは何故だろう。
      ble.sh ではノーマルモードに完全に移行する。

    - qa<C-c>q とすると ^C が二重に記録される。これは何か?
      ble.sh では単に ^C は入力された通りに一個だけ記録する。

    振る舞いで気になること

    - C-v <bracketed paste> では矩形挿入にするべきなのではないか。


2017-11-03

  * vi-mode (extract-block): [Optimize] 現在の実装では毎回フルに矩形を計算している。

    しかし、一部のコマンドでは一部の情報しか必要としないものも多い。
    例えば xmap I, xmap A では sub_ranges[0] と sub_x1, sub_x2 しか使用しない。
    また xmap O では sub_ranges[0] と sub_ranges[最後] しか使わない。
    extract-block に途中の行について取得しないオプションがあっても良い気がする。

  * vi-mode (registers): 各種特殊レジスタの対応

  * vi-mode (map / ? n N): backward search の一致の仕方が異なる。
    現在の実装では一致範囲が現在の位置以前にある一致の最後のものが当たる。
    しかし vim を観察すると、"一致範囲の開始位置" が現在の位置以前にある一致の最後のものが当たる。

    また、vim では一致する物がそれ以上ないときに cyclic に一致するが、
    ble.sh ではこれについて敢えて対応していない。

    2017-11-06 更に試して気付いたのだが、
    / や ? で新しい検索を始めるときでも、
    現在位置にある単語には一致しない。
    現在の ble.sh の実装では以前の一致の上にいる時には現在位置には一致せず、
    新しい一致を始めるときには現在位置に一致するようにしているが、
    これは全く無意味な処理である気がする…。

2017-10-31

  * vi-mode (_ble_keymap_vi_REX_WORD): Unicode categories?

    Bash の正規表現 (<regex.h> ERE) で対応するのは難しい。
    また必ずしも Unicode (UTF-8) で実行されるとは限らない。
    現在は UTF-8 しか対応していないが枠組みとしては
    別の文字コードにも対応できる余地は残して置きたい。

2017-10-22

  * edit: RET 文法に基づく改行挿入

    shopt -q cmdhist &>/dev/null を参照してこれを有効・無効にするのが良い。

    - if .. fi, do .. done, { .. } の対応を取ることを考えていたが、
      よく考えてみると、実は、数を数えてバランスしているかを確かめれば良いのでは?
      後は case esac がある。これらは絶対に対になっているはずである。
      if があれば必ず fi が来る。case があれば必ず esac が来る。他の終わり方はない。

    - for/until/while/select などは do .. done, { .. } で必ず囲まれるので
      本体の中身がバランスしているかどうかは上記の方法で終わっている。

      然し、for/until/while/select が孤立して存在している場合もチェックしなければならない。
      これも for/while/until/select の数と do/{ の数を数え上げればいい気がする。

      どうやって数えるのが良いだろうか。毎回 tree-enumerate したり、
      for in "${_ble_syntax_attr[@]}" するのは遅そうな気がする。
      例えば _ble_syntax_attr に特別な属性を指定しておいて、
      IFS= concat="::${_ble_syntax_attr[*]/%/::}" として、
      後は $concat に対する処理で何とか各属性の数を抽出できないだろうか。

        pat=:$ATTR_KEYWORD_B: a=${concat//$pat}; bcount=$(((${#concat}-${#a})/${#pat}))
        pat=:$ATTR_KEYWORD_L: a=${concat//$pat}; lcount=$(((${#concat}-${#a})/${#pat}))
        pat=:$ATTR_KEYWORD_R: a=${concat//$pat}; rcount=$(((${#concat}-${#a})/${#pat}))

      実際にループで回すのとどちらの方が速いかである。

    - また、文脈値によっては未だ終了してはならない物が決まっているのでそれを見る。
    - nest の状態も見る。
    - ヒアドキュメントの待ちキーワードも確認する

    その他のエラーについては、"続きが必要" という種類のものではないので、
    RET を以て改行を挿入して続きを入力するという機能にする必要はない。x

2017-10-17

  * vi-mode: support :reg

    内容を escape したい。これは info text と同じ仕組みを使えば良いはず。
    →調べてみると info では ble-edit/info/.construct-text で変換している。
    そしてこれは座標計算もしている。其処までは必要ない。
    代替になるものを実装する必要がある。基本的に .construct-text を簡単化すれば良い。
    文字幅を計算しなくて良いので [[:print:]]+ で読み飛ばしてしまっても良い気がする。

2017-10-12

  * vi-mode まだ対応していない・考えていないコマンドを列挙する

    意外とそんなに残っていないようなので。

    * nmap: C-a C-x C-^ '括弧 `括弧
      C-t C-] M Q ZZ ZQ do dp { }
      [{char} ]{char} z{char} C-w{char}
      g<C-a> g<C-g> g<C-h> g<C-]> g# g* g$ g&
      g` g' g+ g, g- g8 g; g< gD gH gN gP gQ gT gV
      g] ga gd gf gF gh gn gp gq gs gt gw gx g@
    * xmap: <C-]> <C-a> <C-x> g<C-a> g<C-x>

2017-10-05

  * vi-mode: 最終行付近で + _ g_ などを呼び出したときの振る舞いが異なる。
    この辺りの振る舞いについては色々調べる価値はある。

2017-10-01

  * syntax: case $x in (a b) : ;; esac のパターン "a b" はエラー

    どうやら一個の単語までしか駄目な様子?

    更に case aaa in ((aaa)) echo;; esac 等の様に () の入れ子もエラーになる。
    shopt -s/-u extglob に拘らずエラーになる。
    一方で extglob の @() に関しては中で () の入れ子が可能である。
    つまり、case の中の (...) と extglob @(...) の文脈は異なる。

    他にも違いはある。@(<>) は許されるが、in (<>) は許されない。
    @(&&) は許されるが in (&&) は許されない。
    in (a|a|a) は許されるが in (a||a) や in (||) は許されない。
    in (&), in (|), in (;), in (<), in (>) は何れも駄目。
    in (a&b), in (a;b), in (a<b), in (a>b) も何れも駄目。

    どうも全然違う文脈の様に思われてきた。

    現在の実装では ble-syntax:bash/ctx-case から CTX_PATN に突入している。
    (他に CTX_PATN に入っている箇所を探すと、
    関数の引数の括弧に何か変な物が入っている場合と、
    コマンドの途中で突然括弧が現れた場合である。
    これらはエラーに対する復帰としての CTX_PATN なのでそんなに気にしなくて良い)

    どうも振る舞いを観察すると ctx-conditions と ctx-globpat の中間のように思う。
    単語を設置しなければならないという観点で言うと ctx-conditions に近い。
    一方で対応している構文の集合という観点で言うと ctx-globpat が幾らか近いように思う。

    2017-11-27 追記
    どうやら () の中の単語ではチルダ展開も有効のようだ。以下で hello が出力される。
    case a=~ in (a=/home/murase) echo hello; esac # これは対応済み
    case a=/home/murase in (a=~) echo hello; esac

2017-09-25

  * 複数行編集スクロール: info の高さとの兼ね合い

    先ず info の高さを制限するようにしなければならない。
    現状では高さを計測する仕組みはあったが制限する仕組みはなかった気がする。
    つまり高さを計測しながらもし予め指定した高さを超えるようであれば
    そこで切るようにしなければならない。

    その後で info の高さを全体の高さの半分になるように制限する。
    編集パネルの高さはその時点での info の高さを引き算した値で決定する。
    もし編集パネルの高さが 2 行未満しか取れない場合には info を削る。

    (そもそも端末の高さ LINES が 2 未満しかないような環境は無視する。)

    →第2のプロンプトも出すようにしたので、それも意識して修正しなければならない。

  * ble.sh リロード機能?

    complete.sh の不整合で度々に問題になるのでリロード機能ぐらいはあっても良いのでは。
    また complete.sh はそれ自身として対策は考えたほうが良い気はする。
    例えばバージョンごとにディレクトリを作成してその中で管理するなど。

    以前 declare -ir だったものを全て消した。
    実はリロードできるのではないか。
    但し注意するべき点はいくつかある。

    先ず bind を再度実行すると変なことになると思われる。
    これについては何らかの変数で現在 bind 中かどうかを判定していたはず。
    現在の状態に関する類似のものは色々あるが、これらについては上書きしないようにする必要がある。

    また bash-3.0 の C-d 対策に使用する子プロセスや、
    stdout/on, off の状態などにも気をつける必要がある。

2017-09-23

  * emacs mode でも複数行のときにはそれが分かるような表示を行いたい。

    これを実際に実装するためには _ble_edit_str に変更がある全ての箇所で、
    複数行モードになったか、或いは逆に単一行モードになったかをチェックする必要がある。
    とは言っても _ble_edit_str を変更する箇所はそんなに多くないはずである。

  * ble-edit: yank-last-arg

    続けて入力するとどんどん遡っていく。
    どの位置から置き換えを行うかは mark に記録されている様子だ。
    また、前回実行された関数が yank-last-arg だった時にのみ遡る。

    前回実行されたコマンドを記録する仕組みを整える必要がある。
    難しい点は marked/nomarked をどの様に取り扱うかである。
    そう考えると呼び出し元 (ble-decode) で記録するのは難しいかもしれない。
    かと言って呼び出される側 (ble-edit) の各 widget で記録するのも面倒である。

    うーん。取り敢えず ble-decode の側で最後に呼び出したコマンド文字列を記録するぐらいはできるし、
    その程度の機能ぐらいはあってしかるべきと思うので実装する。
    marked/nomarked などの無駄な文字列は、記録した文字列を使用する側で何とかする仕組みにすれば良い。

2017-09-18

  * vi-mode: =

    :help = を見ると (設定 equalprog || 内部関数 C-indenting, lisp || 外部コマンド indent) が使われるそうだ。
    但し、indentexpr が非空白の時、indentexpr が使われる (参照: indent-expression)。

    インデントの規則について調べる。
    先ず初めに空行 (空白だけの行) を隔てて前の行に括弧がある場合には、
    それを考慮に入れて初めのインデントが決定される。
    空行を隔てて前の行がインデントされていればそれを継承する。

    結局空行を隔てた前の行のインデントまたは最後の括弧の位置を継承するということ?

    また括弧の種類は () しか見ていない {} や [] は見ていないようだ。
    デフォルトが lisp だからだと思われる。
    これは実のところシェルに適したインデントを実行するようにするべきなのだと思われる。
    しかしながらシェルのインデントはかなり面倒くさい。

  * vi-mode: 関連して [/ 等の実装についても調べたい。

    既に vim-surround.sh で類似の機能について実装したが、
    [/ についても個別に実装したい所である。

    他にテキストオブジェクトで [{ [} [( [) などと同等の機能も実装している。

  * vim-surround: ds cs インデント

    surround.vim では改行が絡むとき = によるインデントを実行している。
    現在 vim-surround.sh ではインデントを実行していない。

    2017-10-09 追記

    yS ySS でもインデントは起こる様である。
    更に、xmap S でもインデントを行う (xmap gS はインデントは行わない)。

2017-09-17

  * cmplstofB: ビジュアルモード・選択モード?

    * 選択モードは範囲に対する挿入モードのような気がする。
      選択モードは取り敢えず対応しないことにする。

    * テキストオブジェクトで範囲を選択し、また範囲を拡大する。

      どうやらテキストオブジェクトの拡大では左右の両端からの拡大を試みるような気がする。
      決して右端からテキストオブジェクトを拡大するというわけではないようだ。

      というのも変なところから初めて (...) の中に右端を移動して、
      その上で ib としてもエラーになるからである。或いは短くなる。
      どうも ib の動作としては左端から外側の ( を見つけて、
      それに対応する ) を右端に直すようである。

      うーん。これはテキストオブジェクトによって動作が異なるのかもしれない。
      aw などは明らかに右に向かって拡大を行っている。
      因みに矩形選択かどうかは気にしないようだ。
      同じ動作をする。行の右端に行くと次に次の行に普通に移動する。

2017-09-16

  * cmplstofB: vim-surround.sh: ds cs cS yS ySsd ySSd S gS 'C-s' 'C-g s' 'C-g S'

    現在のところ特に要望は出ていないが ds cs あたりは使いたくなるのではないかと思われる。
    → ds cs に関しては要望が出たので対応した。
    → cS yS ySs ySS vS vgS にも対応した。

    残っているのは imap <C-s> <C-g>s <C-g>S のみである。

2017-09-15

  * cmplstofB: here string 候補について

    here string 候補にファイル名以外のものがあれば対応する。返信待ち → やはり候補は難しい。

    コマンド名に応じた補完関数の設定を可能にする?
    例えば python3 に対する here document の場合には、import を補完候補に出すなど。


2017-09-12

  * vi-mode: operators

    ydc の他にも色々ある。

    http://vim-jp.org/vimdoc-ja/motion.html#operator

    ! = > <  gq  zf g@

    この内 g~ gu gU g? g@ は y と同様に文字列の長さを変えないものである。

    また ! = > < gq zf は例え文字列単位の範囲であっても行単位の操作に変換する。
    従って、処理を行った後の beg 及び end の位置は変更を受けることになる。
    これは operator:* 関数内からいじっても良いということにすれば現在の枠組みで十分対応可能である。
    何れにしてもそれぞれの機能の動作について調べてから実装する必要はある。

    →実際に < > の実装で (type == char のときに) beg を修正することにした。
    ! = gq zf の実装では < > の実装を参考にすれば良い。

    * todo: ! gq = g@ zf

    * opfunc/g@ はどうやら Vim script のキーボードマクロで使われるようだ。

    * gq の整形とはどういう整形だろう。調べると gw というのもある。
      http://h-miyako.hatenablog.com/entry/2015/01/31/185620 によると折り返しと関係する?
      試してみた所 80 桁に収まるように単語の切れ目で折り返しをする。
      単語は空白区切りであり w による単語とは異なる。
      gw と gq の違いは簡単に試した限りではない。後で help を見る。

      - 行は初めに連結される。空行(空白だけの行)は連結されない。

      というか面倒なので fold コマンドに流し込めば良いのでは?
      と思ったが fold は行を連結してはくれない。
      やはり自分で書いたほうが良いかもしれない。

    * zf は領域の折り畳み。対話シェルでは長いコマンドの編集は推奨されないし、これには対応しない。

2017-08-19

  * cmap/default.sh: "CAN @ ?" 代替?

    "CAN @ ?" は "C-x C-x" と較べて曖昧ということで現在無効にしている。
    これの代替キーシーケンスを定義しても良いかもしれない。
    といいつつ現実の端末に存在するものを登録しなければ意味がない。
    (そういう意味では "CAN @ ?" もこれに対応する現代的な端末が実在するのか怪しいのであるが。)

    思うに s-x だとか H-x だとか A-x を送りたければ CSI 2 7 ; ... ; ... ~ を使えば良い。
    何故 Emacs が "CAN @ ?" に対応しているのかは謎である。

2017-03-18

  * complete: .exe が候補から消去されている場合、.e の入力仕掛けの状態での補完ができない。

2017-03-04

  * syntax: bug ヒアドキュメントによる nparam の更新が追いついていない。

    これは何でかというと nparam の計算に stat 保存点を超えた過去の情報を用いているからである。
    部分更新をしている為に過去の情報が書き換わったとしても
    stat 保存点で解析状態が一致したと見なされてしまい、
    其処で解析が中断してしまうのがいけない。

    これを解決する為にはヒアドキュメントの word に相当する部分は
    一気に解析する様に修正しなければならない。
    結局 word 部分は最終的には独自の方法で読み取るのが良い様な気がする。

    或いは暫定的に範囲を指定して stat を消去する様な機能があったような…?
    →昔その様な処理の仕方をしていたような気がするが、いま確認してみるとない。
    恐らく何か問題が色々生じて結局その方法は使わないという事になった様な気がする。
    記憶が正しければそれは time ... や function func () だとか func () を解析する時の話だった。
    結局何れの場合でも一回の解析で行けるところまで解析するという事になった。
    ヒアドキュメントでもその様に実装するのが一貫している。

  * syntax: ヒアドキュメント 終端 word 着色

    todo: 取り敢えず RDRS 等と同様に完全に入れ子を追跡する様に実装する。

    $() ${} の入れ子も含めた実装が必要になる。

    実は、通常通りに解析してしまって、
    後の着色で一様な色に塗り潰してしまうという方策で良いのではないか。
    しかしそれだと tree-enumerate の際に $() の内部で着色が起こる気がする…。
    % 特に部分更新などをすると確実に内部での着色が発生するのでは…??
    % →部分更新の時は一番外側の単語についても着色が判定されるから特に
    % 部分更新仮想で内科に依る違いは発生しないと思われる。

    取り敢えずの実装として通常通りに解析する様に変更した。
    単に ble-syntax:bash/ctx-heredoc-word から
    ble-syntax:bash/ctx-redirect に処理を委譲するだけで良かった。
    ヒアドキュメント特有の処理は ble-syntax:bash/ctx-heredoc-word/check-word-end
    の方にしかなかったからである。
    また、同時に CTX_RDRI, CTX_RDRH の単語を上から塗りつぶす様にした。
    しかし、やはり予想通り $() の内部などの単語の着色は発生してしまっている。

2017-03-02

  * syntax: パラメータ展開・算術式評価内部の quote 除去が為されない状況での _ble_syntax_attr

    以下の項目で対応しきれなかった (対応しないことにした) ものをここにまとめる。
    cf. #D0375 "2017-03-02 [2016-08-06] syntax: extquote と "${}" の入れ子に関して"

    > - $(()) の中の () のネストに関しては対応していない。
    >   つまり () が一つでも挟まれば quote 除去が有効であるかのように着色される。
    >   →これは対応した。

    - $((a['1+1'])) などの添字の quote 除去は有効であるが、現実装では quote の着色はしていない。
      つまり $(('1+1')) などと同様に quote 除去が為されない物として着色を行っている。

      これに対応する為には $(()) の中でも [] に対応するネストを判定する様にしなければならない。
      ※一方で [] の中では () に対応するネストの判定はしなくても良い。

    - $(("${hello}")) などの構造では CTX_QUOTE の中で自身が有効かどうかを判定して
      自身の着色を変更したりするのは面倒なので、普通に (有効であるかの様に) 着色している。

      算術式の場合には quote 除去されないと分かっている時点で文法エラーになるので
      1文字目をエラーの色にするというので良い気がする。
      パラメータ展開の内部の場合には quote 除去されないからと言ってエラーにはならない。

    - bash では "${var# ... }" の中の '' は quote 除去される一方で、
      "${var:- ... }" の中の '' は quote 除去されない。
      この実装では取り敢えず quote は除去されるという取り扱いである。

      これらについては包括的に振る舞いを調査する必要があるだろう。
      他にも様々な種類のパラメータ展開があるし、
      また将来的に各種類のパラメータ展開についての詳細な構文解析にも対応する可能性がある。
      (特に ${var//a/b} の quote (\?) の取り扱いがややこしいのでこれは視覚的に分かる様にしたほうが良い。)

2017-03-01

  * complete: "function fun [" で補完を実行すると '[[' ではなくて '[\[' になってしまう。
    これを解決するためには complete.sh の source の wordlist で、
    エスケープをオフにするオプションを用意する必要がある。

    ble-complete/action/plain/initialize で行われている escape-specialchars が原因だ。
    action として word を使用している為にそのままその機能を継承している様だ。
    新しい専用の action を定義するか或いは wordlist にオプションを指定できる様にするかすると良い。

  * complete: 既に入力された部分を修正する様な形での補完があっても良いのではないだろうか。

2017-02-27

  * PS1='$(echo "hello")'

    現在の実装では " で囲んでも大丈夫な様に一頻りエスケープしてから
    builtin eval "ps1esc=\"$ps1esc\"" を実行している。
    しかし、この実装だと $() の中にある " も全てエスケープされてしまう。

    これに対応するのは面倒である。
    正しく実装する為には $() の中と ${} の中を読み飛ばして無駄にエスケープしない様にする必要がある。
    それこそ構文解析をして $() や "" <() ${} の入れ子を追跡しなければならない。
    実は入れ子の追跡だけならば () と "" だけ追えば良いのではないか?
    しかし case esac があるとまた厄介になる…が、それに関してはシェル自体も対応していなかったりする。
    @() や +() 等に関しては必ずバランスする事が保証されているのでこれも一緒くたに追跡すれば良い。
    問題は quote されている () "" であるがそれらは… \? '...' `...` を飛ばすという対応で良いのではないか。
    と思ったが文脈によっては ' は quote にならなかったりする。文字列の中では quote にならないし、
    また $(('aa)) だとどうだろう。と思ったが、そもそもこれは算術式のエラーになる。
    実際に試してみた所、更にシェルの文法としてもエラーになる様子だ。つまり、切り出しはやはり '...' の組で行っている。

    うーん。因みに Bash はコマンド置換の中の \w 等についてもちゃんと展開してくれる。

    2017-11-12 改めて Bash の振る舞いについて調べる。

    | 先ず \w が展開された結果として $(...) が現れても
    | それはコマンド置換の対象ではない。
    |
    | ~$ mkdir '$(echo "hello")'
    | ~$ cd !$
    | $(echo "hello")$
    |
    | この状態で PS1 を設定してみる。と、エラーになった。
    | $(echo "hello")$ PS1='$(echo \w)'
    | bash: command substitution: 行 41: 予期しないトークン `(' 周辺に構文エラーがあります
    | bash: command substitution: 行 41: `echo ~/t/\$(echo \"hello\"))'
    | bash: command substitution: 行 1: 予期しないトークン `(' 周辺に構文エラーがあります
    | bash: command substitution: 行 1: `echo ~/t/\$(echo \"hello\")'
    |
    | うーん。どうやら Bash の実装では \w 等を展開した結果に $" が含まれている場合は
    | エスケープ付きに一回置き換える様だ。
    | 因みに ~ もエスケープされないので \w にしていても上記の PS1 では /home/... になってしまう。
    |
    | /home/..../tmkdir '\\\\'; cd '\\\\'
    | /home/..../t/\\\\
    |
    | どうやら、\ もちゃんとエスケープ付きに置換されている。
    | 因みに \w と違って \\ は単一の \ に置換されるようだ。
    | 従って、次の評価の時に数が半減してしまう。
    |
    | /home/....t/\\\\PS1='$(echo \\\\)\$ '
    | \$

    恐らくこういう実装になっている。

    1 最初に \w などの特別な指定を全て置換する。

      この時置換結果に $"\` が含まれている場合にはエスケープする。
      これは丁度 "" 引用符の中でエスケープが必要なものに合致する。
      (! はエスケープの対象ではない。)

      また \\ は \ になる。
      \" は \" のままの様だ。これは PS1='$(echo \\\"hello\\\") '
      とするとプロンプトが \hello\ になる事で確かめられる。

    2 次に文字列を評価する。コマンド置換やパラメータ展開を処理する。

      それも恰も "" で囲まれた環境であるかの様に展開を処理する。
      しかし " は引用符の終わりという意味を失って単なる文字になる。
      この部分が一筋縄では行かない難しい点である。

    " が引用符の終わりという意味を失いつつ、
    それでいてパラメータ展開やコマンド置換が有効な文脈は思い浮かばない。

    a そう言えばヒアドキュメントはどうだろう。

      o ヒアドキュメントは行末の空白は消えない。空白類はちゃんと保持される。
      o 最後に改行は付加される。
      x \" は \" のまま。これは問題である。
      o \$ は $ になる。\\ は \ になる。

      うーん。しかし、厳密に bash と同じ振る舞いでなければならない訳ではない。
      例えば step 1 の段階で \" を " に縮め、
      また置換結果の " をエスケープしないというのも可能である。

      この時 PS1='\\" ' の結果が Bash と異なることになるが仕方がない。
      Bash は \" にし、更にその後の評価で " になる。
      一方で、此処で提案した実装では初めに \" になる所までは同じだが、その後で \" のままになる。
      PS1='\\\" ' の場合はどうだろうか。Bash は \\" にし 更に \" になる。
      此処で提案した方法だと初めに \" になり次のステップでも \" に留まる。
      この時は (中の処理は異なるが) 結果は一致して見える。

      % 更に言うと Bash の実装に従う必要も全然ないかもしれない。
      % 例えば、\w 等の置換結果は当たり障りの無い
      % 特殊 Unicode 文字 (私用領域など) に変換しておいて、
      % 最後に代入するという手法も考えられる。
      % この様にすれば変なディレクトリに入った時に Bash の文法とかち合うこともない。
      % 但し、これだと例えば \w のパスを加工して表示するという様な処理が期待通りに動かない。
      % 直観的でないのでやはりこの方法は避けた方が良い様に思われる。

      x そういう意味で言えば Bash の振る舞いはコマンド置換の中で \w を使う場合でも
        取り敢えず "" で囲んでおけば問題は起こらないので、PS1 を正しく設計すれば大丈夫である。
        一方で、此処で提案したような「" はエスケープしない」という実装だと、
        二重引用符を含むような名前のディレクトリにいる時、"\w" の様に二重引用符で囲んでも駄目、
        ということになり問題が生じる。どんなディレクトリ名でも大丈夫にしようと思うと、
        ヒアドキュメントを更に内部で使用しなければならず、非現実的である。

      そう考えるとやはりヒアドキュメントに頼らない方が良い気がする。
      というかヒアドキュメント自体が悪いのではなくて、
      ヒアドキュメントで \" が " にならないという仕様がたまたま今回の場合に合わないだけである。

    b 他に文脈はあるだろうか。ない気がする。

    c やはり正確に処理する為には地の文にある " だけを全て正確に \" に置き換えるしかない。
      そしてその為には $() ${} "" の入れ子の勘定が必要である。\? '...' `...` はスキップする。
      うーん。場合によっては ble-syntax を呼び出した方が賢明かもしれない。

2016-09-11

  * やはり履歴のロード時間が気になる。

    | time test1=$(ble-edit/history/.generate-source-to-load-history)
    | real    0m3.211s
    | user    0m3.661s
    | sys     0m0.535s
    |
    | time eval -- "$test1"
    | real    0m2.472s
    | user    0m2.383s
    | sys     0m0.080s
    |
    | time _ble_edit_history_edit=("${_ble_edit_history[@]}")
    | real    0m1.552s
    | user    0m1.526s
    | sys     0m0.022s

    generate-source-to-load-history が思いの外遅い。

    time history | cat >/dev/null
    real    0m0.321s
    user    0m0.134s
    sys     0m0.433s

    history 列挙自体はそんなに時間はかからない様だ。
    time command awk ... 2>|~/a.txt
    3.08user 0.02system 0:03.13elapsed 99%CPU (0avgtext+0avgdata 3096maxresident)k
    0inputs+0outputs (0major+281minor)pagefaults 0swaps

    何か変な表示になったが…。
    何故かは分からないが /bin/time が呼び出されている様だ。
    どうやら hoge | time ... とすると time は /bin/time になる様だ。知らなかった…。
    何れにしても awk における処理自体が 3 秒かかっているという事が分かった。
    と、ここで使っている awk の version が古いという事に気づいた。最新版に更新する。
    序に CFLAGS='-O3 -march=native' でコンパイルしてみる。2.5s になった。
    調子に載って icc でも試してみたら 2.6s になった。
    オプションは -fast にしたらリンク関係で失敗したので、-O3 -march=native にした。
    padparadscha の動作が重いようなと思って再起動したら 0.677s にまで短くなった。
    Server というのは長時間起動していると遅くなるものなのか…。
    或いは、kernel のアップデートをする度に何らかの thunk が登録されて動作を置き換えているとかそういう事なのかもしれない。
    という訳でずっと起動しながらアップデートを続けていくとどんどん重くなっていくとかそういう事だったりするのだろうか。

    a 或いは history を配列上に展開するということをしないほうが良いのだろうか。
      つまり ble/util/assign result history ... を用いて各行毎に値を取り出す様にする。
      これは ble/util/assign と配列を辿る速度の差がどれくらいあるかに依存する。
      と思ったが、そもそも history を探してみたが特定の番号の項目だけを抽出する方法がない。
      ということは sed などを起動して目的の行だけを抽出する必要があって、
      アクセス速度はシステムの fork の速度によって律速される。
      つまりとても遅いので使いものにならない。

    b 或いは、必要になった部分だけを少しずつロードするという手もあるかもしれない。
      しかし、そうすると例えば検索で存在しない文字列を入力したりすると、
      何度もロードし直す事になり、余計に時間が掛かる様になる。
      実装が面倒な割に対して効果も得られなそうだ。

    c それとも初めに history の内容を何処か別のファイルに変換してすぐ source できるようにしておいて、
      違いのある部分についてだけ更新を実行するという手もあるかもしれない。
      しかし、必ずしもファイルが後尾に追記されるだけとは限らないし、
      それに対処するために diff などを呼び出し始めると余計に時間が掛かる事になる。
      或いは、history コマンドとは完全に独立に履歴を管理して、
      自分の管理している履歴から bash_history を生成して、
      bash の開始時にはその自分の管理している history を読みこませるという手もある。

    というかこれに関しては既に色々と議論している筈だ。
    → 2016-07-15 #D0346 に記録が残っている。そちらの方が詳しいはず。

    2017-11-11 実は ~/.bash_history を直接読んでしまった方が速い可能性?
    具体的にどれぐらいの時間差があるのかについて調べる。

      $ time mapfile -t array1 < ~/.bash_history

      real    0m0.049s
      user    0m0.038s
      sys     0m0.011s
      $ len=${#array1[*]}; echo len=$len; rex='^eval -- \$'\''([^\'\'']|\\.)*'\''$'
      len=34093

      | $ time for ((i=0;i<len;i++)); do [[ ${array1[i]} =~ $rex ]] && echo yes; done
      | real    0m2.205s
      | user    0m2.197s
      | sys     0m0.005s
      |
      | 高速化を試みる。
      |
      | $ time for ((i=0;i<len;i++)); do [[ ${array1[i]::4} == eval && ${array1[i]} =~ $rex ]] && echo yes; done
      | real    0m1.004s
      | user    0m1.002s
      | sys     0m0.001s
      |
      | $ time for ((i=0;i<len;i++)); do [[ ${array1[i]} == 'eval -- $'* && ${array1[i]} =~ $rex ]] && echo -n yes; done
      | real    0m0.925s
      | user    0m0.923s
      | sys     0m0.001s
      |
      | 判定を分けて見る。少し速くなる。25ms
      | $ function check1 { [[ ${array1[i]} =~ $rex ]] && echo -n yes; }
      | $ time for ((i=0;i<len;i++)); do [[ ${array1[i]} == 'eval -- $'* ]] && check1; done
      | real    0m0.900s
      | user    0m0.897s
      | sys     0m0.002s
      |
      | もっと判定を短くしてみる。クォートはない方が速い (11ms)
      | $ time for ((i=0;i<len;i++)); do [[ ${array1[i]} == 'eval'* ]] && check1; done
      |
      |         'eval'*   eval*
      | real    0m0.877s  0m0.866s
      | user    0m0.876s  0m0.865s
      | sys     0m0.000s  0m0.001s
      |
      | ${array1[i]::4} とすると遅いようだ (114ms)
      | $ time for ((i=0;i<len;i++)); do [[ ${array1[i]::4} == eval ]] && check1; done
      |
      | real    0m0.980s
      | user    0m0.973s
      | sys     0m0.005s
      |
      | 判定で空白まで含めると遅くなる。逆に短くすると速くなる。
      | しかし短くしすぎると偽陽性が多くなるので遅くなる。まあ eval が妥当な所だろう。
      | $ time for ((i=0;i<len;i++)); do [[ ${array1[i]} == eval\ * ]] && check1; done
      |
      |         eval\ *   eva*      ev*       e*
      | real    0m0.873s  0m0.859s  0m0.856s  0m1.101s
      | user    0m0.872s  0m0.857s  0m0.846s  0m1.099s
      | sys     0m0.000s  0m0.001s  0m0.008s  0m0.001s
      |
      | for in でループを回す様にしたが寧ろ遅くなった。
      | $ i=0; time for data in "${array1[@]}"; do [[ $data == eva* ]] && check1; let i++; done
      |
      |         let i++   ((i++))
      | real    0m1.320s  0m1.161s
      | user    0m1.306s  0m1.154s
      | sys     0m0.012s  0m0.005s
      |
      | 配列の中身を修正するようにしても特に速度低下は見られない
      | $ function check1 { [[ ${array1[i]} =~ $rex ]] && array1[i]=${array1[i]:8}; }
      | $ time for ((i=0;i<len;i++)); do [[ ${array1[i]} == eval* ]] && check1; done
      |
      | real    0m0.853s
      | user    0m0.852s
      | sys     0m0.000s
      |
      | 実際に目的の補正を実施してみる。
      | $ time mapfile -t array1 < /tmp/hello.txt
      |
      | real    0m0.056s
      | user    0m0.048s
      | sys     0m0.008s
      |
      | $ function check1 { [[ ${array1[i]} =~ $rex ]] && eval "array1[i]=${array1[i]:8}"; }
      | $ time for ((i=0;i<len;i++)); do [[ ${array1[i]} == eval* ]] && check1; done
      | real    0m0.864s
      | user    0m0.863s
      | sys     0m0.000s


      或いは、~/.bash_history でなくて history を何処かに出力するというのでも良い。
      $ time history | sed 's/[[:space:]]*[0-9]\{1,\}[[:space:]]*//' > /tmp/hello.txt

      real    0m0.146s
      user    0m0.167s
      sys     0m0.049s

      もしこれをする位であれば、現状の方法で eval をする代わりに mapfile で読み出せる様にした方が良い?
      と思ったが、改行を含む場合に何ともできないのでやはり駄目だ。
      しかし、配列の複製よりも mapfile の方が速い様だ…。

      $ time array2=("${array1[@]}")

      real    0m0.590s
      user    0m0.577s
      sys     0m0.012s

      現在の読み取りの枠組みでどれだけ時間がかかっているのかについても確認しておく。

      $ time ble-edit/history/load

      real    0m2.320s
      user    0m2.453s
      sys     0m0.228s

      うーん。mapfile による実装を合計すると大体同程度なのでは。

      history > tmp 146ms
      mapfile       56ms
      複数行補正    864ms + α
      配列コピー    590ms
      --------------------
      合計          1656ms (71% of 2320)

      計算してみると多少短くなっているが、そんなに変わらない。
      しかし、この新しい方法の利点は何かというと、
      一番処理に時間のかかる部分がループになっているので、
      処理を分割して少しずつ裏で更新を行うことができる点にある。

      さて。この方法の問題点は shopt -s lithist の時に、
      改行を含むコマンドが分割されてしまうという事にある。
      改行を含む場合には eval -- の形に変換するなどの工夫が必要になる。
      しかし其処まで行くと、awk でできるだけ処理してからという事もできる。


2016-07-20

  * ファイル名の色付けに LS_COLORS を参照する?
    https://github.com/trapd00r/zsh-syntax-highlighting-filetypes

    ble.sh の枠組で使用する為には ble-color.sh/gflags に変換しなければならない。
    しかし、実際に使っている terminal と sequence が異なる場合に齟齬が生じる。
    従って直接 LS_COLORS を用いるよりは、bleopt_filename_ls_colors 的な変数に指定して貰う事にする。
    そのまま LS_COLORS を使用したい場合は bleopt_filename_ls_colors=$LS_COLORS などとする。
    展開を実行するようにする。

2016-07-15

  * complete: "" の中にある $variable で確定した時は空白は挿入しないようにしたい。
    また ${... の中で variable で確定した場合は '}' を挿入するようにしたい。
    もしくは } が既に存在している場合にはその次の文字へカーソルを進めたい。

    つまり、何を挿入するかは候補側が決めるというよりは実のところ
    候補生成箇所の文脈に依存するという事である。
    variable:= などを導入して候補生成箇所の文脈を伝える様にはした。
    しかしこの方法だと無駄に複雑になる気がする。
    補完の枠組自体を再考する必要がある。

  * isearch: 現在の履歴内の位置を % で表示しているが、
    これは検索の進捗状況の表示の方が分かりやすいのではないか。

  * complete: declare の引数を特別扱いしているがこれも compgen があればそれに従うべきでは。
    もしくは、何か特別な処理をするとしても compgen を介して特別な処理をするべきではないのか。

    現状の実装だと、declare などの変数を宣言する組み込みコマンドについて、
    ユーザが complete によって補完の制御を行う事ができない。

  * complete: そもそも現在の実装は妥当なのだろうか。
    全ての候補に一つずつ候補の文字列・挿入文字列・説明 etc を計算して登録しているが、
    これらは最低限の情報に留めておき表示する必要が生じた時に改めて計算すればよいだけなのではないか。
    つまり、source 番号と一緒に登録しておけば全部計算できるような気がする。

    一つ気になるのが INSERT を事前に計算しておく必要があるのかどうかと言う事である。
    現状の実装では共通一致部分を算出するのに INSERT を使用している。
    - source の種類によって一致対象の文字列が同じでもエスケープの仕方が異なる事が考えられ、
      その場合にはエスケープも含めて共通一致部分までしか確定できないはずだからである。
      例えば変数名 $variable 及びファイル名 variable の両方に一致して $var まで入力しかけた時、
      一致候補の文字列が同じ variable であっても前者による補完は $variable だし、
      後者による補完は $var\variable になる筈である。
    しかし、この措置によって処理が複雑化している気がする。
    その様な状況が本当に発生するのかどうかも含めて再度考え直しても良いのではないか。
    例えば上記の例で言えば、実際には $variable の補完の方が優先される。
    その点から始まる補完 (ファイル名 variable) は他に候補がない場合に限られるからである。

2016-07-08

  * prompt: 最終行・先頭行に何か表示する機能があっても良い。

2016-07-07

  * isearch: 正規表現検索?

    →取り敢えず vi-mode で実装した #D0513。incremental ではない。

    正規表現で incremental にすると一度通り越したものに一致する可能性があるので直観的でない。
    もし incremental にする需要がある場合には再度考える必要がある。
    因みに、emacs は (分かりにくい動作だが) 現在の位置から続きの検索をする。

  * edit: 置換モード (正規表現・固定文字列・globパターン)?

    その為には置換前・置換後を入力する欄を別に表示する必要がある。
    入力欄でも様々な binding が使えた方が嬉しい。

  * HISTCONTROL=erasedups の時 ble-edit/history/add が遅いかもしれない

    重複する項目がないかぎりはそんなに遅くないのではないかと思われる。
    何れにしても bash 配列において何が遅くて何が速いのかについて計測する必要がある。
    filter 部分の操作とそれから truncate の部分について。
    →benchmark-array.sh で filter を実装して試してみたが、
      実装の仕方でそんなに速度が変化するということはなかった。
      もっと巨大な配列の場合などでしか効かないという事だろうか。
    →しかし何れにしても実測してみたところによると
      重複する項目がある時はかなり重くなるという事が予想される。

  * _ble_edit_history, _ble_edit_history_edit 初期化高速化について

    これについての詳細な議論は 2016-07-15 #D0346 に残す。ここでは概要について述べる。

    時間計測すると 40% が generate-source-to-load-history (awk) であり、
    40% が eval -- '_ble_edit_history=(...)' であり残りの 20% が
    _ble_edit_history_edit=("${_ble_edit_history[@]}") である。
    どのステージでも高速化の効果が同程度にあると見て良い。

    現在現実的な手法として残っているのは以下である。
    - _ble_edit_history_edit clone 遅延
    - generate-source の非同期実行

    記述の汚さの割に大幅な高速化が見込める訳ではないので現在は採用していない。
    今後高速化で問題になる様なことがあれば上記の項目・その他について考える。

2016-06-20

  * ble-edit/exec:exec/process コマンド実行時に一時的に .ble-line-info を消す。
    その他にも ble-line-info の使い方について全体的に見直しを行うと良い。

2016-06-22

  * prompt-toolkit という物がある様だ。ちょっと観察してみるのも良い。

    基本的には補完候補を勝手に出すという事と、
    表示の仕方が emacs auto-complete と同様に
    overlay によって実現されているという事。

    所で overlay で実現するためには複数行で編集を行っている時に、
    下の行にある内容を記憶しておく必要性が生じる。
    Emacs の場合には表示している内容を完全に内部に保持しているので問題にならなかった。
    (a) 現在の実装で実現するためには内容を完全に記憶するか、そうでなければ
    (b) 複数行で編集を行っている場合には枠の位置・大きさを変更する際に
    毎回下の方にある行を再描画するかといった事が必要になるだろう。

    Bash では 2 次元配列を実現するのは辛いので
    結局内容を完全に記憶するというのは余り嬉しくない事だろうか。
    と思ったが、表示領域の幅 (COLUMNS) さえ把握しているのであれば、
    実は 1 次元配列の上に terminal の内容を保持してしまっても問題ない気がする。
    というか枠の大きささえ決まっていれば普通に sub window の様な物も
    bash で実現する事ができる。今まで余り考えたくないとして避けていたことだが、
    この方法ならば楽である。

  * GUI Window System を整える? Window を出したり消したりだとかそういう事。

  * timer の実現方法について

    一つの方法は read -t 0.1 < 何処か などという風にすることである。
    しかしこの方法は一定時間の sleep を行うだけで定期的な処理を実行する timer にはならない。
    処理自体に時間が掛かっていると遅延が生じてしまう。

    もう一つの方法は別のプロセスを起動してそのプロセスでひたすら時を刻みながら
    自プロセスに対して通知を行うという方法である。
    通知を行う方法は色々考えられる。シグナル、mkfifo、mkdir など。

    a シグナルには余り頼りたくない。思いがけずクラッシュしそうな気がするからである。
      シグナルハンドラの起動中にシグナルハンドラが呼び出されるとクラッシュするので、
      シグナルハンドラの内部ではカウンタをインクリメントをするだけにする。
      しかしその様にしたとしても何らかの遅延により
      シグナルハンドラが二重に呼び出される可能性は排除できない。
      また、別の問題点としてタイマーの開始・終了を制御する方法がないという事がある。
      →まあ、単純に生成したサブシェルを kill すれば良いだけとも言える。

      $ trap -- '((ble_timer_count++))' USR2
      $ (while xsleep 0.1; do kill -USR2 $$; done) & disown

      →実際にやってみたが思う様に動いていない様に見える。
      どうも親プロセスでキーボード入力をした回数だけしか発生していない様な…。
      というわけでそもそもこの方法は使えないという事なのかも知れない。

    b mkfifo による方法に関しては…。これは処理する側で遅延が発生すると、
      延々とパイプにデータが流し込まれメモリに悪そうだという問題がある。
      しかしバッファが一杯になったら都合良く停止するだろうか (バッファのサイズによる)。

      →或る程度呼び出したら停止した。と思ったらそんな事は無かった。
        というか 1 秒間に 10 文字程度ではすぐには buffer は一杯にならない。

      $ exec 3< <(trap -- '' INT QUIT; while echo -n t; do sleep 0.1; done)
      $ while read -t 0 <&3; do IFS= read -r -d '' -n 1 byte <&3; ((count++)); done; echo $count

      所で timer を停止したい場合にはどうしたら良いのか…。プロセス番号を取得するには?
      と思ったらプロセス置換の場合でもちゃんと $! にプロセス置換のプロセス番号が入っていた。
      なので $! さえ何処かに記録しておけば問題ない。

      更に実際に動かしてみると安定して動いている様に見える。

    c もし自プロセス内で閉じた方法があればそれが一番良い。
      例えばミリ秒単位で時刻を計測することができれば経過時間に応じて
      sleep 量を調整する事ができる。

      printf -v '%(%s)T' を用いる方法だと秒より下の単位は取得できない。
      GNU coreutils の date はその様な機能 (%N) も持っている様だが、拡張に過ぎない。

      あった。procfs をマウントしていれば (そして現在のシステムでは殆どそうだろう)
      cat /proc/uptime でシステムを起動してからの時間を見ることができる。
      と思ったが linux, cygwin には /proc/uptime があるが、mac os x ではそもそも /proc がない様だ。
      FreeBSD でも /proc はあるが、BSD にはなかったからの様だ。他に HP-UX もない。
      Solaris には /proc はあるが /proc/uptime は無い様な雰囲気である (確認できていない)。

      また /proc/uptime を呼び出す overhead が如何程の物かという問題もある。
      →0.05ms であった。本当に計測できているのだろうか??
        関数に入れて見たが計測できている様だ。という訳で overhead はない物として良い。

2016-06-19

  * complete 補間候補一覧表示:
    やはり現在までに入力した部分と、
    未だ入力されていない補間文字列の部分を色分けして表示した方が良い。
    特に入力文字列が長い場合に見にくい。

  * complete 補間候補一覧表示:
    また、候補が長い場合や入力が面倒な場合 (例えば日本語の場合) があるので、
    矢印キーなどで選択できる様にした方が良い。

  * timer/非同期実行機能:
    history 検索やゲーム的機能 (demo 用) の実装のためには、
    やはり timer の様なイベントを発生させる仕組みを整えた方が良い様な気がする。

    →しかし無駄に複雑にしたり需要に合わない様な形に実装しても仕方がないので、
    取り敢えずは history の検索に於いて非同期に処理を行う方法を実装して、
    その後でその実装を参考にして仕組みを整える方が賢明である様に思われる。
    あるいは、history を非同期に検索できる様にしたとしても
    途中で面倒になって統一的な実装にしたくなるかも知れないが、
    そうだとしても history を目的として最小限の統一的実装にするという方向でよい。

    非同期の実行の仕組みとしては、

    1. 先ず処理を中断できる様な方法で実装するという事、
    2. それからユーザからの入力があった場合にそれを検知できるという事。

    これらだけあれば基本的に十分である。
    ユーザからの入力は bash-4.0 以降であれば read -t 0 で確認できる。
    なので、基本的には処理の方を細切れにできれば何も問題は生じない筈である。
    一応ユーザからの入力を受ける時に bash が勝手に色々操作をするので、
    それの対策として色々出力を繋ぎ変えたり表示を更新した理などの処理はあるが、
    それらは別に大したことはない。context switching か何かの一部だと思えば良い。

2016-04-06

  * 補完候補表示で既に入力が完了しているディレクトリ部分についてはそれを表示しない様にする。
    表示されている候補がファイル名とは限らないが、補間されている候補の種類に依らず省略して良いと思う。
    そちらの方が自然である。もしファイル名でないとしても似たような入れ子構造に対応している可能性が高いので。

    →でも、前に何か対応したような気がするが…、と思って改めて確かめてみたら、
      ちゃんと ../../ の様な面倒な物は省略されて表示されている様な気がする。
      では何故先程は ../../ の様な文字列が大量に表示されていたのだろうか…。

    →いや、cd コマンドの候補 (プログラム補間候補) がそうはなっていない様である。
      前に同様の事を議論したような気がするのでログを漁ってみる事にする。

2016-04-05

  * tree-enumerate による skip の実装と解析一時中断の不整合に関して。

    ble-syntax.sh: ble-syntax/parse/shift.impl2 の問題点である。

    現状の方法では、解析一時中断を行った時に shift 対象の高速な列挙が出来なくなる。
    唯一の現実的な高速化手法は "直前非空白要素の位置" を管理するように変更する事である。
    これは解析自体の動作とは全く関係なく、_ble_syntax_tree/stat/nest の配列としてのデータ構造を拡張するという事である。
    解析自体の実装とは直交して実装する事が可能と思われるが、新規情報の管理コストが増えるという問題点が残る。

    →一方で tree-enumerate を使った場合には閉じている単語内部の shift を省略できるなどの利点がある。
      最終的にはこれらを組み合わせたような shift が必要になるだろうと考えられる。
      もう少し詳しく考察を行う必要性がある。

2015-12-23

  * C-r C-s で mark が破壊されてしまう。
    (現状の実装だと、範囲選択に C-r C-s を使う事ができない。)

    例えば mark が設定されている場合は現在の履歴項目の中で、
    mark を解除せずに検索を行うなどの様にすると良い。

    履歴項目を移動した場合には解除するというので良い。
    (また戻ってきた場合には復元する。)

    問題になるのは着色である。layer を追加するか、
    選択範囲の表示に使っている layer を拡張するかする必要がある。

2015-12-20

  * complete: 履歴を用いた候補生成? 特に単語について。

2015-12-12

  * IGNOREEOF に対応 (現在 bash-4.0 未満では勝手な値を設定しているので、
    これはコマンド実行の瞬間だけに復元する様にする必要がある。
    PS1 と同様の取り扱いで良いと思われる。)

2015-12-03

  * undo, redo

  * 色コード ble-color-gspec-list
    → ble-color-show

  * bash-3 で C-d を捕獲する為のメッセージについて

    ignoreeof-messages.txt に入れてそれを grep -F で検索する様にした。
    しかしながら ignoreeof-messages.txt の中身を読み込んでしまった方が速いかもしれない。

2015-12-01

  * vi bind

2015-11-21

  * 公開までに追加であった方が良いかも知れない物

    + 同じ場所で complete (TAB) を連続で呼び出した時にカウントを行うべき
      + peco や sentaku など (?) の外部コマンドを起動する時の基準に使用できる。

    + 拡張性の提供 (拡張の仕方の説明)
      + theme の枠組を整える事 (setting files の置き場?)
        ble-color-list
      + 文字コード拡張 (Unicode との mapping)
      + 端末制御コード拡張
        tput からもっと積極的に読み込むべきなのでは?
        cmap/default.sh に加えて cmap/tput.sh 的な物も?
        > minimal.sh, xterm.sh, rosaterm.sh の整理。

    + 簡単なキーボードハンドラのサンプル (テトリスとか? 或いは sentaku 再実装とか)

      サンプルとしては、端末の出力画面に現れる物よりは、
      画面を altscreen で完全に切り替える物の方が実装しやすいと思われる。
      それでいて、read -t 0 などを有効に使えるとなるとテトリスなどになるだろうか。

    + マウス対応

    + RPS1

    + vi bind (これは bind -p で調べれば大丈夫の筈?)

      →bind -p して見たがどうも vi には vi の完全に異なるコマンド体系がある様である。
        単純な移動コマンドぐらいならば対応できるが、それ以外の物についてはどの様な操作なのか
        よく理解していないので憶測で実装するのは難しい。

    + vbell の色
      + キーボード入力内容を全部 vbell で表示する方法?

  * bug: 複数行編集でカーソルが一番上にない場合 vbell で編集内容が消される。

    元々 vbell を実装した時は複数行になる事を想定していなかった (複数行にできなかった)。
    現在は複数行に対応したので特別の配慮が必要である。
    (ble-edit.sh から値を引っ張ってくる必要があるので interface を決めておく必要はあるが。)

2015-11-18

  * PROMPT_COMMAND を一番外側の環境で実行する様に変更する。

    現在は .ble-line-prompt/update の中で直接実行している。

    また、stty 等を正しく設定して呼び出すようにする?

      参考の為: 現在 ble-bind -cf による登録では、
      function .ble-edit.bind.command を通して .ble-edit.accept-line.add
      でコマンドを登録し一番最後に外側でコマンドを実行する。
      このコマンドによる出力はプロンプトの次の行に表示される。
      またコマンド終了後には改めてプロンプトが表示される。

      一方で ble-bind -xf proc に関してはそもそも未実装の状態になっていた。
      このコマンドではプロンプトの次の行に行ったり、プロンプトを消したり、
      或いはプロンプトを再描画したりなどと言った事は不要である。
      (勝手な出力をしないという前提・表示が乱れた場合 proc の方が悪いという事にする)

  * complete: 存在しない変数名で補完しようとすると \ が挿入される。
    ここは何も実行しないで欲しい所である。

2015-11-06

  * まったく同じ nest 状態になると思われるのに解析中断が起こらない

    ☆これは表面上は何の問題も起きない。多少無駄な処理をするだけである。
      従ってそんなに対処に緊急を要しない。

      | function ble-syntax/parse/nest-equals {
      |   local parent_inest="$1"
      |   while :; do
      |     ((parent_inest<i1)) && return 0 # 変更していない範囲 または -1
    -->     ((parent_inest<i2)) && return 1 # 変更によって消えた範囲
      |
      | local _onest="${_tail_syntax_nest[parent_inest-i2]}"
      | local _nnest="${_ble_syntax_nest[parent_inest]}"
      | [[ $_onest != $_nnest ]] && return 1
    変更によって消えた領域を指している場合は、
    既に消えた領域のデータを捨てているので nest の判定を行う事ができない。
    そんな訳で解析中断はできないと判定されてしまうのである。

    ここで解析中断を出来るようにする為には消えた領域のデータも取って置いて、
    その上で全く同じ解析結果になったら解析中断を行う、という事になろう。
    以降の解析の動作に違いがなければ良いのだから
    過去の nest の状態だけが一致していれば解析中断には充分である。
    これは別項目として独立させて残す事にする。

    ※問題は解析領域拡大によって i1 が後退する事によって
      変化の無かった部分についても解析結果が消去されてしまう事にある。

2015-08-20

  * エラーがある時にはコマンドを実行できない様にする

    一番明らかな物は一番初めのコマンドが見付からない場合である。
    また、文法構造にエラーがある場合も含まれる。
    文法構造にエラーがある場合は ATTR_ERR が指定されている筈である。
    然し乍らそれ以外にはエラーを得る情報が無いとも言える。
    エラーがある時のコマンド実行について考える前に、
    先ずはエラーの処理について再考しておいた方が良いような気がする。

  * エラー検出・表示の管理について

    現状

    現在エラーは様々な方法で使用者に対して提示している。
    解析の途中状態で既にエラーと分かる物については
    _ble_syntax_attr に ATTR_ERR を設定している。
    これは _ble_highlight_layer_syntax1_table を経由して表示の着色に反映される。
    もう一つのエラーの種類は入力したコマンドラインの末端で入れ子が閉じていない物である。
    これは一番最後の文字と対応する入れ子の開始点の色を変更する事によって提示する。
    この着色は解析点より前に対して行われるので部分更新の対象とする事は難しい。
    従って _ble_highlight_layer_syntax3_table を介して、毎回全消去・再計算を実行している。

    以下に改善したい箇所について列挙する。

    - この様に複数の方法を用いてエラーを提示しているのは少し醜い。
      もう少し統一した枠組を作っても良いのではないかという気がする。

    - ATTR_ERR を用いて設定したエラーは、
      後の処理で追加される単語毎の着色によって上書きされてしまう。
      つまり、折角エラー通知の為に着色を設定していても使用者に見えない事がある。
      別の場所にエラーを登録しても良いのではないかという気がする。

    - 各エラー項目に対して何が問題なのか・何のエラーなのかのメッセージを設定したい。
      これらのメッセージも枠組の中で管理して、カーソルの位置に応じて表示できる様にしたい。

    もう少し現状について調べて実装の方法について考える。
    先ずエラー情報を記録する為の配列の形式について。
    既存のエラー着色に使っている配列 _ble_highlight_layer_syntax3_table が気になる。
    これを拡張する形で実装する事はできないだろうか。。
    →この配列は部分更新できないような情報を保持するのに使っている。
      部分更新できない様な着色であっても今回の実装によって
      よりましな方法に変更できるのではないか、という気もするが、
      それは今回の実装が終わってから考えれば良い事である。
      (初めからその様な物にも対応できる様に今回の実装を設計するという事も出来るが
      複雑になるので、取り敢えずは何も考えずに実装する事を目指す。)

    つまり、_ble_highlight_layer_syntax3_table は non local な着色の為に使うとして残し、
    それとは別にエラーを管理する為の配列を作成する。

    部分更新の際の効率を考えると _ble_syntax_attr と同様に、
    編集文字列中の位置を配列のインデックスとする方法が良さそうに思われる。
    然し一方で、エラーの数はそんなに沢山になるとは考えがたい (sparse) なので、
    リストにして管理するという方針も考えられる。どちらの方が良いだろうか。
    リストにしている場合、"エラー設置点 エラー開始点 エラー終了点 メッセージ" というデータ形式になるだろうか。
    shift や解析中断後の再開に際してはエラー設置点を用いた filtering を行う。
    % このエラー情報の内容は解析の動作に全く影響を与えないし、
    % 解析が同じように進めば全く同じエラー情報を生成すると期待できるので、
    % 解析中断の判断基準に含める必要はないと考えられる。
    →本当だろうか。エラー開始点・終了点などの情報は解析状態が同じになっても異なる値になりうるのでは?
      特に、現在 _ble_highlight_layer_syntax3_table で管理している物はその最たる例である。
      ここで、エラー開始点・終了点が正しく設定される為には次の条件が必要である。

      エラー設置点を p1 とする。ble-syntax/parse の 1 step で i=i1 から
      i=i2 まで進む (但し i1 <= p1 < i2) 時、エラー開始点 p2, 終了点 p3 は、
      i1 <= p2 < p3 < i2 を満たす。

      この条件が揃っている時のみに現状の解析中断条件で部分更新安全である。
      因みに p2, p3 を設置点からの相対位置で記録しておけば shift の操作が必要なくなるのでその様にするべきである。


2015-08-16

  * 入れ子構造を考慮に入れた効率的な単語着色

    現状: 新規生成単語及び消滅単語の範囲 (range1) に関して再度単語の着色を実行する。

    x 但し、着色は "消滅単語の存在していた範囲" 及び "新規生成単語登録位置の範囲"
      に登録されている単語及びその子孫だけになっている。
      本来は、range1 に被さっている全ての単語について処理を実行するべきである。

    - 考慮に入れるべき事として、将来的に解析を途中で停止した場合でもそれなりに動くような方法がよい。
      しかしながら未だ解析を終えていない部分については結局どうしようもないから、
      解析が完了している部分文字列について木構造を作成して処理する事になるだろう。
      結局、現在 shift を実行するのに用いているのと同じ事をする事になる。
      (そしてそれは tree-enumerate/.initialize で実装されているので余り気にする事はない。)

    方法

    a 一つの方法は tree-enumerate を使用して末端から順に単語の範囲をチェックしていく方法である。
      つまり、現状の shift の実装と同じになっている。

    b もう一つの方法は、先に単語の木構造の情報だけ構築してから、
      range1 に対応するノードを列挙して構築する方法である。
      木構造として親ノードの位置・子ノードの配列を保持していれば、
      指定した範囲に対応するノードの範囲を効率的に計算する事が出来る。

      ただし、木構造の情報の構築自体にどれだけのコストがかかるかについて考える必要がある。
      木構造は後ろから掘り出すようにして実行する為、
      更新範囲の beg から文字列の末端 iN 迄を完全に構築し直す必要がある。
      部分更新するというのが難しいと思われる。

      しかし、部分更新は全くできないのでは等と考えていたが、
      考えてみると意外と部分更新も出来るのではないかという気になってくる。
      更新範囲に含まれていないノードの内部構造に関しては実は更新の対象ではない。
      また、更新範囲より前にあるノードの内部構造についても同様である。
      但し、親ノードの位置は、更新範囲より前にあるノードであっても更新する必要がある。

    c 或いは、parse の過程でより分かり易い木構造データも同時に構築してしまうという手もある。

      x parse の内部状態を増やせば増やす程、解析中断が難しくなるが
        最終的に構造を再構築するのであれば結局中断してもしなくても同じかも知れない…?
        しかしながら木構造を考えずに parse した後、木構造に対する更新を行った方が処理量は少なくなるはずである。
        というのも木構造を考えながら parse する事にすると、
        更新の必要のない文法的処理も木構造の構築と同時に実行してしまうからである。
        それよりは、文法的処理で必要最低限の所を parse で処理して、
        木構造の構築について必要最低限の所を後の処理で実行する、という形の方が良さそうである。

      o ただ、parse の過程で木構造も一緒に構築するようにした方が、
        データ同士の依存関係が整理されて良いという側面もある。
        parse の後で木構造としてどの範囲を更新するべきかを決定するのは面倒でありバグを生む原因にも成る。
        →parse の後で処理をする際にも何らかの "原則" を決めてその下で実装するなどした方が良いと思う。
        (逆に言えば上手に原則を決める事さえ出来れば、parse で木構造を構築する事の利点はなくなる。)


    入れ子構造の実装後に改善できる箇所
    - tree-enumerate-in-range 及びその呼出元
      現在は愚直に範囲内に設置されている単語識別子を

2015-08-15

  * syntax: `function ...' において関数名の部分に使用した履歴展開を解釈する?
    履歴展開だけを解釈する新しい文脈が必要になると思われる。

    然し乍ら、履歴展開の結果として複数の単語になる場合などを考えると、
    そもそも一つの単語として読み取って良いのかなど疑問点が残る。

    % 或いは、その場で履歴展開としての妥当性を検証して色をつけてしまうという手もある?
    % →これだと正しく解釈されない。例えば履歴展開には $ が含まれて良いが関数名には $ が含まれないので、
    %   先に関数名としての切り出しを実行すると $ の直前で不正に関数名が中断する事になる。

2015-08-14

  * 高速化: ble-syntax/parse: より厳密な shift 範囲の特定・省略?
  * 高速化: $(type -t), $(printf), $(jobs) をファイル書き出し・read読み出しに変更する

    $() を read で実行する為の関数 ble/util/assign を作成した。
    cygwin 環境で特に遅くなる原因と思われる部分についてはこれに置き換えた。

2015-08-11

  * history コマンドで操作を実行したときにそれが ble の履歴情報に反映されない。

    history コマンド自体を上書きするなどするとまたややこしいことになるので、
    ble-history 等のコマンドを用意してそちらを使ってもらうようにした方がよい。

    或いは、もっと interactive に history 操作を実行できるようにしたい所である。

  * 今後必要になる大きな書換・再実装は2つある:
    1 コマンドライン着色の効率的方法の模索
    > 2 shift の高速化の為の _ble_syntax_word, etc. のデータ構造の変更

2015-06-28

  * complete: 沢山の補完候補が存在する時に表示する内容を絞る

  * color: --prefix=filename の filename 部分
  * color: PATH=filename の filename の部分

    単語に対して部分的な着色をする場合、現在の単語毎の着色ではない方法を考えるべき。

2015-03-06

  * 整理
    - 着色の古いコード
      これに関しては現在の複雑な実装と昔の簡単な実装の間の着地点を見つけたい。

2015-03-04

  * 88colors の時の palette について

    16-79 4x4x4 0,58*v+81
    80-87 gray 46+25*v

2015-03-01

  * ble-edit: ble-bind -xf 対応

  * ble-edit: bind 模倣?

    bind -x や bind の機能を実装し、
    更に bind 関数を上書きしてその動作を模倣するという事?

  * ble-edit: 対応する物がない readline 関数

    > history-expand-line magic-space
    > delete-horizontal-space
    history-search-forward/backward
    yank-nth-arg yank-last-arg insert-last-argument
    shell-expand-line alias-expand-line
    tilde-expand history-and-alias-expand-line
    edit-and-execute-command
    transpose-words upcase-word downcase-word capitalize-word
    kill-whole-line
    yank-pop これはkill-ringを正しく実装する必要がある
    digit-argument universal-argument 入力しやすい様に?
    complete関連
    redo, undo

2015-02-27

  * complete

    - 文脈判定を強化する。他にも色々な箇所で補完を実行する。

    - 引用符の中で補完を実行する方法?
      引用符の途中でも正規な単語として認識できる様にする。
      引用符の中であるという情報が必要。

2015-02-24

  * ble-syntax-highlight+* の代替機能の実装と廃止

  * layer の仕組みに対する問題提起

    | 現在の実装では各レイヤーは下のレイヤーが提供した文字配列を弄る事によって動作している。
    | しかし、実の所受け継ぐのは文字配列ではなくて描画属性の配列の方が良いのではないだろうか。
    |
    | o 先ず第一に実装の簡便さがある。
    |
    | o 次に、更新範囲というのは複数のレイヤーで似たような箇所になりがちなのではないかと思う。
    |   属性の配列で渡して置いてから一番最後の所で更新範囲に対して切り貼りをして文字配列を構築した方が良いかも知れない。
    |
    | x ただ、文字配列にするという事の利点も存在する。
    |   region 等の様に大域的に色を一時的に変更する様な物の場合、
    |   文字配列として region の下層にあるレイヤーについて記録を行っておく事は有意である。
    |   選択が解除された時に再び構築し直すというのは時間が掛かる。
    |
    |   但し、その様な動作をする物は限られている様にも思われる。
    |   殆どの場合には纏まった箇所でコンパクトに更新が行われる。
    |
    | x 括弧の対応などの場合、まとめて描画属性から文字列を構築する場合に細かい最適化が出来ない。
    |
    |   複数のレイヤーの描画属性の配列からまとめて文字列を生成する場合、
    |   複数のレイヤーが報告した更新範囲を総合してその範囲で文字列を再生成する事になる。
    |   しかし、括弧の対応など、実際の変更が小規模に渡るにも拘わらず、
    |   離れた二点で実施される色付けの場合には、変更の実体に反して範囲が拡大する。
    |
    |   今迄の様に文字列を各層で構築する方式の場合には、
    |   更新を各層の関数の中で自由に行う事ができるので、
    |   自身の変更の update に関しては最適な方法で更新する事ができる。
    |
    |   とはいいつつも更に上のレイヤーに渡す更新範囲はやはり巨大な物になる為、
    |   上のレイヤーでの合成作業が大域に渡る事は考えておかなければならない。
    |   実のところ合成作業についてはちゃんと実装していない。
    |   region に関しては可能な限り最適な方法になる様に実装したが滅茶苦茶複雑になった。
    |   実際の実装では被覆によって隠される更新などについては考慮に入れなくても良いが、
    |   複雑になりそうだという事に代わりはない。
    |   結局、内部的に描画属性の配列を持って更新に望まなければならないという事態になりそうだ。
    |
    | 何れにしても現在の実装は、今後拡張していく上で非現実的な感じがする。
    | ベースを (下層の情報を含まない) 描画属性の配列を上流に渡す方法に変更した方が良いのではと思う。
    | region 等の実装の際には cache を行う様にする等の工夫をその上で実装する様にしてみたい。
    |
    | また、実装が複雑になるが仕様がない。
    | 取り敢えず現在の所まともに着色を行っている所が syntax だけなので、
    | これを ble-highlight-layer:syntax に対応する上で考えてみる。
    |
    | ble-highlight-layer:syntax の内部で三つの描画属性の配列を用意し、
    | これらの三つの描画属性の配列を総合する事で文字列を構築する様にしてみた。
    | 可もなく不可もない感じの実装である。
    | 少なくとも各層で文字列を構築する様な実装はしたくない。
    | これぐらいが丁度良い実装の複雑さである様に思う。

    将来的には描画属性の配列で対応できる様にする。

2015-02-23

  * bleopt_suppress_bash_output 制限

    - SIGWINCH (ウィンドウサイズ変更) の時に bash の表示する物になってしまう

  * complete

    TAB を打たなくても補完候補がある場合は薄く表示する?

    重くなるといけないので read -t 0 で確認しつつ処理を行うのが良い。

    実際に未だ入力されていない物を上に重ねて表示する場合、また新しい枠組が必要になる気がする。

    a 一つの簡単な方法は「編集文字列を本当に書き換えてしまう」方法である。
      しかし編集文字列を書き換えている状態で別のコマンドが起動されるなどすると
      編集文字列内容に齟齬が生じて面倒な事になる。それを防ぐ為に新しいコマンドが来るたびに
      編集文字列の内容を復元するようにトラップをしかけるのも綺麗でない。
      その他の理由でトラップをしかけたくなった時などに結局齟齬が生じる可能性が残る。

      この方法は現実的でない。

    b もう一つの方法は上に重ねる事のできる「レイヤー」の概念を導入する方法である。

      レイヤーを導入する場合、描画ルーチンが面倒な事になる。

      b.1 既存の描画ルーチンを活かす方向で行くと、
        一旦一番下のレイヤーを描画した後でその上にあるレイヤーの描画をつづけて行えばよい。
        しかしこれだとちらつきが気になる。

      b.2 もう一つの方法は描画を完全に座標指定で行う事にして、
        あるレイヤーを描画する際にはマスクを考慮して描画できる様にする。

        うーん。わざわざ座標指定で描画を行える様にしなくても、
        既存の描画関数の内部を適当に書き換えるだけで行けそうな気もしないでもない。
        要するにマスクされた領域の上にある文字については、文字を出力する代わりに
        位置だけを更新して、最初にマスクされていない領域の文字を書き込もうとした瞬間に、
        その位置へ移動するシーケンスを生成する様にしたらよい。

        ただこの時に問題なのはどの様にしてマスクされた領域を表現するかである。
        領域の上に複雑にレイヤーが存在している場合、領域に沢山の矩形の穴が空いた状態になる。
        この様なマスクがある場合マスクの上にあるかどうかの判定は物凄く重い計算になる。

        やはり描画可能領域は矩形に制限して、上に重なっている別のレイヤーに関しては
        上から重ねて描画してしまうという手を取った方法の方が良いのではないかという気がする。


      b.3 或いは内部に完全に画面のバッファを保存してしまうという手もある。
        そして最後に更新された部分だけ反映させるという方法である。

        o この方法だとサブウィンドウを作成したりする事ができて汎用性が高い。
          何れはこの方法を採らなければならなくなるのではと言う気がする。

        x 特に各座標位置について描画属性などを保存する事になるだろう。
          しかしメモリを食うのではないかなどの懸念も残る。

        x また描画用のシーケンスの生成にも処理時間が掛かりそうな気がする。
          何しろ記録した配列の要素をスキャンしてシーケンスを構築していかなければならないからである。
          或いは現在の編集文字列の記録と同様に配列に描画シーケンスも含めて記録しておいて、
          其処から特定の範囲の要素だけ単純に join して出力できるようにするか。


  * 描画ちらつき: DCH や ICH 等を用いた効率化?

  * bind の上書き

    未だ時期尚早である。先ず、readline の function を一通り実装しなければならない (expand 系が大変)。
    また、bind にある様々なオプションとそれらを組み合わせて使った時の振る舞いについて整理しなければならない。

    一応将来的な実装の為に、既存の bind の呼出に一通り builtin をつけた。

2015-02-21

  * zsh にある機能で気になる物

    menu 補完と言った物もあるようだ。
      選択肢の説明の表示もできる。
      考えつきそうな機能は一通り揃っているという事か。

    /a/b/c 等に対してディレクトリ名の補間も行う
      でも、これはやった後で一意に補完できない事が分かった場合が悲しい。
      TAB を打つ回数が多少減るだけで何が嬉しいのか分からない。
      しかしながら、曖昧一致による補完機能はあった方が便利な気がする。
      ただ、候補を表示するに留め、無断で補完する事はやめる。

2015-02-18

  * エラーメッセージの設定を可能にする

2015-02-16

  * syntax: ToDo

    - [[ 条件式の文法。より正確に。特に括弧の入れ子。

      →括弧の入れ子というのはどういう意味であったか?
      今試してみた所括弧の入れ子などは関係なく ]] が来れば条件コマンドは終了とみなされる様である。
      例えば $ [[ ( [[ == ]] ) ]] は構文エラーになる。初めの ]] で条件コマンドが終了と解釈される為である。

    - ${ ... } 内の文法チェック
      - extglob (但し '}' で強制終了する必要がある。
          一旦全て読み取ってから後付けで着色する?)

2013-06-10

  * ble-bind キーボードマクロの定義に対応

    2017-09-10 ble-decode.sh: キーボードマクロのためには _ble_decode_key__hook と似ているが、

    1. 一回限りではなくて恒久的に処理する
    2. 既定の処理も行う
    3. 複数の物を登録して管理できる

    ような仕組みを取り付ける必要がある (3. に関しては不要かもしれない)。

  * bel-bind 以下の同値なキーに対する処理?
    + DEL を BS にマップする
    + C-_ を C-BS にマップする
    + C-m を RET にマップする
    + C-i を TAB にマップする
    + M-大文字 を M-S-小文字 にマップする? → これは CapsLock に依存するので止めておく
    + DEL の bind している物を BS から bind する。
    + C-_ の bind している物を C-BS から bind する。

  * sword で quote を正しく処理する?

    これは少なくとも解析器が出来た後に考える。

2013-06-06

  * complete: 入力する側から候補を表示?
  * complete: 候補一覧の整列

  * ble-line-info の描画のタイミングを ble-edit-draw.update と同じ時にする?
    それ以外の時に描画したければ、必要に応じてその場で明示的に描画させる。

2013-06-05

  * bashfc
  * RPS1

    zsh で試してみた所、そもそも RPS1 に改行を含めると RPS1 自体表示されない事が分かった。
    改行は含まれていないと仮定して表示してしまっても良いのかも知れない(2015-03-04)。

2013-06-04

  * 説明書:
    + 問題点: 既存の bind を上書きする事
    + 問題点: 既存の trap を上書きする事
    →これらは説明書にその様に書いておけば問題ない

2013-06-01 以前

  * vbell
    + スタイルを指定できる様にする
    + 位置を指定できる様にする
    + メッセージが長い場合に適度に長さを制限する

  * ble-decode
    + [kbd] terminfo からの読み取り (entry 名は tmux が参考になる)
    + ble-bind: -x オプションに対する対応: BLE_LINE, BLE_POINT, 再描画
    * ble-bind: -s オプションで文字入力の羅列を指定できる様にする。

  * デフォルトで bind されている readline 関数の一覧をチェック
  compgen, history コマンドを関数内から自由に利用する事が出来るか

  * 説明書
    + 文字コード decoder の追加方法
    + keysequence を指定する文字列の文法
    + スタイルを指定する文字列の文法

  * 問題点
    + コマンドが完結していない状態で accept-line すると
      既定の動作では続きを入力する事が出来るが、
      eval をすると単にエラーになってしまう。

      →これは寧ろこの様な動作の方が分かりやすいかも知れない。
        取り敢えずそういう仕様と言う事にする。


*******************************************************************************
    ChangeLog
-------------------------------------------------------------------------------

  新機能
  - vi-mode: nmap `u` `<C-r>` `U` `#D0644`
  - edit: 絵文字の文字幅 `bleopt emoji_width=2` `#D0645`
  - vi-mode: nmap/xmap `f1` で `command-help` 呼び出し

  動作修正
  - vi-mode (nmap/xmap/omap `<paste>`): 引数を無視するように変更

  ToDo
  - vi-mode (nmap `/` `?` `n` `N`): 検索開始位置が `vim` のそれと異なる
  - vi-mode (nmap `+` `_` `g_`): 最終行付近での振る舞いが `vim` のそれと異なる

2017-12-03

  新機能
  - edit, vi-mode: bracketed paste mode に対応 `#D0639`

  動作修正
  - core: 端末の状態設定・復元とカーソル形状の内部管理 `#D0638`
    - 外部コマンドを呼び出すときに既定のカーソル形状にする
    - 外部コマンドから戻ったときにカーソル形状を復元する
  - syntax (extract-command): より下の構文階層にいてもコマンドを見つけられるように修正 `#D0635`
    これによりリダイレクトの単語などの上でも `command-help` (nmap `K`, emacs `f1`) が動くように。
  - syntax (チルダ展開): 変数代入の形式を持つ通常単語内部でのチルダ展開に対応 `#D0636`
  - syntax: [...] 内部でチルダ展開が起こったとき [...] は意味を失う `#D0637`
  - vi-mode (cmap `<C-w>`): imap `<C-w>` と同様に vim の動きに変更

  バグ修正
  - complete: 補完候補がない時に空文字列で確定するバグの修正 `#D0631`
  - complete, highlight: `failglob` 周りのバグの修正 (3) `#D0633` `#D0634`
  - vi-mode: `ret` グローバル変数が汚染されていたバグの修正 `#D0632`
  - highlight: 読み取り専用の変数名を入力するとエラーメッセージが出るバグの修正
  - decode: `__defchar__` から呼び出された widget が 125 を返したとき
    `__default__` から呼び出された widget にキー列が渡されないバグの修正
  - core: set -u にすると全く動かないバグの修正 `#D0642`
  - edit: ble.sh ロード中に `read -e` が動かないバグの修正 `#D0643`

2017-11-26

  バグ修正
  - general: failglob で問題が生じるバグの修正 `#D0630`
  - keymap/vi (nmap q): bash-3.0 で動かなかったバグの修正
  - keymap/vi (cmap): C-d で終了してしまうバグを修正 `#D0629`
  - edit (ble/widget/command-help): エイリアスの上でヘルプを実行しようとすると無限ループになるバグを修正
  - edit (ble/util/type): "-" で始まる名前のコマンドの種類の判定に失敗し着色されなかったバグの修正
  - complete: 変数代入の右辺やリダイレクト先で補完できないことがあるバグの修正 `#D0627`
  - complete: 補完する単語にパラメータ展開が含まれるとき ble.sh のローカル変数の値を参照している問題の修正 `#D0628`

  動作変更
  - bind/decode: 孤立 ESC の読み取り方法を変更。<C-q><C-[> で単体 <C-[> が入力されるように修正
  - bind/decode: input_encoding=C の時の孤立 ESC および C-@ の読み取りに対応
  - complate: 重複して列挙される候補を統合する `#D0606`
  - complete: 厳密一致するディレクトリ名が何故かコマンド候補に現れる問題の修正 `#D0608`
  - edit (command-help): 幾つかの組み込みコマンド・予約語について man bash の正しい位置に移動するように修正 `#D0609`
  - edit (command-help): クォートなどを除去してからコマンドのヘルプを探索するように変更 `#D0610`
  - core: 条件コマンドの比較で右辺をクォートし忘れていた箇所を修正 `#D0618`
  - highlight: `shopt -s failglob` の時、失敗する単語にエラー着色をする `#D0630`

  構文解析変更
  - syntax: `> a.txt; echo` は構文エラーではないことに対応 `#D0591`
  - syntax: 変数代入・リダイレクトの後では予約語は意味を失いコマンドとして扱われることに対応 `#D0592`
  - syntax: `time` や `time -p` は構文的に正しいことに対応 `#D0593`
  - syntax: `echo $(echo > )` などの `>` の引数がない構文エラーにより `$()` が閉じず別の構文エラーを引き起こしていたのを抑制 `#D0601`
  - syntax: `function hello (())` は bash-4.2 未満では構文エラーとして扱うように変更 `#D0603`
  - syntax: `time -p -- command` を独立した文脈で解析するように変更 `#D0604`
    - complete: これにより `time` の引数のコマンド補完ができなかった問題は解消した `#D0605`
  - syntax: extglob 内部のプロセス置換 `@(<(echo))` に対応 `#D0611`
  - syntax: `[...]` によるパターンの解析に対応 `#D0612`
  - syntax: 変数代入の右辺にある不活性になった extglob の入れ子 `@(@())` も不活性にする `#D0613`
  - syntax: `shopt -u extglob` の時でも `*` や `?` を着色する `#D0616`
  - syntax: ブレース展開の着色に対応 `#D0622`
  - syntax: チルダ展開の着色に対応 `#D0626`
  - syntax: `for var in args...` の `args` におけるリダイレクトの禁止 `#D0623`
  - highlight: ヒアストリングの場合はパス名展開・ブレース展開を行わない `#D0624`
  - highlight: リダイレクト先ファイル名が複数語に展開されたらエラー着色 `#D0625`

  構文解析修正
  - syntax: `$({ echo; })` や `$(while false; do :; done)` において `}`, `done` 等の後にコマンドがないと構文エラーになっていたバグの修正 `#D0593`
  - syntax: `-` で始まる名前のコマンド・関数名が正しく着色されないバグの修正 `#D0595`
  - syntax: `if :; then :; fi $(echo)` などの構文エラー着色が実行されないバグの修正 `#D0597`
  - syntax: 先読みによる不整合が起こるバグの修正・先読みの枠組みの整備 `#D0601`
    - プロセス置換周りで部分更新により不整合が生じるバグを修正
    - `function hello (())` としておいて `) (` を挿入して `function hello () (())` にすると不整合が生じるバグを修正 `#D0602`
  - syntax: 途中で `shopt -u extglob` にしても `_ble_syntax_bashc` が更新されないバグの修正 `#D0615`

2017-11-09

  新機能
  - vi-mode (nmap): `*` `#` `qx...q` `@x`
  - vi-mode (cmap): 履歴
  - core: bleopt 変数 `pager` (既定値 `''`) に対応。`ble.sh` の使うページャとして `${bleopt_pager:-${PAGER:-適当に探索}}` を使用する。
  - vi-mode (nmap `K`): `ble/cmdinfo/help:$cmd`, `ble/cmdinfo/help` に対応。

  バグ修正
  - vi-mode (cmap `<C-[>`): コマンドラインモードをキャンセルするキーマップが `bell` で上書きされていたバグの修正
  - decode: `shopt -s failglob`, `shopt -s nullglob` で `unset` が正しく動かないバグの修正
  - vi-mode (nmap `K`): `MANOPT=-a` で操作できなくなるバグの修正

  動作変更
  - edit (`ble/widget/command-help`), vi-mode (nmap `K`): カーソル位置のコマンドの `man` を表示するように変更
  - base: キャッシュディレクトリ・一時ディレクトリの決定で、それぞれ `XDG_CACHE_HOME`, `XDG_RUNTIME_DIR` を参照するように変更
  - Makefile: インストール先ディレクトリで、`XDG_DATA_DIR` を参照するように変更
  - isearch: 実際に必要になるまでコマンド履歴のロードを遅延するように変更
  - vi-mode (nmap `K`): 組み込みコマンド・キーワードは `man bash` を表示する。
  - vi-mode (nmap `K`): シェル関数は関数定義を表示する。

2017-11-05

  新機能
  - vi-mode (exclusive motion): `:help exclusive-linewise` 特別規則 (exclusive -> inclusive, exclusive -> linewise) に対応
  - vi-mode (omap): `C-c` `C-[` で明示的にキャンセル
  - vi-mode: keymap/vi_test.sh 追加。regression が酷いので vi-mode の動作テストを自動化
  - complete: bleopt 変数 `complete_stdin_frequency` (既定値 `50`) 追加

  動作変更
  - vi-mode (nmap `e`, `E`): 移動先が最終行の最後の文字の空白のとき、omap なら bell を鳴らさないように変更
  - vi-mode (omap/xmap `<space>`, `<back>`, `<C-h>`): 改行の数え方を変更
  - vi-mode (nmap `cw`, `cW`): 単語の最後の文字、および空白の上にいるときの振る舞いの変更
  - decode (ble-bind): `ble-bind -D` でキーマップの内部状態も出力するように変更
  - term: `_ble_term_SS` の既定値を空文字列に変更
  - complete: `shopt -s no_empty_cmd_completion` では補完を (コマンドの補完以外も) 全く行わないように変更
  - edit (ble/widget/exit): 編集中の文字列が残っているとき、灰色で再描画してから exit するように変更

2017-11-03

  破壊的変更
  - vi-mode (widget): 名称変更 blw/widget/vi-insert/* → ble/widget/vi_imap/*
  - vi-mode (bleopt 変数): 名称変更 bleopt keymap_vi_normal_mode_name → keymap_vi_nmap_name
  - vi-mode (imap): vi-insert/magic-space 廃止。代わりに magic-space を直接用いる。

  新機能
  - vi-mode (xmap): `o` `O`
  - vi-mode (nmap): `.` 取り敢えず完成?
  - vi-mode (xmap/nmap): `gv`

  バグ修正
  - vi-mode (mark `` `x `` `'x`): オペレータが呼び出されないバグの修正
  - vi-mode (txtobj `[ia]w`): 英数字と _ の連続ではなく英字と _ だけの連続を単語としていたバグの修正
  - vi-mode (imap): `{count}i...<C-[>` において `<C-q>x` `<C-v>x` が正しく繰り返されなかったバグの修正
  - vi-mode (imap): `{count}i...<C-c>` において繰り返しが有効になっていたバグの修正
  - vi-mode (nmap `{N}%`): 目的の行に移動しなくなっていたバグの修正
  - vi-mode (nmap `_`): `d_` 及び `d1_` が linewise になっていないバグの修正
  - vi-mode (xmap `I` `A`): 動かなくなっていたバグの修正
  - vi-mode (xmap `I` `A`): 実行後のカーソル位置がずれていたバグの修正
  - vi-mode (xmap `I` `A` `c` `s` `C`): 矩形挿入の後の編集範囲 `` `[`] `` から1行目が抜けているバグの修正
  - vi-mode (xmap `?`): 検索 `?` が operator `g?` になっているバグの修正
  - vi-mode (xmap `/` `?` `n` `N`): ビジュアルモードの選択範囲が検索の一致範囲で上書きされるバグの修正
  - vi-mode (xmap `/` `?` `n` `N`): 現在の履歴項目の中で一致しない時、別の履歴項目にビジュアルモードのまま移動するバグの修正
  - lib/vim-surround (nmap `cs` `cS`): nmap `.` 対応時に引数とレジスタが効かなくなっていたバグの修正
  - lib/vim-surround (xmap `S`): `v` によるビジュアルモードで改行が前後に挿入されていたバグの修正

  動作変更
  - vi-mode (imap `<C-w>`): vim の単語区切り (`w`) による削除に変更
  - vi-mode (nmap `[rRfFtT]x`): `<C-[>` でキャンセルするように変更
  - vi-mode (nmap `w` `b` `e` `ge`): 非英数字 ASCII の連続と、Unicode 文字の連続 をそれぞれ別の単語と扱うように変更
  - vi-mode (xmap `c` `s` `C`): `I`, `A` と同様の矩形挿入に対応

2017-10-30

  破壊的変更
  - vi-mode: キーマップの名称変更 vi_command -> vi_nmap, vi_insert -> vi_imap
  - vi-mode: 一部の widget の名称変更
    - ble/widget/{no,}marked -> ble/widget/@{no,}marked
    - ble/widget/vi-command/* (一部) -> ble/widget/vi_nmap/*
  - vi-mode: ble/widget/vi-insert/@norepeat 廃止。別の方法 (_ble_keymap_vi_imap_white_list) を用いる。

  新しい機能
  - vi-mode (nmap): . は実装途中 (現状 nmap/omap におけるオペレータ経由の変更のみ記録)
  - vi-mode (mode): bleopt 変数 `term_vi_[inoxc]map`
  - decode: 孤立 ESC のタイムアウトに対応
  - edit: shopt -s histverify, shopt -s histreedit に対応 #D0548

  バグ修正
  - vi-mode (xmap): `p`, `P` が正しく動作しないバグを修正
  - vi-mode (imap): 挿入モードに入るときに指定した引数 (繰り返し回数) が常にキャンセルされていたバグの修正
  - vi-mode (txtobj; nmap `gg`, `G`): レジスター指定が消失していたバグの修正
  - lib/vim-surround (nmap ds): 引数が内部使用のオペレータ `y`, `d` に正しく渡っていなかったバグの修正
  - prompt: `PROMPT_COMMAND` で設定された `PS1` が永続化されていなかったバグの修正
  - decode: bind -x で曖昧な登録があって bash_execute_unix_command エラーになっていた問題の修正 #D0545
  - decode: `vi.sh`, `emacs.sh` において `default.sh` が多重に呼び出されていた無駄の修正 #D0546
  - core: bash-3.0 において ble/util/assign が壊れていたバグの修正

  動作変更
  - vi-mode (nmap `x`, `<delete>`, `s`, `X`, `C`, `D`): support registers
  - source ble.sh において無事にロードされたときに終了ステータス 0 を返すことを保証
  - widget marked, nomarked を @marked, @nomarked に改名。元の widget は非推奨 (削除予定)
  - ble.sh: Linux 以外でも (`readlink -f` が動かないときも) シンボリックリンクを通したロードに対応 #D0544

2017-10-22

  新機能
  - vi-mode (mark): `mx` <code>`x</code> <code>'x</code> (`x` = <code>[][<>`'a-zA-Z"^.]</code>)
  - vi-mode (nmap): `gi` `<C-d>` (空文字列のとき exit) `"x` (registers)
  - vi-mode (xmap): `I` `A` `p` `P` `J` `gJ` `aw` `iw`
  - lib/vim-surround.sh: nmap `yS` `ySS` `ySs` `cS`, xmap `S` `gS`
  - タブ・インデントの制御
    - bleopt tab_width= (タブの表示幅)
    - bleopt indent_offset=4 (`>` や `<` のインデントの幅)
    - bleopt indent_tabs=1 (`>` や `<` のインデントにタブを用いるかどうか)
    - 既定のインデントの幅は 8 から 4 に変更

  バグ修正
  - vi-mode: 挿入モードに繰り返し回数を指定したとき `ESC ?` も一緒に繰り返されていたバグの修正
  - vi-mode: オペレータ `g?` が動かなくなっていたのを修正
  - vi-mode (nmap `/` `?`): 検索対象の入力中に `C-c` してもキャンセルされないバグの修正
  - vi-mode (xmap `r` (visual char/line)): 全体を置換したものが選択範囲に挿入されていたバグの修正
  - vi-mode (xmap `$`): 行末で `$` をしたときに表示が更新されないバグの修正
  - vi-mode (motion `0`): オペレータを認識していなかったバグを修正
  - isearch: 一度一致したら同じものに一致し続けるバグを前回の `/` `?` `n` `N` 対応の際に埋め込んでいたので修正
  - complete: `complete -F something -D` で登録されている補完関数が正しく実行されていなかったのを修正
  - prompt: PROMPT_COMMAND によって設定された PS1 を拾っていなかったバグを修正
  - textarea: 端末の下部で複数行編集時に `C-z` (`fz`) すると描画高さを正しく確保できていないバグの修正

  動作変更
  - vi-mode (operator `<` `>`): Visual block での正しい振る舞い
  - vi-mode (nmap `:` `/` `?`): 文字列入力中に空文字列で DEL or C-h することでキャンセルできるように修正
  - vi-mode (nmap `J`, `gJ`): 引数に対応
  - vi-mode (nmap `p`): 最後の行で挿入するときに余分な行が入らないように修正
  - vi-mode (xmap `Y` `D` `R`): 記録するビジュアルモードの種類を修正
  - lib/vim-surround.sh: タグ名入力中に '>' で確定するように修正
  - widget (.SHELL_COMMAND): 実行しないコマンドに色がついているのはややこしいのでグレーアウトする様に変更

  他の変更
  - magic-space: 空白を挿入してから履歴展開していた順番を逆転

2015-03-03
  * ble-edit.sh, ble-edit.color: discard-line の際に着色
  * ble-edit.sh, ble-core.sh, etc: echo を builtin echo に。
  * ble-edit.sh: bugfix, 複数行で上に行けない
  * ble-edit.sh: bugfix, 複数行なのに空行の accept-line でのずれ量が1行になっている
  * プロンプト再実装
    - ble-edit.sh (ble-edit/draw/trace): escape sequences が含まれている文字列の位置追跡。
    - ble-edit.sh (.ble-line-prompt/update): プロンプトの構築を再実装。$() がある場合なども正しい計算。
  * ble-complete.sh (source/command): shopt -s autocd の時にディレクトリ名も候補として列挙。
  * ble-complete.sh: 補完候補の選択の方法を変更。より近くの開始点の物を優先。

2015-03-01

  * ble-edit.sh: .ble-edit-draw.goto-xy, .ble-edit-draw.put 廃止
  * complete.sh: 関数名に / が入っていると compgen -c で列挙されないので、別に列挙する。

2015-02-28

  * 初期化の最適化
    - ble-decode.sh: ble-decode-kbd 書き直し、ble-bind 書き直し
    - ble-getopt.sh: 多少最適化
    - ble-decode.sh: bash-4.3 でも ESC [ を utf-8 2-byte code で受信する様に変更。
    - ble-decode.sh (.ble-decode-bind/generate-source-to-unbind-default): awk 呼出を一回に統合。
    - ble-decode.sh (.ble-decode-key.bind/unbind): [[ ]] による書き換え、bugfix。
    - ble-decode.sh, bind.sh: bind -x を生成する為のコードを bind.sh に分離。
    - ble-edit.sh, keymap.emacs.sh: keymap 初期化部分の分離、キャッシュ化。
    - ble-edit.sh: history 遅延ロード対応
  * ble-core.sh, ble-color.sh: .ble-shopt-extglob-push/pop/pop-all 廃止
  * ble-edit.sh: bugfix, .ble-line-info.clear で位置がずれる
  * ble-edit.sh: ble-edit/draw/put.il, ble-edit/draw/put.dl
  * ble-color.sh (ble-highlight-layer/update/shift): 長さが変わらない場合でも shift する。
  * ble.pp (include ble-getopt.sh): 現在使っている所がないので取り敢えず外す。
  * ble-syntax.sh (completion-context): 簡単なパラメータ展開に対する対応。

2015-02-27

  * <bug> TAB 等の変更文字があった場合に文字列が表示されなくなる
  * bash-3.0, 3.1 対応
    "<bug> bash-3.1 日本語の色付け・描画が変だ"
    - ble-edit.sh, 他: @bash-3.1 bashbug workaround, ${param//%d/x} などは効かないので %d を '' で囲む。
    - ble-syntax.sh, 他: @bash-3.1 bashbug workaround, x${#arr[n]} はバイト数を返す様なので一旦通常変数に入れて ${#var} とする。
    - *.sh: @bash-3.0: += 演算子の置き換え、配列宣言の修正。
    - term.sh: @bash-3.0: bashbug workaround, declare -p で出力すると誤った物になる。
  * ble-edit.sh (.ble-line-text/update/slice): bugfix, 変更文字がある時にもう存在しないローカル変数を参照していた。
  * ble-core.sh: ble-load, ble-autoload
  * complete.sh:, ble-syntax.sh, ble-edit.sh: 文脈依存補完の実装

2015-02-26

  * ble-syntax.sh: a+=( a=( に対応

2015-02-25

  * ble/term.sh: TERM 依存の部分を分離。キャッシュ化。完全移行ではないが徐々に。
  * ble-decode.sh:
    - <bug> $_ble_base/cache の代わりに $_ble_bash/cache を作成していた
    - <bug> accept-single-line-or-newline が二回目以降常に accept
  * ble-edit.sh:
    - <bug> 複数行の編集時に履歴移動をすると表示が乱れる
    - printf %()T を用いた実装の導入、PS1 \D{...} に対応
    - <bug> 表示の属性の更新がうまく行かない事がある。
    - <bug> 編集文字列の行数が変わった時に info.draw の内容がずれる
  * カーソル移動
    - ble-edit: 複数行編集と項目内でのカーソル移動に対応
    - ble-edit.sh: 複数行コマンドの履歴に対応。
  * ble-syntax.sh: ble-syntax-highlight+syntax を ble-highlight-layer:syntax に書き換え
  * ble-syntax.sh:
    - 関数定義 func() の形式に対応、
    - 条件式 [[ ... ]] と配列初期化子内の文脈に対応。
    - コメントに対応。
    - $[...] の形式に対応 (何故か bash の説明には一切載っていないが使える)。
    - <bug> invalid nest " $()" の先頭に for を挿入した時

2015-02-24

  * ble-edit.sh 出力の部分更新に対応 (描画ちらつき対策)
  * ble-syntax.sh: _ble_syntax_word, _ble_syntax_stat の形式の変更
  * ble-syntax.sh: 今迄行っていた dirty-range 拡大の方法を止めて、単に stat の削除を行う。
  * ble-syntax.sh: 及び上記の変更に伴う数々の bugfix
    - <bug> 文字削除時 invalid nest の assertion に引っかかる。
    - <bug> 編集内容が零文字になった瞬間に改行が起こって表示が消える。
    - <bug> 改行しても先頭がコマンドになっていない
    - <bug> _ble_region_highlight_table で空欄になっている箇所がある。
    - <bug> 単語の属性適用が後ろに続く単語にも続いている。
    - <bug> _ble_syntax_attr の中に "BLE_ATTR_ERR" の文字列が混入している。
    - 残っている dirty 拡大と _ble_syntax_word[] の廃止された形式に対する処理の
      コメントアウトされた部分を削除。dirty 拡大の変更に伴う効率化の確認と、
      shift が遅いという事の ToDo 項目の追加。
  * ble-decode.sh: <bug> $_ble_base/cache の代わりに $_ble_bash/cache を作成していた
  * ble-edit.sh: ble-edit+delete-backward-xword の類の動作を変更。

2015-02-23

  * ble-core.sh: ble-stackdump, ble-assert
  * <bug> update-positions で dend-dbeg が負になると警告が出る
  * <bug> info.draw で特殊文字が改行に跨っている時の座標計算

2015-02-22

  * ble-edit.sh: <bug> .ble-line-info.draw を使った時行がずれる
  * ble-syntax.sh: <bug> for や do に色が着かない?
  * レイヤー化
    - ble-color.sh: レイヤーの仕組み、レイヤ region, adapter, plain + RandomColor
    - ble-edit.sh: レイヤーに対応した表示文字列構築関数。古い構築関数の削除。出力関数の変更。
    - ble-syntax.sh: 多少の変更。

2015-02-21

  * 描画の高速化
    - ble-syntax.sh: 属性値の変更範囲に応じて適用を行い、変更範囲を LAYER_MIN, LAYER_MAX に返す様に。
    - ble-edit.sh: 表示用の文字列の構築部分を書き直して部分更新に対応。
    - ble-syntax.sh: 内容に変化のあった word の範囲も記録する様に変更。
    - ble-syntax.sh (parse): _ble_syntax_attr_umin (属性値の変更範囲),
      _ble_syntax_word_umin (word の変更範囲) の累積に対応する為に、これらについても shift を実行する。

2015-02-20

  * ble-decode.sh: bind 周り
    - bash-4.3 C-@ を utf-8 2-byte code で受信する様に変更
    - bash-3.1 ESC [ を utf-8 2-byte code で受信する様に変更
    - bugfix, \C-\\ \C-_ \C-^ \C-] に bind できなくなっていた。
    - bind の version 分岐について整理。
    - 既存の bind を ESC に関係なく bind -r する。
  * ble-decode.sh: .ble-decode-key 部分一致探索の処理の再実装。変な動作だった。
  * ble-decode.sh: bugfix, 8bit 文字を正しく bind できていない。c2s で8bit文字が符号化されていた。
  * ble-syntax.sh: 履歴展開は $- に H がある時のみ有効に。
  * ble-syntax.sh: bugfix, bash-4.2 のバグの work around。配列を参照する算術式の書き換え。
  * ble-core.sh: c2s を bash の機能だけで実装できたので fallback を replace。
  * ble-core.sh: bash-4.0 で .ble-text.s2c を連想配列でメモ化
  * ble-edit.sh: bugfix, bash-4.0 で ret に予め特定の値が入っていると c2w に失敗する。
  * ble-edit.sh: bugfix, bind -x 直前のプロンプトの取り扱いは bash-4.0 では bash-3 系と同じ。
  * ble-edit.sh (.ble-line-text.construct 周り): lc lg を後で計算する様に変更。一区切り。一旦 commit する。

2015-02-19
  * ble-syntax.sh: 履歴展開に対応。
  * ble-decode.sh: bugfix, bind -X から bind -x を生成するコード。
    bind -X の出力する形式は再利用不可能な形式でエスケープされているのでこれを変換。
  * ble.pp, etc: noattach 引数に対応。ble-attach/ble-detach 関数の定義。detach の bugfix。
  * ble-edit.sh: bug, bleopt_suppress_bash_output= にした時にプロンプトが二重になる

2015-02-18

  * ble.pp, ...: ディレクトリの構成を変更
  * ble-syntax.sh: 文法の対応
    - プロセス置換を単語として扱う様に変更
    - リダイレクトの後の引数に対応
    - リダイレクトの前の fd 部分に対応
  * bash-3.1 対応
    - ble-edit.sh: bash-3.1 で C-d を捕捉できる様に(結構無理のある方法だが)。
    - ble-edit.sh, ble-decode.sh: bugfix, bash-3 でカーソルキーの類が動かない。履歴が読み込まれていない。
    - ble-edis.sh: bash-3.1, bleopt_suppress_bash_output=1 の方が安定して動いているのでこちらで行く。
    - ble-edit.sh: bash-3.1, カーソルキーが効かない。例によって ESC [ ... に関係するコマンドで
      keymap が見付からないエラーになっている。これは ESC [ を CSI (utf-8) に変換してから読み取る事にした。
    - ble-syntax.sh: bash-3.2.48 のバグの work-around, (()) 内で配列要素を参照すると制御が無条件に其処に跳ぶ。

2015-02-17
  * ble-edit.sh (ble-edit/dirty-range): 範囲更新の仕組みを追加。
      _ble_edit_dirty はプロンプト再描画の判定も兼ねているので取り敢えず残す。
  * ble-edit.sh: 変数リーク (グローバル変数の汚染) の修正。line i
  * ble-syntax.sh (ctx-command/check-word-end): 単語終了判定の処理タイミングを変更。
  * ble-syntax.sh: context の追加。CTX_CMDXF CTX_CMDX1 CTX_CMDXV CTX_ARGX0
    より正確な文脈判定・エラー検知。
  * ble-syntax.sh: 他にも多くの修正がある。未だ修正が続きそうなので一旦 commit する。

  * ble-edit.sh (accept-line): bug, - で始まるコマンドを実行できない。
  * ble-color.sh: <bug> bg=black を設定しても反映されない。
    "未設定" と "黒" を区別する様に修正。
  * ble-syntax (ble-syntax-highlight+syntax): 入れ子エラーの色の範囲
  * ble-syntax: m, ;& は ;; ;;& 等と同じ取り扱い
  * ble-syntax, etc: bash-3 正規表現対策。bash-3/4 の正規表現の違いに依存しない書き方に変更。

2015-02-16
  * ble-syntax.sh: bugfix, incremental に更新した時に word の長さが更新されない。
    _ble_syntax_word への格納の際に失敗していた。

2015-02-15
  * ble-synatax.sh: bash の文法に従った incremental な解析と色付け。

2015-02-14
  * ble-edit.sh (.ble-line-info.draw): 表示が遅いので修正。
    ASCII 文字は特別扱いする様に改良。劇的に速くなった。

2015-02-13
  * ble-edit.sh (keymap emacs): 既定の keymap に emacs の名を付与。
  * ble-edit.sh (accept-line.exec): bugfix, C-c で再帰呼び出しのループから抜けられない。
    trap DEBUG を用いて再帰呼び出しから抜けられる様に exec 周りを整理・実装し直し。
  * ble-edit.sh: オプション名の変更、各オプションの整理・説明の追加。
  * ble-edit.sh (.ble-edit/gexec): グローバルな文脈でコマンドを実行する仕組み。
    再帰呼出に対する C-c にも対応。bleopt_exec_type で実行の方法を切り替えられる様に。
    exec が従来の方法で gexec がこの新しい方法。

2015-02-12
  * ble-decode.sh: bugfix, exit 後に stty が壊れているのを修正
    これに伴って ble の detach 機能の実装も行った。
  * ble-decode.sh: bugfix, bash-4.3 で三文字以上のシーケンスが悉く聞かない。
    keymap が見付からないエラーになってしまうので全てのシーケンスについて bind -x する事にした。
  * ble-core.sh: bugfix, builtin printf \U.... の使えない環境で command printf fallback が働かない。
    printf のパスを修正。また ASCII に対しては printf は使わない様に変更。
  * ble-color.sh (ble-syntax-highlight+default):
    追加・修正。また選択範囲の反転を ble-syntax-highlight+region として実装し、それを呼び出す形に。
  * ble.pp: 起動時に interactive モードかどうかのチェックを行う様に。

2015-02-11
  * ble-edit.sh (_ble_edit_io_*): ちらつきを抑える為に stdout/stderr を切り替える事にした。
    ちらつくのは bash の既定の出力によって ble の表示がクリアされ、bash の表示したい物が表示されるから。
    これに対抗して ble は bash の出力の直後に上書き再描画して何とか表示していた。
    bash の既定の出力を抑える為に、exec で出力先を切り替える事にした。
    bash の出力はファイルに書き込まれる様にし向ける。出力先ファイルを逐次確認して、
    エラーが出力されていれば visible-bell で表示する事にした。
    bleopt_suppress_bash_output=1 の時にこの新しい方法を実験的に用いる。
    bleopt_suppress_bash_output= の時は従来のちらつく方法。

2015-02-10
  * ble-edit.sh (accept-line.exec): bash-4.3 で内部からグローバル変数を定義できる様に
    declare 及び typeset を上書きして -g オプションを指定する様に変更。
    また、これに関係する注意点を ble.htm に記述。
  * ble-edit.sh (history): ロードに時間が掛かるので最適化。
  * 全般: bugfix, 文字列分割で GLOBIGNORE='*' を設定していないとパス名展開されて危険
  * ble-color.sh (ble-syntax-highlight+default): より良い色づけ。
  * ble-edit.sh (accept-line.exec): ble-bind -cf で bind されたコマンドの実行コンテキストを変更。
    accept-line で実行されるのと同じコンテキストで実行する。
  * ble-edit.sh (keymap default): C-z M-z を fg に bind。

2015-02-09
  * git repos
  * ble-edit: bugfix, locate-xword マクロが展開されていなかった
  * ble-decode: bash-4.3 に対応する為に色々変更
    - bind 指定の場合分けを整理
    - bugfix, ESC ?, ESC [ ? に対して全て bind
    - bugfix, 場合によって全く bind -r できていない
      →"bind -sp | fgrep" が "バイナリ" という結果になる事がある様だ。
        fgrep に -a を指定する。
    - bugfix, 日本語が入力できない。8bit 文字が認識されない。
      →8bit 文字はエスケープシーケンスで bind に指定する様に変更。

2013-06-12
  * ble-edit: history-beginning, history-end, accept-and-next

2013-06-12
  * ble-edit:
    kill-forward-fword, kill-backward-fword, kill-fword,
    copy-forward-fword, copy-backward-fword, copy-fword,
    delete-forward-fword, delete-backward-fword, delete-fword,
    forward-fword, backward-fword
  * ble-edit: history-expand-line, display-shell-version

2013-06-10
  * ble-edit:
    kill-forward-uword, kill-backward-uword, kill-uword, kill-region-or-uword,
    copy-forward-uword, copy-backward-uword, copy-uword, copy-region-or-uword,
    forward-uword, backward-uword

  * ble-edit:
    delete-forward-uword, delete-backward-uword, delete-uword, delete-region-or-uword,
    delete-forward-sword, delete-backward-sword, delete-sword, delete-region-or-sword,
    delete-forward-cword, delete-backward-cword, delete-cword, delete-region-or-cword

  * ble-edit:
    以下の編集関数を廃止:
      delete-region-or-uword, kill-region-or-uword, copy-region-or-uword,
      delete-region-or-sword, kill-region-or-sword, copy-region-or-sword,
      delete-region-or-cword, kill-region-or-cword, copy-region-or-cword.
    代わりに以下の編集関数を用いる:
      delete-region-or type, kill-region-or type, copy-region-or type.

2013-06-09
  * ble-edit: kill-region, copy-region
  * ble-edit:
    kill-forward-sword, kill-backward-sword, kill-sword, kill-region-or-sword,
    copy-forward-sword, copy-backward-sword, copy-sword, copy-region-or-sword
  * ble-edit:
    kill-forward-cword, kill-backward-cword, kill-cword, kill-region-or-cword,
    copy-forward-cword, copy-backward-cword, copy-cword, copy-region-or-cword
  * ble-edit: forward-sword, backward-sword, forward-cword, backward-cword

2013-06-06
  * ble-edit-bind: 全ての文字・キーが入力可能に。
  * complete: 候補一覧の表示 (簡易版)
  * ble-color.sh: 色付け機能を highlight.sh から移植

2013-06-05
  * ble-edit: history-isearch-backward, history-isearch-forward,
    isearch/self-insert,
    isearch/next, isearch/forward, isearch/backward,
    isearch/exit, isearch/cancel, isearch/default,
    isearch/prev, isearch/accept
  * ble-edit: yank
  * ble-bind -d で今迄に bind した物を表示できる様に。
  * ble-edit: complete, 取り敢えずファイル名補完だけ
  * ble-edit: command-help

2013-06-04
  * ble-edit: discard-line, accept-line
  * ble-edit: history-prev, history-next
  * ble-edit: set-mark, kill-line, kill-backward-line, exchange-point-and-mark
  * ble-edit: clear-screen
  * ble-edit: transpose-chars
  * ble-edit: insert-string

2013-06-03
  * ble-edit: bell, self-insert, redraw-line,
  * ble-edit: delete-char, delete-backward-char, delete-char-or-exit,
    delete-forward-backward-char
  * ble-edit: forward-char, backward-char, end-of-line, beginning-of-line
  * ble-edit: quoted-insert
  * ble.sh: 取り敢えず簡単に文字列を入力できる程度までは完成

2013-06-02
  * ble-getopt.sh: bugfixes
  * ble-getopt.sh: 無事に完了した場合に OPTARGS を unset する様に変更
  * ble-decode-kbd, ble-decode-unkbd

2013-05-31
  * ble-getopt.sh: created
  * ble-decode: 大枠が完成

2013-05-30
  * highlight.sh: 取り敢えず簡単な色付け
  * ble.sh:

    -- 経緯 --
    highlight.sh の方針だと bash が表示する編集中の内容を消す事が出来ないし、
    カーソルの位置も bash が表示する物の場所を指している。
    色を付けて表示した物は、補助的に bash が表示する物の下に並べて表示する
    ぐらいしか方法がない。

    また readline 関数をスクリプトから呼び出す事が出来ないので、
    結局、色付けを更新したいタイミングで READLINE_LINE や READLINE_POINT の動作を
    スクリプトの側で全て模倣して再現しなければならない。
    READLINE_LINE, READLINE_POINT の bash の仕様が変な所為で、日本語など
    のマルチバイトで正しく処理する為に、色々と汚い事をしなければならない。

    以上の事から、文字列の編集などの操作からスクリプトの実行まで
    全部自分で好きな様に実装して bash readline の機能を全て上書きする事にした。
    その為に、スクリプトを新しく書き直す。zle を真似て ble (bash line editor)
    と名付ける。

    -- 方針としては --
    a. read -n 1 を用いて 1 文字ずつ標準入力から文字を取り出してそれを処理していく
    b. bash の bind で全ての文字に ble のバイト受信関数を繋げて、
       バイト列を受信しながら処理する。

    highlight.sh の延長線上で b. の方針にしたが、
    もしかすると a. の方針も可能かも知れない。

2013-05-29
  * highlight.sh: 作成


*******************************************************************************
    Done (実装ログ)
-------------------------------------------------------------------------------

2018-02-11

  * 2017-12-04 keymap/emacs: 引き数

    - done: ble/widget/insert-string

      取り敢えず clear-arg しているが、
      本当は繰り返し挿入にした方が良いのではないか。
      →繰り返し挿入にすることにした。対応した。

    - done: ble/widget/transpose-chars

      これはカーソルの左の文字を N 文字右に移動するという効果である。
      また引き数を指定しないとき、行末にいるならばその前の二文字を入れ替える。

    - done: ble/widget/delete-forward-char

    - done: ble/widget/delete-backward-char

    2018-02-10 暫く置いてしまったがリリースの機会を逸したので、
    またこれから少しずつ編集してきりの良いところでリリースする事にする。
    取り敢えず emacs mode における引き数の対応の途中で止まっていた。

    - done: kill-backward-logical-line の動作確認を行う。
      実際に動かしてみると動かない…と思ったら kill-backward-line なので、
      kill-backward-logical-line は実際には呼び出されていなかった。
      - ok: 引き数を指定しない場合は行頭までを消す。
      - ok: 正の引数 a を指定する場合は a 行前の行の行末まで消す。
      - ok: 引数 0 を指定した場合は現在行の行末まで消す。
        既に行末にいる時には何もしない (空文字列をコピーする)。
      - ok: 負の引数 -a を指定した場合は a 行後の行の行末まで消す。

    - done: 次に kill-forward-logical-line の動作確認も行う。
      - ok: 引数を指定しない場合は行末まで。
      - ok: 正の引数 a を指定した場合は a 行語の行頭まで消す。
      - ok: 0 を指定し場合は行頭までを消す。
        元から行頭にいる場合には何も変更せず空文字列をコピーする。
      - ok: 負の引数 -a を指定した場合は a 行前の行頭まで消す。

    - done: kill-forward-logical-line.impl が実装の途中である。
      先ず仕様を明確にする必要がある。
      現在の実装では正負・↑↓について対称である。
      引数として 0 を指定した場合は移動は行わない。

      - 履歴項目の移動の実現方法に関して

        また別の現在の問題として現在の履歴項目を越えて移動する場合の動作についてである。
        forward-logical-line が独立して動作する為には、
        一番上から更に移動しようとした時に何行移動しようとしたかを呼び出し元に伝達する必要がある。
        或いは、vim-mode での実装を真似して forward-logical-line の内部から履歴項目の移動を呼び出すという手もある。
        現在の所、履歴項目の移動についても引数に対応していないので、
        これを現状で実装しようと思ったら履歴項目の移動についても対応する必要がある。
        何れにしても二種類の実装方法が考えられる。

        a 呼び出し元に残っている移動行数について何らかのローカル変数を介して伝達する。
          (現在の実装では終了ステータスを用いて移動できたかできなかったかの二値で対応する情報を伝達している。)
        b 或いは、別に履歴項目を移動するコマンドを用意しておいて、
          移動行数が満たない場合には forward-logical-line.impl の中から、
          その履歴項目を移動するコマンドを呼び出す様にする。
          実際に履歴項目を伴うか伴わないかについての制御は引数を用いて行う。

      - 選択範囲が有効になっている場合には履歴項目の移動は行わない。

      取り敢えずは履歴項目の移動以外については実装を行う。
      動作確認を行う。

      x fixed: 引数を指定した場合は全然動かない。
        何故か行末に移動して bell を鳴らす。行数は問題ない。
        →これは実際に移動した個数 \n を数える所で、
        移動量が正であるかどうかの判定で不等号の向きが誤っていた。
        更に、_ble_edit_str ではなく _ble_edit_ind の中を数えていた。直した。

      x resolved: 引数を指定しない場合はちゃんと動く。
        と思ったら勘違いだった。引数を指定した時と同様に動かなかった。
        これは引数を指定した時の動作と同時に修正された。

      - ok: 引数 0 を指定した時は、期待通りに何もしない。

    - beginning-of-line / end-of-line
      これらは beginning-of-graphical-line / end-of-graphical-line に分離した。
      動作確認。

      - ok: 範囲内の移動であれば 引数を指定しなかった時、0 を指定した時、
        正の数を指定した時、負の数を指定した時、何れも動いている。

      - ok: 範囲外への移動の場合でも、一番最初の行の行頭、または一番最後の行の行末に移動する。
        end であっても正しく行頭に移動するし、home であっても正しく行末に移動した。
        これは意識して実装した訳ではなかったが textmap による幾何的な実装で自然にそうなっていた。

    - done: self-insert で、"M-- 1 0 a" で bell を出すようにする。

    - kill-backward-graphical-line / kill-forward-graphical-line
      これも kill-backward-line / kill-forward-line から分離する。
      動作確認を行う。

      - ok: forward-line に関しては、引数なし、引数 0、引数 1、引数 -1、
        引数 2 において正しく動作している。

      x done: backward-line に関しては、引数の正負を逆転した方が良いのではないか。
        というか、コメントにはその様に書いている。

        →コメントに書かれている動作になるように修正した。
        負の引数について試した。引数 0 引数 1 引数 2 について試した。

    - done: find-graphical-eol の引数に axis を取る様にする。
      find-logical-bol に合わせて → 直した。

    - forward-graphical-line / backward-graphical-line
      これは forward-line / backward-line から分離して統合した。

      動作確認を行う。

      x fixed: 移動できない。というか履歴項目の移動を行ってしまう。
        これは、forward-graphical-line.impl の終了ステータスの問題だろう。
        と思ったが、.bell は必ず 0 を返す。ということは原因は他にある?
        →よく見たら移動後の 位置を求める時に --prefix=a を指定するのを忘れていた。直した。

      x fixed: 履歴項目の移動がそれ以上できなかった時に、
        カーソル位置が移動せずに終わってしまう。これは駄目だ。
        履歴項目の移動を呼び出す前に履歴項目内で移動を行うべき。
        これは forward-logical-line.impl でも同様に修正した。

      - ok: forward/backward 両方について、
        引数なし、引数 0、引数 1、引数 2、負の引数
        について確認した。問題なく動いている。

    - accept-and-next
      引数で指定した分だけ移動しても良いのではないかと思ったが、
      readline の動作を見てみると引数は効果を与えないようなので、取り敢えずそれに倣う。

    - forward/backward-line-or-history-next
      これについては実装し直す必要がある。
      特に埋め込む形で実装する様にする。
      行数は logical-line で数えるという事で問題ないだろう。

      % また、その後で廃止する事にする。
      % history を移動しない形での移動コマンドを提供する可能性もあるが、現在のところは対応しない。
      と思ったが、よく考えたらサブのプロンプトなどでは履歴移動を伴わないものが欲しくなる可能性がある。
      履歴移動を伴う可能性がある場合には widget の引数で opts を指定してもらうことにする。

      →forward-history-line.impl を実装した。動いている。
      →forward/backward-line-or-history-next/prev は廃止し、
        代わりに通常の forward/backward-line に引数 "history" を指定して登録する。

2017-12-03

  * 絵文字の文字幅に対応する [#D0645]
    https://github.com/vim-jp/issues/issues/1086 の表を用いる

  * 2017-09-17 cmplstofB: undo これは vi-mode の実装が終わってから考える [#D0644]

    - xmap I, A で undo は 2 回に分割される。初めの入力と後のコピー。

    vi-mode が落ち着いて来たので改めて考える事にする。
    これはやはり vi-mode を公開する前に簡単でも良いので対応したい。
    先ずは、基本の枠組みだけでも作成する。

    先ず初めにこれまでの考察に関してまとめる事にする。

    | 2015-03-01
    |
    | * undo の実装について
    |
    |   どの様な振る舞いにするのがよいかというのが問題である。
    |   他の shell でどの様に実装されているかについて確認する。
    |
    |   zsh における undo について
    |
    |   履歴行に関係なく "表示されている文字列" の redo undo の様に見える。
    |   つまり、履歴で上へ行ったり下へ行ったりするとそれも含めて undo される。
    |   これが分かり易いのかどうかは不明。というか分かりにくいと思う。
    |   また、一旦 accept した後はそれ以前の履歴にはアクセスできない。
    |
    |   bash における undo について
    |
    |   bash で試してみるとコマンド履歴の行毎に編集履歴は記録されている様である。
    |   また、accept した後でも編集が残っている。
    |   但し、accept した編集行については中身が編集前の状態に戻る。
    |   (つまり、後で実際に実行されたコマンドを確認するには undo しきらなければならない)
    |   これも分かり易いのかどうかは分からないが、少なくとも zsh よりは良い様にも思う。
    |
    |   とはいいつつも accept-line した後も編集が残っているのは良いのか微妙である。

    a 実のところ二重配列は bash にはないのでやはり一つの配列に全部入れたほうが良いかもしれない。
      例えば、undo の個数に制限をかけて 1000 個までとする。
      この時、1000 * hindex + undo_index 番目の要素に格納するなどする。

      しかし、これだと上限に達した時の処理が面倒である。
      新しい編集を行う度に shift を実行しなければならない。
      1100 まで増やして 1100 に達したら 100 だけ shift するなど
      ということにすれば毎回 shift するのは避けられる。
      しかし、其処までしてもやはり上限が存在するという事実は変わらない。

    b 或いは、現在の履歴項目の undo 履歴だけを配列に格納し、
      他の履歴項目に移る時にはシリアライズして別の配列に格納するという様にすれば良い。

      実際 keymap/vi.sh の mark で似たような運用方法を取っている。
      % 同様に履歴項目を移動する時に保存・復元を行えば良い。
      改めて実装を見てみたら、必要になった時に hindex と記録した hindex を比較して、
      もし異なっていれば save/load を行うという実装になっていた。

      コマンドを実行して erasedup などによって項目が移動する事はあるが、
      それに関してはコマンドを実行する度に履歴項目を全てクリアするという様にして対応する?
      そもそも _ble_edit_history_edit ですら shift ではなくて全クリアにしている。
      従って、undo についても全てクリアするという事で問題ないだろう。

    取り敢えず実装してみた。

    - vim の動作を調べてみると undo/redo をしても . による repeat は設定されない様だ。
    - また、`[`] は変更があった部分の最初の位置に設定される?

    意外と簡単に実装できてしまった。
    `[`] の枠組みを整備していたお陰でそれに沿って実装できたのが大きい。

    `U` に関しては readline "revert-line" と同じ効果になる様にした。
    U 自身を記録すると訳が分からなくなるので記録しない。

  * 2017-11-29 そう言えば read -e の問題についてここに書いていない [#D0643]
    と思ったら上の "制限" に書いていた。少なくとも警告ぐらい出すようにするべきなのでは。

2017-12-02

  * 2017-11-29 set -u にすると動かないに違いない [#D0642]
    やはり動かない。動かない原因を少しずつ除いていく。
    と思ったら、set -u だと arr1=(); arr2=("${arr1[@]}") すらできない。
    各配列の要素があるかないかで "${arr[@]}" を切り替えるのは困難である。
    仕方がないので、やはり set -u は毎回コマンド実行前に復元・保存する事にする。

  * 2017-11-29 README.md に GitHub アカウントを持っていない時の記述方法を書くと良いのではないか [#D0641]
    と思ったら元々 GitHub アカウントを持っていない時の記述であった。

  * 2017-11-29 update blerc -> bashrc [#D0640]
    やはり名称の変更は行わない。中身は更新した。

  * 2015-08-14 DECSET 2004 に対応する? (ref http://srad.jp/~doda/journal/506765/) [#D0639]

    bash-4.0 未満では read -t 0 がないので貼付などが行われた時に長く待たされる事になる。
    DECSET 2004 を用いて貼付を検知するなどの対策が必要。

    2017-11-29 @cmplstofB さんからの要望

    vi-mode における振る舞いを調べる。

    - 置換モードで実行すると上書きされる。
      改行は新しい行の挿入。
      つまり、一文字ずつ上書きした時と同じ振る舞いである。

    - ビジュアルモードで実行すると範囲を削除してから挿入を実行する様だ。
      挿入が終わった時にはノーマルモードになっている。c ... ESC だ。

      . を実行すると先に貼り付けたのと同じ内容が繰り返される。

    % うーん。色々考えると bracketed paste mode として特別に処理するよりは、
    % 今まで通りに処理する方が楽かもしれない。
    % ただし _ble_keymap_vi_paste 等のフラグを立てて、
    % コマンド実行などの操作を抑制する。
    % しかし貼り付け内容にキーシーケンスが含まれている場合などはどう扱うのだろう。
    % →試してみるとそのまま入力された。つまり、やはりキー入力をとして受け取るのではなくて、
    % 文字として受け取るのである。従って、今までと同様の処理では駄目だ。

    一方で、\e[201~ はどの様に検出したら良いのだろうか。
    文字列として溜めておいて末端が \e[201~ になったら
    其処で抜けて挿入操作を開始するという方法が良いのか?

    うーん。vi-mode で実装する前に emacs mode で実装した方が良い気がしてきた。
    そして、それを参考にしつつも独立に vi の各 mode での bracketed-paste を実装する。
    実装した。動いている。改行は CR LF も CR も LF に変換することにした。

    次は vi-mode における実装である。

    % 今見たら vi-mode で quoted-insert が white list に登録されていない。
    % と思ったが、よく見たら手動で登録していた。というより vi_imap/quoted-insert が定義されていた。

    - vi_imap/bracketed-paste は実装した。動作を確認する。
      何か二回挿入される。これは実装途中だった。直した。

    - 次に vi_nmap での実装を行う。これは思うに i ... ESC と同じと考えれば良い。
      調べてみると寧ろ a ... ESC の様である。
      更に、行頭に位置していた時には i ... ESC になるが、
      "." で繰り返す時には常に a ... ESC になる。
      ble.sh の実装では a <元々行頭なら行頭に戻る> ... ESC として、
      <もともと行頭なら行頭に戻る> は記録しないというようにする。
      動くことを確認した。

    - vi_xmap も同様に operator c を実行する様に実装する。
      v に対しては期待通りに動いている。

      しかし、C-v に対しては思ったとおりの動作をしない。v と同じ動作になっている。
      更に、V に対しても v と同じ動作になっている。何故だろうか。
      一旦、operator c の直後で中断してみることにする? と思ったが、
      それより後で複数行に亘って削除するようなコマンドは存在しないので、
      operator c を呼び出した時点で誤った結果になっているというのは明らかである。
      しかし普通に xmap で c を呼び出してもちゃんと linewise/blockwise になっている。
      念のため、bracketed-paste でも operator c の直後で中断してみると、やはりこの時点で失敗している。
      linewise/blockwise に切り替えるのは _ble_edit_mark_active を参照している。
      と思ったら、_ble_edit_mark_active が ble/widget/bracketed-paste によってクリアされているのだった。
      _ble_edit_mark_active を記録する様にした。ちゃんと動いている事を確かめた。

    - vi_omap ではエラーになる。
      続きの貼り付けないようがコマンドに渡されるということもないので、
      単に paste_begin を束縛しないのではなくて、
      貼り付け内容を破棄する様に実装する必要がある。

      エラーになった後の状態は何か。調べるとノーマルモードに戻っている。
      その様に修正した。

    - 引数に対する応答を調べる

      "x は無視される xmap の場合でも消えた文字列が "x に入っていく事はない。
      nmap の時は勿論無視される。

      数字の引数がある時には一文字進んだ状態で nmap -> imap になる。
      恐らく append-mode に入ってその時点でエラーになるなどするのだろう。
      これはもしかすると vim のバグかもしれない。
      xmap で数字の引数を指定した時は、完全に無視されて分からない状態になる。

      更に気付いたことは実は block-insert は起こらないという事。
      面倒なので、そのままにする。現在の実装の方が自然である。

2017-11-29

  * 2017-11-27 core: 端末の状態設定・復元とカーソル形状の対応 [#D0638]

    先ずそのタイミングについて調べる必要がある。
    結局 ble-stty/* と全く同じタイミングで全て調整する事にした。

    カーソルに関しては ble/term/cursor-state/* において
    hidden 及び 整数値 に対応した。

    しかし、実際に動かしてみると微妙である。
    overwrite mode 用の highlight-layer が、
    カーソルの hidden を解除するので、
    その時に既定のカーソルになってしまう。
    よく考えてみると overwrite mode であっても、
    文字の上にカーソルがない時には予め指定したカーソルの形状にする。

    これに対応するためには二種類の方法がある。

    a overwrite mode 側でカーソルを表示している時の
      カーソルの形状を保持する。
      vi.sh からは overwrite mode 時のカーソルの形状を指定する様にする。
      つまり、vi.sh とは独立にカーソルの形状をカーソルに紐付ける。
      そして表示・非表示に関しては overwrite mode が管理を行う。

      よく考えるとこの様な方法にするのだとしたら、
      結局 ble-edit のレイヤーでカーソルの形状と表示・非表示を管理するのに等価である。
      一応、既定のカーソルの形状の設定として "非表示" というものを許し、
      ble-edit のレイヤーで合成した結果を ble/term のレイヤーに適用するなどの事はできるが、
      そのようなことをしても余り利点はないように思われる。

    b もう一つの方法はカーソルの形状と表示・非表示は別の設定項目にする。
      カーソルの表示・非表示に関しては完全に overwrite mode 側に委ねる。
      カーソルの形状に関してだけ vi.sh から設定を変更する。

    結局 overwrite mode のために非表示機能は予約されているのだから、
    カーソルの表示・非表示の設定と形状の設定を統合する意味はない。
    もし将来的に必要になったらその時に統合すれば良いだろう。
    従って、 b の方法に書き換えることにする。

    動かしてみた。動いている。
    と思ったが external に移動する時に正しくカーソルが既定の状態に戻されていない気がする。
    実際に調べてみると external のカーソル形状に戻す部分は呼び出されている。
    →実は制御シーケンスが flush されていないというだけでなのでは?
      そうだった。flush するようにしたらちゃんと external のカーソル形状が反映される様になった。

2017-11-27

  * syntax: 変数代入の各括弧式とチルダ展開 [#D0637]

    #D0636 では角括弧式の中に : が含まれる場合には各括弧式をキャンセルするという実装にした。
    しかし、改めて試してみるとそうでも内容だ。

    $ echo a=[:~:] はチルダ展開が実行され角括弧式は意味を失う。
    $ echo a=[:+:] はチルダ展開は起こらず、角括弧式として解釈される。
    $ echo a=[:~mura:] はチルダ展開に失敗し、角括弧式として解釈される。

    つまり、実際にチルダ展開が起こったかどうかで、
    各括弧式が各括弧式として解釈されたかどうかが決まる。
    つまり、角括弧式の中でもチルダ展開は解釈することにして、
    チルダ展開であるということが明らかになった時に初めて
    角括弧式を解除することにする。

    角括弧式の終端はチルダ展開の終端または ":" の位置に置く事にすれば良い。

  * 2017-11-24 syntax: 変数代入に於けるチルダ展開 [#D0636]

    [bash の振る舞い]

    - 変数代入では値の : または = の直後でチルダ展開が始まることが許される。
      つまり、a=~:~ では両方のチルダについて展開が起こる。
      a=~=~ では後者のチルダについて展開が起こる。

    - [追加] 因みに a=(~:~) に関しては最初の ~ しかチルダ展開の対象にはならない。
      つまり、:= による区切りが有効になるのは本当に CTX_VRHS の文脈のみの様だ。

    - [追加] 気付いてしまったのだが、通常の単語でも = の直後でチルダ展開は有効のようだ。
      echo var=~ は展開される。一方で echo var:~ は展開されない。
      これについて man bash に何か記述はあったろうか。やはり探してみたが見つからない。
      更に、LANG=C man bash で見てみても見つからない。

    - [追加] 更にまた振る舞いの違いを見つけてしまった。
      : はチルダプレフィックスの終端になるが = はチルダプレフィックスの終端にはならない。
      これについては現在の実装で正しく実装することができている。

    [どのように実装するべきか]

    現在の実装ではチルダ展開が有効かどうかを一つ前の文字を見て決めている。
    しかし、やはりひとつ前の文字を読むのは解析再開用ルールの違反である。不整合になる。
    例えば a=~:~ にしておいて : を消すと2つ目の ~ がチルダ展開のままになる。

    a 例えば変数代入の時には : 区切りで単語を設置する様にする。
      そうすれば着色の際にも値についてファイル名の存在確認が取れる。

    b 或いは : と = の前後で文脈値を切り替えるなどして、
      次の文字に移った時に前が := の何れかであるかどうかの状態を保持する様にしても良いが、
      文脈値が無駄に増えるということと、結局補完の際にはまた特別な処置が必要になる。

    % ここは迷わず a の方針で考えることにする。
    % 但し、注意しなければならないことは、
    % この変更により単語が設置されるが、
    % これにより既存の補完などの枠組みに問題が生じないかということ。
    %
    % - extract-command に与える影響はどうだろう
    %
    %   | 先ず、単語はどの様に設置するべきだろうか。
    %   | 例えば変数代入自体を一つの大きな単語として、
    %   | その中に入れ子で単語の集合を設置するのか、
    %   | 或いは、親の文脈で一つの変数代入に対して複数の単語を設置するのか。
    %   |
    %   | 文法構造という観点からいうと入れ子にして設置したほうが良い気がする。
    %   | しかし、補完などの観点からいうと extract-command した時に変な切り出し方をされると嫌だ。
    %   | と思ったが、既にリダイレクト (ctx-redirect) や配列 (ctx-values) などの場合には内部に入れ子構造を作っているのだから、
    %   | extract-command で問題になったりしそうなものである。これについては現在の振る舞いを確認する。
    %   | →どうも調べてみると現状の extract-command だと、
    %   | リダイレクトや配列の代入の中では親のコマンドを正しく抽出できていないという事が分かった。
    %   | 従って、extract-command を改修して入れ子になっていても大丈夫な様にする必要がある。
    %   | そしてその様に改修した暁には変数代入に関しても入れ子にして問題ないだろう。
    %
    %   従って extract-command 関係については以下の様に対応すれば良い。
    %
    %   1 extract-command を改修して一番最初にコマンド単語 (CTX_ARGI) のあった階層で抽出する様にする。
    %     これにより echo hello; arr=(hello @world) など (@ はカーソル位置を表す) に対して
    %     echo hello が抽出される様にする。同様に echo world > te@st に対して echo world が抽出される様にする。
    %
    %   2 extract-command のコマンド単語抽出の方法について再確認を行う。
    %     コマンドの引数単語は常に CTX_ARGVI または CTX_ARGI と決まっていただろうか?
    %     またコマンド単語は常に CTX_CMDI と決まっていただろうか?
    %
    %   3 その上で変数代入に関しては、それ自体を一つの単語とすると同時に、
    %     内部に入れ子で単語を導入する様にする。
    %
    %   4 実は declare var=hello の右辺でも同様にチルダ展開が有効になるはずである。
    %     これについても同様に内部に入れ子で単語の構造を導入する事にする。
    %
    %   1, 2 に関しては #D0635 で取り扱う事にした。
    %
    % - もう一つの懸念事項は既存の補完で変数代入の右辺について何かあっただろうか。
    %
    %   % これに関してはまた確認する必要がある。実の所、現状では何も補完できていないので、
    %   % 何か実装しようとしていたとしても表面上は破壊する事にはならないだろうが。
    %   % 念のために確認しておく事にする。
    %   % →調べてみると ctx==CTX_VRHS で file を設置している。
    %
    %   実際に補完してみたら補完された。動いている。
    %   completion-context で ctx が CTX_VRHS の時に file を設置している。
    %
    %   補完開始点はその CTX_VRHS の先頭になっている。
    %   つまり、CTX_VRHS で複数回数で解析を行っている場合補完が働かなくなる。
    %   実際に var='w'or@ において補完を実行しようとしても補完できなかった。
    %   これは独立した項目で処理する事にする。#D0627
    %
    %   何れにしてもこの補完が動く様にする為には文字列を開始する必要がある。
    %
    % うーん。ここで通常コマンドの引数でも = の直後でチルダ展開が有効になるという事を発見した。
    % という事は、上記の方法を取っている限りは全ての単語について入れ子構造を導入しなければならない。
    % その様に実装すると余計に複雑になる。この方法はやはり駄目である。

    c =~ や :~ の連なりを見てチルダ展開を実行する様にすれば良い。
      これならば問題は起こらないはず。

    どうもまた色々試すと思っていたよりも複雑の様だ。
    先ず、echo a=~:~ とすると両方共展開される。
    また echo ~:~ だと前者しか展開されない。
    echo a+b=~:~ だと展開されない。
    echo a=~:b=~ だと前者しか展開されない。
    echo a=b:~ だと展開される。
    echo a+=~ だと展開され、echo a-=~ だと展開されない。
    a=b=~ は展開されない。
    echo a[$((1+2*3))$(echo 1)]=~:~ などでも有効になる。

    以下の様な規則になっていると思われる。
    先ず初めに通常の単語であっても変数代入と同様に解釈される。
    変数代入の右辺の初め、または、途中の : の直後ではチルダ展開が有効になる。

    これに対応するためには通常の単語であっても変数代入と同様の解析を行う必要がある。

    - どうも対応が微妙になってきた。そもそも配列代入の解析は正しく出来ていたのだったか?
      怪しい振る舞いをしていたので調べてみたが、それは解析の問題ではなかった #tmp0004

    [実装1]

    改めて考え直す必要がある。
    取り敢えず変数代入に関しては正しく動く様に実装できたと思う。
    通常の単語については以下の対策が必要である。
    結局通常の単語に関しても変数代入の形式の読み取りを実施しなければならない。

    - v= の形式の時 CTX_VRHS 的な別の文脈に移動する。
      これは取り敢えず CTX_ARGI のクローンとして実装すれば良い。
      例えば CTX_ARGIR という名前にする。

    - a[...]= の形式の時、通常の単語の場合には [] の中身は CTX_BRAX で読み取る。
      CTX_BRAX を抜ける時に ntype を見て 'a[' ならば、
      続きが ]= であることを確かめて CTX_ARGIR に移行する様にしかける。
      移行した時には変数代入の時と同様に tilde-expansion のチェックをその場で行う。

    取り敢えず、ARGVI, ARGI, FARGI3, CARGI1 それぞれについて
    変数代入の右辺になった時の文脈値を定義した。実装した。
    通常の引数について動作のテストを行う。

    x fixed: stackdump が出る。これは _ble_syntax_bash_command_isARGI が整数値のはずなのに、
      文字列として扱おうと考えて "a" などの値を入れたのが悪かった。
      結局文字列の値は使わないことになったので "a" から "1" に戻した。

    x fixed: echo a[i]=1 において CTX_BRAX から抜けた時の着色が変だ。
      等号は ATTR_GLOB で塗らない。直した。

    x fixed: 変数代入の後に ctx=CTX_UNSPECIFIED になっている。
      単語の形成にも失敗している。直した。

    x fixed: declare var=value の value の着色が変だ。
      これは上の項目と同じ原因だった。直った。

    x fixed: declare var=value の後の文脈がコマンドを受ける文脈になっている。
      CTX_ARGVX に戻るべき。これは _ble_syntax_bash_command_EndCtx[CTX_ARGVIR] の値を誤っていただけだった。
      CTX_VRHS の設定をコピーしただけになっていた。直した。

    o ok: チルダ展開が有効でないはずのものはちゃんとチルダ展開以外になっている。
    o ok: declare arr[123]=~:~ なども期待通りに動いている。

    x wontfix: 実は echo a[]=~ もチルダ展開として有効である。
      しかし、現在の実装では [ の直後の ] は "]" を閉じる力がない。

      改めて試すと echo a[]b]=~ はチルダ展開が有効にならない。
      つまり、チルダ展開としては "a[]"b]=~ の形式であると見做し、チルダ展開は起こらない。
      一方で 'ab=~' という名前のファイルに一致するのでパス名展開としては echo a["]b"]=~ と解釈している。
      これについては blesh は パス名展開の方が正しく着色されるようにする。

    o ok: for var in args... や case arg in の arg の部分でもちゃんと動いている。

    [実装2]

    未だ残っている。ctx-values や ctx-conditions でもチルダ展開は有効である。
    ctx-values については対応した。ctx-conditions にも対応した。

    * 変数代入形式の単語の右辺でブレース展開を使うと、チルダ展開は無効になる。
      % echo a=~:{a,b}:~ とするとチルダ展開は有効にならない。
      % ブレース展開があると駄目なのだろうか。
      % 規則がよく分からないのでこれは保留にする。
      と思ったが後で対応するのも面倒なので分かる範囲で対応することにした。

2017-11-26

  * 2017-11-24 syntax: extract-command の実装を再確認する [#D0635]

    これは元々 #D0636 の方法 b を整備する時に
    extract-command の実装を確認した時に気がついた extract-command 自体の問題。
    結局方法 b は棄却されたので、独立させてここで実装する事にする。

    | 1 extract-command を改修して一番最初にコマンド単語 (CTX_CMDI) のあった階層で抽出する様にする。
    |   これにより echo hello; arr=(hello @world) など (@ はカーソル位置を表す) に対して
    |   echo hello が抽出される様にする。同様に echo world > te@st に対して echo world が抽出される様にする。
    |
    | 2 extract-command のコマンド単語抽出の方法について再確認を行う。
    |   コマンドの引数単語は常に CTX_ARGVI または CTX_ARGI と決まっていただろうか?
    |   またコマンド単語は常に CTX_CMDI と決まっていただろうか?

    2 に関しては ble_debug を見て試した限りでは問題ない様に見える。
    1 に関しては現在の実装を改めて見ないと分からない。
    実装を改めて読む。そもそも tree-enumerate は一体どのような実装になっていたのだったか。

    | 先ず初めに tree-enumerate/.initialize を見る。
    | 出力する変数は tree と i と nofs である。
    | 恐らく .initialize では未だ閉じていない入れ子を末端位置で仮に閉じた時に、
    | _ble_syntax_tree[iN-1] がどの様な値になるかを計算している。
    | - _ble_syntax_tree[i-1] は境界 #i で終わる範囲の情報を格納することに注意する。
    | - 範囲は二種類ある。word と nest である。
    | - word は word を直接子に持つことはない。
    | - inest は範囲の開始点であり、_ble_syntax_nest[inest] に範囲の開始情報が格納されている。
    |
    | 次に tree-enumerate/.impl を見る。
    | - 同じ位置で複数の階層の範囲が終端するとき、
    |   それらの情報は連結されて _ble_syntax_tree[i-1] に格納される。
    |   外側の範囲の情報の方が左側に格納される。
    | - tclen tplen を用いてこれらの範囲情報は互いに参照する。
    | - 他の位置から参照されるときは必ず一番外側の情報を参照する。
    |   同じ位置から参照されるときに限り一つ右の情報を参照する。
    | この関数は同じ階層に位置する兄弟を末尾から列挙して指定した関数を呼び出す。
    | 範囲の情報は wtype wbegin tprev tchild nofs を用いて渡される。

    結局 tree-enumerate は一番外側の階層の範囲を列挙し、
    tree-enumerate-children は現在の範囲の中に下の階層があれば、
    その階層について範囲を列挙するということをする理解は正しい。
    使える変数は wtype wbegin tprev tchild nofs であり、
    通常用途であれば直接ユーザが使用するのは wtype wbegin である。
    tree-enumerate-break は強制的に tprev=-1 にする事で
    兄要素がないことにし、そこで兄弟の列挙を停止させる。

    ble-syntax:bash/extract-command/.scan では、
    現在位置が含まれる一番下の階層の単語を探している。
    先ず初めに現在以前で始まる範囲まで見送る。
    範囲が現在位置よりも左まで行ったら中断する。
    現在位置を含む範囲を見つけたらその中に潜るというのを繰り返す。

    その階層に単語 (wtype/ntype が整数値の範囲) が含まれる場合には isword を設定する。
    isword は、一つ上の階層で construct を呼び出して貰うためのマーカである。
    この isword は一番最初に見つかった単語である。
    つまり、現在位置以前に始まる一番最後の単語の wtype になる。
    そうは言っても誰も使っていない様である。
    isword は分かりにくいので extract_has_word に変数名を変更した。

    うーん。結局 iscommand=1 (改め extract_command_found=1) の位置を変更するだけで良い気がする。
    試してみる。動いている。OK

    ? fixed: _ble_syntax_tree の構造を見ていて気付いたが、
      よく考えると _ble_syntax_tree であっても、wtype に任意の文字列が入りうるから、
      node=(${_ble_syntax_tree[i]}) とすると failglob で不味いのでは?

      と思ったが、ntype としてグロブパターンになる物がなければ大丈夫のはず。
      これは nest-push を全て確認すれば分かる。a[ や v[ など怪しい物もあるが、
      現状ではグロブパターンになる様なものは含まれていない。
      将来的なことを考えると本当はグロブパターンが含まれることも
      想定して修正した方が良いのかもしれないが。

      現状では問題ないが、やはり後々のためにちゃんと安全な方法で split する事にする。直した。

  * edit: history 初期化で先頭行に行く [reported by @cmplstofB] [#D0634]

    > 起動直後に履歴を遡る (というより ^P を押下する) と一番始めの履歴にまで戻ってしまいます。

    送ってもらったログを見て分かった。
    failglob の為に history_line=($history_line) を
    ${history_line%%[$IFS]*} に変更したのが原因だった。
    どうやら history で出力される履歴番号は printf %5d で出力されている為に、
    履歴項目の数が 5 桁より小さい時には先頭にスペースが入るのだ。

  * complete: failglob 時の問題 (3) [reported by @cmplstofB] [#D0633]

    > コマンドに glob が含まれている場合などはいいのですが，
    > 存在しないパスを補完しようとすると不具合が発生します。

    うわ。未だ残っている…。うーん。
    候補生成にパス名展開を使っているのが悪い。
    試しにエラーメッセージを殺す方向で試してみたが、
    すると今度は ble.sh の処理自体が其処で死ぬ。

    % 先に対応したパス名展開では死んでいなかったが何故だろう。
    % 見てみると eval している。試してみると eval だと大丈夫のようだ。
    % 関数を作る。ble/util/eval-pathname-expansion
    % 一応パス名展開をしているところはこれに置き換えた。
    % エラーメッセージは出ていない。
    結局この実装は以降の修正により使わない事になった。

    x fixed: 後、shopt -s nocaseglob も現在の実装だと不味い。
      パス名展開で候補を生成しているので、
      a.txt に対して A@ で補完を実行すると A.txt になってしまう。

      そもそも何故 compgen -A file -- ... を使わずに、
      "$COMPV"* を使っていたのだったか。
      先ず初めに compgen は fork またはファイルへの読み書きをしないと結果を取得できないので遅い。
      次に、何故か prefix を認識してくれないことが過去にあったから。
      今試してみるとちゃんと動いている様に見えるが、実のところ良くわからない。
      更にディレクトリ名を / を付きで生成するのも楽である。

      今 nocaseglob に合わせて、既に存在している文字列を
      書き換えてしまうという手も考えられるが、quote がある場合など諸々を考えると面倒だ。
      後でまとめて対応する様にした方が良い気がする。
      この大文字小文字の違う候補でも補完できるようにするのは独立した項目にする。

      今は compgen で候補を生成する事にする。

    x fixed: 起動時に一時ファイルを消すところでもパス名展開を使っている。
      これも対処しないとそもそも ble.sh のロードに失敗する筈。

      これは起動時の処理なので ble/util/* などの高等な機能は使えない。
      従って、shopt -u failglob して処理する事にする。

  * 変数が漏れている。ret が定義されている [#D0632]

    1 先ず emacs mode でも定義される。
    2 ble-syntax/parse で local ret としてみても変わらない。
    3 ble/textarea#render で local ret としてみても変わらない。

    逆に外側から絞っていく事にする。
    4 ble-decode/.hook で local ret としたらさすがに大丈夫だ。
    5 ble-decode/PROLOGUE, EPILOGUE は関係ないようだ。
    6 ble-decode-key で local ret としたら大丈夫だ。
    7 eval -- "$WIDGET" の前後で ret が設定される様だ。
      ret の値が破壊される時の WIDGET を出力させると以下の様になった。
      ret=0:WIDGET=ble/widget/vi_imap/accept-single-line-or vi_imap/newline

    どうも複数存在する様である。一つは _ble_edit_str/update-dirty-range から。
    見つけた。以下で漏れている。

      ble/keymap:vi/mark/set-global-mark
      ble/keymap:vi/mark/set-local-mark

    直したら取り敢えず ret の値は保持される様になった。
    実は他の箇所でも漏れがあったような気がしたが、今の所は再現していない。

    x 更に、一回 normal-mode に入ってそれから insert-mode に入ると ret が消える。
      これも ret が漏れている証拠である。どうも normal-mode に入る瞬間に駄目の様だ。
      と思ったが当たらない。どうも実行直前に insert-mode に入っていて、
      insert-mode の実装で ret を宣言するのを忘れていたということのようだ。

      さて、これは直したと思ったが、未だ直っていない。
      insert-mode で local ret したが反応しない。と思ったら xmap/insert-mode を見ていた。
      そう思って nmap/insert-mode で local ret をして見たがそれでも直らない。
      vi_imap/normal-mode-without-insert-leave の方でも修正したがそれでも駄目。
      もう一度外側から絞っていくしかないのだろうか。もう一度 ble-decode にしかける。

      | local ret=trap1
      |   builtin eval -- "$WIDGET"; local exit=$?
      | [[ $ret == trap1 ]] || echo "ret=$ret:WIDGET=$WIDGET" >> a.txt
      |
      | 結果
      | ret=<U+009C>:WIDGET=ble/widget/vi_imap/normal-mode-without-insert-leave
      | ret=<U+009C>:WIDGET=ble/widget/vi_nmap/insert-mode

      うーん。何と両方で ret が書き換わっている。道理で片方だけ書き換えても反応しない訳だ。
      というかよく考えたら local -r ret すれば犯人が分かるのでは?
      と一瞬思ったが駄目だ。local -r ret すると新しいローカル変数の定義も禁止されてしまう。

      normal-mode-without-insert-leave に潜る。ble/keymap:vi/update-mode-name が駄目だ。
      中を覗いてみると呼び出している関数は ble-edit/info/default しかない。やはりそうだ。
      辿っていくと ble-edit/draw/trace.impl にまですぐに行く。見つけた。

      改めて ble-edit.sh についても ret のリークがないか調べる必要がある気がしてきた。
      他に 2 箇所同様の ret のリークを見つけた。直した。
      心配になったので ble-syntax.sh と ble-decode.sh も確認する。問題は見つからなかった。
      ble-color.sh も確かめた。一つ上の階層で local ret している例を見つけたが、
      実際の処理内容を見ると不自然なので local ret は中に移動した。
      (ble-highlight-layer:plain/update / ble-highlight-layer:plain/update/.getch)

    x done: keymap/vi.sh の実装について一通り ret の使用を見てみたら、
      かなり local ret を忘れている箇所が見つかった。見つかった物は直した。

    * また最初の調査で "emacs mode でも定義される" と書いたが、
      これは _ble_edit_dirty_observer に登録した
      ble/keymap:vi/mark/shift-by-dirty-range がそのまま動いていて、
      更にこれの中で ret が上書きされていたのが行けなかったようである。
      これについては emacs mode に入る時には _ble_edit_dirty_observer
      から消去する等の対策が必要な気がする。

2017-11-25

  * 2017-11-23 complete: bug 補完で謎の現象が起こっている。空白が補完される [#D0631]
    というか echo [a でも同様に空白が補完される。
    echo $(echo > ) の > の後で実行しても同様である。
    更に echo $(echo) の後でも空白が補完される。
    どうやら同じ点で nest-pop が 2 回起こっているとなっている気がする。

    % どうもこれは昔からあった振る舞いの気がする。後で対応する事にする。

    というか "echo @" でも空白が挿入される。
    この振る舞いは今までなかったはずだ。
    今までは、候補一覧が表示されたはず。
    つまり、これは最近埋め込んだバグである。

    調べてみると空文字列の候補が生成されている。
    どうも compgen で一つも候補が生成されなかった時に、
    ヒアストリングで <<< "$compgen" とした時に空候補が作られる様だ。

    - そもそも compgen が空の時には候補生成の処理はしなくても良いのだから先に抜ける様に変更した。
    - 更に、compgen に内容が含まれていたとしても空行がある場合には、それを除く様に変更した。
    - ble/util/assign-array も調整した。

  * highlight: failglob でエラーメッセージが出る [reported by @cmplstofB] [#D0630]

    > コマンドラインで $ l* と入力すると bash: 一致しません: l* という
    > エラーメッセージらしい表示が入力位置の右隣に発生し，続く入力が妨げられます。

    直した。パス名展開を試みている箇所では同様のことが起こりうる。

    x fixed: あと、ble/string#split も火を吹いていた。諦めて set -f する事にした。

    x fixed: また、失敗するコマンドを一度実行するとそれ以降どのキーを入力してもエラーメッセージが出る様になる。
      しかも、C-c などの操作が効かなくなる? DEL も効かない。何故? decode の問題だろうか。
      先ず初めにどのタイミングでエラーが発生しているのかを確認しなければならない。
      これは getcount を実行する時に count=($(history 1)) に相当することを実行していたのが悪かった。

      調べてみると類似の物は広範囲に亘って存在する。全て修正しなければならない。
      grc '=\(\$' で検索して当たるものを全般に調べる必要がある。
      特に ble-syntax.sh における _ble_syntax_stat の類を ble/string#split で分割する必要がある。
      というのも、nparam にはヒアドキュメントの終端が入り * が含まれうるから。
      _ble_syntax_nest も同様である。

      大変なので ble/string#split-words 関数を追加した。

    - done: あと、パス名展開に失敗したらその単語をエラー着色するようにする。

  * keymap/vi (cmap): C-d で終了してしまうバグ [reported by @cmplstofB] [#D0629]

    > たとえコマンドラインに文字があっても終了してしまいます。

    直した。

2017-11-24

  * complete: 更に key=key とした後に echo $key""@ も補完できない [#D0628]

    そのまま echo key@ だと勿論補完できる。
    調べてみると is-simple は true を返し、更に eval も期待した値 key になっている。
    一体何が問題で補完に失敗しているのだろうか。

    うーん。何と別のファイル名だと再現しない。
    しかも更に変数名を変えたら動く。
    $ var=key
    $ echo $var""@

    途中の様子を調べてみたら…何と $key"" が 67108969 という値に展開されていた。
    成る程、ローカル変数の変数名と被っているために変数の中身がすり変わっている。

    [cf memo/D0628.extract-global-values.sh]

    | x [困難] これに対処するのは困難である。外部文脈で評価するしかないが、
    |   評価の度に外部文脈にまで移動するのは難しい。
    |   処理を完全にファイバーにして処理しなければならないが、それは滅茶苦茶である。
    |
    | a [不可能] 或いは declare -g key などとすれば外部変数にアクセスする事ができるか?
    |   これは具体的に試してみないと分からない。試してみた所、
    |   declare -g key を用いるとグローバルでの変数の値を変更できるだけであって、
    |   グローバルでの変数の値を読み出すことができる訳ではないようだ。
    |
    | さて、グローバルでの変数の値を設定することができるのだから、
    | 何処かにその値を読み出す方法があるかもしれないと思って検索してみる。
    | しかし、サブシェルの概念を知らずに変数の値が設定できないと相談している人や、
    | 関数内で変数宣言のコマンド (local declare readonly typeset) を用いた時に、
    | 自動的に関数内の局所変数になるということを知らないで記事を書いている人が当たったりで、
    | "ローカル変数を定義している時にグローバルの値を読み出す方法" についての記事は簡単には見つけられそうにない。
    |
    | b [不可能] よく考えてみたら declare -p -g var とすれば見る事ができる筈だ。
    |   しかし $var でアクセスできる様になる訳ではないという事に注意する。
    |   declare -p -g var 等して得られた結果から、
    |   先頭の declare 云々の部分を消して local を付加し、
    |   それから eval すればローカルに値を丸っと持って来ることができる。
    |
    |   - 所で declare -p にはバグがあって改行について再現できない、
    |     と思ったがよく考えたらバグは bash-3.0 の話であり、
    |     一方で declare の -g オプションは bash-4.2 以降なので、
    |     これについては気にしなくても良い。
    |
    |   - この時にその文脈での変数名を上書きしない様に注意する必要がある。
    |     変数名は全て _ble_* という名前にすれば良い。
    |
    |   何と実際に試してみた所できないという事が判明した。
    |   declare -g に -p オプションを指定すると -g は無効になる。
    |   "declare -g" で現在定義されているグローバル変数を全て出力できるのではないかとも思ったが、
    |   実際に試してみるとローカル変数も含めて全変数について、現在での文脈の値が出力されるだけだった。
    |   結局グローバルでの値は分からない。
    |
    | c [不可能] 既に設定されているローカル変数を全て unset すれば
    |   グローバル変数に到達することができるはずだが、
    |   先ず、何回 unset したら良いかわからない。一番最後に定義されていた変数は分かるが、
    |   それが果たしてグローバル変数なのか、それともローカル変数なのか判別できない。
    |   declare -g var としても変数が "定義" される訳ではないので多分駄目だ。
    |   更に、unset した後でまた元の状態に復元する方法が存在しない。
    |
    | d [不可能] 或いはシグナルを用いてシグナルハンドラから出力させるという手もある。
    |   これは遅そうだが仕方がない。実際に試してみた所駄目だった。
    |   先ず呼び出しの順序はちゃんと保たれている。
    |   しかしながら、ローカル変数はそのままにして呼び出される様で、
    |   シグナルハンドラの中からでもローカル変数の値しか見えない。
    |
    | e 或いは bind の一番外側で毎回全てのグローバル変数を何処かに記録するという手もある。
    |   しかし、これは明らかに滅茶苦茶遅い。特に _ble_* の類を除外する方法がない。
    |
    | f もしくは、全てのローカル変数の名前を _ble_* に変えるという手もある。
    |   その様にすれば _ble_* という変数名を参照しない限りは
    |   グローバル変数の値を (何もせずに) 参照できるということが保証できる。
    |   更に、この方法は declare -g などと違ってどの bash の version でも使える。
    |
    |   然し、これはこれで変更コストが大きいし、またコードも読みにくく・書きにくくなる。
    |
    | g c の方法に於いてサブシェルに潜れば unset でグローバル変数を掘り出しても、
    |   外側では影響が出ない様にする事ができるのではないか。
    |   unset を繰り返し実施して一番最後に定義されていた変数の値を取れば良い。
    |   この方法でグローバル変数が定義されていればそれを取得できるという事が分かった。
    |
    |   v 実際に複数階層の場合でも各階層での値を逐次的に取得できることが分かった。
    |
    |   x ok: 途中にローカル変数があった場合は?
    |
    |     | 思ったのだが途中で -r のローカル変数があった時に unset できるのだろうか。
    |     | →試してみたところ駄目だった。できない。
    |     | これに関しては -r なローカル変数を設置しないという今までの方針を用いている限りは問題ない。
    |     | complete の処理の途中でユーザ関数を通過することはないので問題にはならない。
    |     | ただ、中で補完などを呼び出すような widget を書くときには readonly にしない様に注意するしかない。
    |
    |     グローバル変数にアクセスするには途中のローカル変数に readonly を指定してはならない。
    |
    |     というか試していて分かったことだが local -r 宣言してしまうと、
    |     更に呼び出した先の関数でその変数を local 宣言することができなくなってしまう。
    |     実際に検索してみるとそれをやっている箇所が ble-syntax.sh に二箇所見つかった。これは消す。
    |
    |   x solved: 問題点はグローバル変数が定義されていなかった時に、
    |     一番最初に定義されたローカル変数の値を拾ってきてしまうという事である。
    |
    |     a その変数がグローバル変数かどうかを判定するには、
    |       declare -g var=xxx を実行して値が変化するかどうかを見れば良いが、
    |       もしそれがグローバル変数ではなかった場合にグローバル変数の値を破壊してしまう。
    |       破壊が起こらない様にする為にはサブシェルの中で値が変化するかどうか見れば良いが fork が増える。
    |
    |       一応、以下の方法を用いれば余分な fork は一回に抑えることができる。
    |       先ず初めに unset を繰り返す事で何階層の変数が定義されているかを調べ、
    |       その後で改めて初めから unset を実行して一番最後の階層に移動し、
    |       そこで declare -g var=xxx に応答するかどうかでそれがグローバル変数かどうか判定する。
    |
    |     b 或いは declare -g var だけ実行すればそこに変数が存在することが保証されたりしないだろうか。
    |       或いは declare -g -r var などとすれば readonly な物をグローバル変数と解釈できる。
    |
    |     ここは b で実装してみた。動いている。
    |
    |     c 但し、declare -g は bash-4.2 以降でないと使えないので、
    |       bash-4.2 未満では [[ ${var+set} ]] による実装に切り替える。
    |       しかし、これだとやはりグローバル変数に到達できない場合があり問題だ。
    |
    |       或いは、__ble_MaxLoop=20 迄回してしまうというのも手である。
    |       fork に比べれば大した処理量ではない。また、別目的にこの関数を使うとしても、
    |       bash-4.2 未満の話なのでパフォーマンスは余り気にしない事にする。
    |       その様に修正した。動いている。
    |
    |       唯、bash-4.0 未満 ${!varname+set} が期待通りの動作をしていない気がする?
    |       しかし普通に bash-3.2 -c 'var=hello; [[ ${!var+set} ]]' とすると動いて見える。
    |       まあ、調べるのも面倒なので、少なくともグローバル変数がある場合には
    |       正しい値を取得できているので良しとする。
    |
    |   x ok: 途中に宣言だけの変数があった場合 (local var) は?
    |
    |     [[ ${var+set} ]] とすると変数が存在することになっている?
    |     と思ったが、それも2回だけで 2 回 unset すると変数は存在しないことになる。
    |     ところが、無視して unset を続けて行くと最終的にグローバル変数に到達することはできる。
    |
    |     まあ、取り敢えず動いているので気にしない事にする。
    |
    |   x ok: もう一つの面倒なことは、サブシェルで実行するので、
    |     実行結果を返すために標準入出力を用いなければならないという事である。
    |     といってもこれは面倒なだけで fork をするよりはコストも小さいし問題にはならない。

    結局 g の方法でテスト実装して動くようなものができたのでそれを使う事にする。
    ble/util/print-global-definitions という関数を定義した。

    次に simple-word から変数名を抽出する。テストした。
    それから変数名が一つ以上ある時に print-global-definitions を呼んで eval する。
    幾らか修正したら、問題なく動いている。

    些細な事のために大分実装が複雑になったが仕方がない。

  * complete: ファイル world があるとき var='w'o@ (@ はカーソル位置) で補完できない [#D0627]

    これは completion-context の CTX_VRHS において、
    CTX_VRHS が最後に設置された位置を補完開始点としているからである。
    上記の例で言えば o を起点に補完を実行しようとしてしまう。
    ここでは wbeg から変数名をスキップして補完を実行するべきである。

    この修正により以下の項目も解決した。

    | 2017-11-06
    |
    | * complete: リダイレクトのファイル名に @ が含まれているとき @ 以降で補完できない。

  * syntax: チルダ展開 [#D0626]

    チルダ展開が起こる文脈は?
    ctx-command ctx-values では起こる。
    ctx-conditions では %%起こらない%% と思ったら起こっている様だ。
    ctx-redirect CTX_RDRF/CTX_RDRS/CTX_RDRD では起こる。

    extglob や [...] の中では起こらない。
    最初のブレース展開の中では起こる。が、これは面倒なので認識しない。

  * highlight: リダイレクト先ファイル名が複数語に展開されたらエラー着色 [#D0625]

  * highlight: echo <<< {a,b} や echo <<< * ではグロブ展開が起きないのに、 [#D0624]
    着色はグロブ展開も含めてファイル名に一致するかどうかが確かめられている。

  * 2015-08-15 syntax: CTX_CMDXC, CTX_CMDXF 等に於いて redirect は許可するべきでないのでは? [#D0623]
    更に、CTX_CMDXC においては var=... も許可するべきではない。

    また CTX_CMDX1 についても直前のコマンドによっては redirect は許可するべきでない?
    (while, if, do, then, else, '(', time の直後では redirect も可能な様だ。)

    2017-11-24 改めて一通り動作を確認する事にする。

    | CTX_CMDX1 について調べた所、他に && などの直後が CTX_CMDX1 のようだが、これについても redirect は可能である。
    | 結局、現状のコードでは CTX_CMDX1 の場合はいつでも redirect は可能に思われる。
    |
    | CTX_CMDXF は CTX_FARGX1 に改名した。CTX_FARGX1 では redirect はできない。
    | CTX_FARGX2 でも redirect はできない。これらは大丈夫。
    | しかし、CTX_FARGX2 から CTX_ARGI に変換しているが、
    | bash は for a in aaa bbb > redirect; の形式を許していない。★これは修正が必要
    |
    | CTX_CMDXE は fi fi などの文脈であるが、
    | この直後に > redirect がある事はいつでも許される。
    | また redirect の後は CTX_ARGX0 になるという振る舞いも正しい。
    |
    | CTX_CMDXC は関数定義の始まる前の文脈であるが、ここでは redirect は使えない。
    | この振る舞いについても ble.sh で試したところ正しい。
    |
    | CTX_CMDXD は for ((;;)) 直後の文脈である。
    | これも現状の ble.sh の振る舞い通り redirect は使えない。

    結局 for a in の後の引数の列でリダイレクトを使えないという事に対応すれば良い。
    対応した。新しい文脈値 CTX_FARGX3, CTX_FARGI3 を追加した。

2017-11-23

  * 2017-11-21 syntax: ブレース展開? [#D0622]

    | 少し試してみたが、ブレース展開が起こる条件が謎。
    | echo ${aaaa:-{a,b}{c,d}} # 起こらない
    | echo ${aaaa:-{a,b}{c,d} # 起こらない
    | echo ${aaaa:-a,b}{c,d} # 起こる a,bc a,bd
    | echo ${aaaa:-{a,b}}{c,d} # 起こる {a,b}c {a,b}d
    | echo ${aaaa:-a,b}}{c,d} # 起こる a,b}c a,b}d
    |
    | bbbb=1234; echo ${bbbb:-{a,b}{c,d}} → 1234{c,d}} となるので、
    | ${} は特に {} の入れ子の回数を数えるという事はしていない。

    うーん。仮説は以下の通り。
    1 先ず初めにブレース展開を試行する為に {,} を抽出する。
      ${} が現れたら {} の入れ子を数えつつスキップする。
      ブレース展開が見つかったら展開する。
    2 展開後の単語について ${} 等の展開を行う。
      この時は ${} の中の {} の入れ子は数えず、
      "}" が現れた時点で即座にパラメータ展開が閉じるとする。

    この 1 と 2 の間の ${} の終端点の抽出の違いに依って
    変な振る舞いが生まれていると思われる。
    これは bash がおかしいので多少の着色の違いは無視する。
    基本的に ${} の抽出に従い (つまり {} の入れ子は考えない)、
    仮にブレース展開が {} の入れ子で無効化されていたとしても、
    気にせずに着色を実施する。

    ブレース展開の着色に対応するのであれば、
    {aa..bb} や {aa..bb..cc} や {aa,bb} 等の途中の区切りについても着色したい。
    CTX_BRAX と同様に delimiters が来たら抜ける。

    | a 初めは .. が来るか , が来るか分からない状態として解析し、
    |   何か複雑な構成が来たら , だけを受け付ける状態に移る?
    |
    | b と思ったが .. が許されるのは内部に構造がない時のみなので、
    |   "{" を nest-push する時点で .. の形式かどうかを判定する事ができる気がする。
    |   正規表現 (([0-9]+)\.\.([0-9]+)|[a-zA-Z]\.\.[a-zA-Z])(\.\.[0-9]+)?\} で読み取れる所まで読み取り、
    |   一番最後まで読み切れたら {aa..bb} の着色を行う。
    |   もし途中で一致しないと分かったら、その時点で , を受け付けるブレース展開の文脈に push する。
    |
    | c b の方法だと先読みのために何処まで読んだかを調べなければならないので、もっと単純化する。
    |   "{" が来たらそこから前方に [0-9a-zA-Z.]*\}? を読み取る。
    |   もし \} まで読み切ったら、中身が b の形式になっていれば {a..b} として着色し、
    |   そうでなければブレース展開ではなく通常の文字列として読み取る。
    |   途中までしか読み取れなかった場合には "{" で nest-push して
    |   {,} 形式のブレース展開の文脈に入る事にする。

    ここでは c の方法を用いることにする。

    ブレース展開の文脈でも角括弧式やグロブパターンは有効である。
    ブレース展開から角括弧式を呼び出した時には
    角括弧式は通常のコマンドの終端に加えて ,} でも終端する様に注意する。

    取り敢えずブレース展開に対応する事にする。

    [実装]

    1 done: 先ず初めに _ble_syntax_bashc[CTX_ARGI] を修正する。
      "{" を追加した。

    2 done: 影響範囲を確かめる。
      ${_ble_syntax_bashc[CTX_ARGI]} を参照しているのは、
      ctx-command, ctx-values, ctx-conditions, ctx-redirect である。
      更に ctx-bracket-expression でも使用している。

      - ctx-values ではブレース展開は有効である。
      - ctx-conditions ではブレース展開は無効である。
      - ctx-redirect ではどうだろうか。試してみると文脈によって振る舞いが異なる。
        - CTX_RDRF で使うと曖昧だと言われてエラーになる。
        - %%CTX_RDRH で使うとブレース展開は完全に不活性の様だ。%%
          →そもそも CTX_RDRH は ctx-redirect の対象ではなかった。
        - CTX_RDRS で使った場合も不活性の様だ。
        - CTX_RDRD これは fd を受け取る形式のリダイレクトである。
          曖昧なリダイレクトだと言われてエラーになる。

      つまり、少なくとも CTX_RDRF, CTX_RDRD ではブレースを認識し、
      そして、エラー着色を設置する必要がある。と思ったが、
      不完全なブレース展開の場合には入る時に確実なエラー着色を実行できない気がする。
      と思ったが、これは "}" が現れてブレース展開が閉じる時にエラー着色すれば良い。
      そして途中の "{" や "," は不活性という事にする。

    3 done: 取り敢えず ctx-command で使う為に check-brace-expansion を実装する
      実装した。動いている。

    4 done: 次に文脈毎に対応していく事にする。

      - ctx-values ではそのまま対応すれば良い。

      - ctx-conditions では着色しないし nest-push もしないという様にすれば良い。
        (或いは、そもそも ctx-conditions の通常文字集合から "{" を除けば良いのだが、
        新しい文字集合を定義するのも面倒なのでそのままにしておく。)

      - これは CTX_RDRS %%及び CTX_RDRH%% でも同様に取り扱えば良い。
        また CTX_RDRD 及び CTX_RDRF では一応読み取るがエラーにする。
        と思ったが > {1..1} 等の様に 1 個しか値が生成されない時はエラーにはならない様だ。
        うーん。これは展開の結果としてのエラーであって構文エラーではないので、
        余り気にせずそのまま解析してしまえば良い?
        唯、> {1..3} の様な場合はやはり明らかにエラーになることが分かっているので、
        この解析の時点でエラーにしてしまって良い気がする。エラーにする事にした。

        特に nest-push した時には最終的に , なしで終わってブレース展開として有効にならない事もある。
        その様なことを考えると nest-pop した場合にはわざわざエラーの着色はしなくても良い?
        →これは次の項目で対処する様に "," の前後で文脈値を変えることにしたので、
        実は "," なしで終わったかどうかは判定可能である。
        というか、"," より後でしか "}" で終わる事ができない。
        取り敢えず現状では "}" で抜ける時にエラーを設定する事にする。

    5 done: 実は echo {aaa},bbb} は {"aaa}","bbb"} と解釈される様だ。
      初めの "," が現れるまでは "}" は有効でない。対応した。

    6 done: ctx-brace-expansion の入れ子について。対応した。

    7 done: CTX_PATN や CTX_BRAX との入れ子の関係について考える必要がある。

      | CTX_PATN 及び CTX_BRAX の失効の関係についてまとめる。
      |
      | CTX_VRHS  -> CTX_BRAX 不活性, CTX_PATN 不活性, CTX_BRACE? 失効
      | CTX_RDRS  -> CTX_BRAX 不活性, CTX_PATN 不活性, CTX_BRACE? 失効
      | CTX_BRAX  -> CTX_BRAX 不活性, CTX_PATN 不活性, CTX_BRACE? 有効
      | CTX_CONDI -> CTX_BRAX 有効, CTX_PATN 有効, CTX_BRACE? 失効
      | CTX_RDRF  -> CTX_BRAX 有効, CTX_PATN 有効, CTX_BRACE? 不活性
      | CTX_RDRD  -> 同上
      |
      | 伝播は CTX_BRAX, CTX_PATN, CTX_BRACE の間で行えば良い。
      | と思ったが、そもそも CTX_BRAX 及び CTX_PATN の内部での
      | ブレース展開を許可するのかは謎である。
      |
      | | うーん。取り敢えず CTX_PATN の下からは好きに CTX_BRACE に入れる様にする?
      | | と思ったが、CTX_PATN の呼び出し元として何が考えられるか。。
      | | うーん。現状では glob pattern が有効な ctx-command 系統の文脈に限っている。
      | | 従って、CTX_PATN の呼び出し元が何であれ CTX_BRACE に入って問題はない。
      | |
      | | 一方で、今後 ${var#pattern} に対応したことを考えると事情は複雑になる。
      | | この場合はブレース展開は無効にしなければならない。
      | | 一つの方法は、${var#pattern} における extglob 及び 角括弧式
      | | は別の文脈値を使って解析するという物である。
      | | ${var#pattern} の場合には CTX_VRHS CTX_RDRS 等の不活性処理が不要である。
      | | 一方で CTX_BRAX による不活性処理は必要である。うーん。然し…。
      | |
      | | そもそも CTX_PATN を抜ける条件である "}" をどの様に伝播するつもりだったか。
      | | もし CTX_PATN を抜ける条件として "}" が有効かどうかを確かめる手段を与えるのだとしたら、
      | | この 「"}" で終わるかどうか」を以てブレース展開が有効かどうかを判定できるはず。
      | | その様に考えれば、将来的に ${var#pattern} に CTX_PATN が対応するかどうかに依らず、
      | | 現状として CTX_PATN から CTX_BRACE に入るのを有効にして良い気がする。
      |
      | 現状では CTX_PATN からブレース展開はいつでも呼び出せることにする。
      |
      | 1 先ずブレース展開に入るときを考える。
      |
      |   CTX_PATN/CTX_BRAX が不活性の時、その原因は CTX_VRHS/CTX_RDRS/CTX_BRAX のどれかである。
      |   原因が CTX_VRHS/CTX_RDRS のときブレース展開は不活性にする。
      |   原因が CTX_BRAX のときブレース展開は通常通りに処理する。
      |   CTX_PATN/CTX_BRAX が有効のときは、何も考えずにブレース展開を有効にすれば良い?
      |
      |   但し、CTX_BRAX の親 nctx が CTX_CONDI の時にはブレース展開はやはり無効にする。
      |   CTX_PATN の親 nctx についてもチェックできるが、CTX_PATN は幾らでも入れ子にできるので、
      |   入れ子の階層によってブレース展開が有効になったり無効になったりするのは分かりにくい。
      |   仕方がないので、[[ @() ]] の中ではブレース展開は有効になるように解析する。
      |
      | 2 次に CTX_PATN に入る時を考える。CTX_BRAX も同様にできそう。
      |
      |   特に CTX_BRACE(不活性) から CTX_PATN に入る時はどうするべきか。
      |   不活性要因は CTX_RDRF, CTX_RDRD だが、両者とも基本的には CTX_PATN, CTX_BRAX は有効である。
      |   従って、CTX_BRACE(不活性) から CTX_PATN に入る時はそのまま CTX_PATN に入れば良い。
      |   CTX_BRAX に入る時も同様である。一方で、CTX_VRHS, CTX_RDRS によって CTX_BRACE が無効化されている時は、
      |   そもそも CTX_BRACE? の文脈に突入しないので考慮しなくて良い。
      |
      |   問題は CTX_BRAX -> CTX_BRACE(有効) -> CTX_PATN/CTX_BRAX となる時だが…
      |   CTX_BRACE になっている時点で外側の CTX_BRAX は分断されるので、
      |   bracket expression として有効なのかも分からない。
      |   従って、内部で CTX_PATN や CTX_BRAX が有効でも良いのではないかという気がする。
      |
      |   つまり、これに関しては何も考慮しなくて良い。という事にする。
      |
      | 表にする。
      |
      |   CTX_VRHS  -> ... -> CTX_PATN(不活性) -> ブレース展開 x
      |   CTX_VRHS  -> ... -> CTX_BRAX(不活性) -> ブレース展開 x
      |   CTX_RDRS  -> ... -> CTX_PATN(不活性) -> ブレース展開 x
      |   CTX_RDRS  -> ... -> CTX_BRAX(不活性) -> ブレース展開 x
      |   CTX_CONDI -> CTX_BRAX(有効)          -> ブレース展開 x
      |   CTX_BRAX  -> ... -> CTX_PATN(不活性) -> ブレース展開 o
      |   CTX_BRAX(有効) -> ブレース展開 o
      |   CTX_PATN(有効) -> ブレース展開 o


    CTX_PATN/CTX_BRAX の入れ子に関して表にしてみたが分かりにくい。
    やはり日本語でまとめる事にする。

    以下のとき、ブレース展開は無効となり通常文字列として読み取られる。
    - CTX_CONDI/CTX_VRHS/CTX_RDRS からブレース展開を試みるとき
    - CTX_VRHS/CTX_RDRS によって不活性化した CTX_PATN/CTX_BRAX からブレース展開を試みるとき
    - CTX_CONDI の直下にある CTX_BRAX(有効) からブレース展開を試みるとき
    以下のとき、ブレース展開は不活性となりブレース展開として有効になったときエラーを設置する。
    - CTX_RDRF/CTX_RDRD からブレース展開を試みるとき
    - 不活性の CTX_BRACE1/CTX_BRACE2 から入れ子のブレース展開を試みるとき
    その他のとき、ブレース展開は有効になる。但し、bash と違い以下の場合を含む
    - CTX_BRAX によって不活性化した CTX_PATN からブレース展開を試みるとき
    CTX_BRACE1/CTX_BRACE2 から CTX_PATN/CTX_BRAX に入る時は特別な処理は何も必要ない。

  * syntax: "{fd}>" 形式のリダイレクトで先読みに問題が生じる可能性? [無問題] [#D0621]

    echo {f,d}> a.txt を echo {fd}> a.txt に書き換えるとどうなるのか。
    うーん。実はこれは問題にならない。何故なら、
    {f,d} の場合には {f,d} まで一気に読み取るので、
    "," が消えると必ず解析再開点は "{" になる。

    問題はリダイレクトとして有効な形になった瞬間に、
    解析再開点が "{" 以前になることが保証されるかである。
    もう少し落ち着いて考える。リダイレクトとして有効な形でないとき、
    ある点でそれがリダイレクトとして有効でないという事が判明する点がある。
    上記の例で言えば "," の位置である。これより前の位置ではリダイレクトとして有効である。
    この時、 "{" から "," の直前の位置までの解析が 1 回で済んでいれば問題ない。
    そして実際にその様になっているかどうかについては…。
    現状では /\{[0-9a-zA-Z]+|[0-9]+/ の連なりは一気に読み取るので途中に解析再開点が設置されることはない。

    ブレース展開に新しく対応する際にも \{[0-9a-zA-Z]+ については
    一気に読み取るという事を変更しない様にすれば大丈夫のはず。
    例えば、その文脈でブレース展開が有効でなかったとしても、
    "{" 単体で読み取るということはせずに後ろに続く alnum も一緒に読み取るようにする注意が必要である。

  * syntax: for ((i=0;i<10;i++)) { echo; } が構文エラーになってしまっている。 [#D0620]
    ble_debug=1 で見ると (()) の直後は ARGX0 になっている。
    うーん。is_command_form_for=1 の設定がうまく伝播していないのが原因だろうか。
    調べてみると is_command_form_for=1 は設定されているが、
    実際に ble-syntax:bash/ctx-command/.check-delimiter-or-redirect に到達する事には消えている。
    関数の呼び出しのされかたについて勘違いをしているだろうか。

    と思ったら ble-syntax:bash/ctx-command の先頭で
    local is_command_form_for= が実行されている。これが原因だ。これを削除する。
    しかし、そうすると野に is_command_form_for という変数があった時に誤動作する。
    変数名は _ble_syntax_bash_is_command_form_for 等に変えるのが良いだろう。

  * syntax: [[ ]] の中で <>();|& の文字を使った場合は構文エラーにするべき [棄却] [#D0619]

    但し、 "<" ">" "(" ")" "||" "&&" 等の特別な単語の時にだけエラーでなくなる。
    と思ったが、改めて調べてみると "<" ">" "(" ")" "&&" は何れも単語を構成していない。
    Bash でエラーが出ている様に見えたのは、
    各演算子の使い方が誤っていたからである。

    だとするとそもそもこの項目を立てた時に実装していた
    CTX_BRAX の方で不整合が生じているかもしれないので確認する必要がある。
    特に [aa&& でちゃんと && 演算子の手前で CTX_BRAX から抜けるだろうか。
    →これは特に対策もしていないので抜けるはずである。実際に確かめてもそうなっている。
      特に問題にはならなそうである。

  * 条件コマンドの比較の右辺で怪しいところが幾つかある [#D0618]

    $ grc '== \$[^'\'']'
    修正した。色々バグっていた気がする。

  * 2017-11-14 syntax: 後 !; は履歴展開ではないはずなのに履歴展開と解釈されている[保留] [#D0617]
    と思ったが、文脈によって履歴展開だったりそうでなかったりしている気がする。
    どうも履歴展開と解釈されてはいるが、必ず展開に失敗する?

    これは気にしなくても良いという事にする。

  * syntax: *? 等の文字は extglob の時にしか着色されない [#D0616]

    | また ble-syntax:bash/.update-_ble_syntax_bashc が extglob の変更に際して呼び出されていない。
    | →これは #D0615 で取り扱う。

    これは取り敢えず現在取り掛かっていることが終わってから対処する。

    多分、これは単に _ble_syntax_bashc で [ の他に * や ? も含める様にすれば良い。
    変更した。動いている。多分大丈夫だろう。

  * syntax: shopt -u extglob にしても _ble_syntax_bashc が更新されない [#D0615]

    これは _ble_syntax_bashc の変更条件は histc12 及び shopt -q extglob で決まるのに、
    ble-syntax:bash/cclass/update の呼び出し元で勝手に histc12 だけで呼び出しを判定している為である。
    無条件に ble-syntax:bash/cclass/update を呼び出す様にすれば良い。

    更に ble-syntax:bash/.update-rex_simple_word も、
    ble-syntax:bash/cclass/update の内部で更新が実行された時に限り呼び出す様にする。

  * syntax: hist1, hist2, hist12 等の変数は bash 固有である [#D0614]

    これはローカル変数として管理するのではなく、
    グローバル変数として _ble_syntax_bash_* にした方が良い。
    現在は bash 決め打ちで initialize-vars の前に、
    local "${_ble_syntax_bash_vars[@]}" しているが、
    別の言語を用いる際に動かない。

    もしくは、言語に依存したローカル変数を定義できる仕組みを提供する。
    本来はローカル変数を定義できる仕組みにするのが良い気がするが、
    設計がより複雑になる割にそんなに必要性があるか分からない。

    解析をしている途中に更に別の解析を開始する等の事をしない限りは
    グローバル変数にしていても特に問題にならない気がする。

    →取り敢えず直した。_ble_syntax_bash_hist12 というグローバル変数に入れる事にした。
    hist1, hist2 は実際に使うときに _ble_syntax_bash_hist12 の部分文字列として得る。
    また histstop についても _ble_syntax_bash_histstop という変数にした。
    ローカル変数は廃止した。

2017-11-22

  * syntax: 変数代入に於ける pattern で入れ子 @(@()) の内側が不活性になっていない [#D0613]

    これは var=@(aa|[bracket]) の [] も同様である。

    これは ble-syntax:bash/check-glob で
    ((ctx==CTX_PATN)) の分岐以下で attr を補正しているところを参考にすれば良い。
    というかこの部分をより前方に持ってくれば済む話なのでは?

    - ctx=$attr という ntype は検索しにくいので ctx:$attr などに変える。
    - また ctx:$attr ではなく ctx:$ctx にする。
    - CTX_PATN を nest-push している箇所で ntype を確定させる。

    これは #D0612 の対応に際して統合的に対応した。

  * 2017-09-06 ble-syntax: echo ${a#[!0-9]} は履歴展開ではない [#D0612]
    どうやら "echo [!1 " と入力しても展開されない。[ の中は (対応する ] がなくても) 履歴展開は無効ということ。

    実は、もう少し試してみた所、以下は何れも履歴展開となった。

    $ echo [a!a
    $ echo [a!a]
    $ echo [[!a

    1 つまり、[! の組み合わせで始まる range expression だけ特別扱いする。
    2 range expression の中で [! の組み合わせは特に特別な意味は持たない。

    ということ。しかし、それでも [! が特別な意味を持つかどうかの判定の為に、
    結局、現在 range-expression の中にいるかどうかの判定は必要になる。

    これに対応するには、やはり新しい文脈に対応するのが良い様な気がする。
    思うに $(()) と類似の文脈にするのが良いだろうか。
    というより $(()) と違って入れ子も考えなくて良いし、より簡単な気がする。
    或いは case のパターンの中と同様の文脈と考えても良いかも。
    但し空白・delimiterは来ない。これは丁度 ctx-command の check-word-end/is-delimiter で良い気がする。
    と思ったが、これは呼び出し元の文脈に依存する。例えば ${a#[a ]} などの場合には
    其処で bracket expression が終わったりはしない。これは ntype か何かで記録する事にする。

    うーん。然し、条件コマンドとの区別がややこしい。
    或いは条件コマンドをチェックして、それから [ をチェックする様にすれば良い気もする。
    例えば [[ の直後に文字列末端または delimiter が来る時には条件コマンドとし、
    それ以外の時には nest-push する。

    nest-pop が同じ点で起こっても良いのだったか。これは確かめる必要がある。
    nest-pop は tree-append により情報を登録している。
    tree-append は word の登録にも使う。つまり同じ位置で複数の tree-append が来ても良い様にできている筈だ。
    問題は tree-append を複数回出来るとしても nest-pop が同じ位置で
    一回しか呼び出されない的な仮定がないとは言い切れないことである。

    角括弧式の中で何が有効なのかについて調べる。

      $ echo [@(a|\*)]
      * @ a

    これを見ると角括弧式の中では extglob も含めて意味を失う様である。
    但し、quote は意味を失わない。

    [実装1] ctx-command での実装

    先に ctx-command から入った場合について実装することにする。
    取り敢えず nest-push について実装する。

    何が何だか分からなくなってきたので取り敢えず
    ntype は気にせずに ctx-command から入った時の終端方法で実装して動作確認する。
    その後で様々な場合に対応する事にする。

    x fixed: 空白や文字列末端で終端していない。
      check-word-end の is-delimiter が効いていないのではないか。
      実装仕掛けの ntype チェックで引っかかっていた。

    x fixed: stackdump が出る。
      これは check-word-end で nest-pop した時に、
      更に外側の check-word-end を呼び出さなければならないのを抜かしたのが行けない。
      nest-pop が二重に起こる場合も含めて動いているように見える。
      ただ、この方法が設計上良いのかどうかは分からないが、取り敢えず。

    x fixed: [!a*] などで * がエラーになっている。
      これは glob の入れ子を許可する様にすれば良い。
      直した。echo [a*] や echo [!a] は OK。
      取り敢えず echo [![!a] も期待通りに解析されている。
      echo [!a@(aaa|bbb)] は着色が変な事になっているが、
      これについてはまた後で実装しなおせば良い。

    [実装2] 呼び出し元文脈に依存した振る舞い

    次に角括弧式を抜ける位置をどの様に特定するかについて考える。
    現在の実装では常に ctx-command から呼び出されたと思って角括弧式を抜けている。
    しかし、実際には角括弧式に入った時の文脈によって色々である。

    % * ntype はどうするのが良いか。
    %
    %   nest-push "$CTX_BRAX" する時の ntype はどうしたら良いか。
    %
    %   - "]" が現れる前に中断される時にどのタイミングで中断するかを見るためには、
    %     やはり呼び出し元の ctx が必要になる。
    %   - また内部で CTX_PATN を実行する時には不活性にしなければならない。
    %
    %   従ってやはり ctx=$ctx を ntype にして伝播させるのが良いだろう。
    %   もう一つの方法は type=command だとか type=vrhs だとかであるが、
    %   これは CTX_PATN 等との兼ね合いを考えると面倒である。
    %
    %   よく考えてみると、CTX_PATN と混ざってくるとより面倒な事になる…。
    %   CTX_PATN の場合は不活性にするかどうかは一番最初の呼び出し元が CTX_VRHS かどうかで決まる。
    %   或いは、途中で CTX_BRAX になってその中で CTX_PATN を呼び出した時にも不活性になる。
    %   一方で、CTX_BRAX の読み取り方の制御はどの様に行われるかというと、
    %   一番最初の呼び出しにおける文脈に依存する。
    %   しかし、CTX_PATN と同様に不活性になった時の色にも注意しなければならない。
    %
    % 現在の実装では突入時の文脈を指定する事にしているが、
    % この方法で問題ないだろうか。
    %
    % - [] の中で更に [ や @(...) や * がある時にはどうするのか?
    %   [ は無視する。@(...) は着色せずに読み取りを実行する。
    %   * や ? は *() や ?() になっているかもしれないので、読み取る。
    %
    % うーん。実は一つ上の階層の ctx を考慮して CTX_BRAX の終端を判定すれば良いのではないだろうか。
    % そして、それとは独立に着色のために ctx= を用いるのが良いのではないだろうか。

    当初の考えでは入った時の文脈の種類に応じて ntype を設定して、
    ntype に応じて CTX_BRAX の中で処理を切り替えるという事を考えていた。
    しかし ntype は CTX_VRHS CTX_BRAX の下に入れ子になっている時に、
    着色を無効化する為に用いたいので、別の方法を考える。

    | 別の方法と言っても入った時の文脈を nest 情報から抽出するという事である。
    | ※実のところこの nest 情報は入った時の文脈というよりは、
    |   抜ける時の文脈といった方が正確である点には注意する。
    | 入った時の文脈を取得する関数として ble-syntax/parse/nest-ctx を作った。
    | 今までこれがなかったのは不思議であるが、便利そう。
    |
    | これを使って文脈を取得し、特別な文脈以外では ctx-command 由来として処理する。
    | さて、どのような文脈で CTX_BRAX が nest-push されるだろうか。列挙する。
    | 現在 CTX_BRAX を nest-push しているのは check-glob のみであり、
    | この check-glob を呼び出している箇所は以下の通り。
    |
    | - ble-syntax:bash/ctx-command (色々)
    | - ble-syntax:bash/ctx-values (CTX_VALI)
    | - ble-syntax:bash/ctx-redirect (CTX_RDR[FDS])
    | - ble-syntax:bash/ctx-conditions (CTX_CONDI)
    | - ble-syntax:bash/ctx-globpat (CTX_PATN)
    | - ble-syntax:bash/ctx-bracket-expression (CTX_BRAX)
    |
    | この内、ctx-command ctx-redirect は同様に扱って問題ない。
    | 残っているのは全て単一の文脈値なので直接比較して問題ない気がする。
    | 一つずつ見ていく事にする。
    |
    | - CTX_VALI の場合は、実は ctx-command と殆ど同じ扱いで良い気がする。
    |   但し、")" が来たら終わる。でも ")" が来たら終わるのは ctx-command でも同じ。
    | - CTX_CONDI の場合は、
    |
    |   % ctx-command と似ているが少し処理を変える必要がある。
    |   % 空白を除く delimiter つまり ()<>;|& が単語に含まれることが許されている。
    |   % これらは例えば "()<>;|&" を chars から除いて処理すれば良いのだろうか。
    |   % 念のため確認する。[...] の中に delimiter の文字が現れても良いのだろうか
    |   % →と思って試したら構文エラーになる。というか [...] の中でなくてもエラーになる。
    |
    |   改めて考え直す。先ず "()<>;|&" を含む単語で許されているのは、少数の物のみであり、
    |   更にそれらに "[" が含まれる事はない。従って、()<>;|& が現れた時点で [...] を抜けて良い。
    |   外側で自動的にエラーが設定されるだろう。また、空白類が来た時も [...] を抜ける。
    |   結局、CTX_VALI と同様に ctx-command と同じ処理をすれば良い。
    | - CTX_BRAX から check-glob を呼び出した時は nest-push が起こらない。
    |   つまり nctx が CTX_BRAX になる事はない。
    | - 結局特別な取り扱いをする必要があるのは CTX_PATN だけの様だ。
    |   CTX_PATN では < や > が単体で現れる事が許される。
    |   これは [] の中でも同様なのだろうか。どうも許される様だ。
    |
    |   さて、@([a|b]) はどの様に解釈されるのか?
    |   →調べてみると @(["a|b"]) と解釈されている様だ。
    |   @([a b]) は @(["a b"]) と解釈されている。
    |
    |   @([a()b]) は @(["a()b"]) と解釈されている。
    |   @(a|[) はどうも構文解析はうまくいくがパス名展開は失敗している。
    |   何れにしても ")" が現れた所で終わるという解釈で良さそうだ。
    |   うーん。つまり、[...] の中でも () の入れ子を追跡しなければならないという事。
    |   (後のパス名展開で失敗するかもしれないとしても、構文解析上はそうなっている気がする。)

    まとめる。CTX_BRAX による読み取りの判定は nctx を用いて行う。
    - nctx を取得するためのシェル関数 ble-syntax/parse/nest-ctx を追加した
    - nctx が CTX_PATN の時以外は、ctx-command から呼び出したと考えたと時と同様の処理で良い。
    - nctx が CTX_PATN の時は、) が来たら終わる。
      ( が来たら nest-push して入れ子を数える。
      その他の文字 (|<>*?@+!) は単に [...] に含まれる事が許される。

    x fixed: echo @([a|b]) で | の着色がエラーになっている。
      これは特別に追加する必要があった。
      他の文字 (*?!+@) は check-glob で着色される
      (extglob ならピンク、extglob でなければ黒) ので必要ない。

    [実装3] CTX_PATN と CTX_BRAX の入れ子について再確認

    | * CTX_BRAX の中で CTX_PATN になって更に "[" に出会った時にはどうするのか。
    |   調べてみると、"[" を bracket expression と認識している様子だ。
    |
    |   echo [@(aaa|[!a])] は履歴展開が無効だが、
    |   echo [@(aaa|[a!a])] は履歴展開が有効になる。
    |   つまり [! の組を認識している。
    |   と思ったが、実は echo [[!a]] も履歴展開は無効だし、
    |   echo [![!a]] も履歴展開は無効のようだ。
    |   一方で echo [[!a や echo [!a は履歴展開が有効になる。
    |   つまり bracket expression が閉じていれば [! の組の履歴展開は無効で、
    |   bracket expression が開いていれば [! の組でも履歴展開は有効になる。
    |
    |   従って、CTX_BRAX であっても [! は認識するべきである。
    |   但し、CTX_BRAX の時には nest-push はしないという事にする。
    |
    | * echo [![!a]] はどのように組まれるか?
    |   実際にファイル名に一致させて試すと
    |   echo [!"[!a"]"]" と解釈される様である。
    |   つまり、[!...] の入れ子は考慮に入れられないが、
    |   "[!" の組で履歴展開にならないということだけは処理される。
    |
    | * やはり [@(...)] の中で更に [...] があった時の解釈が分からない。
    |   ファイル名に一致させてみると echo [@([aaa])] は、
    |   echo ["@([aaa"]")]" というパターンになっている様である。
    |   これは実際の解析のまとまりとはばらばらの様に思われる。
    |   うーん。つまり最初の切り出しは ["@([aaa])"] となるが、
    |   実際の解釈では ["@([aaa"]")]" となるという事である。
    |   これは ble.sh の解析の枠組みでは直接取り扱えない。
    |   つまり着色は ["@([aaa"])] のまとまりで行いつつも
    |   残った ")]" の部分についてのエラーは
    |   ["@([aaa])"] の構造があるとして抑制しなければならない。

    - [...] の入れ子は考慮に入れられない。
      つまり "[" の登場に拘らず "]" の登場ですぐに閉じる。
    - [...] の中でも [! の組は履歴展開の ! とは認識されない。
      つまり、入れ子の勘定には入れないが、"[!" の組は認識している。
    - [...] の中でも extglob @(...) のまとまりは有効である。
      但し、元の意味は失う。つまり、解析にだけ考慮される。
    - [...] の中で @(...) があって、更に中に [...] があった時の解釈は厄介である。
      例えば [@([abc])] の場合には、
      構文構造としては [@([abc])] のまとまりで切り出されるが、
      最終的なパス名展開の適用に際しては [@([abc] のまとまりで切り出されてしまう。
      これについては構文構造を優先して着色する事にする。

    この辺りの振る舞いについては現在の実装で問題ないはずである。
    問題は @([(...)]) の場合に () の入れ子を処理する必要がある事である。
    check-glob を弄って ctx==CTX_BRAX の時も入れ子を数える様にする。
    取り敢えず色はさておき、構文構造は正しく解析できる様にする。
    取り敢えず対応した。

    [実装4] 入れ子になっている時の色の伝播に関して。

    % 改めて CTX_PATN が関わってくる場合を考える。
    % CTX_PATN の中で更に [...] がある場合には、
    % [... の不完全終端は CTX_PATN の終端と同じにする。
    % 一方で、着色に関しては CTX_PATN と同じ色にすれば良い。
    % 但し、CTX_PATN の nest の時には別の色にしなければならない。

    | 変数代入の右辺でどうなっているか。
    |
    | $ echo=[a] # → パス名展開は起こらない。
    | $ echo=[!a] # → 履歴展開されない。パス名展開も起こらない
    | $ echo=[a!a] # → 履歴展開される。パス名展開も起こらない
    |
    | つまり、解析としては [!...] を拾っているが、
    | パス名展開は起こらないと考えて良い。
    | 現状の @(...) と同様に nest-push して解釈はするが、
    | 着色はしないというように処理すれば良い。

    変数展開の下の glob パターンは、全て解析はするが着色は無効化する。

    うーん。特に色を無効化させるのであれば、
    色を外側から伝播させれば良い様な気がする。

    CTX_VRHS から下はどう頑張っても全て無効化
    同様に CTX_BRAX から下はどう頑張っても全て無効化。
    それ以外の時には nest の括弧は無色。それ以外は着色。

    さて、現在 ntype=nest は他の用途で使われているだろうか。
    どうも、ここで色を決定することにしか使われていない様だ。

    ntype の意味を次の様に定める。
    1 ntype='nest' の時はその括弧及び内側の | は特別な色をつけない事を意味する。
      更に内側の [...] や @(...) は有効になる。
    2 ntype='ctx=...' の時はその括弧及び内側の | はその ... で着色する事を意味する。
      更に内側の [...] や @(...) に対してもその塗り潰しは継承する。

    取り敢えず実装した。

    * supported: here string でも glob/bracket は無効化されるべき。

    [実装5] 後は新しく生じた不整合を解決する。

    x fixed: [[ が無効になっている。

      これはどの様に対応するべきか。
      先ず初めに [ の直後に [ がある場合はそれも一緒に読み取ってしまう?
      しかしそうすると今度は [[! の場合に其処まで読み取らなければならない。

      というかそもそも現状はどの様な状態なのだろうか。
      '[[' の部分を見ると i=$wbeg ble-syntax/parse/nest-push している。
      これはつまり単語の開始点が現在の解析 step の開始点以降である事を前提としている。
      現在の実装だとその仮定が崩れてしまっている。

      正しく実装し直す為には、nest-push の点をずらすか、
      或いは [[ の連なりは一度に解析できる様に修正するか。
      取り敢えず [[ の連なりは一度に解析する様に修正する。
      これは直した。

    x fixed: simple word で [] が許されなくなっている。
      これは _ble_syntax_bashc_simple に "[" が混入していたのがいけなかった。
      _ble_syntax_bashc_simple を _ble_syntax_bashc[CTX_ARGI] と独立に生成する様にした。

  * syntax: プロセス置換が @(<(echo)) で認識されていない。 [#D0611]
    角括弧式対応の途中で気付いた。
    これは元からあった問題である。修正した。

  * edit (command-help): quote されていると駄目 [#D0610]

  * edit (command-help): function, until が引っかからない。 [#D0609]

  * 2017-11-14 complete: コマンドの補完候補に出てくる functions とは何だろう [#D0608]
    実際には見つからないし実行できない

    →これはどうもディレクトリ functions が一致している様だ。
    所で、functions まで入力して TAB を押しても functions という候補が二重に出ている所為で補完できない。
    他のディレクトリ名についても同様の様である。

    重複を除く様にしてみたがそれでも 2 つ出て来る。
    異なる source から複数現れているのだろうか。
    と思って調べてみた所、ble-complete/source/command から 2 つ現れている。
    ble-complete/source-command では sort -u する様にしたはずなのにおかしい。
    と思ったら、ble-complete/source/dir が明示的に呼び出されている。

    しかし、そうだとしても不思議だ。shopt -s autocd は有効になっていないので、
    前者からは候補が出てこない筈である。

    うーん。と思ったら、どうも compgen -c -- foo で
    foo がディレクトリ名に厳密に一致している場合、
    foo も補完候補として表示されてしまうのだという事が分かった。
    これはどの様にしたら良いか。

    また、実際に補完候補が確定した時の振る舞いについても考える必要がある。
    例えば、確定された単語がディレクトリ名だったら / を後置する様にするなど…。
    しかし、コマンド名とディレクトリ名が被る場合はどうするのか謎である。
    mkdir grep として調べてみると、どうやら実行する時にはコマンド名の方が優先される様だ。

    a 一つの方法はディレクトリ名としての候補の場合には予め / を後置する様にする。
      確定した単語が / で終わりかつ実在するディレクトリ名だった時には、
      そのまま確定する。それ以外の時には空白を空ける。

      これだと / で終わる名前のシェル関数とディレクトリ名が同じ時に、
      本来はシェル関数の方が呼び出されるはずなのにディレクトリ名として解釈されて、
      空白が後ろに付加されない。しかし、まあ妥当な振る舞いの範疇だろう。

    - 同様に autocd によって列挙されるディレクトリ名の場合にも / を後置する。
      その様にしないと既存のコマンド名とディレクトリ名が被っていた時に、
      ディレクトリに移動しようとしてもコマンドを実行してしまうからである。

    適当に実装した。

    - 実は shopt -s autocd かどうかには依らずに、ディレクトリ名は foo*/ で生成すれば良い。
    - foo というディレクトリがある時に compgen -c -- foo で foo が列挙されてしまう問題については、
      workaround として "cand がディレクトリ名であって該当するコマンドが見つからないとき、
      その候補を除去する" という処置を取ることにした。

  * syntax: declare, local, の類が予約語の色になっている。 [#D0607]
    修正した。と思ったら、今度は declare の上での変数名の補完が効かなくなっている。
    ble_debug=1 で見てみると declare の直後の文脈が通常のものに戻っている。
    と思ったら、is_keyword でない時には後で ctx=ARGX に上書きされて、
    通常の引数のための処理が行われている。

  * complete: echo echo などのように二重に候補が出るのは何故か。 [#D0606]

    これは compgen -c -- echo の時点で再現する。
    どうも組み込みコマンドの echo と通常コマンドの echo が両方一致している?
    しかし、grep の場合も同様に二つ表示される。と思ったが、これの場合は alias だ。

    取り敢えず sort -u を呼び出すことにしたが、
    実は compgen に重複を発生させないオプションが合ったりするかもしれない。
    と思って man bash を見るがやはり complete と共通のオプション以外はない。
    そして complete には重複を除くなどのオプションはない。
    結局自前で sort -u を呼び出すようにしなければならない。

2017-11-21

  * 2017-11-11 complete: time の次に来るコマンド名で補完ができない。 [#D0605]
    これは恐らく文脈値を増やしたのにそれを追加していないのがいけない。

    これは調べてみた所、time -p command まで一度に解析する様にしているのが原因である。
    コマンド名の先頭に stat (ctx) が設置されていないのが原因である。
    現在の補完の枠組みでは ctx を使っているので、これでは補完候補を生成できない。

    或いは、コマンドの候補を生成する時には先頭が "time [-p]" になっていれば、
    その部分は削って候補生成を行うという様にも出来るが、
    それは実装として汚い気がする。やはり新しく文脈値を導入するほうが良さそうだ。

    →これは #D0604 の対応と共に実装した。

  * 2017-11-14 syntax: time -p -- echo hello (bash-4.2 以降) [#D0604]

    実は time -p -- echo hello とできる。
    time -- echo hello はできない。
    調べてみると、これは bash-4.2 以降の以降である。
    bash CHANGES にもちゃんと書かれていた (bash-4.2-alpha/3.r)。

    これに関しては途中に解析再開点を設置する様にしたいので、
    やはり文脈値を拡張して対応することにしたい。
    文脈値の拡張に関しては CTX_CARGX1 などを参考にするのが良い気がする。
    in 等の代わりに -p が特別な意味を持つようにする。

    取り敢えず CTX_CARG{X,I}{1,2} を複製する形で CTX_TARG* を作った。
    然し、実際の処理はもっと異なる形になるような気がする。
    一つずつ CTX_TARGX1 から順に対応していく事にする。

    少し対応した所で整理した。と思ったら完成していた。
    取り敢えず動いている。

  * 2017-09-05 syntax: function hello (()) は bash-3.0 では構文エラー。 [#D0603]
    →どうも調べてみた所 bash-4.1 まで使えなかった様だ。bash-4.2 以降で使える。

  * 2017-09-05 syntax: function hello (()) としておいて function hello () (()) にすると解析が誤っている。 [#D0602]
    これは新しく導入した set-lookahead 2 で簡単に直った。

  * 2017-11-14 syntax: echo $(echo > ) において $() が閉じていないとなっている。 [#D0601]

    元々 > の次に ) が来た時点で構文エラーなのだから、
    ")" がどう取り扱われようと勝手なのかもしれないが、

    - やはり直観としてはエラーは > の手前で止まってほしいし、

    - 例えば、長いコマンドの最初の方の $() の中にリダイレクトを追加する時、
      一瞬この様な状態になったことで部分更新が働かなくなるのも嫌である。

    従って、> において ) が現れたらその手前で nest-pop
    をするという訳には行かないだろうか。

    nest-pop/tree-append の都合で 1 文字以上進んでからしか pop できないと思ったが、
    よく考えてみれば、check-word-end 辺りで確認を行って、
    次に delimiter が来ていればエラーを設置すると共に、nest-pop すれば良い。

    と思ったが、調べてみると実際にその様な実装になっている。
    何故だろう…と思ったら、そもそも単語が始まっていない時には nest-pop は実行されない様だ。

    a それなら、単語を構成する文字が見つからない場合には初めから nest-push しなければ良い、
      と考えたが、駄目だ。先読みしてしまうと部分更新の時に破綻してしまう。
      先読みした分だけ呼び出し元で単語の設置などしてしまうと、
      結局新しい文脈を使って解析している意味がない…というか、
      プロセス置換などの構成を使っている時に対応がどんどん面倒になってくる。

    b 或いは、次の一文字だけなら読むことを許されているのだから、
      次の一文字が許される文字だったならば nest-push する。
      そして、CTX_RDRF 等の文脈において失敗したならば、

      と思ったが、次の一文字だけを見るのだと [<>] がいる時に、
      それがプロセス置換 [<>](...) の一部かもしれないので、
      受け入れざるを得ない。従って、[<>] の時は nest-push する。

    さて。nest-push するところを修正したらすぐに大丈夫になった。何故?
    よく見てみるとリダイレクトの後に続く空白類は既に
    redirection の始まりの記号の一部として読み取っていた。
    従って、直ぐに単語が始まる状態になっていたのだった。
    なので単語に突入しないという状態にはならない。

    [プロセス置換の先読み問題]

    例外はプロセス置換の時である。
    将来的にプロセス置換を構成するかもしれない < が単体で入力された状態の時、
    一体どのように解釈されるべきか。

    というか ble-syntax:bash/ctx-redirect/check-word-end で2文字以上先を参照しているが良いのだろうか。
    % うーん。どうやら > A<(B から A<B に化ける時には、直前の再開点は < であり…と思ったが、駄目だ。
    やはり問題になる気がする
    →現実に問題になることを確認した。
      先ず echo >A<(echo) の状態にしておいて ( と ) を削除すると、
      echo >A<echo において、"<" の位置でエラーという事になる。
      一方で、普通に echo >A<echo とすると構文エラーにはならない
      (但し、echo というファイルは見つからないというエラーにはなる)。

    これはどの様に処理するべきか。

    a 一つの方法は先読みの文字数を 2 文字にするということ。

      広範な変更が必要になりそう。
      また、解析再開が非効率になるのが気になる。
      実際どの程度非効率になるのだろうか。

      それに解決策としては余り綺麗でない気がする。
      例えば、今後 3 文字先読みが必要になったら、
      全体で 3 文字の先読みを許容するようにするのか? 際限がない。

    b 或いは、先読みをした時にはその文字数を記録する。

      % 因みに、読み取りの終端位置を決めるのに、
      % 例えば [[:alnum:]]+ 的なことをするので、
      % 実質必ず 1 文字以上先読みはしているような物である。
      % ただ、物によっては $(( など、それ以上一度に読み取らないというものもある。

      この方法が良い様な気がする。
      但し、stat に新しい要素を追加する事になる。
      stat に要素を追加する時の方法について確認する必要がある。

      また、今回の問題の解決に実際に使わないとしても、
      今までの実装を考えると先読みの文字数を指定できる様にすると大分楽になる気がする。
      実のところ、今までの方法では "先読みをした場合には、先読みされた部分まで一気に解析する"
      または "先読みした時にはそこには解析再開点は設置しない" という方法を取っていたので、
      実のところ解析の効率が落ちるということもない気がする。

    c もう一つの方法は "曖昧な状態" を表す文脈を用意するということ。

      しかし、これは <( の直前に現れる可能性のある文脈値全てについて、
      その種類が倍化するので始末が悪い気がする。
      或いは、別の変数を使って曖昧な状態を表現するとしても、
      それは結局 b と等価になるのではないだろうか。
      寧ろ、b よりも間接的なので分かりにくい。

    d 実のところ解析再開点を設置しないという対策だけで良いのではないかという気もしてきた。

      問題点は何かというと、現在の補完の枠組みでは解析再開点を用いて補完候補生成方法を決定しているので、
      解析再開点を省略するとそこから始まる単語について補完候補の生成を行うことができない事にある。

      現在の補完の枠組みは、解析再開点を用いるのではなく単語などの情報を用いるように変更するべきの気がする。
      と思ったが、結局単語の詳細な情報はその単語の読み取りを開始した時の文脈値に依存する。
      結局、解析再開点の情報も必要になるのではないか。

      或いは、"無効化した解析再開点" の様なものを用意して、
      そこにおける文脈値だけを記録するという手もある。

      やはり先読みの文字数を設定できるようにした方が柔軟な気がしてきた。
      また、解析再開点を設置しない方法だと、先読み位置以降・次の再開点以前の範囲で変更があった場合に、
      本来必要のない再解析をすることになる。更に先読みが続くと解析再開点が連続で設置されないという事になる。

    やはり先読みの文字数を記録する b の方針で考える。
    比較的大きな書き換えになるし、ちゃんとできるか分からないので取り敢えず commit を切る。

    [書き換え]

    1 解析変数の追加

      前回 nparam を書き換えた時と同様に行えば良い。
      注意点としては nparam は空文字列になりうるので、
      _ble_syntax_stat に格納する際には空文字列は none に置き換えるか、
      或いは nparam の前に新しい変数を挿入するかである。

      新しい変数を導入する度に nparam の位置が変わるのは始末が悪いので、
      空の nparam は none に置き換える事にする。
      これは _ble_syntax_stat に格納・から読み出すところで弄れば良い。
      と思ったら初めからそのような実装になっていたので問題ない。

      nparam の次の解析変数として lookahead を追加する。
      調べてみたが新しい解析変数の追加はそれほど大変ではないようだ。
      初期化と保存と ble_debug による出力に対応すれば良い。

    2 次に lookahead を見て解析再開点を決定する様にする必要がある。

      現在の実装では parse の以下の部分で決定している。

      | # 解析予定範囲の更新
      | local i1 i2 j2 flagSeekStat=0
      | ((i1=_ble_syntax_dbeg,i1>=end0&&(i1+=shift),
      |   i2=_ble_syntax_dend,i2>=end0&&(i2+=shift),
      |   (i1<0||beg<i1)&&(i1=beg,flagSeekStat=1),
      |   (i2<0||i2<end)&&(i2=end),
      |   (i2>iN)&&(i2=iN),
      |   j2=i2-shift))
      | if ((flagSeekStat)); then
      |   # beg より前の最後の stat の位置まで戻る
      |   while ((i1>0)) && ! [[ ${_ble_syntax_stat[--i1]} ]]; do :;done
      | fi

      先ず flagSeekStat とは何だろう。
      というか何故 i1 end0 _ble_syntax_dbeg, _ble_syntax_dend など色々あるのか。
      コメントに書かれていた。_ble_syntax_d* は前回の解析でやり残した部分を記録する。
      先ず初めに i1..i2 に前回の解析でやり残した範囲を読み込む。
      その後で今回の文字列の編集範囲を用いて i1..i2 を更新する。
      flagSeekStat は、今回の文字列の編集範囲によって解析を開始することを示す。
      flagSeekStat が立っていないとき、前回の解析中断位置から再開するが、
      必ず stat が設定されている位置で中断される (予定) なので、わざわざ解析再開点を探す必要がない。

      lookahead によるマージンを取るのは flagSeekStat の中で判定すれば良い。
      実装した。取り敢えず既存の解析再開の仕組みは動いている様に見える。

    3 後は、折に触れて lookadhead を更新すれば良い。

      lookahead の更新はただ代入するのではなくて、
      前の値よりも大きい時に更新するという様にする。

      そうすれば一回の解析の間に複数箇所で先読みをした時に対応できる。
      元々2文字以上の先読みを実行する箇所は少ないのだから、
      このぐらいのチェックで遅くなるということは考えにくい。
      従って、速度については気にしなくて良い。

    と思ったが、実のところ一回 lookahead を設定した後に、
    解析位置が進んだ場合にはどうするのだろう。
    その場合には lookahead を再び clear しなければならない。
    改めて lookahead の方法について考える。

    a 一つの方法は必ず解析の最後で lookahead を設定するという事である。
      その様にすれば lookahead の位置がずれる事はない。
      しかし、問題点は check-process-subst 等で一致するかどうか参照しているが
      引っかからなかったという時に lookahead をどう設定するのかということである。
      或いは、引っかからなかった時には lookahead は設定しなくても大丈夫だろうか。

      実のところ 2 文字ならば lookahead は設定しなくても大丈夫である。
      何故なら 1 回の解析で少なくとも 1 文字は進み、
      更に少なくとも 1 文字の先読みが存在するので、
      もし失敗して別の方法で進む場合には 2 文字まで先読みして大丈夫である。

      では任意の文字数先読みすることは可能なのだろうか。

      % もしかするとそもそも先読みがなかったことにできるという可能性もある。
      % 例えば <() について考える。今 <a 等の様になっていたとする。
      % この時一致は失敗して < 単体に後で引っかかる。
      % ここで先読みがなかったことにするとどうなるだろう。
      % "<(a" の様に "(" を挿入したとする。実際のところ a まで見て一致しないと判定したのに、
      % 解析再開の際には "<" の部分に変更がないからという理由で、
      % 前回の解析結果が採用されて、今回も一致しないという様になってしまう。
      % この例の時には、実際には > が読み取られてその次の文字まで先読みになるので問題にはなっていなかったが、
      % 3 文字以上に渡る先読みの場合にはやはり問題が発生する。

      一致に失敗したとしても先読みして動作を変更したのであれば、
      それを記録しておかないと後で不整合が起こってしまう。

      x 先読みの長さに関する制限もある。

        前回の解析ステップで先読みした長さを、
        次の解析ステップでは必ず全て取り尽くさなければならない。

        何故なら、解析再開点の決定では文字列変更範囲より前の再開点で、
        一番最初に見つかったものを採用するからである。
        もし前回の解析ステップの先読みを取り尽くさないと以下のような場合に問題になる。

          aaaaaaXa 文字列と編集位置
          +------- 解析再開点1 + 先読み
            +---   解析再開点2 + 先読み

        X の位置で編集が起こった時、本来であれば解析再開点1 から解析を再開しなければならないが、
        実際には最初に見つかった解析再開点2 から解析が再開されてしまうことになる。

    b もう一つの方法は、現在は lookahead を "何文字先か" で管理しているが、
      実際の解析の過程では "先読みした最後の位置の index" を管理する様にする。
      _ble_syntax_stat に記録する時に何文字先かの情報に書き換える。

      | すると shift の対象になるのではないかとも考えたが、shift はしなくてよい。
      | % というかむしろ shift するべきではないと思われる。
      | lookahead を設定するのは再開点と先読み点の間で変更があった場合に、
      | 解析再実行範囲を再開点まで拡張するために用いられる。
      | もし文字列変更範囲が再開点よりも前にある時には shift は必要ない。
      | 文字列変更範囲が先読み点よりも後にある時にはやはり shift は必要ない。
      | 文字列変更範囲が被っているとき、
      | 再開点が文字列変更範囲に含まれる場合にはそもそもその再開点は消滅するので気にしなくて良い。
      | 再開点と先読み点の間で文字列変更範囲が始まっている場合には shift してもしなくても、
      | その再開点は使えないということが計算して分かる。
      | なので、shift の機会があるとしても shift してもしなくても何も変わらない。

      [結論] shift の必要はない。

      % 或いは、寧ろ "何文字先まで見たか" を記録する為だけに "先読み点" を計算していたのであって、
      % 飽くまで "何文字先か" という情報なのだと思えば自然かもしれない。
      % と思ったがこの考え方はやはり安易な気がする。

      この方法を用いれば a の所に書いた先読みの長さに関する制限も自然に解消できる。
      こちらの方法を用いるべきである。

    2' 改めて b の方法に従って lookahead を書き換えることにする。
      変数名はどの様にするべきか。lookahead を文字数として、
      ilook を lookahead の位置ということにしようか。
      書き換えた。まあ問題なく動いている。

    3' 取り敢えず問題になっていた部分について設定を行う。

      % と思ったら…再現しない。現在は問題なく解析できている。
      再現した。スペースがあるかないかで変わる様だ。
      "echo > A<(echo)" から "echo > A<echo" に書き換えるとなる。

      これの原因は何だったかというと "> A<(echo)" となっている時に、
      解析再開点が < の位置に設置されリダイレクト先の続きを読む設定になっている。
      ここで、<( となっている時には問題がないが < に書き換わると、
      ここはリダイレクト先の続きを読むのではなくて、
      新しい別のリダイレクトとして読まなければならない。
      つまり、この解析再開点が誤っている。
      何故このような事になったかというと、そもそもこの解析再開点を設置した時に先読みして
      "<(" まで見てリダイレクト先の続きを読むとした為である。
      つまり "(" が消滅する様な場合には、この解析再開点は無効化されなければならない。

      さて set-lookahead で先読みしたことを設定してみる。
      正しく先読み情報が記録されている。
      そして上記の編集の後でも正しく文法が解析されていることを確認した。取り敢えず OK

    4' その他のプロセス置換の部分についても確かめる。

      % と思ったが、よく考えたらプロセス置換に限らず
      % $(( や $( でも問題になるのではないだろうか…。
      % しかし、これらについて問題になるのではないかという事は今まで意識したことがない。何故か。
      %
      % 例えば $(( について考える。一致した時には $(( の末端まで移動するので問題は起こらない。
      % 一致しなかった場合には、3 文字目まで見たときは代わりに $( の方に一致するはずである。
      % この時、3 文字目も先読みしたことになるので問題ない。
      % 2文字目まで見て一致しないという事が分かったとき、必ず後で 1 文字は解析が進むので、
      % やはり 2 文字目の先読みの範囲に自動的になるので問題ない。

      $( や $(( で問題にならなかったのには、ちゃんと理由がある。
      $(( は 3 文字目まで見て失敗した時は必ず $( に一致するので OK。
      先読み2文字以下の構造については、そこで採用されなかったとしても必ず1文字進んで、
      その先読みで2文字は必ず進むので、気にしなくても良い。

      - その他、同様に check-word-end で参照している部分については、
        共通の関数 check-word-end/is-delimiter を用意してそれを使う事にした。

      - また、starts-with-delimter という関数も用意する事にした。
        これは実際に読み取りを行うよりも前の位置で呼び出すので、
        恐らく先読みの設定はしなくても大丈夫。
        先読みが当たればそれに対応する分だけ解析が進むし、
        先読みが外れるとしても1文字少ない部分列で解析が進むので、
        先読みの文字数に問題は起こらない。

      - 最後に starts-with-delimiter-or-redirect については、
        'time' 予約語に対して使っている箇所と、
        ctx-command の冒頭で使っている箇所がある。

        ctx-command の冒頭で使っているところでは、
        最終的に対応する redirect または delimiter を読み取るので問題ない。
        'time' 予約語に関してはまた実装を見直す予定なので、
        ここでは未だ余り真面目に考えなくても良い。
        実のところ、駄目な気がする…というか check-word-end/is-delimiter を使うべきでは?
        →starts-with-delimiter-or-redirect ではなく check-word-end/is-delimiter を使う事にした。

    取り敢えずよしとする。

  * memo.txt: D0535 が重複している。D0587 も重複している。 [#D0600]

    以下を使って調べたところ重複は他にはない。
    $ grep -ao '\[#D....\]' memo.txt | sort | uniq -cd

    跳びもない
    $ grep -ao '\[#D....\]' memo.txt | wc
    599

    番号が付いていない項目もない
    $ grep -Ea '^  \* (.*\[#D....\]$)?' memo.txt


    どの様にしたら自動的にずらす事ができるだろうか。
    D05\(3[5-9]|[4-9].\) → D05\,(1+ \1)

    うーん。
    D05\(3[5-9]|[4-9].\) → D05\,(+ \1 (if (<= \1 87) 1 2))
    D05\(3[5-9]|[4-9].\) → D05\,(let ((num (string-to-number \1))) (+ num (if (<= num 87) 1 2)))

    修正した。多分、大丈夫。

  * syntax: $(()) が常にエラーの着色になってしまっている。何故か。 [#D0599]

    [状況]

    調べてみると nest-push した時に中で ARGX になっている。
    $() も赤くなってしまっている。"$(echo)" も最初の " が赤くなっている。

    これは明らかに、#D0597 の書き換えによって単語内部を解析する時の
    wtype を変更したのが原因である。しかしどの部分でエラーになっているのだろう。
    調べてみるとエラー着色は構文解析の時点で設定されている。
    特に nest-push が発生した時に限り起こっている様に思われる。

    [原因]

    もう少し調べてみる。先ず初めに $(( が来ると check-dollar に入る。
    ここで attr には CTX_PARAM が設定される。そして nest-push をしてそのまま抜ける。
    抜けると ble-syntax:bash/ctx-command に戻る。
    flagComsume=1 が設定されるので、後でその分岐に入る。
    エラーが設定される条件は2パターンある。

    - 1つは _ble_syntax_bash_command_expect[wtype] に設定されている wtype であること。
      これは違う。この配列に登録されているのは CMDXE などだけである。

    - もう一つは unexpectedWbegin が設定されていること。
      しかし、こちらだと考えると変だ。

      例えば " の場合は "a" の様に単純な場合にはエラーにはならない。
      一方で "$(echo)" だとエラーになる。unexpectedWbegin は其処にある文字で判定するので、
      " の後に何が来るかに依存しないはずである。

      エラーになるかならないかを分けているのはやはり nest-push したかしないかである。
      nest-push では unexpectedWbegin は書き換えない。wtype は書き換える。
      という事を考えると、やはり wtype が書き換わる nest-push が怪しい。
      nest-push で wtype は -1 になる。しかし _ble_syntax_bash_command_expect に -1 はない。
      配列に -1 を指定すればエラーになる。と思ったが、よく考えたら負の添字を渡すと、
      一番最後の要素の値が取れるのではなかったか。実際に試してみるとそうだった。

    [修正1]

    ${_ble_syntax_bash_command_expect[wtype]} の確認をする前に
    wtype が 0 以上である事を確認する様にした。直った。

    test/benchmark/benchmark-201711-arithmetic.sh
    所で、0 以上である事を調べてから条件コマンドで中身を確認する時に、
    算術式コマンドと条件コマンドに分割した方が速いのか、
    或いは、単一の条件コマンドのした方が速いのかについて調べた。
    このケースの場合にはどちらが速いとも言えないが
    基本的に算術式で評価できるものは算術式で評価した方が速い様だ。

    [修正2]

    直ったと思ったら、今度は本来の目的の fi $(echo) をエラーにするという機能が駄目になった。
    nest-push しているので wtype が変わってしまい、エラーを設置する機会が失われている。
    また、今まで動いていた様に見えたのも nest-push して wtype=-1 になった事で、
    誤った条件判定によりエラーが設定されていただけの事であった。

    nest-push があった場合には nest-push する前の wtype が必要になる。
    これは実は初めの wtype を覚えて置くだけで良いのかもしれない。

2017-11-15

  * edit: echo !( !a ) で !a の直後で magic-space しても展開されない。 [保留] [#D0598]

    現在の実装ではカーソル位置よりも前の部分に対して展開を試みる。
    しかし、どうやら "echo !( !a" だと構文エラーか何かで失敗する様だ。
    最後の位置までカーソルを持っていかないと展開されない。

    元々の bash の実装ではどうなっていただろうか。
    echo !( !a の状態で SP をすると event not found のエラーになる。
    そして space も入力できない。これは不便だ。

    また、!( !a ) の状態ならば magic-space すれば展開される。
    カーソル位置もちゃんとなっている。

    echo !( !a) !a の状態で初めの !a の直後に magic-space を入れようとすると、
    履歴展開は両方共実行される。実行後のカーソルの位置は最後から四文字目。
    これは展開で挿入された文字列の中途なところである。
    つまり、実際に展開で挿入された文字列の位置ではなくて、
    展開前の最後尾からの位置を覚えておいて、展開後に覚えておいた最後尾からの位置に移動するだけの様だ。
    しかも、展開した後に空白を挿入するせいで、変なところに空白が挿入されている。
    Bash の magic-space の実装は微妙である。

    その様に考えると現在の実装の方が妥当に思われる。
    因みに、全体に対して展開を実行して、
    それでいて、展開後の現在位置に対応する箇所を特定する方法はあるだろうか。
    うーん。難しい気がする。ならばわざわざ実装する必要もないのではないだろうか。

2017-11-15

  * syntax: 以下はエラーにするべき。 [#D0597]
    if true; then true; fi <(echo)

    おかしい。fi echo はちゃんと赤く着色されているが、どの時点で着色されているのか謎だ。
    調べてみると単語を読み取る時には赤くなっていない。
    これは考えてみれば単語が終わるまでは、fi の後に fi done などが来るかもしれないので、
    この時点では未だ構文エラーかどうか分からないので、妥当な処理である。
    しかし、実際に赤くなっているのは誰が管理しているのだろうか。

    更に気付くことは fi echo$(echo) とすると赤くならないという事である。
    fi $(echo) も赤くならない。これは問題である。

    これはプロセス置換に限った話ではなくて全般的な問題の様に思われる。
    さて、そもそも現在の着色は何処で行われているのかを特定する必要がある。
    どうも、文法的に着色されている訳ではなくて、後付で着色されている様だ。

    うーん。実は CTX_CMDXE 及び CTX_CMDXD では取り敢えずエラーを設定して、
    word が終わる箇所でもし許容できるコマンド名になっていたら attr を設定する
    という方式で良いのではないだろうか。許容できるコマンド名は単純なので必ず同じステップ内のはずである。
    CTX_CMDXE CTX_CMDXD 以外にもあるかもしれない。
    これについては、後付で着色しているコードを観察すれば良い。
    所で、未だ後付で着色している部分の特定には至っていない。

    →多分分かった。ble-highlight-layer:syntax/word/.update-attributes/.proc
      CTX_CMDXE 及び CTX_CMDXD では wtype に ATTR_ERR を設定しているのだ。
      そして wtype が ATTR_ERR ならば赤く色を付けるという様にしている。
      然しながら、この判定をしているのは $wtxt =~ $_ble_syntax_rex_simple_word の中なので、
      $(echo) などを含む単語についてはエラーの着色が起こらないのである。
    →では wtype に ATTR_ERR を設定しているのは何処だろう。
      ble-syntax:bash/ctx-command/check-word-end の中で
      _ble_syntax_bash_command_expect を参照している。
      この配列に正規表現が登録されている問、この正規表現に一致しない物について
      wtype=ATTR_ERR を設定している。

      逆に言えば、この配列に登録されている様な文脈の場合には属性値を取り敢えず ATTR_ERR にしておいて、
      正しいと分かった時に改めて、期待される属性値を代入するという具合にするのが良い気がする。
      更によく見ると CTX_CMDXE CTX_CMDXC CTX_CMDXD で許容されるコマンドは何れもキーワードなので、
      改めて期待される属性値を代入しなくても正しい値で上書きされる様に見える。つまり、気にしなくて良い。

      % と思ったが、属性値を ATTR_ERR にしようと思っても、
      % 実は属性値は ctx の値をコピーして設定する事になっているので、
      % 自由に設定できるようなものではない。
      % 特に単語の開始境界の位置で設定できる物という訳ではない。
      と思ったが、ctx の値をコピーして設定する所で wtype も参照して設定する事にした。動いている。

      ところで、わざわざ wtype を設定して highlight で色を付けて貰うこともないのではないかとも思ったが、
      'echo' 等の様にして囲んだ場合には現状の方法だと対応しきれないので、
      やはり wtype によるエラー着色は必要である。そのままにする。

    しかし、それでも未だ if true; then true; fi <(echo) はエラー着色が見えない。
    やはり全体をエラーの色で塗り潰したい物である。
    →単語を構成する要素は全て先頭にエラー色を上書きする事にした。動いている。
    多分問題も生じないであろう。

    さて、改めて今まで調べて問題だったものについて確認する。何れも着色されている。OK
    正しい場合にはエラーの色は残っていない。OK

    * resolved: 因みに、[[ echo ]] echo や (( echo )) echo に関しては
      構文的に誤っているということがすぐに分かるのにも拘らず、
      エラーの着色が為されていない。これも何故だろう…。
      _ble_syntax_attr にはちゃんと CTX_ARGI が設定されている。
      CTX_ARGX0 なのに ble-syntax:bash/ctx-command/.check-word-begin がちゃんと返していないのが悪い。
      しかしちゃんと返しているとしか思えない。と思って、呼び出し元を見たら、
      何故か unexpectedWbegin に値を設定するはずの所が壊れていた。
      どうやら色々試している内にここを壊してしまっていた様だ。
      これについては直った。

    * fixed: 後、echo とした時、普通は後付の色で上書きされるために見えないが、
      その下にはコマンドの色がついているはずなのに黒である。これはどういう事か。
      _ble_syntax_attr[i]=ctx によって現在の ctx を代入している様にみえる。
      というか ble_debug の一番左の列に表示しているのが attr だった。
      これによるとちゃんと CTX_CMDI が設定されている。
      だとすれば、attr から色に変換する所で誤っているのか。
      別に bashrc で syntax_command の色設定を上書きしている訳でもない。
      何と色指定を誤っていた。元々 red となっていたのを brown に書き換えたのだったが、
      正しくは fg=red であるべきで、それを fg=brown に書き換えるべきだった。直した。

2017-11-14

  * syntax: [[ a == b ]] などが誤って構文エラーになっている。 [#D0596]
    これはごくごく最近発生した問題のはずである。

    直した。序に、[[ と ]] は今まで予約語色にしていたが、
    構文レベルで ATTR_DEL にする事にした。
    (今までは構文レベルで [[ を ATTR_DEL にしていたが、
    その後の単語の着色で予約語色になっていた。
    ]] はそれを見越して構文解析の時点で予約語色にしていた)

  * syntax: - で始まる名前のコマンド・関数だと正しく着色されない。 [#D0595]
    これは type がコマンド名をオプションと勘違いしている為である。
    type を呼び出す時に -- を前置すれば良い。

  * syntax: time の後に何もなくても文法的には正しい。 [#D0594]
    time -p の後に何もなくても文法的には正しい。

    実は ! / time の直後は特殊な文脈になっている様だ。

    以下はリダイレクトの文法の詳細について調べている時 (#D0591) に分かったこと。

    | 実は ! 単体でも OK
    | while !; do break; done
    | これは直したのに直っていないと思ったら、
    | そもそもリダイレクトに関係ないので修正とは関係なかった。
    | 独立に修正する必要がある。
    |
    | 所が調べてみると ! ; echo これは文法エラーになる。不思議だ。

    調べてみるとまたよく分からない規則がある様だ。

    $ ! ;                          # OK
    $ time ;                       # OK
    $ ! ; echo                     # Error 何故?
    $ time ; echo                  # Error 何故?
    $ while ! ; do break; done     # OK
    $ while time; do break; done   # OK
    $ while false; do ! ; done     # OK
    $ while false; do time ; done  # OK

    どうやら !, time 直後の ; の後は CTX_CMDXE になっている様だ。

    もう少し調べる。

    $ time &        # Error
    $ time && echo  # Error (&& が来た時点で既にエラー)
    $ time || echo  # Error
    $ time | echo   # Error
    $ time |& echo  # Error
    $ case a in (a) time ;; esac  # Error
    $ case a in (a) time ;& esac  # Error
    $ case a in (a) time ;;& esac # Error

    つまり ; 以外が来るともう駄目ということである。
    さて、; 以外については現状の振る舞いと一致しているので、
    ; が来た時だけ特別扱いをすれば良い。

    ! と time の後は、現在の枠組みでは文脈値として CTX_CMDX1 になっている。
    これは例えば else の時も同じである。試してみる。

    $ if true; then true; else ; fi # Error
    $ if true; then true; time ; fi # OK
    $ if true; then true; ! ; fi    # OK

    やはり明確に !, time の直後だけ文脈が異なる。
    そして、! と time の直後はやはり類似の文脈の様だ。

    % と思ったが、! に関しては寧ろ else と同じ?
    % 勘違いだった。構文エラーではなくて単に ! が実行されて終了ステータスが 1 になっただけだった。

    取り敢えず CMD_CMDX1 を複製することにする。複製した。
    time ; 及び ! ; に対応した。
    次に行末での処理に対応する。改行のある時と、最後(文字列末端)のチェックを直す。
    多分、これで対応できた。

  * syntax: 以下で ")" の位置で誤って構文エラーが報告されている。 [#D0593]

    echo $({ time echo helo; })
    echo $(while true; do break; done)

    CTX_CMDXD の後にコマンドがなくて終了しても OK にする。

  * syntax: 予約語と変数代入・リダイレクトの順番に関する修正 [#D0592]

    というか time や ! 周りの文法が分からなくなってきた。試してみる。

    * ok: 何と、以下の何れも文法的に正しい。
      今まで深く考えていなかった実装でそんなに間違っていはいなかった様だ。

      $ time ! echo hello
      $ ! time echo hello
      $ ! time ! echo hello
      $ time time echo # 一個しか time を指定しなかったときと同じ
      $ ! ! echo
      $ ! ! ! echo # ちゃんと数に意味があって奇数個・偶数個で振る舞いが変わる

    * fixed: 以下は time はコマンドとして実行される。! はコマンドが見つかりませんと出る。

      $ > a.txt time echo
      $ > a.txt time -p echo
      $ a=b time echo
      $ > a.txt ! echo
      $ a=b ! echo

      % これについては !, time は CTX_CMDXV 以外で有効ということにすれば良い。
      %
      % そう言えば他の特殊文脈での振る舞いはどうなのだろう。確かめる。
      % CTX_CMDXC の場合は time があると駄目である。! も駄目である。
      % CTX_CMDXE の場合は如何にもだめそうだが…一応試すと time も ! も駄目だった。
      % CTX_CMDXD の場合も試すと time も ! も駄目だった。
      % これらは元々エラーなので特別の対策はいらないだろう。
      % 特に ! や time を下手にコマンドとして取り扱うと、
      % それ以降に復号コマンドなどがある時に振る舞いがおかしくなるので、
      % これはそのまま通過するということで良い気がする。
      %
      % さて、どの様に対応したら良いだろうか。
      % 実際に '!', 'time' 等の判定をしているところを見ると、
      % ctx は既に CTX_CMDI になっているので元々の文脈値が分からない。
      % ここで、元々の文脈値を過去に遡って確認することは許されていただろうか。
      % 少なくとも直接に stat/attr 配列を参照して確認することは許されていない。
      % 部分更新の際にこれらの情報は書き換わってしまうからである。
      % | 或いは、必ず1回の step で '!' や 'time' の終端に達すると考えれば、
      % | 実は '!' や 'time' 以降の状態を参照しても良い気もするが、
      % | 原則を破ると汚くなってなんだかよく分からないので、できるだけこれはしない。
      %
      % では word の情報としてこれらは記録されていただろうか。うーん。
      % どうも wtype として記録されている気がする。
      % 調べてみると CTX_CMDX[CDE] に関しては実は既に wtype にそれが設定されていた。
      % しかし、それ以外の場合については wtype は word の中を解析する ctx (つまり CTX_CMDI) に統一されている。
      % これには意味はあっただろうか。取り敢えず一旦 wtype になったものが ctx になることはないだろう。
      % なので wtype で CTX_CMDI に特別な意味を持たせているものについてチェックすれば良い。
      % ble-syntax.sh で登場する CTX_CMDI について wtype に関係するものは以下の二箇所で出て来る。
      %
      %   ble-syntax:bash/extract-command/.construct-proc
      %   ble-highlight-layer:syntax/word/.update-attributes/.proc
      %
      % これらは何れも tree-enumerate の過程で呼び出される proc である。
      % という事は最終的に登録される wtype だけしか効かない筈である。
      % 途中で CTX_CMDXV などになっていても大丈夫のはず。

      というか、今気づいたのだが、そもそも

      $ a=b function hello [[ a ]]
      $ > a.txt function hello [[ a ]]

      等は何れも function をコマンド名扱いしている。
      他のキーワードのチェックに現れるコマンドを全て確認したが、
      何れもコマンド扱いされるようになる様だ。

      a うーん。新しい文脈値 CTX_CMDIV 的なものを導入する可能性も考えたが、
        其処まですることもない様な気がする。何より違いというのはここにしかない。

      b したがって、CTX_CMDXC 等と同様に wtype に記録するのが良い気がする。

      c というかそもそも解析中の wtype を参照する箇所は他にあるのだろうか。
        探してみた所見つからない。という事は、実は開始時の wtype をそのまま指定して、
        それから word-pop する直前で調整すれば良いだけなのではないだろうか。

        word-push では単に wtype 変数に値を指定するだけなので気にしなくて良い。
        実際に tree に登録されるのは word-pop の時である。
        そして、既にそのことを意識して途中で wtype を書き換えるという事は行っている。
        但し、その wtype の書き換えの際には実際には元の wtype は参照していなくて、
        ctx に基いて新しい wtype を設定しているだけである。つまり、wtype は使われていない

        うーん。念のため、以前実装した時にどうしてこの様にしたかを確認する。
        関係がありそうなのは #D0393 #D0382 #D0378 #D0372 #D0371 だが、
        何れにおいても現在の実装については議論されていない。
        _ble_syntax_bash_command_bwtype を弄っている commit を見てみると、以下の通り。

          70e1e49d     2017-03-05 19:07:58 → これは #D0382 だろう。
          fdbfb399     2017-03-01 11:40:26 → これは #D0372 なのだろう。

        結局そんなに分からない。恐らく元々 wtype=ctx としていたのを破壊しない様に修正した結果、
        現在のような形になったというだけで、これに対した意味は無いだろうと思われる。

      [実装]

      wtype には octx を設定する様にする事にした。
      check-word-end で _ble_syntax_bash_command_ewtype を使って変換してから word-pop する。
      取り敢えず分かっている範囲での動作に破壊が生じないことは確認する。

      wtype が CTX_CMDXV だった時には予約語は解釈しない様にする。
      直してみたらエラーになった。うーん → 修正した。

    * 変数代入とリダイレクトの後は予約語を解釈しないように変更したが、
      相変わらず予約語の色で着色されている。
      これはコマンドとしてマークされた予約語には現在予約語の色をつけている為である。
      しかし、思うに予約語はそもそもコマンドとしてマークする必要はないのではないか。

      (ところで初めは以下のように書いていたが、実は予約語全般に当て嵌る話だった)

      | 所で、現在の実装では '!' は何も着色していないが、
      | type -t '!' とすると keyword と出るので keyword 色にするべきでは。
      | もしくは、[[ 等と同様に太字にするか。性質を考えると time と同じにしたい。つまり青字。

      コマンドとしてのマークをしないという事にした時にどの様な影響が出るかについて考える。
      先ず初めに extract-command が正しく働かなくなる。予約語の為の word type を用意するべきだろうか。

      或いは、別の方法でコマンド着色の際に判定を行う。
      例えば、初めから attr に予約語の色が設定されている時には改めて着色は行わないなど。
      こちらの方が現実的な気がする。

      さて、では予約語に対応する語がコマンドとして呼び出される時は、
      実際にはどのようにして色を決めれば良いのだろう。
      例えば type -tP time などとすればコマンドがあるかどうか分かる様だ。
      しかし、a=b time は関数でも良いようだ。なので、関数があるかどうかも調べなければならない。

      そう言えば 'time' 等として呼び出す場合にも同じことが当てはまる。
      現在の実装では 'time' なども予約語として取り扱われて青くなったのだったろうか…
      と思ったら、'time' とした場合には正しく解決できている。これを参考にする必要がある。
      →これは ble-syntax/highlight/cmdtype2 の $type == $ATTR_CMD_KEYWORD 分岐で処理されていた。

      [実装]

      a 予約語の時は語の先頭の attr を書き換えれば良い…と思ったが、
        よく考えたら check-word-end に至った時点で既に先頭の attr は設定されている。
        この値を書き換える為には [[ で行っている様に、

          ble-syntax/parse/touch-updated-attr "$wbeg"
          ((_ble_syntax_attr[wbeg]=ATTR_DEL))

        という様な事を明示する必要がある。

        これだと解析の効率が下がるのではないかとも思ったが、
        よくよく考えてみるとそもそも予約語の様な単純な単語の場合には、
        必ず 1 回で解析が終了するので、これで効率が下がることはない。
        寧ろ、ble-syntax/parse/touch-updated-attr "$wbeg" をわざわざ呼び出す必要も、
        本当は無いのかもしれない。ただ、これはルールとして呼び出すようにしておく。

      b wtype に記録された情報を用いる。

        そう考えると寧ろ check-word-end の支配下にある
        word-pop で登録される情報を弄る方が良い気もしてくる。
        然し、改めて実装を見てみると word-pop を使うとしても
        現在のコードの流れでは word-cancel を実行してから、
        再度 word-pop をしなければならないという面倒なことになっている。

        word-cancel はそれなりに面倒なことをしている。
        もしこの wtype を用いる方法を採用するとすれば、
        処理の流れを変えて word-cancel をしなくて済む様にしたい。

      どちらの方が良いだろうか。

      | extract-command の観点から考えてみる。
      |
      | | しかし、そうするとこれは extract-command に影響が出てくる。
      | | (所で、extract-command を使っている command-help の方はどうなのだろう。
      | | 例えば a=b function となっていた時、command-help の中からは
      | | それが予約語の function なのか、コマンドの function なのか判定ができない。
      | | command-help にも配慮した設計にするべきなのではないだろうか。
      | | と思ったが、(attr を用いる方法か wtype を用いる方法か) 何れの方法を用いたとしても、
      | | 現状の枠組みでは command-help に情報を伝えるのは難しい。
      | | 或いは、extract-command において単語開始位置の情報まで全て返すようにすれば、
      | | 後は attr/wtype に拘らず command-help 側で好きに調べることができる。
      | | もし wtype になっていれば extract-command を返す時に、
      | | 先頭の単語の種類も一緒に別の変数かなにかで返すことができる。
      | | しかし、現状の実装ではそれが予約語かそれ以外かの二択なので、
      | | わざわざ変数にして返す意味があるのかという疑問も生じる。
      | |
      | | 更に、よく考えてみると command-help だけでなく、
      | | complete を行う時にもそれがコマンドかどうかによって振る舞いは変えるべきなのではないか。
      | | と思ったが、complete の場合にはそもそも予約語に対して引数はないので、
      | | complete が呼ばれることもない気がする…いや、for 等の場合には complete が呼ばれる。
      | | もし complete で関数が登録されていればやはり extract-command を呼び出すのが良いだろう。
      | | しかし、この時には bash の補完関数の仕組みではそれが予約語かコマンドか判定する仕組みがないので、
      | | 結局、そのような情報を提供する意味がない。
      |
      | - command-help で表示するヘルプを選択するときには、何らかの方法で予約語かそうでないかを区別したい。
      | - Bash の補完関数の枠組みを模倣するときは予約語かそうでないかの区別はない。
      |
      | highlight の観点から改めて見てみる。
      |
      | wtype 及び attr は何れも簡単にアクセスできる物だろうか。
      | そもそも highlight は wtype を参照して着色する方法を選択している。
      | その場所は ble-highlight-layer:syntax/word/.update-attributes/.proc である。
      | 一応、この箇所で _ble_syntax_attr[wbeg] を参照すれば良いが、
      | やはり綺麗なのは別の wtype にする事の気がする。
      |
      | 改めて wtype CTX_CMDI を明示的に調べている部分を探す。
      | これは先程調べたものである。extract-command と highlight 以外では使っていない。
      | extract-command の wtype == CTX_CMDI を新しく追加した wtype にも対応するという風にするだけで良い。
      |
      | さて、wtype を追加するとしたらどの様な値にするべきだろうか。
      | a 一つの方法は新しい文脈値を作るというものだが、
      |   実のところ解析に関与していない文脈地は作りたくない。
      | b 或いは、既存の文脈値を流用する。しかし予約語に向きそうなものはない。
      |   一応 CTX_CMDXE や CTX_CMDXD は予約語しか次に受け付けないが、
      |   これらは既に来る予約語名までの空白の色に同時になっている気がする。駄目。
      | c 或いは、ATTR_CMD_KEYWORD を用いる。
      |   現在の実装では ATTR_CMD_KEYWORD は CTX_* と重複しないようになっているので問題はないはず。
      | もし wtype の方法にするとしたら ATTR_CMD_KEYWORD を用いる。
      |
      | function の最後の文字のエラーの着色が透過するためには、
      | 予約語の時には敢えて単語の種類による着色を行わないという様にすれば良い気がするが、
      | その為には結局最初から _ble_syntax_attr を書き換えて置かなければならない。
      |
      | 或いは、function のエラー着色を今まで通りに上書きしても良いとしても、
      | 予約語について上から予約語色で塗るというのは、
      | わざわざ highlight の phase で実行しなくて良い気がする。
      | 色の管理が面倒になるので、寧ろ文法解釈の時点で分かる色・属性はそこで設定した方が良い。

      [結論] _ble_syntax_attr[wbeg] を書き換える。

      - wtype を用いて判定すると予約語の時に改めて着色する必要がある。
        予約語の色は構文解析の時点で分かっているので、改めて着色の判定をするのは無駄である。
        また孤立 function のエラーなど構文解析でのエラー着色が上書きされてしまう問題があった。
        これを解決する良い機会でもある。

      - _ble_syntax_attr[wbeg] を書き換えると、一見、解析の効率が悪くなる様にも思われるが、
        実際には予約語は単純なので wbeg の位置は同じ解析ステップの範囲のはずなので気にしなくて良い。

    この修正により以下の古い項目は解消した。

    | 2015-08-15
    |
    | * ble-syntax.sh: `function' と入力した時に最後の n の部分にエラーを設定するが、
    |   command 名としての着色の際に上書きされてしまっている。

  * 2017-11-10 syntax: > a.txt ; echo が文法エラーとされているが、これは文法エラーではない。 [#D0591]

    * fixed: 以下は本来文法的に正しい
      > a.txt; echo

    他にも試してみると色々新しいことが分かった。
    以下は何れも文法的に正しい。

    * fixed: 以下は本来文法的に正しい
      while > a.txt; do break; done
      →これは色々試してみた所、
        リダイレクトを挟むと CTX_CMDXV になるとすれば良さそうだ。
        リダイレクトの後に変数代入があってもいいし、
        変数代入と変数代入の間にリダイレクトがあっても良い。

    以下は本来文法的に正しくない。

    * fixed: 関数の本体の直前
      function hello () > a.txt ((a+=b)) # 駄目
      function hello () ((a+=b)) > a.txt # 備考: これは正しい
      →これは CTX_CMDXC ではリダイレクトは駄目ということにすれば良い

    * fixed: fi などの直後にリダイレクトを挟んで fi などが来るとき
      if true; then if true; then echo hello; fi > a.txt fi # 駄目
      if true; then if true; then echo hello; fi fi # 備考: これは正しい
      →これは CTX_CMDXE でリダイレクトを挟むと CTX_ARGX0 になるとすれば良い。

2017-11-12

  * encoding: input_encoding を切り替えた時ごみが残るのでは。 [#D0590]
    detach の時にもこれは処理するべき。
    ごみは flush するのかそれともそのまま消去するのか。
    ble-decode/unbind で消去してしまうのが良い気がする。

  * encoding: この辺りで __ENCODING__ という部分を整理する。 [#D0589]

    調べてみるともう2箇所しか残っていない。
    一箇所は ble-color.sh の ble-highlight-layer:plain/update/.getch で、
    これは C1 文字を M-^? の形の表示に変える為のものである。
    これは ble/util/s2c でコードに変換してから判定することにした。
    多少重くなるかもしれないが仕方がない。

    ble/util/s2c は必ず Unicode の値になるのだろうか。
    現在の実装を調べてみると結局 builtin printf %d "'あ" を使っている。
    これは実際に試してみた所、eucJP でも 12354 という値を出力したので、
    最終的に Unicode に変換してから出力するようである。

    | 疑問: ble/util/s2c の実装は本当に Unicode 値を得られているのだろうか?
    | [cf memo/D0589.test-printf-s2c.sh]
    |
    | eucJP で試す。_ble_bash>=40100 の実装は OK
    | builtin printf %d "'あ" はちゃんと unicode の値を返す。
    | 他の実装も結局同様に builtin printf を使っているので大丈夫のはずだ。

    もう一つの __ENCODING__ は ble-edit/draw/trace に残っている。
    現在では LC_ALL=C ではなく LC_COLLATE=C にしているので、
    問題は起こりそうにないが念のため実験する。
    試してみた所 glob でも正規表現でも、
    ちゃんと LC_CTYPE に従った文字の単位で切って、
    その後で LC_COLLATE=C に従った比較になっている様だ。
    問題になることは無さそうに思う。
    [cf memo/D0589.test-lc_collate.sh]

    ただ、比較をする上で直接 ST を正規表現に埋め込んでいた。
    これはソースコード上 UTF-8 で符号化されて埋め込まれている。
    UTF-8 でない環境で source ble.sh した時に問題になると思われるので、
    ble/util/c2s 156 で文字を取得するように変更する。

    | 唯、気になるのは ST に対応する文字が存在しない環境で、
    | ble/util/c2s (もしくは printf -v var '\uXXXX') がどの様な結果を齎すかである。
    | [cf memo/D0589.test-printf-uXXXX.sh]
    |
    | 例えば空欄になるのか、或いは変な文字がそこに入るのか、変数に代入が行われないのか。
    | 手許の環境では ST のある文字コードしかないので取り敢えず別の文字を使う。
    | ここは周回積分記号 ∮ を用いることにする。U+222E である。
    | iconv -f UTF-8 -t EUC-JP <<< ∮dx とすると以下のエラーになる。
    |
    |   iconv: illegal input sequence at position 0
    |
    | 従って、これは EUC-JP に対応するもののない文字である。
    | さて、実際に printf '\u222E' を試してみると
    | 何と '\u222E' という文字列がそのまま出てきた。
    | \u3042 (あ) はちゃんと ja_JP.eucJP でも変換されている。
    | と思ったら、実際に使っているのは $'\uXXXX' だった。
    | 改めて調べなおすと同じ振る舞いだった。'\u222E' という文字列になる。
    |
    | 所で、もう一つ気付いたことは $'\uXXXX' は、Bash が parse した時の文字コードで先に文字に変換されている。
    | 従って、eval で評価を遅延させる必要がある (これは実際に c2s でやっていることとも一致する)。

    →対応する文字が存在しないときは '\uXXXX' の形になるので文字数が 2 文字以上なら失敗と見做せば良い。

    % ところで周回積分記号の幅の計算が誤っているがこれはどうしてか。
    % どうも幅 1 と思っている様だ。手許の emacs では変なことは起こっていない。
    % そして現在の ble.sh は emacs のテーブルを元にしているはずなのだが。
    % →と思ったらこれは直したのだった。最新の ble.sh では変なことは起こらない。
    % ble.sh を編集しているシェルセッションが古いのがいけなかった。

    他に動作に深く関わるもので Unicode の文字 (C0 GL でない文字) が直接埋め込まている箇所はあるだろうか。
    実のところ意味を持つのは C1 程度なので、C1 以外を埋め込む意味がないように思われる。
    あるとすれば(エラー)メッセージに日本語が含まれる場合だが、
    日本語のメッセージを出力する箇所はないはずだし、
    もし日本語メッセージが UTF-8 で出力されたとしても大きな問題には至らない筈である。
    ST (\u009C) と CSI (\u009B) は検索したが、今回対処したところ以外にはない。
    多分、他の文字も存在しない。OK

  * ble_debug=1 で表示していた内容が :q で消去されない。 [#D0588]
    これは info の仕組みを用いて表示していたので、
    :q をする時に消去されるはずなのではないか。

    というか、普通どおりに exit しても消去されない。
    と思ったが補完候補達は初期されている気がする。うーん。
    もしかして高さの計算を誤っている?

    と思ったが mode 変更の際に info が変わる時には
    ちゃんと正しい高さだけ削除されている。

    実装の方を観察してみる。
    ble/widget/vi-command:q は ble/widget/exit を呼び出している。
    ble/widget/exit は ble-edit/info/hide を呼び出している。
    もしかして hide した物が再度描画されてしまっている可能性?

    と思ったが、再描画されるようなタイミングはなく exit している気がする。
    うーん。途中の出力の様子を見てみると何も出力されていない?
    直前の高さを確認してみたが _ble_form_window_height にはちゃんと高さが設定されている。
    そして hide の直後には高さが潰れている。

    うーん。どうも調べてみると ^O しか出力されていない様だ。
    と思ったが、どうやら alias less で確認していたために
    エスケープシーケンスが表示されていなかったようだ。
    ちゃんと確認したら消去のシーケンスは _ble_util_buffer に入っていることは分かった。
    ESC[m^OESC[1B^MESC[8M となっている。SGR() ^O CUD(1) DL(8) である。
    では、何故実際に消去されていないのだろうか。
    flush を挟んで見る。しかしながら消去できていない…。どういうことだろうか。
    あれ、もしかして高さの計算を間違えている? と思ったがそんな事もない。

    うーん。おかしい。もしかして render の中で再描画されている?
    →そのようだ…。高さが復元している…。
    あ…分かった。textarea#render が中で syntax を呼び出して、
    syntax は ble_debug=1 の時中で info を呼び出すのだった。

    ble/util/hide の方を後にしたら収まった。

  * ble_debug=1 で表示される内容の _ble_highlight_layer_disabled_buff [#D0587]
    の行が前の行にくっついている。
    これは ble/util/assign の実装を変更して行末の改行を除くようにしたのが原因だった。直した。

    改めて ble/util/assign の様子を観察してみるとどうも最後の改行が除かれている
    前提のコードが多いような気がする。今まで動いていたのはなんだったのか不思議である。
    一応動作を統一するために bash-4.0 未満でも最後の改行は除くようにした。

  * bind: bleopt input_encoding=C は動かない気がする。 [#D0586]

    素直な bind ではちゃんと入力を読み取れないので UTF-8
    では文字を 2 byte 表現に一旦変換してから読み取るなどの工夫をしている。

    これに正しく対応するためには、C であっても特定のシーケンスについて特別な意味を持たせる必要があるのではないか。
    そうすると、例え C であっても C1 の領域の何れかの文字を生贄にするしかない。
    因みに vim では right を <80>kr という表現でキーボードマクロに記録する。
    これを考えると <80>? を特別な表現に割り当てれば良い気がする。

    % とここまで書いて思ったが、実は現在の設計は文字符号化方式の部分と、
    % bind の部分が癒着しているのがいけないのではないか。
    % つまり、ble-decode/.hook から直接 ble-decode-byte を呼び出しているが
    % その手前で特別表現からバイト値に変換する段があっても良いのではないかという事である。
    %
    % そうすれば bind の文字符号化方式依存の部分は解消するし、
    % 場合によっては孤立 ESC を受け取るために使った
    % <wait> などの仕組みについてももっと綺麗に解決できるかもしれない。
    %
    % 取り敢えず、孤立 ESC の細かい取り扱いは抜きにしても、
    % 文字符号化部分とバイト受信部分を明確に分離する。
    % 特別なバイトを受け取る時に使用するシーケンスとして何を使うか考える必要がある。
    % これには UTF-8 で決して使われないバイトを使うのが良い気がする。
    % 勿論、完全に文字符号化部分と分離するのであるから、UTF-8 で使われるバイトを用いても良い。
    % 然し、多くの場合 UTF-8 で使われることを考えると効率の観点などから考えて、
    % やはり UTF-8 では来ない様なバイト値で処理をするのが良い様に思われる。
    %
    % 先ず初めにどのバイトを用いるのかを決定する。
    % UTF-8 で使われないバイトは \xFF \xFE と、
    % 更に不正な表現の先頭バイトになる \xC0 と \xC1 である。
    % 実は現在の実装では \xC0? (不正な 2 バイト表現) に置き換えているので、
    % \xC0 を特別なバイトとして扱う事にすれば bind.sh の変更を最小限にできる。
    % 0xC0 を特別なバイトとして採用する事にした。
    %
    % 後は、0xC0 自身をどう表現するかである。
    % 一つの方法は \xC0\xC0 とするものである。或いは \xC0\xC1 とする。
    % 混乱を防ぐ為には \xC0\xC0 は避けた方が良い。\xC0\xC1 とすると、
    % 仮に \xC1 を受け取りたい時との混乱を避けられないのではないかという懸念があるが、
    % 実の所それは例えば C-@ を受け取るのに \xC0\x80 を使う時に \x80 で混乱が置きないかと心配するのと同じである。
    % 寧ろ、\xC1 は UTF-8 として不正な値であるので、寧ろ受信される頻度は殆どないと考えて良い。
    % ここでは \xC0 は \xC0\xC1 として受け取る事にする。
    % \xC0 については特に問題も起きそうにないので一旦 bind '"\xC0": "\xC0\xC1"' と置き直す必要もない。
    % というか、その様な置き換えをしてしまうと無限ループになってしまうので駄目だ。
    % 所で…現在 "\C-@": "\xC0\x80" 及び "\C-[": "\xC0\x9B" で置き換えているが、
    % これらは最終的に \xC0 \x80 として受信される。だとすれば、
    % この \xC0 と本来の \xC0 はどの様にして区別するのだろうか。
    %
    % ここで何故現在のような実装になっているかを思い出す。
    % その文字符号化方式で送られてこないような符号に変換する必要があったのだ。
    % そして UTF-8 の場合にはたまたまそれぞれのバイトに対する
    % 多バイト表現があったので、それを使うことができたのである。
    %
    % しかし、本当にそうしなければならないのかについて考える。
    % 先ず、\xC0 を使って表現すると決めた時点で、
    % \xC0 自身を区別して受信する方法が必要になる。
    % しかし "\xC0": "\xC0\xC1" などのようにすると無限ループになるし、
    % 更に、これだと "\x1B": "\xC0\x9B" なども "\xC0" に突入してしまう。
    % "\xC0\xC1" にも同時に bind -x する事にすると単体の
    % \xC0 が来た時に timeout を待つことになる。
    %
    % やはり符号化の "穴" を突くしか無いのだろうか。
    % そうすると結局また符号化方式依存になってしまう。
    %
    % 或いは制御文字は恐らくどの (現実的な) 文字符号化方式でもあるだろうと考えれば
    % (そうでなければ C-@ ～ C-_ の表現が普通と異なってしまい大変だ)、
    % 制御文字のどれかを特別な文字として組み合わせで受信することができる。
    % しかし、これもその制御文字に対する timeout が発生することになる。
    %
    % 勝手に keymap-timeout を変更すると、それはそれでキーシーケンスが
    % 認識されなかったり、途中の timeout によって文字が連なって来た時に混乱が生じたりする。
    % なので keymap-timeout はそのままにしておく。すると 300ms の遅延が生じる。
    % 結局、既存の文字に割り当てる時と同様に問題になる。
    % 特に制御文字は ASCII にないような変な文字に比べて入力する機会が多いし、
    % 結果として大きな変化を齎す物もあるから遅延があるのは通常文字に増して問題がある気がする。

    結局、Bash のキーボードマクロが反復して適用されることにより、
    1対1の対応付を作ることが難しい。従って、遅延などが起きない様にしようと思うと、
    文字符号化方式に依存して使われていないコードポイントを使用するしかない。

    * しかし、やはりできそうな気がしてくる。本当に不可能なのだろうか。

      | 先ず前提として、或る文字を直接受信できないときに、
      | bind '"\x1B": "\xC0\x9B"' などの様にして別のシーケンスにして受信できる。
      | この時、受信できないバイト "\x1B" は当然代替シーケンスには含まれない。
      |
      | 問題は以下の様に要約できる。
      |
      | 1 256 種類のバイトを 254 種類のバイトで符号化する方法を作る。
      | 2 この符号に対して再び符号化を適用しても不変である。
      |
      | 254 種類というのは、直接受信できないバイトが 2 種類存在するという前提である。
      | この時 bind -x で受信するためには残りの 254 種類のバイトで行わなければならない。
      | 要求 2 は、bind '"\xC0": "\xC0\x9B"' に対して反復して変換が試みられる実情を反映する。
      | この条件が満たされないと無限ループに陥る。
      |
      | この様な符号化は不可能な気がする。
      | もう少し真面目に考える。とにかく鍵となるのは直接受信できないバイト
      | B1, B2 を表現するために使われるシーケンスを構成するバイトである。
      | 特に Encode(B1) の先頭文字を B3 ということにする。
      | この時、曖昧でないためには B3 自体も符号化しなければならない。
      | 無限ループに陥らない為には B3 は B1-B3 以外の文字で表さなければならない。
      | これを繰り返すと最終的に文字がなくなる。よって不可能だ。
      |
      | これを克服するには少なくとも条件を緩くしなければならない。
      | 例えば bind -x '"\xC0\xC0": hoge' 等のようにする。
      | \xC0 は単体で受信されることはなくて必ず二文字に増やしてから受信するのだとすれば、
      | これで遅延が生じることはないように思われると思ったが…
      |
      | 1 \xC0 単体で受信した時に次の文字が来ないか待つのでここで timeout 分遅延する
      | 2 更に、たまたま本当の入力に \xC0\xC0 の様な並びがあるときに
      |   それが別のバイトに化けてしまう。

      やはり文字符号化方式の穴を使わずに
      完全な読み取りを実現することは不可能であると判断する。

      (全て Bash の bind で直接受信できないバイトが存在するのが悪いのだが)

    * さて、この時 input_encoding=C については全ての文字が意味を持つので、
      穴など存在しない様に思われる。何れかのバイトを犠牲にするしかない。
      例えば C1 制御文字の何れかを犠牲にするのが一番影響が小さいだろう。
      C1 制御文字をコマンドの文字列を構成する文字の一つとして使いたい時は問題だが、
      その様なケースは限られているので仕方がない。

      一番影響が少ないと思われるのは、元からシーケンスの一部として使われる様な文字である。
      例えば ESC がそれだが、これが丁度 Bash では直接受信できない文字である。
      次に CSI などがある。他に DCS SOS OSC PM APC 等がある。
      DLE (C-p) は実際に使われるので駄目。まあ CSI を使って置くのが妥当であろう。

      さて CSI を犠牲にすると言えば、どの様にするのが良いだろう。
      実際に 8 bit CSI シーケンスが送られてきた時と干渉しないためには、
      これ自身も CSI シーケンスになる様に構成するのが良い。

      | a 2文字で表現する案
      |
      |   また CSI は、もし CSI シーケンスを処理するのだとしたら、
      |   結局何れにしても 2 文字目以降を待つ必要があるので都合が良い。
      |   private CSI を使うことにする。特に、端末制御用のシーケンスは
      |   逆に端末から送られてくることは無さそうなので、それが良い。
      |   下手に使われていない private CSI は端末によっては拡張で対応している可能性がある。
      |
      |   然し、そのように考えてみると実は private CSI ではなくて ANSI CSI seq の方が良いかもしれない。
      |   と思ったが CUU, CUD, CUF, CUB などはカーソルキーで使われているし、際どい。
      |   もしかすると端末によってはその他のキーについても ANSI CSI seq と同じものを使ってくるかもしれない。
      |   しかしその危険性は private CSI の方が高いような気もする。結局 private/ansi は当てにならないので
      |   実際の実装を確認するしか無い様に思われる。vt100 の function key f1-f10 で ESC O ? が使われている。
      |   ? には P Q R S t u v l w x が使われている。これらは避ける。
      |
      |   しかし、現在では CSI による制御シーケンスは使われず、
      |   専ら ESC [ による 7 bit の制御シーケンスが使われる。
      |   従って、そんなに気にする必要もないのかもしれない。
      |
      | b 或いは 2 文字でなくても良い。
      |   <csi>27;1;2047~ などとしてこれに対して bind -x しまう手もある。
      |   しかしこの方法で問題が生じないかは疑問である。
      |
      |   と思ったが、bind -x で 2 文字以上に bind できるのは
      |   bash-4.3 以降なのでこれは駄目である。
      |
      | c うーん。或いはそもそも CSI シーケンスの形をしていなくても良いのでは。
      |   CSI シーケンスとして不正なものに割り当てるのが良い。

      ここは c を採用する事にした。

    * 次に bind を符号化方式依存にするのであるから、
      bind.sh の方も符号化方式に依存して切り替える様にするべきなのではないだろうか。

      一つの方法は符号化方式毎に generate-binder を設計するというものである。
      もう一つの方法は、現在の UTF-8 の generate-binder を元にして、
      各符号化方式毎に後付の補正を行うという方法である。
      各符号化方式毎の後付の補正にする方が管理が楽であるように思う。
      何より新しい符号化方式に対応する時のコストが小さくて済む。

      取り敢えず現在の UTF-8 用の bind の整理を行う。
      #D0583 で C-x について単純化できないか考えたができなそうだ。
      #D0584 で ESC ESC について単純化を考える。これは現在の枠組みでは不要だった。

      現在の UTF-8 用の bind で UTF-8 依存なのは以下の物である。
      bind の設定に依っては変わるかもしれないが気にしないことにする。

        ble-decode/generate-binder/bind-s '"\C-@":"\xC0\x80"'
        ble-decode/generate-binder/bind-s '"\e":"\xDF\xBF"'
        ble-decode/generate-binder/bind-s '"\e'"$ret"'":"\xC0\x9B'"$ret"'"'

    [実装1] ble-decode-attach/ble-decode-detach で符号化方式依存の物にする。

    % bind 修正用の関数を定義した。
    % ble/encoding:C/rebind 及び ble/encoding:C/unbind である。
    % 更にそれに応じて ble-decode-char+C も修正した。
    % isolated ESC にも対応している。しかしその前に isolated ESC が UTF-8 でも動作することを確かめたい。
    %
    % 同時に ble/encoding:UTF-8/rebind 及び ble/encoding:UTF-8/unbind も用意する。
    %
    % 更にこの rebind, unbind を適切なタイミングで呼び出す様にする必要がある。

    と思ったがこの ble/encoding:UTF-8/rebind の時間計測を行うと存外に遅い。
    42ms かかっている。bind のキャシュを source するのにかかる時間が 19ms である事を考えると遅い。
    やはり encoding 毎の bind キャッシュを考えるべきだろうか。やはりそうする。

    取り敢えず対応した。動いている。意外と変なことも起こらず普通に動いている。
    所で、やはり UTF-8 の binder を上書きするようにしている為に、source には多少時間がかかる。
    元々 18ms だったのが 26ms に増えている。8ms の増加である。
    まあ、UTF-8 でない変な文字コードを用いることの代償としてはそんなに大きくないので気にしない。

    ところで思ったのだけれど bind のキャッシュを生成するときに
    bind.sh のタイムスタンプは見ているが、ble/encoding:C/generate-binder のタイムスタンプは分からない。
    新しい符号化方式に対応する時には、このタイムスタンプも確認する必要がある。
    これについてはメモに記録することにする。

    [実装2] 動的に符号化方式を切り替えるときについて対応する。

    新しく ble-decode/bind 及び ble-decode/unbind を作成した。

    今回の改修で memo.txt の冒頭にある文字コード対応についての以下の記述は古くなったので更新した。

    | ble-decode.sh (function .ble-decode-bind):
    | bash-3 で "ESC [" を bind する為に ESC [ を
    | utf-8 の非正規な符号 "\xC0\x9B[" に変換している。
    | bash-4.3 で "C-@" を bind する為に \C-@ を
    | utf-8 の非正規な符号 "\xC0\x80" に変換している。
    |
    | UTF-8 以外の文字コードを使う場合には
    | これらのバイト列を特別に認識する様にするか、
    | 別のバイト列を指定する必要がある。
    | (これらは bind にハードコードされているが、
    | 外部から指定できる様に変更する必要がある。)

  * decode: <C-q><C-[> とすると ^[[27;5;91~ が入力される。 [#D0585]

    これは単体の ESC を ESC[27;5;91~ に翻訳し、
    何かに前置されてやってくる ESC を ESC で受信しているのが原因。

    <C-q> の引数として一文字読み取るのに使うためには、
    寧ろ単体の ESC を ESC として読み取って、
    Meta と解釈されるものを別の文字として受信するべきなのではないか?

    しかし、そうすると今度は <C-q><left> の方がより変な入力になってしまう。
    現状では ^[[C が入力されるがこれが ^[[27;5;91~[C などになる。
    どちらでも期待通りに入力するためには bind/decode の側で工夫しなければならない。

    | a 例えば同一の文字として解釈されるが内部的な表現の異なる UTF-8
    |   (要するに不正な UTF-8 表現) を使って両者を区別する方法。
    |   しかし、この違いは ble-decode-char まで来た時に吸収されているので、
    |   区別することはできない。
    |
    |   区別しようと思ったら ble-decode-byte:UTF-8 の中を弄るか、
    |   或いは、不正な UTF-8 表現に対して ble_decode_Erro フラグを立てて、
    |   それの有無で ESC の種類を特定するという方法がある。
    |   しかし、現状では ESC の受信には常に不正表現を使っているので、
    |   ble_decode_Erro フラグをつけるとすれば常につける事になるので良くない。
    |
    | b もう一つの方法は、ble/util/is-stdin-ready を修正して、
    |   ble-decode-byte 及び ble-decode-char で処理中の文字が残っているかどうかで、
    |   それが孤立 ESC か続きのある ESC かを判定するという方法がある。
    |
    |   こちらの方が良さそうだ。問題点としては何があるだろうか。
    |   例えば、キーボードマクロに登録されたものを再生する時は、
    |   元々孤立 ESC だったものも Meta になってしまうという問題がある。
    |   と思ったが、これについては記録する時に ^[[27;5;91~ に変換すれば良い。
    |   と持ったが、<C-q><C-[> として記録する時にはどうするのだろう…。
    |
    | c 或いは、孤立 ESC の時には、ESC に続いて
    |   無視される文字 <wait> を読ませるという手もある。
    |   つまり、ESC は取り敢えずは Meta として読ませて置いて、
    |   Meta が設定されている時に <wait> 文字が来たら、
    |   それを C-[ として ble-decode-key に伝達する。
    |
    |   何もない時に <wait> が来たら無視する。
    |   (これは <C-q><C-[> によって先頭の ESC が横取りされた時などに発生しうる。)
    |
    |   キーボードマクロに登録する時には、<wait> 文字も含めるようにすれば良い。
    |   p 等でレジスタの中身を表示するとそこに文字があることが見えてしまうが、仕方がない。
    |
    |   さて。問題はどの文字を <wait> として採用するかである。
    |   a C0 の文字でそういう意味を持ちそうな文字はありそうだが、
    |     実のところこれらは C-? としての意味を持つので、他の意味には使えない。
    |     例えば C-@ や DEL は元々は通信では無視されるものだったが、今では意味を持つ。
    |   b C1 の文字についてはどうだろうか。これはキーボードから直接入力することはない。
    |     (M-C-? で入力できる端末もあるかもしれないが、まあ ESC C-? で送ってもらうべきである)
    |     しかし、現在の実装ではコピーペーストなどによって、
    |     実際に self-insert で編集文字列の一部として入力可能である。
    |     この動作を破壊するのも難がある。編集文字列の一部になりえないのは C-@ のみであるが、
    |     これは文字列として入力されることはなく特別な操作に使われる。
    |   c Unicode の定義されていない文字を用いるというのが無難そうである。
    |     Unicode の文字を使用すると他の符号化方式に対応した時に問題になるが、
    |     他の符号化方式を使うときはその符号化方式で使われていない code point を使うことにすれば良い。
    |
    |     現状で C0 も GL も <wait> には使えないとなれば
    |     結局文字符号化方式によって大きく意味が異なる C1 か GR の領域を使わざるを得ないので、
    |     このように文字コード毎に特別な文字を確保するということは不可避である。
    |
    |     ただ文字符号化方式が C の時に限れば何処にも特殊な文字を置く場所がないので、
    |     この問題は不可避である。というかよく考えたら、現状で既に文字符号化方式 C は壊れているのではないか。
    |     →これは別項目で議論することにする #D0586
    |
    |     https://ja.wikipedia.org/wiki/Unicode%E4%B8%80%E8%A6%A7_0000-0FFF を見ると、
    |     未使用は結構あるようだが不使用ではない。つまり、将来的に何か文字が割り当てられるかもしれない。
    |     不使用の文字はずっと後ろの方にありそうである。
    |     一方で、特別な文字については余り沢山の文字を消費したくない。
    |     UTF-8 で 2 byte に収まるのは 0-800 の範囲である。7FF が良さそうだ。
    |
    |   d 或いは Unicode の場合には UTF-8 不正表現の内のどれかを特別に wait に割り当てても良い。
    |     例えば 0 (NUL) の 2 byte 表現はどうだろうか…と思ったら既に NUL を受信するのにその対処が必要だった。
    |
    | d 逆も考えうるかもしれない。つまり、孤立でない ESC の時は、その直後に <meta> の文字を挟む様にする。
    |   (vi-mode の) キーボードマクロで記録する時には常に CSI 27 ~ に M-* も含めてしまう様にする。
    |
    | e うーん。孤立 ESC かどうかを判定してキーの組み立てに影響を与えるのは ble-decode-char の中である。
    |   これは文字符号化の復号を行う ble-decode-byte よりも後段になる。
    |   という事は、ble-decode-byte を貫通して Meta の情報を伝達する仕組みは何れにしても必要である。
    |   或いは、実は Meta の時には ble-decode-byte をスキップして直接 ble-decode-char に対して、
    |   特殊な文字を送り込むという手管も考えられる。そうすれば、文字符号化方式と直交させることができる。
    |   その折にはそもそも ESC <meta> などという 2 バイトの組み合わせにする必要はなくて、
    |   単に <meta> を ble-decode-char に送りつければ良い。
    |   更に、ble-decode-char に渡される文字は既に Unicode になっている筈なので、
    |   文字符号化方式毎に <meta> のために使う特別な文字を割り当てなくてもよい。

    #D0586 で議論されている方法を用いて、上記の e の方式で行くことにする。

    % - 孤立 ESC はそのまま ble-decode-byte に入っていく。
    %   文字符号化方式が ESC を特別扱いしなければ、
    %   これはそのまま ble-decode-char に入っていく。
    %   ble-decode-char では ESC は即座に key C-[ に変換し、
    %   キーシーケンスの一部になることは防ぐ。
    %   但し _ble_decode_char__hook が設定されている時は ESC として処理する。
    %
    % - ESC ? として受信した場合は <meta> を ble-decode-char に流し込む。
    %   或いは、そもそも meta という文字を定義しなくて
    %   単に ble-decode-char/set-meta 的な関数で良い。
    %   但し _ble_decode_char__hook が設定されている時は ESC として処理する。
    %
    % 問題となるのは文字を構成するバイトの途中で ESC が現れた時である。
    % その様な文字符号化方式は (少なくとも現実的なものでは) 存在しなそうだが…。
    %
    % と思ったが、そもそも iso-2022-jp などでは文字コードの制御に ESC を用いるので、
    % 孤立 ESC でなかったからと言って処理をスキップすることは不可能である。
    % 寧ろ孤立 ESC の時こそ ble-decode-byte をスキップするべきである。

    という訳で以下のように手順を修正する。

    - 孤立 ESC は文字復号には参加せず ble-decode-char に
      <isolated-esc> として入っていく。
      _ble_decode_char__hook が設定されているとき、
      <isolated-esc> は ESC (^[) に変換してから呼び出す。
      それ以外の時はそのまま C-[ になって出ていく。
    - 先行 ESC は文字復号に参加する。例えば UTF-8 などの場合には、
      そのまま貫通して ble-decode-char に渡る。

    vi-mode のキーボードマクロに記録する時は、
    isolated-esc をどうにかしなければならない。

    | a 或いは再生時に esc を isolated-esc に変換するか。
    |
    |   % と思ったが、それだと通常のキーシーケンスも isolated-esc になってしまう。
    |   % 通常のキーシーケンスは ESC [ ではなくて CSI で始まる様にするという手もあるが、
    |   % そうすると今度は ble-bind -c で ESC 云々 として登録された物が処理されない。
    |   % と思ったが、よく考えたらそれは気にしなくても良い。
    |   % 結局キーボードマクロに記録されるのは文字ではなくてキーであり、
    |   % キーは必ず CSI 27 ~ で記録されるので ble-bind -c の設定には関係ない。
    |
    |   キーは CSI 27 ~ で記録するようにすれば問題ない。
    |   後、これに対応するためには decode で CSI に対応しなければならない。
    |
    | b 或いは、全て先行 ESC と解釈して実行してしまっても良い?
    |   と思ったがやはり不便である。<wait> 的な文字をやはり実装するべきか。
    |   しかし、その様な物を実装するくらいであれば、
    |   初めから <isolated-esc> としてレジスタに記録すれば良いのである。

    上記 a の方法を採用する。
    vi のキーボードマクロでは全て isolated-esc として ble-decode-char に送る。
    また decode は CSI 27 ~ に対応する。

    % [孤立 ESC を ESC とし、先行 ESC を <meta> として ble-decode-char に入れる案]
    %
    % ここまでの案では孤立 ESC は <isolated-esc> として ble-decode-char に入り、
    % 先行 ESC についてはそのまま ble-decode-char に入るという話だった。
    % しかし逆にするという手もあるのではないか。
    % そうすれば vi のキーボードマクロでの実装も自然になる。
    %
    % この時孤立 ESC はそのまま ESC として ble-decode-char に入り、
    % キーシーケンスの一部とはなりえない。
    % 一方で、先行 ESC は <meta> として ble-decode-char に入り、
    % キーシーケンスの一部になりえる。
    % キーシーケンスの一部ではないときは単に C-[ になる。
    %
    % と思ったが、ユーザが ble-decode-char 27 を呼び出した時に、
    % それが孤立 ESC として取り扱われ決して先行 ESC として取り扱われないのは変だ。
    % やはり先行 ESC として取り扱う方が自然なのではないのか。
    % 或いは、ble-decode-char に同時に複数の引数を指定することがあれば、
    % 一番最後の引数の 27 でなければ先行 ESC として取り扱うという手もある。
    % x しかしそれだと結局キーボードマクロの孤立 ESC を孤立 ESC として取り扱わせるために特別の処理が必要なので、
    %   孤立 ESC の方を <isolated-esc> として取り扱う手法に対する利点がなくなる。
    % x また、ble-decode-char を連ねて書く場合とそうでない場合で振る舞いが異なるのも混乱の元である。

    →やはり孤立 ESC を <isolated-esc> として取り扱う方が自然である。

    [実装1] 孤立 ESC を 0x7FF にする

    取り敢えずキーボードマクロの事はさておき、
    孤立 ESC の受信方法を変更することにした。
    孤立 ESC は U+07FF で表すことにする。ble-decode-char で適切に対応する。

    % と思ったら全く入力できなくなっている…。
    % bind -s を見てみると登録されているべきものが登録されていない。
    % と思ったらテスト用の設定がそのままになっていた。戻した。

    今度は C-[ は動くが、M-a や M-i を押した時の動きが変だ。
    うーん。今までは動いたはずである。例えば M-c は動いていた。
    bind -s の違いは \e を何に翻訳するかが異なるだけである。
    bind -X の違いはなかった。だとすると ble-decode の方の問題だろうか。
    → keylog で確認してみた所、何と ESC c a が M-a ESC a に翻訳されている。
    これは一体どういうことだろう。最後の ESC a は vi_imap/__default__ による物だろう。
    だとすると ESC c を処理する時に c が消えてしまっているのが問題だ。
    連続してきた文字の処理ができていない? と思ったが矢印などは処理できている。

    と思ったら while (($#)) を for char に書き換えたのが駄目だった。
    ループの途中で set -- "${rest[@]}" "$@" などとしている為である。
    取り敢えず動くということを確認した。

    また <C-q><C-[> がちゃんと ^[ の入力になるということを確かめた。

    [実装2] 次にキーボードマクロの為 CSI シーケンスを解釈する様にする。

    対応した。簡単だった。多分、これで大丈夫。

    今まで CSI に対応していなかった理由を探したが特に書かれていなかった。
    現在の CSI シーケンス抽出の仕組みを整える前は、
    CSI まで全て cmap に登録すると大変になるという理由で対応していなかった。
    現在では CSI シーケンスに対応しないという理由はない。
    ble-decode-char の中での処理なので UTF-8 を構成するバイトの CSI と干渉するという事もない。
    多分、大丈夫である。

    [実装3] vi のキーボードマクロに登録する時は CSI を用いるの事。

    対応した。同時に C-[ は ESC として記録する。
    再生時には ESC は ble_decode_IsolatedESC に変換する。

  * bind: ESC ESC for bash-4.1/4.2 は不要なのでは? [#D0584]

    これは #D0586 の整理の一環である。

    過去に bash-4.1, 4.2 の ESC ESC で問題が生じていた。
    これは元々 #D0055 で議論されている。

    然し、その後で ESC の方式を切り替えた。
    もしかすると、今となってはこの対策も不要になっているのでは?
    うーん。これも今は再現しない。

    再現することはできなかったが、実際の実装を見てみると、
    bind '"\e\e": "..."' に移しているのだから、
    現状の ESC の読み取りの方法と同様である。
    従って、特別にこの方法を取る必要性はない。
    現在の方法を利用している際には有効にならないように修正した。

  * bind: C-x の workaround を別の方式に切り替える [却下] [#D0583]

    これは #D0586 の整理の一環である。

    この辺りで既存の UTF-8 用の binder について整理が必要に思われる。
    観察していて気付いたのは、C-x を捕まえる為に使っている方法である。
    二文字の組み合わせで捕まえることにしている。しかし、これは本当に必要だろうか。
    実は C-@ と同様に別の文字に振り替えれば問題なく捕まえることができたりしないのか。

    % 取り敢えず、work around の原因となった問題の再現を試みる。
    % bash-4.2 と bash-4.4 と bash-3.1 で確かめる。
    % おかしい。何れを用いても再現しない。
    % この問題は例えば #D0391 などに記録が残っているがヒントはない。
    % もっと遡ると #D0148 #D0122 #D0057 #D0018 #D0017 にある。
    % C-x C-b C-b 等と入力してみてもやはり再現しない。

    →分かった。vi-mode だと発生しない。emacs mode だと発生する。
    bash-4.2 で再現した。bash-3.1 で再現する。bash-3.2 は無限ループになる。
    bash-4.0 もクラッシュする。bash-4.1 もクラッシュする。
    bash-4.3 は大丈夫。bash-4.4 はコマンドのキーマップがありませんと出る。
    まとめると以下のようになる。

    version | 症状
    --------+--------------------------------------------------
    3.0-3.1 | segfault
    3.2     | 無限ループ
    4.0-4.2 | segfault
    4.3     | 大丈夫
    4.4     | "コマンドのキーマップがありません" のエラー

    ここで別の方式に切り替える。bind -s '"\C-x": "\xC0\x98"' に変更する。
    すると C-x C-x と押しても即座に反映されなくなってしまった。何故だろう。
    以前に似た症状があった #D0395 これを確認してみたが、
    この時の原因は今回とは関係ないはずである。

    以下を実行してみてもやはり遅延は残る。
    for ((i=0;i<256;i++)); do ble-decode-bind/c2dqs "$i"; bind -r '\C-x'"$ret"; done

    結局遅延を抑える為には C-x? に bind するしかない様だ。
    そうするとクラッシュの問題は生じなくなるので気にしなくて良い。

  * vi-mode: bug, キーボードマクロで Meta が正しく記録されていない [#D0582]
    #D0586 周りの考察をしている時に見つけた。直した。

2017-11-10

  * 2017-11-08: vi-mode (nmap K): ページャの表示の問題 (reported by cmplstofB) [#D0581]

    * 再描画の実施

      | - 再描画を実施するように変更する。
      |   どのページャも常に altscreen を使用するとは限らないということ。
      |
      |   但しヘルプを表示する度に新しい行に移動するのは嫌なので、
      |   一旦現在表示している内容を消去してからヘルプを呼び出し、
      |   その後でまた再描画するようにする。
      |
      | - cmplstofB さんの報告によると:
      |
      |   > 私は Xfce4 Terminal [1] を使っているのですが，この仮想端末は xterm-256color
      |   > を terminfo として用いており，xterm-256color の terminfo ではきちんと
      |   > alternate screen は有効になっておりました。
      |
      |   だとすると、複数画面に亘る時に空行になってしまう問題の原因は altscreen off ではない?
      |   何故なのかよく分からないが、取り敢えず毎回再描画することにすれば何れにしても解決する気がする。
      |
      | leave/enter と編集文字列の消去と再描画を実施するようにした。
      | しかし、現状の実装だと man に失敗する場合でも
      | 編集文字列の消去と再描画を実施するようになっていて気になる。
      | 本来であれば man が成功して何か表示できると分かった時点で再描画を実施したいものである。

      PAGER を設定できるようにするのであれば、何れにしても完全に対応しなければならない。
      従って、ヘルプを表示する前に消去して、ヘルプを表示した後に再描画する。

    * stty で leave/enter をちゃんと実施する。
      man はキーボード入力を求めるが、これが操作不可能になってしまう。

      > これも私の設定の問題ですが，$MANOPT に --all 等の値を設定していると，
      > ble.sh と man ページが競合するか何かしてキー入力が受け付けられなくなります。

      多分、これはこの leave, enter が原因なのである。
      もしかすると違うかもしれない。実装後に確認が必要である。
      →実際に leave/enter を呼び出すようにした所直った。

    * 日本語 man の内容を正しく取得する方法?

      | 問題点は何処にあるかというと $(man ...) もしくは、man > ... として実行すると、
      | man の日本語見出しが壊れてしまうということと man の太字などの修飾が消滅してしまうということである。
      | なので、現在は成功するかどうかわからない man をいきなり実行する様にしている。
      |
      | a 一つの方法は、一回 man ... &>/dev/null を実行して成功するかどうか確かめて、
      |   その上で man を再度実行するというものである。これは二回 man を呼び出すので遅い。
      |
      | b 或いは PAGER='...' もしくは man -P '...' に cat などを指定して
      |   何処かにデータを書き出してしまえば良い。
      |   しかし POSIX man ではその様な規定はないので、
      |   これが実際に使えるかどうか分からない。
      |
      |   PAGER 指定が無効な man の為に PAGER=... man > file などとすると、
      |   また日本語見出しが壊れたり太字などの情報が消えたりする。
      |
      | c 別の方法として仮想端末を新しく作るという方法はあるかもしれない。
      |
      |   exec 9<>/dev/ptmx で 9 に開く。
      |   pty=$(tty <&9) でスレーブのファイル名が分かる
      |   grantpt は chown $UID $pty; chmod 620 $pty とすれば良い。
      |   unlockpt は分からない。
      |
      |   と思ったが tty <&9 では /dev/ptmx が得られるだけだった。
      |   slave のファイル名が分からないので開けない。
      |   検索してみても shell で同じことを実現しようとしている人は見つからないし、
      |   また Python でも似たことを挑戦しようとしている質問では、
      |   ptsname, grantpt, unlockpt の手段がないということで、
      |   専用のライブラリ pty を import して使うことを薦められている。
      |
      | しかし改めて考えてみると run-help 的な枠組みに対応するのだとしたら、
      | 何れにしても成功するのか失敗するのかは外側からは分からない。
      | 結局、毎回消去してヘルプの表示を試行して再描画するということになる。
      | 一応 run-help 的関数が定義されていない場合には、
      | 無駄な消去・再描画がないように頑張れるが、構造的に面倒だ。
      | 毎回消去・再描画がある方が自然な実装になる。

      結局日本語 man の中身を正しく抽出する方法は不明である。
      しかし (遅いが) 一応動いているので取り敢えずよしとする。

    * run-help 的関数は complete の枠組みと統合するべきか。

      | そもそも未だ実装していないが complete の枠組みとして以下のようなものが構想にある。
      | 現状では補完関数は専ら組み込みの complete によって設定されるものだけであるが、
      | より分かりやすい枠組みとして ble/complete/コマンド名 という関数を通して定義できる様にする。
      | 或るコマンドの引数を補完する時は、その関数が定義されていればそれを使う。
      | また、"${BLEPATH:-$_ble_base}/complete/コマンド名" が存在すればそれを
      | source して定義された関数を使う。
      | それでも見つからないときは従来の complete による枠組みを使用する。
      |
      | 同様に、引数の色つけ関数も考えうる。
      | 例えば ble/color/コマンド名 というシェル関数で定義できる様にして、
      | "$BLEPATH/color/コマンド名" というファイルも探索する様にするとできる。
      |
      | しかし、機能毎にファイルを配置するのは大変だし、
      | 恐らく実際の設計上はやはり同じファイルで補完も色つけも定義したい。
      | その様に考えれば "$BLEPATH/command/コマンド名" 的なファイル名にして、
      | 更に、ble/command/complete:mycmd, ble/command/color:mycmd などという関数名にする。
      |
      | % また、引数の補完ではなくて標準入力 (ヒアドキュメント) の補完といった物も考えうる。
      | % →これは新しい関数として定義するというよりは ble/command/complete:mycmd に、
      | %   特別な引数を指定して呼び出すというのの方が良いような気もする。
      | と思ったが、恐らく complete:mycmd を実装する時には
      | そのような滅多に実装しない様なものの為に毎回条件分岐するのも面倒なので、
      | ここはやはり独立した関数として提供するべきである。例えば、
      | ble/command/complete-stdin:mycmd
      |
      | 更にリダイレクト先のファイルの補完も同様に処理できる。
      | ble/command/complete-redirect:mycmd
      |
      | この延長で ble/command/help:mycmd というのを入れるのは妥当である。
      |
      | 所で名前空間 ble/command に関してはもう少し考察の余地がある。
      | この名前空間は実際に補助のファイルを配置するディレクトリの名前と合わせたい。
      | $BLEPATH/command/mycmd というファイル名があると、
      | 其処に実際のコマンドを格納するみたいである。なので、command ではないより良いものが欲しい。
      | 例えば terminfo の様に commandinfo もしくは cmdinfo とするのはどうだろうか。
      | cmdinfo は省略形なので余り好まれないかもしれないと思ったが、
      | 実のところ commandinfo の時点で command-information の略である。

      従って cmdinfo で良いような気がしてきた。以下のような感じにする。

      ble/cmdinfo/complete:mycmd
      ble/cmdinfo/complete-stdin:mycmd
      ble/cmdinfo/complete-redirect:mycmd
      ble/cmdinfo/color:mycmd
      ble/cmdinfo/color-stdin:mycmd
      ble/cmdinfo/help:mycmd
      ble/cmdinfo/help-stdin:mycmd

      結論としては即座には統合しないが、将来的に統合するときのために関数名だけは決めておく。
      ble/cmdinfo/help:mycmd という事にする。

    * ble/cmdinfo/help:"$cmd" と ble/cmdinfo/help に対応する。
      対応した。動作テストはしていない。

    * テスト項目

      - done: bash buitlin
      - done: bash keyword
      - done: bash [[
      - done: alias resolve
      - done: function

  * 2017-11-08 command-help: bash 組み込みコマンドの man (suggested by cmplstofB) [#D0580]

    > $ # K --> function-for-help test --> man -P 'less $LESS -p ^test' bash

    そのままだと動かない。少し工夫が必要である。

    man bash | \grep -n '^[[:space:]]*test' | awk '/^([0-9]+)/ {sub(/[^0-9].*/, "");print;exit}'

    結局色々試した挙句複雑な実装になった。
    ble/widget/command-help/.locate-in-man-bash に実装した。

  * vi-mode (cmap): isearch している途中に決定を押すとその内容が実行されてしまう。 [#D0579]
    調べると ble/widget/isearch/accept の中で ble/widget/accept-line を呼び出している。
    これは駄目。仕方がないので、ble-decode-key "${KEYS[@]}" を呼び出すことにした。
    isearch では C-m で確定である。同様に呼び出し元でも C-m が確定であると想定して良い。
    だとすれば、そのまま "${KEYS[@]}" を呼び出しておけば問題ないだろう。

  * decode: bug 'unset var[index]' が failglob/nullglob で全滅する (reported by cmplstofB) [#D0578]

    > あと，もう一つ細かいのですが，failglob を有効にしていると，l* のようなコマンドを入力した場合，
    > (決定キーを押下する前に) 「-bash: 一致しません: _ble_decode_keymap_stack[last]」というエラーメッセージが出ます。

    failglob は厳しい。浮いている [] があるともう駄目だ。
    というか nullglob の時は何もメッセージを出さないので、なおたちが悪い。

    unset _ble_decode_keymap_stack[last] が駄目になっていた。

    類似のものがないか検索する。

    grc 'unset [[:alnum:]_]+\[|^[^][#"'\''`{}()]+\[[^[]'

    どうも unset は全て確認したほうが良さそうな感じがしている。
    他に ble-bind -f C-[ となっている物が vi.sh の中にある。
    これは大丈夫かもしれないが念のため囲むことにする。

    更に、この問題は過去の version にも波及する。修正が必要である。
    これは一応探してすぐ分かるところは直した。

2017-11-09

  * vi-mode (cmap): 履歴に対応 (requested by cmplstofB) [#D0577]

    現状の履歴の仕組みはシェルのコマンド履歴 history とくっついている。
    これを分離しなければならない。実際の変更はそんなに大変ではないだろう。
    ただ、それぞれの変数の役割を特定するのは面倒である。

    | 何れにしても一つずつ調べていくしかない。
    | 恐らく履歴に関係しているのは _ble_edit_history* という変数のみである。
    | この名前の変数は幸いなことに ble-edit.sh において、
    | ./ble-edit.sh:4248-4982 に固まって存在している。
    |
    | 以下の変数はコマンド履歴と関係なく必要な変数である。
    | 使われ方も共通で良さそうに思われる。
    |
    | _ble_edit_history=()
    | _ble_edit_history_edit=()
    | _ble_edit_history_dirt=()
    | _ble_edit_history_ind=0
    |
    | * 以下の変数と関数もコマンド履歴とは独立に対応するべき気がする。
    |   従って、そのまま利用できるようにする。
    |   但し、onleave.fire で呼び出された関数で変なことにならない様に注意する。
    |   これは keymap を見て vi_cmap だったら何もしないという事で対処できそう。
    |
    |   _ble_edit_history_onleave=()
    |   ble-edit/history/onleave.fire
    |
    |
    | * 以下の変数は危険である。これが空欄の時にはコマンド履歴を呼び出してしまう。
    |   コマンド履歴ではない時には、これらの変数は空白であってはならない。
    |   これらが非空白であればコマンド履歴は呼び出されない。
    |   というか _ble_edit_history_loaded だけ注意していれば良さそうだ。
    |
    |   _ble_edit_history_loaded=
    |   _ble_edit_history_count=
    |   ble-edit/history/getindex
    |   ble-edit/history/getcount
    |   ble-edit/history/load
    |
    | * 以下の関数はコマンド履歴に追加を行うので、
    |   コマンド履歴以外では呼び出してはならない。
    |   現在は accept-line の一箇所でしか呼び出していないので
    |   それ程気にしなくても良いが、名前を変えるなどする必要がある。
    |
    |   ble-edit/history/add
    |
    |   これは ble-edit/history/add-command-history に改名した。
    |   単に追加を行う関数として ble-edit/history/add を追加した。
    |
    | * isearch 関係の関数は殆どコマンド履歴と直交している。
    |   isearch keymap に入る瞬間の以下の widget で
    |   ble-edit-/history/load を呼び出しているが、
    |   これは _ble_edit_history_loaded だけ注意していれば良い。
    |
    |   ble/widget/history-isearch-backward
    |   ble/widget/history-isearch-forward
    |
    | うーん。状態変更にどのように対応すれば良いだろうか。
    |
    | a 初めに考えたのは history に関連する widget それぞれについて、
    |   cmap/history-* のような新しい widget を作って、
    |   その中でローカル変数を設定して _ble_edit_history_* をすり変えて、
    |   その上で各関数を呼び出すという物である。
    |   呼び出した後は、変更のあったものについては
    |   自前の履歴変数に書き戻すなどする。
    |
    |   しかし widget 毎に一つ一つ用意するのは非効率的である。
    |
    | b なので @vi_cmap-history などの修飾 widget を作成しても良い。
    |
    |   それでも色々と面倒はある。
    |   例えば、isearch は特別の keymap を用いるので、
    |   cmap で isearch を利用しようと思ったら、
    |   isearch keymap の clone を作成しなければならない。
    |
    |   - これは色々問題が残る。先ず、似たような履歴を持つ編集モードの
    |     それぞれについて isearch の clone を作らなければならない。
    |   - 更に、isearch キーマップを変更しても、それは clone には適用されない。
    |     全ての isearch clone たちに対して同様の変更を適用する必要がある。
    |     これは場合によっては有用かもしれないが、非直感的であるということの方が勝る。
    |
    |   また、一様に状態を復元し・保存しということをすると、
    |   毎回全項目について状態を保存しなければならず非効率的である。
    |   大体の場合は履歴移動しかしないのだから、履歴番号だけ書き戻せば十分のはずである。
    |   % と思ったが、history 云々のコマンドからは、元から履歴番号だけしか書き戻さないかも。
    |   履歴番号だけしか書き戻さなくて良いかどうかは
    |   history, isearch の実装の方が知っているはずなのでそちらに任せたい。
    |
    | c やはり history, isearch 側で代替履歴の存在を
    |   認識する様に実装するほうが自然に思われる。
    |
    | ここは c で行く事にする。先ず初めに _ble_edit_history_prefix という変数を定義する。
    | 幾らか実装したが、すり替えによる実装は混乱が大きい。
    | 先ず、どの関数がすり変えたことが前提になっていて、
    | どの関数が何も考えずに呼び出せるのかが分かりにくい。
    |
    | 更に、或る関数が、すりかえを実行している関数とすり替えを
    | 実行していない関数の両方から呼び出されているとき、
    | どの様に処理をするのかが謎である。
    |
    | a 関数がすり替えを実行する時に local _ble_edit_history_prefix= とする?
    |   その様にすれば呼び出された関数が重複して復元・記録を行うことはなくなる。
    |
    |   しかし、これは何を意味するかというと使用しない変数も含めて
    |   全ての変数を復元・記録するということになる。
    |   或いは、どの変数がすり替えられていてどの変数がすり替えられていないかについて
    |   一つ一つの関数について決定して、それに基いて注意深く実装するということも
    |   原理的には可能だが、これは言語道断の実装である。
    |
    | b 或いは、二重にすり替えが起こっても大丈夫な様に設計を行う。
    |
    |   すり替えが実際に実施されていたとしても、
    |   変数の内容を書き換えたりしていない限りは、
    |   元の変数の方にアクセスしている限りにおいては問題はない。
    |
    |   従って、search-history などの関数において、
    |   内部で変数を _ble_edit_history_edit にロードしていても、
    |   何も考えずに他の対策済み関数を呼び出して良い。
    |
    |   関数に対する要請は以下の通りになる。
    |
    |   1. prefix が設定されている時には本来の変数 (コマンド履歴) にはアクセスしない。
    |   2. ローカル変数にロードしてすり替えを行う時には、変数の中身に対する変更はしない。
    |
    | c 或いは、外部から直接呼び出せる関数に制限をかける。
    |   その関数を呼び出した時に、全変数をすり変える。
    |   外部からも内部からも呼び出す関数については、
    |   外部から呼び出すための物と内部から呼び出すものの二つを用意する。
    |
    |   x この方法は重そうだ。
    |     調べてみた所、変数のすり替えが必要になりそうな関数は、
    |     内部に履歴のループを含む {for,back}ward-search-history 系の関数のみである。
    |     そして、この関数は 1 回の呼び出しで何度も呼び出されるものではない。
    |     寧ろ、恐らく1回しか呼び出されない。
    |     従って、全変数を毎回すり替えるとういことをしても速くはならない。寧ろ遅くなる。
    |
    |
    | ここは b の方向で実装することにする。
    |
    | - すべての関数は prefix の値に応じて適切な変数を参照・設定して動作するようにする。
    | - すり替えによる実装はできるだけ避ける。
    | - すり替えを実行して効率化を測る関数の場合には、
    |   その関数自体は履歴情報に対して副作用を持たない。
    |   また、そこから呼び出す関数も履歴情報に対して副作用を持たない。
    |
    |   この時、実はすり替えをしていたとしても、
    |   その他の関数を安全に呼び出すことができる。
    |   また、その関数で直接使う変数のみすり替えれば十分である。

    取り敢えず修正した。これで _ble_edit_history_prefix の値に応じて対象の履歴を切り替えられる様になった。
    実は未だ vi.sh にも _ble_edit_history* を触るコードがあるが、
    これらは全て本体のコマンド履歴を操作するための関数であり、
    再利用する予定も (今のところ) ないので、このままで良い。

    次に cmap に入る時と出る時に _ble_edit_history_prefix を設定・解除する。
    また出る時に履歴項目を追加して最後の位置に移動する。
    その様に設定した。動いている様に見える。
    但し、未だ keymap に登録を行っていなかった。

  * edit: C-r で即座に履歴をロードしようとするが、 [#D0576]
    実は、現在の履歴項目に一致が見つからないということが分かってからでも遅くないのでは。

    →これの対応は実は簡単だった。既に _ble_edit_history* に直接触るのは
    backward-search-history-blockwise, forward-search-history.impl 関数に限られていた。
    ここで ble-edit/history/load を呼び出す様にすれば、
    isearch に入る時の ble-edit/history/load は必要なくなる。
    多分、これで動いているような気がする。

  * vi-mode (cmap): bug C-[ でキャンセルできない (reported by cmplstofB) [#D0575]

    vi_cmap/define を見てみると登録されている。しかし、実際に実行してみると動かない。不思議だ。
    と思って ble-bind -d で見ると bell になっている。
    実は、vi_cmap/define の下の方で上書きされていた。修正した。

2017-11-08

  * 2017-11-01 vi-mode: キーボードマクロ対応 [#D0574]

    | 挿入モード繰り返しの quoted-insert 対応に関連して、
    | 繰り返し機能とキーボードマクロの整合性について考察した。
    | 結論は両者 (キーボードマクロ vs 挿入モード繰り返し) は独立に実装するべきとなった。
    | その時に調べたキーボードマクロの振る舞いと対応方法の可能性に関する議論をここに残す。

    さて、矢印キーなどの操作をした時にレジスタにどの様に記録されているのかを調べる。
    →どうやら右矢印は <80>kr という文字列に変換される様だ。実際に正しく再生することもできる。
      これは端末から渡される文字列とは異なることに注意する。
    - つまり、一旦 key から文字の列に逆に戻すという過程が入っている様に思われる。
      特に2文字目と3文字目が通常の文字であることから矢印キーを UTF-8 の特別な文字に割り当てていることによって
      そのまま文字列にしたら文字化けしているということではなくて、
      むしろ明示的に key を文字の列に符号化していると思われる。
    - 因みに "xp とすればその中身を直接挿入することができる。
      <80>kr という部分を選択して "by して、@b として再生するとちゃんと右矢印として解釈される。

    うーん。面倒なので ble.sh では矢印キーはそのまま kcode に対応する UTF-8 で文字列に埋め込んで良い気がする。
    但し、その為には c2s で矢印キーに対応する文字を生成できる必要がある。
    これは UTF-8 環境ではできることが明らかであるが C などの環境ではできない。
    また将来的に別の文字コードに対応するときにも毎回問題になる。
    その様に考えると特別なキーシーケンスを与える必要があるのかもしれない。

    取り敢えず対応した。

    - 通常の文字はそのまま記録
    - C-@ C-[ を除く制御文字が対応するキーは制御文字で記録
    - その他は "ESC [ 2 7 ; * ; * ~" シーケンスで記録
    - @: には対応していない。これは bind -f '@ :' で登録することにする。
    - 無限ループを防ぐためにマクロの中でマクロは呼び出せない

    * 無限ループの問題について。
      実際の vim でやると本当に無限ループになる。
      C-c をすると中断することができる。

      ble.sh ではどのように実装するか。
      stdin を確認してもし何かあればその時点で
      マクロの中でマクロ呼出しができなくすれば良い。
      stdin を確認できない bash-3.0 未満では、
      常にマクロの入れ子呼び出しはできないことにする。

      或いは最大の再帰の深さを設定すれば良いのではないか。
      →再帰の深さを設定できるようにした。

      これで正しく動作するだろうか。

    ? checked: 現在は accept-line の直前に記録を完了する様にしている。
      他にそのような対策が必要な箇所はあるだろうか。
      これは keymap を観察して見れば良い。
      簡単に確認したところその様な箇所はない様に思われる。

      一つ気になるのは :commandline を実行している間の操作だが、
      vim で試してみると、その間の操作も全て記録されている様なので問題ない。

    x fixed: 実際のキーボード入力と、再生または再度のやり直しによるキーボード入力が
      重複して実行されないように後者が登録されないようにする必要がある。

      % vi.sh については ble-decode-* の呼び出しの前に、
      % ローカルに _ble_decode_keylog_enabled= を設定する様にした。
      %
      % 実は他の場所で定義されている widget についても同様に対策する必要があるのではないか。
      % 調べてみると ble-edit.sh に同様に ble-decode-key を呼び出している箇所があった。
      % この場所でも _ble_decode_keylog_enabled= を設定するようにした。
      %
      % しかし考えて見るにもっと根本的な対策が必要なのではないか。
      % つまり keylog を記録する側で、それがキーボードからの入力なのか、
      % 或いは、更なる呼び出しによるものなのかを判定する様にしても良いのではないか。
      %
      % もう一つ気になるのは、ローカルに _ble_decode_keylog_enabled= を設定した状態で、
      % 更に qa でマクロの記録を開始した場合にどうなるのかという事である。
      % 結果として、書き込み先のレジスタがすりかわるという事が起こる。
      % また、もっと悪いことに q で記録を停止することができなくなってしまう。
      % (M-q をもってノーマルモードに戻ると共に記録を停止するなどのことができない。)
      %
      % % これについては、現在マクロを記録中かどうかは、
      % % _ble_decode_keylog_enabled 変数ではなくて、別の変数を用いるというようにすれば良い。
      % % それでも未だ問題は残る。例えば end-logging が中で呼び出された場合に、
      % % ローカルの _ble_decode_keylog_enabled のみが解除される。
      % % 関数を抜けると再び logging が開始してしまう。

      ローカルに設定した _ble_decode_keylog_enabled= ではなくて、
      もっと別の仕組みによって重複して実行されるコマンドを防ぐ必要がある。
      それも ble-decode の内部で完結した方法が良い。
      例えば、widget を呼び出す時に、何らかの特別な変数を設定すれば良い。
      _ble_decode_keylog_suppress という変数を導入することにした。
      また、外部で手で _ble_decode_keylog_enabled= を指定している部分は削除する。

      今度の仕組みを使えば上記で述べたような問題点は発生しないだろう。

      o 5i12<C-[> としても 12 がたくさん登録されるなどのことはない。
      x M-q が C-[ q に分解されてから改めて実行された場合でも、
        C-[ q が二重に実行されるということはない…。

        % と思ったが、確認してみると <C-[> が登録されている? と思ったら、
        % そうではなくて単に M-q がその 27 表現として記録されているだけだった。
        % いや。改めて 27 表現を調べてみると <M-q> としてではなくやはり <C-[>q として記録されている。
        % 変だ。と思って再度試してみると、ちゃんと期待通りの振る舞いになっている。大丈夫。
        % しかし別の問題があることが分かった。これは別項目を立てる。

    x fixed: 現在、KEYS に入っているキーの数だけ pop して内容を記録しているがこれは正しくない。
      _ble_decode_keylog_suppress が設定されて呼び出された時 KEYS は本来と異なる値になっている。
      →これは次の項目と一緒に解決した。

    x fixed: M-q などを用いてロギングを中断した場合に <M-q> が全て記録されない。
      <M-q> が <C-[>q に分解されて <C-q> の部分だけは記録されてほしいのにも拘らず、である。
      その様な場合にはどの様に処理したら良いのだろうか。
      これは _ble_decode_keylog_enabled とはまた別の問題である。

      % むしろこの場合こそ KEYS を pop するべきなのではないか。
      % そして _ble_decode_keylog_suppress=1 の時には pop を行わない様にする。
      %
      % また、_ble_decode_keylog_suppress= にして記録が行われるようにする…
      % と思ったがこの対処は本当に正しいのだろうか。
      % 例えば直接ユーザの入力から decompose-meta が呼び出された場合には、
      % _ble_decode_keylog_suppress= により記録が実施されるようにすれば良い。
      % ところが widget A から ble-decode-key を通して decompose-meta が呼び出された場合には、
      % 先ず初めに pop が起こらないというのは良い。
      % しかし、次に _ble_decode_keylog_suppress= を解除してしまうと、
      % widget A によって生成された仮想的なキー操作が記録されてしまう。駄目だ。

      思ったが上記の方法には色々問題がある。
      先ず初めに _ble_decode_keylog_suppress=1 の時には pop を行わないと書いたが、
      widget の呼び出し中は常に _ble_decode_keylog_suppress=1 なのだから、
      _ble_decode_keylog_suppress の値は当てにならない。
      思うに _ble_decode_keylog_suppress の値は整数値にして入れ子のレベルを表す様にするべきなのだ。

      →_ble_decode_keylog_suppress は _ble_decode_keylog_depth に改名して、
      入れ子のレベルを保持することにした。
      そして _ble_decode_keylog_suppress == 1 の時にのみ pop を行うことにして、
      更に decompose-meta では _ble_decode_keylog_suppress を 1 だけ減ずることにした。
      また記録は _ble_decode_keylog_suppress == 0 の時にのみ行う。

    ? fixed: レジスタの中に qa...q が含まれている場合にそのレジスタを再生するとどうなるのか。
      ... がレジスタ a に記録されるのか、
      それとも実際のキーボード入力がユーザからされる訳ではないので a は空文字列になるのか。
      更に qb などとして別のレジスタへの記録を実行している途中に @c (中身 qa...q) などとして、
      別の記録を開始した時の振る舞いもどうなるのか気になる。a. 前の記録が中断されるのか、
      b. その時点で終了するのか、c. 記録が入れ子になるのか。記録が入れ子になるのだとしたら、
      内側の記録の内容は c1. 外側の記録にも反映されるのか c2. 外側の記録からは抜けるのか。

      →実際に試してみると再生中には q は全て失効しているようだ。
      特に qa...q という組があったとしても a... が実行されたのと同じ結果になる。

      さて 12qa...q とした時には引数 12 は捨てられるのか、それとも a に渡されるのか。
      →試してみると a には引数は渡らない。つまり、q を押しても全く何も起こらないのではなくて、
      引数などの消費は行われるという事である。

    x fixed: 何故か既定のレジスタにも値がコピーされている。
      これは register#set を用いているのが行けない。

      そもそも register#set を使う必要はないのではないか。
      と思ったが追記の時に何が起こるのかは非自明である。
      もしかすると通常の "Ay 等による追記と異なる振る舞いをするかもしれない。
      ("Ay の時には既にレジスタに登録されている内容の種類 char, line, block かによって
      追記のされ方が異なっていた事に注意する必要がある。)
      →確かめる。うーん。何か不思議なことになった。動作を詳細に調べる。

      | | - 先ず行指向で A^JB^J という内容にしておく。
      | |   ここで v{motion}"Ay で文字列を追加すると A^JB^JC^J という内容になる。
      | |   更に、qAihello^Cq としてキー操作を追記すると A^JB^JCihello^C^C^J という内容になる。
      | |   どうやら最後の改行の直前に追記されるようだ。
      | | - この後に v{motion}"Ay で追記するとちゃんと ^J の後に追記される。
      | | - <C-c> 単体でも ^C^C と記録される様だ。^V は重複しない。
      | |   ^V 中の ^C も重複する。というか別に追記でない時でも ^C は重複する。
      | |   これについては別項目で調べることにする。
      | | - 行指向でそのまま qAihello^[q としたらどうなるか。
      | |   →やはり改行直前に挿入される。
      | | - 挿入した後のレジスタの性質は変わるか。つまり p が行指向挿入になるか。
      | |   →なる。行指向のままである。
      |
      | つまり行指向レジスタに追記する時は改行の直前に挿入される。
      |
      | | - 矩形の場合には最後の行に追記される。新しい行ではない。
      | | - また q で追記した後も矩形挿入のままである。
      |
      | | - 文字指向の場合はそのまま追記される。文字指向のまま。
      | | - 文字指向の時に末端に改行がある時でも、そのまま追記される。文字指向のまま。
      |
      | - 実は追記の場合には同時に既定のレジスタにも変更後の値が設定される。

      まとめると、

      - マクロの登録の場合には記録先レジスタの他に "" にも登録されるということはない
        但し、例外として、追記の場合には "" にも登録される。
      - 行指向のレジスタに追記するとき、最後の改行の直前に挿入される
      - 矩形指向のレジスタに追記するとき、最後の行に追記される。
        文字範囲を追記したときの様に新しい行に追加される訳ではない。
      - 文字指向のレジスタに追記する時は通常と同様に、ただ追記する。
      - 何れの場合でも追記先のレジスタの指向を変えることはない。

    ? ok: vim では記録中に押された ^C は重複して記録される。何故か?
      ble.sh では当然その様にはなっていない。もう少し詳しく調べる。

      例えば、i<C-q><C-c><C-[> と操作した時にはどうなるのだろうか。
      試してみるとこの場合には ^C は単体で記録されるようである。
      ということは無条件に ^C が二重化される訳ではない。

      うーん。これはどういう事だろうか。キャンセルとしての C-c
      が内部で呼び出さされるともう一度 C-c を実行する等のことが
      内部的に実行されているのだろうか。謎である。

      これについてはよく分からないので、ble.sh では取り敢えずは ^C は
      実際に入力されたとおりに 1 個だけしか記録しない様にする。

  * vi-mode: 実は以下で ggvj"ay とすると echo^J^J がレジスタに登録される。 [#D0573]

    % | echo$
    % | $
    % | $
    %
    % これはどういう事だろうか。一番最後の行で同様に試してみた所、echo^J だった。
    % つまり、空行の末端で実行するとそこにある改行まで含むという事になる。
    % 最後の行にいる時にはそこに改行がないので含まれない。
    %
    % | echo$
    % | $
    % | ~
    %
    % というかそもそも以下で vjd とすると二行消える。
    % つまり、ビジュアルモードに置ける範囲というのは行末の改行も含むという事。
    % しかも、今調べると現在の ble.sh 実装でもちゃんとその様になっている。
    %
    % | echo$
    % | $
    % | hello$

    これは現在の ble.sh の実装でもそうなっているので気にしなくて良い。

2017-11-05

  * 2017-11-03 edit: command-help [#D0572]

    現在の文脈に従ってコマンド名を抽出して調べる。
    実のところ、complete 辺りで似たようなことをしているはずだから、
    簡単に実装できるはずである。

    ble-syntax.sh の syntax-complete の辺りを見ると
    先ず初めにただ単に文脈によって argument だとかを返しているだけである。
    complete.sh の方を覗いてみると、
    ble-complete/source/argument/.compgen で
    ble-syntax:bash/extract-command "$index" を呼び出している。
    この関数は変数 comp_cword comp_words comp_line comp_point を設定する。

    対応した。--help よりも man の方を優先する様に変更した。
    また man の出力をパイプに流すと日本語の見出しが変なことになるので、
    man を直接起動することにした。man の標準エラー出力は /dev/null に捨てる。

  * vi-mode (nmape * #): 単語の検索に対応するということ [#D0571]

    * をおした時カーソルの下に単語 (WORD) があればそれを検索する。
    行内の forward に単語があればそれを検索する。
    http://vim-jp.org/vimdoc-ja/pattern.html#star には keyword か WORD と書かれているが、
    実際にテキストファイルで試してみると word である。WORD ではない。
    として、ソースコードのなどの編集を考えると WORD は不便である。
    word でなければならない。従って ble.sh では word で対応する。
    :help star で確認してみると WORD とは書いていなくて non-blank word と書いている。誤訳か?

    | 実のところ bash の正規表現では \<\>\b しか使えず、
    | これらの振る舞いを自由に変更することは敵わない。
    | 従って、bash の定義する単語にするしかない。
    |
    | 先ず初めにどの様にして単語を抽出すれば良いか。
    | 例えば \<(.\B)*.\> などとすれば内部に単語区切りを含まない単語を抽出できる。
    | 現在のカーソルの下にある文字が単語を構成する文字かどうかを判定するにはどうすれば良いか。
    | 実は (.\B)*. の様な面倒なことをしなくても判定する方法があるのではないか。
    | これには POSIX ERE を調べる必要がある。というか調べたら BRE/ERE には \b, \B, \<, \> はなかった。
    | 然し bash の正規表現では確かにこれらの演算子を使うことができる。
    | ということは bash の正規表現はどの正規表現なのか? Bash のマニュアルには何も書かれていなかった気がする。
    |
    | 昔作った表によると \b\B\<\> に対応しているのは GNU grep -G/-E および GNU Emacs, それから Perl 5 である。
    | 大分限られている。という事は bash の実装は GNU Regexp もしくは独自エンジンと考えられる。
    | 調べてみると lib/sh/shmatch.c から regex を呼び出している。
    | 実は POSIX の header regcomp/regexec を呼び出しているだけだった。
    | という事は \b\B\<\> に対応しているかどうかは非自明である。環境依存という事になる。

    [結論] つまり Bash の正規表現は <regex.h> regcomp/regexec による物で ERE にないものは環境依存。
      また [[:alpha:]] などの文字クラスも環境依存・ロケール依存である。

    - ok: 因みに今までの実装で \b\B\<\> を使っているとそれは対策を考える必要がある。
      と思ったが実際に検索してみると今までは \b\B\<\> は使ってこなかった様だ。問題ない。

    | さて、もう少し vim で試してみると /// などには一致しない。
    | 確かにこれは \<\> で囲んでも一致しないので除外するべきである。
    | その様に考えると vim でも既に w や W で定義される word や WORD
    | とは異なる種類の "単語" である (それでも word に近いが)。
    | という事は ble.sh でも厳密に対応する必要はない気がする。
    |
    | 取り敢えず \<[[:alnum:]_]+\> で捕まえるというのはどうだろうか。
    | 更にいうと手許の環境で試してみた所 [:alnum:] で平仮名などに一致する一方で、
    | \b\B の方も平仮名と英数字の間を単語の内部と判定している。
    | \b\B\<\> が一体どのようなものかについて定義はあっただろうか。
    | 例えば POSIX awk での定義はどうなっているだろうか。
    | 調べてみたら実は POSIX awk でも単語境界演算子は定義されていなかった。駄目だ。
    |
    | 仕方がないので \b\B\<\> が定義されている別の環境ではどのように実装するのが普通なのか調べる。
    | 取り敢えず GNU/Linux の <regex.h> の振る舞いは全て共通と仮定して良い。
    | だとすれば恐らく [[:alnum:]_] とそれ以外の境界が単語境界である。
    | perlre では \w とそれ以外の境界が単語境界ということになっているが、
    | \w の意味については明記されていない。ロケールや設定に依存すると書かれている。
    | 例えば /.../a というオプションを指定すると ASCII の [:alnum:]_ に制限されるとも書かれている。
    | 因みに ES8 だと 21.2.2.12 で \w は WordCharacters() と書かれている。22.2.2.6.1 を読むと、
    |
    |   WordCharacters() = {c | Canonicalize(c) in [a-zA-Z0-9_]},
    |   (Note: 但し Unicode && IgnoreCase のとき以外は [a-zA-Z0-9_] になる)
    |
    | である様に思われる。Canonicalize は 21.2.2.8.2 で定義されている。
    | Unicode && IgnoreCase のときは Unicode データベース CaseFolding.txt に従って変換されるそうだ。
    | しかし、これは大文字小文字の変換であるような気がするので、実のところ [a-zA-Z0-9_] なのか?
    |
    | まとめ
    |
    | vim の実装は \<\> を使って定義される "単語" である。
    | Bash 正規表現について \b\B\<\> に対応していない環境もある。
    | 対応している環境の場合には、これらの演算子は
    | "単語を構成する文字とそれ以外の文字の境界" として実装されると見て良い。
    | 単語を構成する文字は環境依存であるが、
    | a [a-zA-Z0-9_] のときと
    | b [[:alnum:]_] のときと
    | c 更にこれを Unicode に拡張したもののときと、
    | d perlre の様に名言を避けているとき
    | の4種類がある。GNU/Linux <regex.h> では \<\> は b で対応しているようだ。に対応しているとき、
    | 基本的に [[:alnum:]_] で判定できるとしてしまって問題ない気がする。
    | 因みに [:alnum:] は POSIX ERE で存在することが保証されている。

    [結論] ble.sh では [[:alnum:]_]+ を単語として取り扱うことにする。
      これが \<\> の境界の判定条件と合致すると仮定する。
      合致しなくて起こる不整合については仕方がないので諦める。

    何れにしてもどの様にして対応を行うかを考える必要がある。

    | 1 先ず \b\B\<\> が使えない環境から考える。
    |
    |   先ず初めにカーソルの下の単語の抽出から考える。
    |   これは実のところ可能である。
    |   単に、現在位置の文字が [[:alnum:]_] であれば前後に拡張し、
    |   それ以外ならば \G[^[:alnum:]_\n]*([[:alnum:]_]+) を捕まえれば良い。
    |   但し \G は現在のカーソルの位置。
    |
    |   検索については厳しい。一応 (^|[^[[:alnum:]_]])my_word([^[[:alnum:]_]]|$) で検索してから、
    |   前後の余白を除去すれば一致させることは可能ではあるが、
    |   これは search の仕組みに手をいれなければならない。しかも汚い。
    |   なので境界に一致させることには対応しないことにする。
    |
    | 2 次に \b\B\<\> が使える環境について考える。
    |
    |   先ず初めにカーソルの下の単語の抽出を行う。これは同様である。
    |
    |   次に検索について。原理的には単に \<\> で囲めば良い。
    |   しかし、もし \<\> と [[:alnum:]_] の間に不整合がある場合には、
    |   これによって全く一致しなくなってしまう可能性もあるので、
    |   念のため my_word =~ \<my_word 及び my_word =~ my_word\> を試して、
    |   それぞれ一致したら付加することにする。
    |   実のところ、この様に実装すれば \<\> が使えるかどうかに
    |   依存しない実装に出来る気がする。

    1. [[:alnum:]_] の連続として単語を抽出する。抽出した単語を my_word とする。
    2. my_word =~ ^.{len}\>$ ならば \> を付加する。
    3. my_word =~ ^\<.{len}$ ならば \< を付加する。

    対応した。動いている。

  * vi-mode (nmap :q): 残っている文字列を灰色にする? [#D0570]

  * vi-mode (omap): C-c 及び C-[ 等でキャンセルするべきなのでは。 [#D0569]

    マニュアルを少し探してみたが該当する記述は見つからない。
    vimindex によるとC-c は現在のコマンドをキャンセルと書かれている。
    恐らくコレが該当するのだろう。
    C-[ 及び <esc> は未使用と書かれている。

  * vi-mode: cw cW の特殊な動き (reported by cmplstofB) [#D0568]

    | echo   hello   vim   world # 元の文字列
    |
    | echo   hello@  vim   world # カーソル位置
    | echo   hellovim   world # cw
    | echo   hellovim   world # 1cw
    | echo   helloworld #2cw
    |
    | echo   hell@   vim   world # カーソル位置
    | echo   hell   vim   world # cw
    | echo   hell   vim   world # 1cw
    | echo   hell   world # 2cw
    |
    | echo   @ello   vim   world # カーソル位置
    | echo      vim   world # cw
    | echo      vim   world # 1cw
    | echo      world # 2cw
    |
    | echo nihongo日本語にほんご # 元の文字列
    |
    | echo nihong@日本語にほんご # カーソル位置
    | echo nihong日本語にほんご # cw
    | echo nihong日本語にほんご # 1cw
    | echo nihongにほんご # 2cw
    |
    | echo @ihongo日本語にほんご # カーソル位置
    | echo 日本語にほんご # cw
    | echo 日本語にほんご # 1cw
    | echo にほんご # 2cw

    - 先ず初めに cw と 1cw に違いはない。
    - 空白の上にいる時には {N} 個先の w の手前まで。
      これは cmplstofB さんの報告通り {N}dw と同じ範囲で良い。
    - 単語の文字の上にいるときは {N} 個先の単語終端まで。現在位置を含む。

    うーん。もしかして caw の終端点? と一瞬思ったが全然違った。

    空行を挟む場合にはどうなるか。
    先ず空行または行の最後の空白文字で実行すると、その文字以降を消すだけ。
    行の最後の単語の上で cw を実行しても同様に、その文字以降を消すだけ。
    行の最後の単語の上で 2cw を実行すると、空行を飛び越えて最初の非空行の最初の単語の末端まで消える。
    行の最後の空白の上で 2cw を実行すると、空行が1つ消えるのみである。

    x fixed: というか 2dw の時点で vim と ble.sh で振る舞いが異なっている。
      →これについては #D0567 で修正した。

    x fixed: あと、最終行で最後に空白しか無いときに e を押すと最後の文字に移動して bell がなるが、
      vim ではオペレータ付きでこれを実行すると bell はならない。
      ble.sh ではオペレータがついていても bell を鳴らしていたので、修正する。

    取り敢えず対応した。これから動作確認をする。
    取り敢えず提示された編集を実行してみることにする。

  * vi-mode: w, dw の動作の違いに関して。 [#D0567]

    これは既に Issues #2 にも書いたが、
    以下の内容に対して H5|w だと 9 位置に行くが、
    H5|dw だと 5678 を削除するという振る舞いについてである。

    | 12345678
    |     90ab

    - 実は :help word-motions に記述があった。
      {op}w の時には最後に通過した単語が行末にあった時、
      その後の空白は含まれないというものである。

    - {op}W に関しては記述がないが、
      実際に試してみると {op}w の時と同様に働く。

    - "最後の単語" の後に空白があってから改行でも良い。
      更にいうと、word-motions には単語の終わりがオペレータの対象の終わりと書いてあるが、
      これは間違いで実際には行末までがオペレータの対象の終わりになる。

    - "最後の単語" が改行の場合でも成立する。
      この時には改行の直後がオペレータの対象の終わりになる。
      (但し、その後で exclusive-linewise の規則が適用される。)

  * vi-mode: SP DEL は vi_xmap 及びオペレータが設定されている時は改行も数える。 [#D0566]

  * dw に引数を与えて試していて気付いたが、 [#D0565]
    exclusive-linewise の辺りに書かれている記述の意味が分かった気がする。
    これらの記述は移動先自体が変わるという訳ではなくて、
    オペレータで処理するときの範囲が変わるという話だったのではないか。

    幾つか試してみる。以下 ★◆ を付記したものが
    特別な範囲補正が必要になり、ble.sh で再現しないものである。

    - 以下で H3|2w とすると cc の 1 文字目に行くが、
      H3|2dw とすると " bb" だけが削除され行が連結されるということはない★

      aa bb
      cc

    - Hdgj とすると1行目が消える。行指向になる◆

      % exclusive-linewise に記述されている結果になっているが、
      % 条件を満たしていない気がする。
      % これは読み間違えであったということが分かった。日本語訳が悪い。

      →"その行" とは移動後の位置の行のことではなくて、
      移動初めの位置の行のことである。日本語ではわざわざ "その" とは付けない。
      わざわざ付けると "別のものに属する行" の意味になる。

      | aa
      | bb

    - Hldgj とすると1行目の最後の "a" だけが消える★
      これは :help exclusive-linewise の上の段落の記述に合致する動作である。

      | aa
      | あ

    - 3Hdgk とすると2行目が消える。行指向になる◆

      | xxxx
      | 1234
      | 5678

    - 3Hldgk とすると2行目と "5" が消える。1行目に連結はされない。
      :help exclusive-linewise の上の段落の記述と一致せず、
      特別な動作は何もしていないように見える。

      | xxxx
      | あ34
      | 5678

      日本語訳がおかしいのかと思って改めて英語の説明を見る。
      しかし英語でもこの動作を正しく言い表しているようには見えない。
      むしろ "}" と "d}" が何故異なるのかについて、
      より矛盾を孕む動作になっているような気がする。

      > If the motion is exclusive and the end of the motion is in column 1, the
      > end of the motion is moved to the end of the previous line and the motion
      > becomes inclusive.  Example: "}" moves to the first line after a paragraph,
      > but "d}" will not include that line.

      ここまでの振る舞いから実際には以下の様になっていると思われる。

        移動コマンドが排他的で、現在の位置より後の列1に移動し、omap のとき、
        範囲は移動先の前の行の最後の文字になり inclusive になる。

    - 前の行が空行の時にはどうなるのだろうか?
      以下で H5d<SP> とすると 1234<LF> が削除される。★
      つまり、前の行の行末までになる。

      | 1234
      |
      | 5678

      更に行指向になる。◆
      これはつまり ★の修正と exclusive-linewise★
      の修正が同時に起こりうるということである。

    - 2Hdh としても何も起こらない。1 行目に連結はされない。
      つまり移動前と移動後の位置が同じときには★は作動しない。

      1234
      5678

    - ◆の動作の説明には非空白行頭と書かれているが、
      空白行頭にいた場合には有効ではないのだろうか。

      % 以下で Hdgj とすると行指向になる。
      % H dgj, H3 dgj, H4 dgj の場合は行指向にならない。
      % 2Hdgk は行指向になる。
      % 2H dgk, 2H3 dgk, 2H4 dgk は行指向にならない。
      %
      % | 12341234
      % |     5678
      %
      % 以下で試しても全く同様であった。
      %
      % |     1234
      % |     5678
      %
      % うーん。不思議だ…と思ったらよく考えると移動先が列1でないと駄目なのだった。

      % うーん。"d}" と "d12 " で振る舞いが異なる気がする。
      % "d`a" は "d}" と同じ振る舞いである。
      % "d}" の場合には移動元が行頭以降・非空白行頭以前のときに行指向になる。
      % 別に非空白行頭の直前でなくても良い。(これも日本語訳が悪い。
      % "その手前の位置" と書いたら非空白行頭の直前の位置一点を指すのかと思うが、
      % 実際にやってみると別に直前でなければならない訳ではない。)
      %
      % "d12 " の振る舞いは不可解である。
      %
      % |     1234
      % | 567890ab
      % |
      %
      % において "d4 " は "1234" を削除するが、
      % "d12 " は "12..0a" までを削除する。b を削除しない。
      % 更に言うと :help exclusive-linewise の上下の 1./2.
      % のどちらが適用されるかはどう決まるのか…。

      これは分かった。<space> はオペレータがある時は文字の数え方が異なる。
      :help whichwrap に書かれている。

      上記の例で "d}" "d`a" (3Hma してある) "d2gj" は全て同じ振る舞いである。
      bol <= src <= nol の時は◆になり nol < src の時は★になる。
      と思ったが振る舞いを見ると bol <= src <= nol の時は◆と★の両方が適用されている。

    これの修正は何処で行われるべきか。
    テキストオブジェクトや inclusive も exclusive-range.impl を呼び出す。
    従って、exclusive-goto.impl の中で修正を行うべきの気がする。

2017-11-04

  * 2017-08-19 ble-edit: C-x C-x で微妙な遅延が見える。これは stty の問題だろうか? [#D0564]

    これは現在大きな問題にはなっていないので優先度は低い。

    | ちょっと stty -a の結果を見たり ble-stty/* の実装を見ても分からない。
    | そもそも ^X は stty で特別な文字としては扱われていない様に見える。
    | もしかすると stty raw などとすると遅延は起こらないのかもしれないが、
    | これは時間のある時に試すことにすれば良い。
    |
    | →screen の maptimeout や readline の
    |   keyseq-timeout を変更してみたが変わらない。
    |   screen を抜けても変わらない。ローカルでやると遅延はない。
    |
    | - どうやら ssh ごしだと遅延があるようだ。
    |   ssh で timeout で検索すると別の timeout が当たる。C-x や Ctrl-x で検索しても何も出ない。
    |
    | - よく考えたら実は ssh は関係なくて端末の設定なのではないだろうか。というのも Emacs では遅延はない。
    |   stty の設定を動いている時と動いていない時で比較したが良くわからない。
    |   できるだけ似るようにして見たが遅延はそのままである。
    |   padparadscha ではなく tkynt2 でやってみても同じである。
    |   ローカルでは screen の中でやっても同じである。
    |   $ ssh pad bash -i として端末を割り当てずにやってみた所、それでも遅延はある。
    |   つまりやはり端末の設定ではなくて ssh が怪しいのではないだろうか。
    |
    |   と思ったがそれもおかしい。Emacs はやはり遅延がない。bash が悪いのだろうか?
    |   ローカルでは bash-4.4 でリモートでは bash-4.3 である。
    |
    | - リモートで bash-4.4 を動かしてみたら遅延がなくなった。
    |   つまり bash-4.3 に何らかのバグがあって C-x に遅延が生じているということなのだろう。

    bash-4.0, 4.1, 4.2, 4.4 では遅延はない。
    bash-4.3 のみで遅延がある。これの対策はしない。

2017-11-03

  * vi-mode: refactor [#D0563]

    - done: ble/keymap:vi/mark/set-local-mark 96 "$_ble_edit_ind" を実行するコマンドを提供するべき。
      例えば ble/keymap:vi/mark/set-jump など。

    - done: また、linewise-goto.impl 及び linewise-range.impl は
      bolx nolx を用意しなければならないのが分かりにくい。これも修正するべき。

    - done: ビジュアルモードの種類 char line block を格納する変数名は type ではなく context に統一する。

  * 2017-09-16 vi-mode merge 直前に一括して行うテスト・仕様変更など [#D0562]

    * 各コマンドについて再度動作するかどうかについてテストする必要がある。
      Wiki に各コマンドの説明を書きつつテストして行くのが良いだろう。

      x fixed: ihello world<C-[>. で world 以降しか挿入されない。
        これは vi_imap/magic-space によって記録が reset されていた為に起こった物である。
        現在は irepeat は実際に行われたコマンドの列で記録されているし、
        また xmap I, A なども dirty-range による追跡を行っている。
        imap での様々な編集が起こっても問題ないようになっているので、
        単に magic-space を登録してそれを white としても問題ないだろう。

        vi_imap/magic-space は廃止した。今後は magic-space を直接使ってもらう。

      x fixed: a123<C-[>.. において1つ目の . ではちゃんと a で実行されているが、
        2つ目の . においては i で実行されている。これは何故か。
        record-insert で (vi_nmap/repeat で呼び出されたかどうかに拘らず)
        毎回記録しているのが原因である。→修正した。

      x fixed: nmap w b e ge において単語の定義が異なる。
        これは imap <C-w> や text object iw aw と同様にすれば良さそうだ。
        というか、imap <C-w> や text object iw aw についても数字が考慮されていなかった。

      x resolved: imap <C-w> でスペースの削除の仕方が異なる気がする。
        と思ったら、これは bashrc で設定している関数が問題だった。

      x fixed: {N}% がいつも同じ位置に移動する気がする。
        →これはどうやら local bolx= nolx= を定義せずに linewise-goto を呼び出したのが行けなかったようだ。
        類似の修正を text objects ip ap に対しても行った。

      x fixed: `a 'a でオペレータが全く動いていない。
        goto-local-mark.impl, goto-global-mark.impl を呼び出す前に clear-arg を実行していたのがいけなかった。
        他にも operator の効かない移動コマンドが存在したりするかもしれないので確認する。

      x fixed: d_ 及び d1_ が charwise になっている。正しくは linewise である。

      ここまでで取り敢えず setup-map で登録されているコマンドについては一通り動作することを確認した。
      次に omap nmap xmap に登録されているコマンドについてテストを行う。

      x fixed: lib/vim-surround (xmap S): vS が linewise になっているが、
        元々の surround.vim ではそうではない。
        vS は charwise で vgS の時に linewise になっている。
        また VS および VgS の時も linewise だがインデントは行わない?
        surround.vim の振る舞いは謎だが、取り敢えず修正した。

      x resolved: command-help が常に一番最初のコマンドの help しか出さない?
        →調べてみた所、これは元からそういう仕様だったようだ。
        これの改良については別項目を立てて処理することにする。 #D0572

      x implemented: 実は xmap c, xmap s, xmap C では InsertLeave を設定する様だ。
        これの対応は面倒である。

        先ず初めに operator:c の中で、
        現在の operator の実行が xmap 経由であることを認識しなければならない。
        と思ったが、よく考えたら context == block となるのはビジュアルモードだけなので、
        この時は常に block-insert-mode.impl を呼び出すようにしてしまえば良い。

        block-insert-mode.impl は今まで自身で extract-block を呼び出していたが、
        operator:c context=block の時は既に sub_ranges があるので、これを利用したい。
        block-insert-mode.impl の呼び出し元で sub_ranges を計算することにした。

        operator:c で .insert-mode を呼び出す代わりに block-insert-mode.impl を呼び出す様にする。
        vi_xmap/exit が重複して呼び出されることの対策を vi_xmap/exit に追加した。

        実装した。動いている。と思ったが、挿入される文字の数が少ない。

        operator:c の中で、block-insert-mode は行の長さの変化を見るから、
        これを呼び出した後で領域を削除する訳にはいかない。
        従って block-insert-mode.impl を呼び出す前に領域を削除しなければならない。
        すると、それに応じて sub_ranges の修正が必要になる。
        block-insert-mode は sub_ranges[0] しか参照しないので、これを修正すれば十分である。
        →修正した。OK

      取り敢えず各 keymap で定義されているコマンドは確認した
      (imap cmap は面倒だし殆ど emacs-mode と同じなので良いだろう)。

      後は各 mark, 各 registers の特殊な振る舞いについて確認すれば良い。

      o 先ず registers については、そもそも特殊レジスタには対応していない。
        なので確認することは現時点ではない。

      o mark `^ (挿入モードを抜けた位置)
      o mark `" (最後にその履歴項目から抜けた時の位置)
      o mark `. 最後に編集の起こった位置。これは vim のそれと
        厳密には振る舞いが異なる可能性もあるが、気にしない。
      o mark `[`] これはよく使っているので問題はないはず。
      o mark `` これについても既に試したので問題はないはず。
      o mark `<`> これも gv で使われているので問題ないはず。

      x fixed: xmap ? を押したら rot13 が呼び出される。
        xmap: / ? n N これは motion として働くべき。
        確認してみると元から登録されている。
        単に operator rot13 が上書きされていた。削除した。

      x fixed: xmap で / ? n N を実行すると選択範囲がずれるのでは?
        →ずれた。これは修正する必要がある。
        単に xmap にいる時には選択範囲のハイライトをしないという様にすれば良さそう。

        と思ったら、_ble_edit_mark を用いて現在位置が
        既に一致したものなのかどうか判定している様だ。
        そうすると _ble_edit_mark を設定しておかないと n N で移動ができなくなる。
        と思ったが、既に一致したかどうかの判定は ble/keymap:vi/search/invoke-search の中で行っていて、
        _ble_edit_mark_active または _ble_keymap_vi_search_activate が search になっているかで判定している。

        うーん。invoke-search の中を vi_xmap の時に合わせて書き直そうとしたが難しい。
        やはり既に一致したかどうかの情報は必要である。
        そしてそれは _ble_edit_mark_active の clone の様な変数を用意すれば良い。
        (或いは _ble_edit_mark_active=line+! などのようにどんどん構造を複雑にすることも可能ではあるが、
        全体に汚くなるのでやはりそのような方法は駄目だ。)

        うーん。取り敢えず _ble_keymap_vi_search_matched という変数を導入してみた。
        しかし、この変数が正しくクリアされるかどうかについては自信がない。

        - _ble_edit_mark_active は異なるタイミングでもクリアされる。
          特に xmap から抜けるときと xmap に入る時。
          xmap から抜ける時は実のところ一致状態が残っていても良い。
          xmap に入るときも一致状態が残っていても良い。
          問題は motion によって解除されるはずのところ解除されないということが起こる場合だが、
          恐らく問題はないはずである。

        - 他に imap や cmap に移るときに問題になることはあるだろうか。
          cmap に移る時には _ble_edit_mark_active はクリアされるが、
          _ble_keymap_vi_search_matched はクリアされない。
          しかしながら cmap から _ble_keymap_vi_search_matched を参照することはないから問題ない。
          更に、また元の nmap に戻ってきたときには _ble_edit_mark_active が復元されて元の状態に戻る。
          : を実行している場合には更に adjust-command-mode が呼ばれるので、無事に両方共解除される。

        - imap に移る時にはどうだろうか。_ble_edit_mark_active は解除される。
          _ble_keymap_vi_search_matched は解除されない。
          そのまま挿入の操作をしても _ble_keymap_vi_search_matched は解除されないまま残る。
          次に normal-mode に突入するときにも残る。ここで初回から n などを実行すると、
          本当は一致していないのに一致しているという様に勘違いして検索が始まる。

          この微妙な違いにユーザは気づかないかもしれないが、確かに変な振る舞いになる。
          取り敢えず .insert-mode の _ble_edit_mark_active をクリアしているところで、
          _ble_keymap_vi_search_matched もクリアすることにする。
          取り敢えずこれでよしとする。

        さて実際に試してみると駄目だ。動いていない。うーん。

        x fixed: これは invoke-search の中で _ble_edit_mark を用いて開始位置を探索していたのが駄目だった。
          単に 1 文字進めるというようにすれば良いだろうか。。
          或いは再度一致させてしまえば良い→再度一致させる方針で実装した。

        x fixed: それでも動かないと思ったら、そもそも _ble_keymap_vi_search_activate を
          vi_xmap の時に設定していなかった。従って、_ble_keymap_vi_search_matched も設定されなかったということだった。
          _ble_keymap_vi_search_activate を設定するようにした。

        x fixed: 所が今度は _ble_keymap_vi_search_activate を設定したら _ble_edit_mark_active が上書きされてしまった。
          これは _ble_keymap_vi_search_activate から _ble_edit_mark_active に移す時の keymap の判定が誤っていた。修正した。

        x fixed: また詳しく見てみると範囲がずれている。
          元々は _ble_edit_mark から読み取って _ble_edit_ind++ していたが、
          具体的に再一致させて end を読み取っているときには _ble_edit_ind++ は要らないのだった。直した。

      x fixed: / ? n N xmap の時に履歴項目を移動するのはまずいのではないか。
        →xmap にいる時には履歴項目の移動はしない様にした。動いている。

      取り敢えずはこんなところだろう。

    * vi-mode を bash-3.0 でもテストする。

      そんなに詳しくテストするつもりはない。
      簡単に動かしてみているが、問題はないようだ。
      少なくとも全く動かないということはないことは確かだ。

      x fixed: ところで矩形挿入の時の `[`] が変だということに気付いた。
        修正した。commit-edit-area を追加すれば良いだけだった。

2017-11-02

  * vi-mode (operator): ble/keymap:vi/call-operator [#D0561]

    オペレータの中で更に編集コマンドを実装する場合に備えて
    _ble_keymap_vi_mark_suppress_edit を設定してオペレータを呼び出す。

  * vi-mode: ble/widget 実装の注意点 [#D0560]

    これらは Wiki に記述することにした。

    | vi-mode 用の ble/widget を実装する上での注意点についてまとめる必要がある。
    |
    | - 先ず __before_command__ の内部で set-previous-edit が発生してはならない。
    |   set-previous-edit 内部では . で繰り返すために、その編集が起こった原因となる
    |   コマンドを WIDGET によって特定する。__before_command__ は
    |   WIDGET 経由で呼び出されないので、誤った復元をしてしまうことになる。
    |
    | - WIDGET を widget 本体の中で変更してはならない。
    |   これは同様に . で繰り返すための情報を破壊してしまうことになるからである。
    |   __before_command__ 内部でコマンドを変更する目的で書き換えることは可能。
    |
    | - operator の定義方法について
    |
    |   もし . による繰り返しに登録しないときには
    |   空の関数 ble/keymap:vi/operator:foo/norepeat を定義する。
    |
    |
    | - `[`] が正しく設定されるために
    |
    |   編集を伴うコマンドについては、編集後に編集範囲を設定するために
    |   ble/keymap:vi/mark/set-previous-edit-area 編集開始位置 編集終了位置 を呼び出す。
    |
    |   複雑な編集について編集範囲が容易に決定できない場合には、
    |   ble/keymap:vi/mark/set-previous-edit-area を自分で呼び出す代わりに、
    |   編集が行われるコード全体を ble/keymap:vi/mark/start-edit-area と
    |   ble/keymap:vi/mark/end-edit-area で囲めば良い。
    |
    |   | ble/keymap:vi/mark/start-edit-area
    |   | local _ble_keymap_vi_mark_suppress_edit=1
    |   |
    |   | ... # 編集操作
    |   |
    |   | unset _ble_keymap_vi_mark_suppress_edit
    |   | ble/keymap:vi/mark/end-edit-area
    |
    |   mark/{start,end}-edit-area の内側で更に別の編集コマンド (内部で `[`] が設定される)
    |   を呼び出す場合には、更に _ble_keymap_vi_mark_suppress_edit を設定する必要がある。
    |
    |   | ble/keymap:vi/mark/start-edit-area
    |   | local _ble_keymap_vi_mark_suppress_edit=1
    |   |
    |   | ... # 編集操作 (`[`] の設定を行う widget の呼び出しを含みうる)
    |   |
    |   | unset _ble_keymap_vi_mark_suppress_edit
    |   | ble/keymap:vi/mark/end-edit-area
    |
    |   オペレータについては外側で自動的に編集範囲が検知されるので、
    |   自身で {set-previous,end}-edit-area を呼び出す必要はない。
    |   但し、編集は起こらないが範囲を設定したい場合 (operator y など) には、
    |   commit-edit-area 関数を明示的に呼び出す。
    |
    | - . による繰り返し操作が正しく設定されるようにするために
    |
    |   基本的には繰り返しの対象になる widget で ble/keymap:vi/repeat/record を呼び出せば良い。
    |   繰り返しの対象となるコマンドは2種類ある。
    |   一つは編集を伴うコマンドで、もう一つは挿入モードに入るコマンドである。
    |
    |   1 ble/keymap:vi/mark/{set-previous-edit-area,end-edit-area} を呼び出すときは、
    |     そこで1単位の編集が完了するということを表すので、
    |     大抵、対応して ble/keymap:vi/repeat/record も呼び出すと考えると良い。
    |
    |   2 ble/widget/vi_nmap/.insert-mode を呼び出した後も、
    |     場合に応じて、ble/keymap:vi/repeat/record または ble/keymap:vi/repeat/clear-insert を呼び出す。
    |     repeat/record はその挿入モード突入に至るコマンドを . で再現したい時に使う。
    |     repeat/clear-insert は、挿入モードの途中で挿入操作をクリアする時などに使う。
    |     repeat/clear-insert は実例として imap の <C-o>, 移動操作, コマンド実行などで使われている。
    |     - 但し operator の中では、外側で自動的に repeat/record が呼び出されるので、これらは自分で呼び出さない。
    |       例えば operator:c では .insert-mode を呼び出すが、自身で repeat/record を呼び出すことはしていない。
    |       operator による非同期読み取りによる継続の場合は、mark/set-previous-edit の時と同様に自分で呼び出す必要がある。
    |     - repeat/record はその時の keymap を参照するので、vi_nmap/.insert-mode よりも後で呼び出す必要がある。
    |
    |     また、編集を行って更に挿入モードに入るコマンドの場合であっても、
    |     1回だけ repeat/record を呼び出せば問題ない。
    |     その時でもやはり .insert-mode よりも後で repeat/record を呼び出すようにすること。
    |
    |   KEYMAP, KEYS, WIDGET, ARG, FLAG, REG の値は記録され
    |   繰り返しの対象となる widget を呼び出すときに再現される。
    |   繰り返しの対象となる widget が、それ以外の "状態" に依存して振る舞いが変化し、
    |   その時選択された振る舞いを繰り返しの際にも再現したい場合には、
    |   それを明示的に記録・再生する必要がある。

  * vi-mode: xmap I A が動かなくなっている…。 [#D0559]

    これは修正した。InsertLeave オプションが指定されているかどうかの判定が誤っていた。直した。

    という事は、いつからなのか分からないが、ずっと誤っていたのではないかと思われる。
    blame で見ると最後の書き換えは 453da8a2 (2017-10-12) である。
    調べるとこの時に複数に分かれていた insert-mode を統合したのだった。

    さて、更に振る舞いで気になることがある。
    挿入を終わった後のカーソルの位置が一つ戻っている。
    これは何か? nmap に戻る時にカーソル位置が一つ戻ることに関係するだろうか?
    そうだった。その様になっている。これは前からそうだった筈なのだが何故気が付かなかったのか。
    何れにしても修正する。どの様に修正するのが良いだろうか。

    a 例えば InsertLeave が設定されている時には一つ戻るという操作を行わない?
      これは駄目。例えば InsertLeave にカーソル移動を伴わない・編集を伴わない操作が設定されることも考えうる。
      その時に、(カーソル移動も編集もないのに) 位置が1つ戻るという操作がキャンセルされるのは変だ。

    b InsertLeave の内部でカーソル移動が起こった場合には 1つ戻るという操作を行わない?
      これは魅力的だが微妙。もしかすると InsertLeave の中で
      明示的に現在位置と同じ位置に移動するという事があるかもしれない。
      その様な場合には結局 1 つ戻るという操作が無駄に発生してしまうことになる。

      更に言うと InsertLeave の中でのカーソルの移動が、
      normal mode に移行する時に 1 つ戻ることを前提としている or それが自然という場合も考えうる。

    c 或いは、InsertLeave の中でカーソル移動を行う時は、
      normal mode に復帰する際にカーソル位置が 1 つ戻るという事を前提として、
      1つ次の文字に設定するということも考えうる。

    実のところ c の実装が最も自然に思われる。

  * 所で挿入モードに a で入った時と i で入った時で <C-o> 後のカーソル位置が異なる? [#D0558]
    と思ったけれど改めて試してみるとそうでもなかった。

  * vi-mode: . 実装 (6) 取り敢えず完了 [#D0557]

    #D0543 各 widget の戻り値の確定
    #D0550 WIDGET/KEYMAP/ARG/FLAG/REG ローカル変数の導入
    #D0551 nmap/omap における operator 操作の記録と復元
    #D0555 xmap における operator 操作の記録と復元
    #D0556 挿入モードの操作の記録 (これの為に imap-repeat も整理した #D0554)

    - 3l. とするとそれより前に行われた編集コマンドが実行される。
      つまり編集コマンドしか繰り返しの対象とはならない。

      どのコマンドが繰り返しの対象になるかについては help を見るのが良いだろう。
      help には repeat last change, also yank is repeated
      commandline command is not repeated としか書かれていない。

      % しかも実際に試してみると yiw は repeat されない様である。
      % also yank is repeated とはどういう意味だろう?

    * $widget.record 的な関数を定義して、それが使われていたらという話があったが、
      operator などの内部で記録を行いたい場合には難しいのでは?

      % と思ったが operator の内部では基本的に記録は行わず記録を行うとすれば非同期な読み取りが関わるときだが、
      % その場合には改めて hook 関数が呼び出されるのだから、"(hook 関数).widget" という形の関数名にすれば良いのでは?

      とも思ったが、直接 hook 関数が _ble_decode_key__kmap に登録されているとは限らない。
      例えば、vim-surround.sh の async-inputtarget では async-inputtarget 用の関数が WIDGET の本体になってしまう。
      従って、"(WIDGETの本体).record" をそれぞれ定義して動作を制御するというのは難しい。

      従って、やはり $widget.record の様な仕組みは余り意味がない。
      各自で ble/keymap:vi/repeat/record の代わりに独自の記録関数を定義するのが良い。
      その場合には _ble_keymap_vi_repeat{,_irepeat} 配列を必ず設定させるようにする。

    [実装]

    * 後は一つ一つのコマンドについて確認を行って行くことにする。

      - nmap ~ OK
      - nmap p P OK
      - nmap rx Rx OK
      - nmap J gJ OK
      - xmap rx Rx OK
      - xmap p P OK
      - xmap I A OK
      - lib/vim-surround: ysiw" OK (surround.vim とは異なるが想定した動き)
      - lib/vim-surround: cs"b OK (同上)

      どうも実装した後で気付いた事だが、lib/vim-surround.sh の ysiw" に対して
      . を実行すると、最後の " の部分に関しては前回のものが使われるのではなくて、
      改めて入力を求められる様である。

      更に、cs"b などについても入力が求められるが
      cs<空><入力したもの> という解釈になる様だ。
      これはバグなのではないかと思っている。

    * 一段落したら set-previous-edit / end-edit-area と統合できないか考察する。
      実装してみた結果、考察するまでもなく、これは全然統合できない。

2017-11-01

  * vi-mode: . 実装 (5) 挿入モードの操作の記録 [#D0556]

    | - ihello<C-c>. とすると o の前に再度 hello が挿入される
    | - ahello<C-c>. とすると末尾に hello が挿入される
    |   つまりどのような挿入モードによって挿入が起こったかを覚えている。
    | - 更に c$123<C-[>. を実行してみるとちゃんと削除してから挿入するまでを一通りの編集として記録している。
    | - 挿入モードの途中でカーソルを動かして更に編集を行うと、
    |   最後にカーソルを動かしてからの編集が繰り返される。
    |   最初に指定した繰り返し回数の引数は忘れられるようだ。
    |   またこの場合には a で始めたとしても、i と同様の状態になる。

    動作を調べる

      a<C-w><C-[>... とするとちゃんと単語毎に削除される。
      つまり削除された文字数ではなくてちゃんとキーの列で記録されている。

      という訳で {count}i の為の記録と同じ枠組みで記録した物を用いる。
      と思ったがよく考えると quoted-insert が正しく再生されないのではないか?
      試してみた所やはりうまく再生できていない → #D0554 で修正した。
      この修正によりキーの列として記録するのではなくて、
      実行したコマンドの列として記録することになった。

    - done: さて . による繰り返しに対応する為には
      先ず初めに imap-repeat を _ble_keymap_vi_irepeat_count の有無に拘らず
      常に記録する様に修正する必要がある。
      そして white list にないコマンドが来た場合には中身をクリアする。

    - done: どうやら ihello<C-o>. とやると hello の挿入が繰り返される訳ではなく、
      それより前の操作が繰り返される様だ。試してみると、<C-o> では繰り返しは登録されない。
      更に現在の挿入モードが ciw などによって導入されたものの場合にはどうだろうか。
      この場合も ciwhello<C-o> とやった時点では ciw は繰り返しに登録されていない。
      つまりオペレータが呼び出されたと言ってもその時点では記録されていないのだ。

      これを記録する為には、オペレータを呼び出した後に記録を行う時、
      _ble_decode_key__kmap == vi_imap の時には、repeat に直接記録するのではなく、
      一旦 _ble_keymap_vi_repeat_insert などに記録を行う様にし、
      最終的に <C-[> または <C-c> を行う時に実際に記録する様に修正する必要がある。

    - done: また <C-o> や途中の non-white な操作の際には、
      この内容を ble/widget/insert-mode か何かに書き換えてしまえば良い。
      →これは ble/keymap:vi/repeat/clear-insert の中で処理することにする。

    - done: 更に .insert-mode を呼び出す各 widget で ble/keymap:vi/repeat/clear-insert を呼び出すようにする。

    - ok: また、最終的に <C-[> または <C-c> で抜ける時に、最後の <C-o> 以降の内容が記録される。
      これは <C-o> を行う時に reset すれば良い。実の所 <C-o> から insert mode に戻る時に
      何れにしても reset されるのでこの点に関しては気にしなくても良い。

    | 挿入モードの途中でカーソルを動かしてもOK
    | (注意: これは i の引数による繰り返しがキャンセルになる状況である)

    これについても対応する。

      というか、実際に試してみると、カーソルを動かした瞬間に記録される様だ。
      例: iA<C-c>ihello<left><C-o>. とすると . で ihello<C-[> が実行される。
      また、その後でカーソルを動かしただけで (挿入を伴わずに) <C-c> or <C-[> を押した場合には、
      改めて記録されるということはない様だ。つまり clear-insert では単に repeat_insert を空にして、
      record-insert において repeat_insert が空の時には repeat_irepeat 操作が
      1 つ以上記録されているときに限って記録を行う様にすれば良い。

      実際に <C-o> における clear-insert でも同様に動作するようだ。
      つまりそれ以降に操作がなければ最終的には記録されない。
      例: iA<C-c>ihello<C-o>.<C-[>. とすると最後の . でも A が入力される。
        つまり最後の <C-o>. 以降に何も挿入操作が行われないので、
        <C-[> においては何も新しく登録されない。

    取り敢えず実装したので今度は動作確認が必要である。

    x resolved: ahello<C-c>. で動かしてみた所 . で挿入モードには入るが実際の挿入操作は行われない様だ。
      というかノーマルモードに戻るという動作すらしていない。
      →これは widget 実行後に vi_imap かどうかの確認をするのに KEYMAP を使っていたのが駄目だった。
      現在の keymap は _ble_decode_key__kmap で確認するべき。修正した。

    x resolved: ahello<C-c> の後に、何故か . を実行する度に挿入操作が一つずつ減っていき、
      最後には誤った添字のエラーメッセージが発生する。
      このエラーメッセージは ble/keymap:vi/imap-repeat/pop で出ている。

      これは imap-repeat/pop が normal-mode で呼ばれているのが原因?
      取り敢えず /normal-mode を手で呼び出している箇所で
      imap-repeat に 0:ble/widget/dummy を push する様にする。

    o 繰り返し (. に対する引数) はちゃんと動いている。
    o 3ahello<C-[> で元々指定した引数 3 も動いている。
    o ciwcheck<C-c><別の単語に移動>. もちゃんと動いている。
    o a<C-w><C-[>... も動いている。

    x resolved: iA<C-c>ihello<left><C-o>. で A が挿入される。
      ここは hello が挿入されるべきである。
      これは記録を実行するのを忘れていた。修正した。

    x resolved: 試していて気付いたのが vim では iA<C-c>i<C-o>. とした後にちゃんと元の挿入モードに戻る。

      % normal-mode の呼び出しを分解して無駄なものを除きつつ、
      % 有効な部分だけ記述しようと思ったが、存外に複雑である。
      % やはり norma-mode の呼び出しはそのままにして、外部から動作を修正する方が良さそうだ。

      うーん。これは挿入モードの繰り返しに限らず . 一般の問題の様だ。
      実際に繰り返しを行う前に _ble_keymap_vi_single_command を保存して、
      更に最終的に vi_nmap に戻るようにして、
      その上で _ble_keymap_vi_single_command を復元するという具合に修正した。

    o iA<C-c>ihello<C-o>.<C-[>. の動作も OK

  * vi-mode: . 実装 (4) xmap における operator 操作の記録と復元 [#D0555]

    * done: 次に実装するのは xmap の場合の復元である。

      | なんと矩形削除についてもちゃんと再現される。
      | 因みに矩形削除では引数は無視されるが、. に引数を指定するとどうなるか。
      | 試してみた所、無視された。つまり . の引数は繰り返し回数では決してなくて、
      | 以前に実行したコマンドに渡す引数に他ならないのである。
      |
      | 矩形の大きさは何処で保持されているのだろうか。
      | 完全に独立に保持されているのか、それとも gv や 1v と共にしているのか。
      | 調べてみた所、先ず gv と 1v は完全に独立になっている。
      | gv は <C-c> でも記録されるが 1v に関してはキャンセルすると記録されていない。
      | % というか vim で試すと 1v は前回の編集があったときの大きさであって、
      | % 前回の矩形範囲ではないような気がする。現在の実装は怪しい。
      | % →よく考えたら現在の実装でも 1v は前回の編集が合った時の大きさである。
      |
      | また gv は開始行と終了行 (追跡) とそれぞれの行での列 (追跡なし)
      | を覚えている。つまり、mark で覚えている。というか実際に `< と `> で囲むだけ。
      | 一方で 1v は高さと幅だけ覚えている。

      .save-visual-state と 1v によるデータの記録が同時に行われるのだとすれば、
      単に .restore-visual-state を呼び出して vi_xmap を push すれば良さそうである。
      実装してみたが、よく考えると .save-visual-state と
      1v によるデータの記録のタイミングは異なる気がする…。

      <C-v>jll~<C-v>jjly1v<C-c>. とやってみると両者が独立に記録されていることが分かる。
      つまり、先の調査の以下の部分は誤りであったということが分かった。

      | % ところで、矩形繰り返しが 1v と独立なのかどうかについて調べるためには、
      | % 編集操作を伴わずに 1v の範囲を変更すれば良い。そのようなことは可能か。
      | % 調べてみると ble/widget/vi_xmap/.save-visual-state は編集を伴うときにしか呼び出されない。
      | % つまり、矩形繰り返しが 1v と別かどうかを調べる方法はない気がする。
      | % 逆に言えば .save-visual-state を参考にして操作を繰り返せば良いということになる。
      | % (或いは、実際に .restore-visual-state を呼び出して処理するというようにすれば良い)。
      |
      | →マニュアルの記述に反して y は繰り返し対象ではないようである。
      | 1v の場合には y による領域も記録されるから、これを以て繰り返しと 1v の記録が独立かどうか確かめられる。
      | 実際に試してみると両者は独立に記録されているということが分かった。

      さて。1v の記録 (.save-visual-state) ではどのような変数を用いているか。
      _ble_keymap_vi_xmap_prev という変数一つに記録しているようである。
      従って、この変数をすり替えて .save-visual-state/.restore-visual-state を呼び出せば良い。

      と思ったが、repeat/record が呼び出される頃には既に _ble_edit_ind などの位置は変更されているので、
      むしろ独立に .save-visual-state を呼び出すのではなくて、
      .save-visual-state によって記録された領域をコピーして来るので良い。
      但し、その為には repeat/record を呼び出すときに必ず .save-visual-state が呼び出し済みである必要がある。
      これに関しては vi_xmap で編集が起こるときには必ず .save-visual-state が呼び出されるはずだから恐らく大丈夫である。

      ところで、一番下の行などで . を実行したことによって、
      記録されたのよりも小さな領域に対してしか繰り返し処理を実行できなかった時、
      更にそれより後に実行する繰り返しでは領域が狭められるということはあるのか?
      →調べてみると初めに記録された領域の大きさを使い続けるようだ。
        記録された領域の大きさが改めて設定されることはないようだ。OK

    x resolved: xmap 動かない。と思ったら WIDGET の復元に失敗していた。修正した。

  * vi-mode (imap): 挿入モードの引数で C-q ? による繰り返しが正しく再生されていない。 [#D0554]
    これはキーの記録を keymap のレイヤーで実行している為に、
    _ble_decode_key__hook, _ble_decode_char__hook によって
    読み取られたキー・文字を取得できていないためである。

    一旦は quoted-insert の中で keylog に登録することを考えたが、
    よく考えてみると hook をかけるのは key に対してではなく char に対してである。
    key に登録するのだと振る舞いが変わってしまう。

    a 一つの方法は再生時には quoted-insert は key に対して
      hook する様に動作が変わる様にする。

      aa 動作の切り替えは例えば、keylog から C-q を pop して
        特別な key (例えば s-q) を push する。
        s-q に対して key に対して hook する quoted-insert-key 的な widget を登録する。

        x これは keymap に対して vi-insert/quoted-insert を登録するだけでは動かないので分かりにくい。
        といって vi-isnert/quoted-insert の内部で s-q に bind するのは効率が悪い。
        x また、s-q に本当に何かを bind したい時に困る (そのような場合は余りありそうにないが可能性が全くないわけではない)。

      ab 再生時に特別なローカル変数を定義して、
        その変数が非空白のときには key に対して hook する様に動作を変更する。

    b 或いは、keylog として記録するのではなく charlog として記録する。

      charlog で記録する場合には、最後の normal-mode を呼び出す発端となったイベント
      (C-[ など) が、何文字の char によって引き起こされたのかを調べる方法が必要になる。
      これによって最後の C-[ を除去することが可能になる。

      ba 一つの方法は最後に記録した時の長さを覚えておいて、
        それ以降に増えた部分を今回のイベントを引き起こすのに関与した文字と解釈する。

      またこの方法は ble-decode に手を入れる必要がある気がする。
      というのも、keymap 経由だとどんなに頑張っても key の情報しか得られないからである。

    c もしくは widget の列として記録を行う。
      この時には KEYS 及び呼び出す WIDGET の名前の配列として記録する。
      quoted-insert は self-insert に変換することで動作する様にする。

      この方法の方が自然である。例えば keymap が変更された後でもこれなら同じように動作する。
      問題は KEYS と WIDGET だけ保存すれば完全に同じように動作するのかどうかという事である。
      うーん。多分動作する?

    % しかしよく考えてみると vim の qx ... q @x で "レジスタ" に操作を記録する仕組みとの整合性も考えなければならない。
    % そう考えるとむしろ charlog で記録した方が良いのかもしれない。
    %
    % うーん。というかレジスタに記録する機能は挿入モードに限らず全体に渡って適用される。
    % そう考えると、挿入モードの繰り返しとの整合性を考える必要は全く無い。

    思うに c の方法が最も綺麗である。
    しかしその為には挿入モード繰り返しの記録と再生を完全に再実装する必要がある。

2017-10-31

  * vi-mode (xmap): o O [#D0553]

    動作を確認する。v, V では o, O に違いはない。
    単に mark と ind を交換するだけの様な気がする。
    C-v においては o は mark と ind を交換する。
    O は同じ行内で右端から左端または左端から右端に移動する。
    - 選択領域の幅が1文字しか無いときには動かない。
    - 最初の行または最後の行の端に中途半端な全角文字が含まれている場合には
      幅が拡張する方向でどんどん大きくなる。例えば

      | echo ああああああああああ
      | echo aああああああああああ

      のような形にしておいて適当なところで C-v で囲んで、
      O を連打すると少しずつ幅が拡大していく。
    - 末尾拡張の時に o または O を押すと末尾拡張は解除される。

    O はどの様に実装するのが良さそうか。
    一番簡単な実装方法は矩形領域を実際に切り出して、
    mark, ind をそれぞれ行内で丁度反対側の文字になるように移動することである。

    % もう少し効率的な実装方法にするとすれば、
    % 矩形領域の最初の行と最後の行についてだけ範囲を計算すれば良い。
    % しかし、それは似たような処理の再実装になるのでやはり避けたい。
    % もし効率化を測るとすれば extract-block にオプションとして、
    % 最初の行と最後の行に関する情報だけで良いというものを用意する手があるが、
    % 現在の所そんなに遅くて困るということもない気がするので、
    % 取り敢えずは直接 extract-block を呼び出すという実装方法で問題ないだろう。
    % (或いは、そのようなオプションを簡単に導入できるのだとしたら実装しても良いが)
    %
    % 取り敢えず extract-block で実装したら動いた。
    % そしたら急に面倒になったので効率的な実装は問題になるまでは考えない。

    実装した。動いている。

    o ちゃんと全角文字があるときに領域が拡大されていく振る舞いも再現している。

    x resolved: 末尾拡張のときの振る舞いについて少し異なる。
      どうやら末尾拡張を解除した後で、領域を決めて移動先を決定するようだ。
      →修正した。

    x resolved: 更に O の結果としてカーソルが行末に来ることも許される。
      驚くべきことに(?)交換によって mark が行末に来ることも許される。
      これは sfill があるかどうかで判定すれば良いだろう。
      sfill が 1 以上であれば行末に移動する。
      →修正した。試した。期待通り動いている。

    _ble_edit_mark が行末に来るということは想定していなかったが、
    これによって既に書いた機能について何か問題が生じる可能性はあるか。
    つまり、_ble_edit_mark の位置は行末ではないという仮定を行っている箇所があるだろうか。

    o 例えば keymap:vi/mark の枠組みで記録される列の位置に関してはどうだろう。
      実のところ、これについては復元時に行の長さが変化している可能性も考えて、
      位置の調整が行われるので、復元時に nmap として不正な位置にカーソルが来ることはない。
      また gv などで復元する場合を考えるとむしろ行末に mark を設定できるべきである。
      つまり keymap:vi/mark についてはそもそも行末に置けないという制限はないはずなので、問題ないということ。

    o 他に _ble_edit_mark が影響を与えるのは xmap における範囲の決定である。
      これについても mark/index を区別せずに実装しているはずなので、
      mark が index と同様に行末に来たとしても問題は起こらない筈である。

    o 他には vi-mode で _ble_edit_mark が意味を持つことは無い気がする。

    まあ、恐らく大丈夫だろう。問題が出てきたらその時に対処する。

  * vi-mode: どうやら yiw の振る舞いが異なる [#D0552]

    ble.sh では現在 ///日本語 は一つの塊だと考えているが、
    vim では "///" と "日本語" の二つに分けて考えているようだ。
    vim のマニュアルを見てもこの振る舞いについては書いていない。
    非空白文字の連続としか書かれていない。

    調べてみると "日本語ひらがなカタカナ" は
    "日本語" "ひらがな" "カタカナ" の3つに分割されるようである。
    つまり Unicode の Category を見て判定している様である。
    これは厳しい気がする。

    取り敢えずの簡便な実装としては ASCII の記号と、
    それ以外の非空白文字を区別して実装するという事である。
    ASCII の記号は [!-/:-@[-`{-~] で表される。対応した。

2017-10-30

  * vi-mode: . 実装 (3) 取り敢えずの記録の仕組みと再実行の仕組み [#D0551]

    | - diw もちゃんとそのように記録される。
    |   つまり、ただ単に削除範囲の広さを記録するのではなくて、
    |   どの様な motion に伴って削除されたかの情報も記録される。

    どの様に実装したら良いだろうか。
    単にキーシーケンスを覚えるという方法は通用しない。
    visual mode で実行したコマンドは visual mode で実行しなければならないし、
    normal mode で実行したコマンドは normal mode で実行しなければならない。
    挿入モードに入って文字列を入力して抜けたら、挿入モードの種類も含めて再現する必要がある。

    うーん。取り敢えず、set-previous-edit が呼び出されるのと
    同じタイミングで記録を行うようにする。

    | a 一つの一番簡単そうな方法は set-previous-edit が起こった時に、
    |   それを呼び出したコマンド COMMAND を見るというものである。
    |   この情報だけでどの程度までコマンドを知ることができるだろうか。
    |
    |   先ず、diw などの場合には text-object が二文字目を受け取った時に実行される。
    |   この二文字目は _ble_decode_key__hook を介して呼び出されるため、
    |   実は COMMAND 情報を抽出することができない。
    |   或いは、ble-decode を修正して hook の場合には、
    |   hook に設定されていた文字列を指定する方法を提供するようにする。
    |
    |   うーん。実際の vim の実装はどうなっているのだろう。
    |   vim の場合には非同期に実装する必要はないから、
    |   呼び出されたコマンドの中で次の文字も全て処理できる。
    |   つまり、現在の呼び出しの関数というのは容易に分かる。
    |   ただし、読み出した文字などは全て記録しておく必要がある。
    |
    |   個別コマンドについて文字を記録するのは不毛だと考えれば、
    |   実のところ入力されたキーの列を記録する方が現実的なのかもしれない。
    |   とは思ったが、挿入モードの途中でカーソルを動かした時の動作などを考えると、
    |   やはり単純にキーの列を記録すれば良いというわけでもないように思われる。
    |
    |   やはり set-previous-edit からコマンド内容を調査するという方法で頑張ってみる。
    |   ble-decode では _ble_decode_key__hook を一旦変数 hook に移してから実行している。
    |   この hook を BLE_COMMAND, BLE_WIDGET などのような変数に入れて公開することにする。
    |   そしてこの変数を set-previous-edit は記録するようにする。
    |   但し、KEYS やそれまでに用意したローカル変数の様子なども一緒に記録する必要がある。
    |   KEYS は既定で保存することにして、もし特別に保存する必要があるものがある時には、
    |   ble/keymap:vi/save-widget/* という関数を用意することにすれば良い。
    |   set-previous-edit はその関数が存在するかどうかを調べ、
    |   もし存在すればそれを呼び出すことにすれば良い。
    |
    |   保存専用の関数名には議論の余地がある。
    |   ble/widget/vi-command/text-object.hook:save などでも良いかもしれない。
    |
    |   問題点は実際に set-previous-edit が呼び出されるに至るときには、
    |   既に _ble_edit_arg などの変数の値は使用済みとして消去された後であることだ。
    |   これの解決方法は4通りある。
    |
    |   | a get-arg した瞬間にはまだクリアしないことにして、
    |   |   widget の最後でクリアする関数を呼び出すようにすること。
    |   |
    |   |   これの問題点は widget の内側で更に別の widget を呼び出しているときに、
    |   |   引数が残っているがために繰り返し引数が解釈されてしまうことである。
    |   |   更に内側の widget によって引数が消去されてしまうので、
    |   |   この場合には引数を知ることができなくなってしまう。
    |   |
    |   |   内側の widget を実行するときには何らかのフラグを立てるようにして、
    |   |   get-arg によって引数が読み取られないようにするという手もあるが、
    |   |   複雑になるし、今後の widget 実装をを間違える可能性がある。
    |   |
    |   | b 或いは、get-arg する瞬間に引数を別の箇所に退避するという手もある。
    |   |
    |   |   この方法を使うと widget の内側で別の widget を呼び出しても、
    |   |   引数が繰り返し使われてしまうという問題点は防げる。
    |   |   しかし、内側の widget で get-arg を呼び出すと
    |   |   そのときに折角退避した引数が上書きされて消えてしまう。
    |   |
    |   |   つまり、退避はただ1回しか実行しないようにする仕組みが必要である。
    |   |   そのためにフラグを設定するというようにすると、
    |   |   結局 widget 実装の注意点は a と余り変わらない。
    |   |
    |   |   更に、内部で ble-decode-key を呼び出している場合の処理はどうなるか。
    |   |   →その場合は改めて BLE_COMMAND なり何なりが設定されるので、
    |   |   混乱が起こることはない。
    |   |
    |   | c widget の呼び出し元で _ble_edit_arg などの値を退避して記録する
    |   |   という方法もある。しかし、それは ble-decode で退避を行うということを意味する。
    |   |   一応 .before_command という仕組みはあるが、これは _ble_decode_key__hook に対しては効果がない。
    |   |
    |   |   更に、内部で ble-decode-key を呼び出している場合は…これは気にしなくても大丈夫そうだ。
    |   |
    |   | d 或いは arg flag reg の3変数を、get-arg 以外の用途で使用することを禁止するという手もある。
    |   |   そうすれば set-previous-edit の中で単に arg flag reg を参照すれば、
    |   |   それが実際に使われる引数の値であると考えて良いことになる。
    |   |
    |   |   後で widget を実装するときに誤って別の用途で使用しないように、
    |   |   ARG FLAG REG の様に大文字の変数名に変更するという手もある。
    |   |   しかし、それはそれでうるさい。
    |   |
    |   |   また関数で受け渡された変数も arg flag reg の名前を継承しているが、
    |   |   これらの変数に関しても同じ名前を使って良いのかどうかということである。
    |   |
    |   |   - 特に問題になるのは引数を渡すときに、$((-arg)) などのように修正して渡す場合である。
    |   |     このような場合には受け取り側は arg ではない変数名で受け取るように修正しなければならない。
    |   |     あくまでも一番外側の widget を呼び出すときの _ble_edit_arg などなどを記録するためである。
    |   |
    |   |   - 更に引数を握りつぶして何も渡さないということもある。
    |   |     この場合も実のところ引数を記録する必要はなかったりするのかもしれないが、
    |   |     (或いは、そもそも set-previous-edit が発生しない)
    |   |     やはり念のため元々の引数を復元するようにしたいものである。
    |   |
    |   |   - うーん。"オペレータの引数" という概念にも arg を使っているが、
    |   |     これは別名にした方が良い気がする。
    |   |     と思ったがオペレータ内部では一般に set-previous-edit は起こらないような気もする。
    |   |     基本的に自分で set-previous-edit を呼び出すか end-edit (call-operator) で設定される。
    |   |     従って、call-operator の引数名だけ直せばそれで良い。
    |   |     ところが、call-operator の引数名 arg を修正するのであれば、
    |   |     やはり operator の arg も修正する方が自然である。
    |   |
    |   |   色々考え合わせるとやはり get-arg のときだけ大文字にして、
    |   |   それ以外の引数で受け取ったりする引数名は小文字に統一するのが、
    |   |   書き換えとして最も安全なのではないかと思われる。
    |   |   枠組みとしても引数が直接透過して見えるので、それが自然である。
    |
    |   d の方針にする。特に arg flag reg は一番最初に取得するときに大文字にする。
    |   引数で受け渡しするときには今まで通り小文字のままにする。
    |
    | b set-previous-edit と独立に各コマンドで . 情報を記録するようにする可能性はあるか。
    |
    |   単純なコマンドの場合にはそのまま記録する。
    |   motion の場合には通常は何もしなくても良い。
    |   omap から motion/txtobj に貼る時には編集が起こる。
    |   これらに対応するためには motion コマンドにおいて、
    |   flag が設定されている場合には arg flag reg とそのコマンドを記録するという事になる。
    |   flag が設定されているにも拘らず失敗して記録されないということはあるだろうか。
    |   或いはキーを非同期に読み取る為に 27 を返してそのまま終了するという場合もある。
    |
    |   うーん。motion の場合に問題になるとすれば、
    |   或る widget を実装する為に別の widget を呼び出す場合があるということである。
    |   その場合には呼び出し元の widget を繰り返しとして登録するように工夫しなければならない。
    |   しかし、基本的には _ble_edit_arg, _ble_keymap_vi_opfunc などを設定しない限りは、
    |   編集が発生するということはないから、注意が必要な箇所はすぐ分かる。
    |
    |   あと、問題になるとすれば書き込み専用のレジスタに書き込もうとして失敗した時などの動作である。
    |   試してみた所、そのような場合には、やはり . の繰り返しコマンドとしては登録されない。
    |   更に、*.impl で実装している場合には、呼び出し元で設定しなければならないので、
    |   実際に変更があったかどうかの情報を呼び出し元に通知しなければならない。
    |   これはに終了ステータスによってよって行うのが自然であるが、
    |   終了ステータスに別の意味を持たせている場合があるかもしれず、その場合には使えない。
    |   また、全般に終了ステータスを確定させるように書き換えが必要になる。面倒だ。
    |
    |   ただ、この . の実装とは独立に終了ステータスを確定させるというのはあった方が安心な気もする。
    |   → #D0543
    |
    |   うーん。一番外側で情報を記録するようにすると問題になるのは、
    |   オペレータが中で実際に何をしたか分からないということである。
    |   もしかすると opfunc として何もしないものが登録されているかもしれない。
    |   その時にも . の対象とするのだろうか。
    |   Vim script では opfunc は結局キーの列として登録される。
    |   だとすると何か意味のある操作をするとすれば :func() のようになる。
    |   この時 : なので、これは . の繰り返し対象として登録されない気がする。
    |
    |   しかし実際の vim の動作はどうであれ operator が呼び出されれば記録するというのは
    |   一つの一貫した動作であるのでそのように動作するのが適切な気もする。

    やはり a の方針で行くことにする。

      b の方法だと、コマンドが成功したかどうか、
      オペレータが処理を実行したかどうか (例えば y は繰り返し対象ではない)
      などを一番外側の WIDGET に伝達するのは困難なので、苦しい。
      set-previous-edit-area の中か、またはそれと同じ箇所で記録の処理を行う方が現実的と判断する。

    [実装計画A] 主に set-previous-edit で記録する

    * done (→ #D0550): 取り敢えず現在のコードの整理をした。
      ble-decode.sh 側で WIDGET 及び KEYMAP を提供することにした。
      また vi.sh において get-arg にて取得されるパラメータは
      ARG FLAG REG という名前の変数に格納することにした。

    * resolved: set-previous-edit で色々記録を行う。
      これは set-previous-edit で行うのではなくその前後で独立に実装することにした。
      もし後で統合できそうならば統合するが、初めは独立に実装する。

    * done: 再実行するコマンドを取り敢えず何も考えず実装する。

    [振る舞い]

    振る舞いについて再度実装しながら確認していくことにする。

    * done: レジスタの記録

      % 先ず "x などのレジスタ指定は記録されるのか。
      % または改めて . に対して指定されたレジスタ指定はどのように使われるのか。
      %
      % 先ず記録時にレジスタが指定されていた場合には
      % . による繰り返し時にもそのレジスタが使用される。
      % . に対して指定されたレジスタは無視される。
      % 記録時にレジスタが指定されていなかった時には、
      % もし . に対してレジスタが指定されていたらそれを使う。
      % 記録時に既定の "" のレジスタが指定されていた場合には、
      % もし . に対してレジスタが指定されていたらそれを使う。
      %
      % まとめると、記録時に "" 以外のレジスタが指定されていたらそれを使う。
      % それ以外のとき、. 実行時にレジスタが指定されていたらそれを使う。
      %
      % 現在の実装では "" を指定した時はレジスタ指定は削除される。
      % 丁度この振る舞いに符合するので都合が良い。そのままにする。

      これには勘違いが入っていた。"" であっても指定されればそれが使われた。
      なので "" が指定された場合でも _ble_keymap_vi_reg は空欄にせずに 34 を設定することにした。

      | またレジスタが指定されていないときに、レジスタを指定して . を呼び出すと、
      | それ以降の . の呼び出しでは新しく指定したレジスタが使用される様だ。
      | 一度レジスタが指定されれば、それ以降はレジスタが変わることはない。
      | それは "" によるレジスタの指定であっても同様である。
      | つまり、この点に於いて "" とレジスタを指定しないことはやはり異なる。

      記録時にレジスタが指定されていたらそれを使う。
      それ以外のとき、. 実行時にレジスタが指定されていたらそれを使い、
      . の実行に成功したらそのレジスタを新しく記録する。

    * done: 引数の記録

      既に、. に対して引数が指定されていた場合にはそれが優先されることを確かめた。

      | 3x. とすると 3 文字さらに削除される。
      | 3x1. とすると 1 文字さらに削除される。
      | つまり、. に引数を指定しない場合は元の引数を使い、
      | もし . に引数を指定する場合には代わりにその引数を用いる。

      例えば 3d2l の様にした場合には 6 が記録されて、
      . に指定された引数で置き換えられるのか、
      或いは、3 x 2 と記録されて (. に指定された引数) x 2 の様になるのか。
      確かめてみると全体 6 が (. に指定された引数) に変わる様だ。
      つまり記録する時には全体の引数で記録すれば良い。

      | またもうひとつ気づいたことは、. に引数を指定した場合には、
      | 更に後続の . では新しく指定した引数が用いられるということである。
      | これは元々引数が記録されていたときでも記録されていなかったときでも同様である。

      つまり . に指定した引数は記録する。

    * done: フラグの記録は気にしなくて良い

      これは後で任意に指定できるものではないので (というか omap でしか指定できないが、
      omap には . は存在しないので) 優先順位だとか上書きされるかだとかについて気にする必要はない。
      KEYMAP や KEYS についても、WIDGET に紐付いているもののはずだから上書きしない。

    * done: . が失敗したときに引数やレジスタを上書きするかどうか

      | また . が失敗したときの動作についても確認して置かなければならない。
      | →一番下の行で dj をすると失敗する。これを利用して . を失敗させると、
      |   引数の上書きは起こらないようである。つまり、引数の上書きは、
      |   実際に set-previous-edit-area が呼び出されたときに行えば良い。
      | →レジスタについても失敗したときに新しく設定されるかどうか確認する。
      |   レジスタについても失敗したときには新しく設定されない。

      →. を呼び出したときの ARG, REG については成功したときに記録する。
      記録されている ARG/REG と区別するために repeat_arg,
      repeat_reg というローカル変数に記録することにする。

    * KEYMAP の記録に関して:

      | % 更に気付いたことだが、呼び出した時の keymap に依存して振る舞いを変えるコマンドが存在して、
      | % しかし、呼び出しの途中で ble-decode/keymap/push, pop を実行することがある。
      | % この時 set-previous-edit の中から元々の keymap を復元する必要が生じる。
      | % これに関しては .invoke-command にて (zle に倣って) KEYMAP なる変数を定義すれば良いのではないか。
      |
      | - KEYMAP というか _ble_decode_key__kmap によって全く異なる動作になるのは
      |   vi-command/operator ぐらいである。
      | - 他に text objects が xmap で異なる動作をするが、
      |   これは範囲の変更のみで編集を伴わないので . のために記録されることはない。
      | - それ以外については . で繰り返されるとしても _ble_decode_key__kmap
      |   によって振る舞いが変わって自然なものだけである。
      |
      | 従って考えるとしたら vi-command/operator の動作を如何に再現するかについて考えれば良い?
      | よく考えてみると、widget を呼び出した後に _ble_decode_key__kmap が変更されて、
      | その後で vi-command/operator が呼び出された場合、
      | vi-command/operator が参照するべきなのは widget 呼び出し時の KEYMAP ではなくて、
      | vi-command/operator 呼び出し時の _ble_decode_key__kmap ではないだろうか。
      | 但し、そのような場合には WIDGET として記録されるのは vi-command/operator ではなくて、
      | 一番最初に呼び出された widget のはずなので記録される KEYMAP について気にしても仕方がない。
      |
      | ここでの問題は何だったか。KEYMAP を記録したとしてそれをどのように利用して、
      | 元々の処理を再実行するかということであった。
      | 一つの方法は元々の KEYMAP で記録した keymap に一時的に切り替えて WIDGET を呼び出すというもの。
      | しかし、これは keymap の状態遷移がよく分からないことになる。
      | 一時的に切り替えたものは元に戻さなければならないが、
      | 途中で keymap が更に切り替わったらどうすれば良いのか。
      |
      | よく考えてみると . を呼び出せるのは nmap からだけである。
      | omap/imap/cmap からは呼び出せない。xmap についても確かめてみた所 . は呼び出せない。
      | 一方で、編集が起こるのは nmap/omap/xmap/imap のみである。
      | nmap で記録されたものに関しては keymap について気にせずに直接呼び出せば良い。
      | omap/xmap に関しては変更が起これば自動的に nmap に落ちてくるはずなので
      | 一旦 ble-decode/keymap/push してしまえば問題ない。
      | また xmap の . に関しては事前に選択範囲を復元するなどの特別な処理が必要になることに注意する。
      | imap に関しては完全に特殊なので keymap の復元がどうとかそういうものでもない。

      つまり記録した KEYMAP は状態復元に使うというよりは、
      repeat を呼び出すときの特別の処理のときに参照するという実装になるだろう。

    * 実は y は . の繰り返し対象にはならない [要考察]

      つまり set-previous-edit-area で一括して記録するということを想定していたが、
      これについては再考しなければならない。
      更に vim では 0dh などとして 0 文字削除にしたときでも . で dh を繰り返せる。
      一方でこのとき `[ 及び `] は設定されない。
      つまり、これは set-previous-edit-area と . の記録は全く別系統であるということの示唆になっている。
      やはり、set-previous-edit-area の中で記録を呼び出すというのは使えない。

      うーん。それでも set-previous-edit-area を呼び出すのと
      同じ箇所で記録するかしないかを判定するという様に設計するのは有効のはずである。
      これについては再度 (set-previous-edit-area を多目的に拡張する方向性も含めて) 後で考え直すことにする。

      うーん。どの様に対処するべきか。

      | a operator で実際に編集が行われたかどうかと、
      |   edit-area の記録は独立に行う。
      |
      |   この方法の問題点は面倒ということである。
      |   特に、edit-area の場合には _ble_edit_str.replace, reset
      |   における hook を利用して自動的に operator 内の編集を検出できたが、
      |   実際に編集を行う操作が operator 内で呼び出されたかどうかは、
      |   (実際に文字列に変更が行われなかった場合に) 検出できない。
      |   これを正しく実装するためには operator 内で
      |   "記録に値する何かを実行した" というフラグなどを明示的に立てる必要がある。
      |
      | b commit-edit-area による編集範囲の登録と、
      |   実際に行われた編集に基づく編集範囲の記録を独立に行い、
      |   set-previous-edit-area を呼び出すときに両者を合成する?
      |
      |   この方法は問題が色々あるので駄目。
      |
      |   x まず初めに独立に記録を行って後で合成することは不可能である。
      |     それぞれの編集範囲を構成する各操作の順序の情報が失われてしまうので、
      |     後でそれらを合成することは不可能である。
      |
      |   x また、実のところ . で記録するかどうかは、
      |     編集が行われたかどうかなのでわざわざ編集範囲まで記録する必要はない。
      |     編集範囲の更新をするのは処理の無駄である。
      |
      | c start-edit-area で編集が行われたかどうかのフラグを下ろしておいて、
      |   shift-by-dirty-range が呼び出された時にそのフラグを立てる様にする。
      |   そして end-edit-area においてフラグが立っていれば記録を行う。
      |
      |   x この方法の問題点は 0dh などについて、
      |     実際の文字列の変更が発生しなかった時に shift-by-dirty-range が呼び出されず、
      |     最終的に記録されないということである。
      |     vim の動作としては実際の文字列の変更が行われなかったとしても dh が記録される。
      |     そして何処か別のところに移動して . を押せば dh が実行される。
      |
      | d 或いは、operator 毎に記録するべきか記録しないべきかの属性を静的に持たせる。
      |
      |   例えば既定では記録するようにする。
      |   ble/keymap:vi/operator:foo/norecord などの空関数を定義し、
      |   その関数が定義されている場合には記録しないというようにする。
      |   また operator:foo 自身の呼び出しで 0 以外を返した場合も記録しないようにする。
      |
      |   operator 以外に関しては特に指定しない限りは
      |   start-edit-area と end-edit-area で囲んで変更を検出する。
      |   というかこれはそんなに気にしなくても良い。現状の set-previous-edit-area も同様に、
      |   必要な各箇所で end-edit-area か set-previous-edit-area を明示的に呼び出している。
      |   それと同様に実装すればよいだけの筈である。

      ここは d の方法を採用することにする。
      各オペレータ毎に成功した時に記録するかどうかの属性を持たせる。既定では記録する。
      →その様に実装することにした。

2017-10-26

  * vi-mode: . 実装 (2) WIDGET KEYMAP (decode) 及び ARG FLAG REG (vi-mode arg) の整理・対応 [#D0550]

    * done: get-arg, get-arg-reg の出力先の変数名は大文字にする。
      get-arg, get-arg-reg を直接呼び出している関数名の変数は大文字にする。
      引数として受け取っている arg flag reg は大文字にしない。

      直接呼び出し元の arg flag reg を触るような関数は現在存在しないはずなので、これで問題は起こらないはず。
      (直接呼び出し元の変数を触るように設計するのは、
      特に out パラメータとして使う場合かグローバル変数の場合であるが、
      arg flag reg に限って呼び出し元に変更を通知するようなことはないしグローバル変数でもない)

      * done: 先ず初めに vi_nmap からのみ呼び出すことを目的とした widget については、
        関数名を vi-command/* から vi_nmap/* に変更し、更に flag のチェックは省略する。
      * done: 更に get-arg を使っている部分については get-arg-reg を使う様にする。
      * done: get-arg は廃止し、get-arg-reg の関数名を get-arg にする。


      * done: get-arg を呼び出している箇所を機械的に大文字に変換していく。
        これを実行するに当たって良い方法はないだろうか。
        Emacs の置換の文字列で特別な記法があれば良いが難しい。

        こんな記事を見つけた。\,(...) で replacement に S 式を含めることができるようだ。
        https://stackoverflow.com/questions/677021/emacs-regular-expression-replacing-to-change-case

        \_<\(arg\|flag\|reg\)\_> -> \,(upcase \1) これで置換を行った

    * done: ble-decode: _ble_decode_key__hook から読み取ったコマンドを一旦
      BLE_COMMAND 的な変数に入れてから実行する。引数も含めて。
      これは _ble_decode_{char,key}__hook についても同様にする。
      通常の widget 呼び出しに使っているのも COMMAND から BLE_COMMAND 的なものに改名する。
      {BEFORE,AFTER}_COMMAND も同様にする? もし COMMAND -> BLE_WIDGET にするならこれは変えなくても良いかも。
      もしくは __before_command__ 自体を __before_widget__ に変更するか。

      % また、現在の実装では __before_command__ の内部で
      % COMMAND= としてコマンドをキャンセルする手法を用いているが、
      % この手法により何らかの問題が生じないかについても考察する必要がある。
      % というか、実のところ何も実行されないのだから、BEFORE_COMMAND 内部で set-previous-edit
      % が起こるような事態にならなければ大丈夫。むしろ、そのような場合には BLE_COMMAND
      % を記録して再実行したとしても動作を再現することはできないので別の問題が生じる。
      % →これは恐らく問題ない。OK

      そもそも {BEFORE,AFTER}_COMMAND なる変数は定義していないのであった。なので気にしない。
      COMMAND に関しては (BLE_COMMAND などではなく) zle に合わせて WIDGET にする事にした。
      現在の kmap を zle に倣って KEYMAP に記録することにしたのだから WIDGET も同様に zle に倣うのが良い。


2017-10-25

  * 2017-09-16 vi-mode merge 直前に一括して行うテスト・仕様変更など (1) [#D0549]

    以下は先に破壊的変更してしまうことにした。

    * done: vi_command は vi_nmap に変更する?
    * done: vi_insert は vi_imap に変更する?
      →widget で vi_nmap と vi-command (vi_nmap, vi_omap, vi_xmap 用) を区別したかったので、
      早々に名前を変更することにしてしまった。これは破壊的な変更なので、今度 push する時に説明が必要。

    % * vi-insert/@norepeat は @vi-norepeat 辺りに改名する。
    %
    %   C-c の説明は "InsertLeave autocmd が実行されない" である。
    %   これより @vi-cancel-leave などの方が分かりやすいのでは。

    * done: vi-insert/@norepeat は廃止された。従って改名の必要はなくただ消すのみである。
      _ble_keymap_vi_imap_white_list に登録されていない widget は全て
      __before_command__ で repeat を reset するように変更したためである。

    * done: また同時に marked/nomarked も @marked/@nomarked に変更する。
      →2017-10-25 これはもう修正した。今は marked/nomarked は obsoleted とし、
      @marked/@nomarked に振り替える様にしているが、後に削除する。

    * done: vi-insert/@norepeat, marked/nomarked の廃止

2017-10-24

  * 2015-11-18 histexpand: shopt -s histverify histreedit 対応 [#D0548]

  * support: shopt -s lithist? [#D0547]

    % 元々改行を含む履歴項目を登録する機能はあった様である。
    % この時の振る舞いについて調べ ble.sh でもこの形式に従って history を登録するべきだろう。

    先ず初めに echo hello のような感じのコマンドを複数一度にじっこうしても一つの履歴項目にはならない。
    for 等のコマンドが単体行としては不完全な形で実行されると一まとまりに登録される。
    この時 history コマンドで見ると改行がそのまま出力されて表示されている。
    .bash_history を除いてみると行毎に登録した場合と同様に改行で分かたれて登録されている。
    bash を再起動して再度 shopt -s lithist して履歴を遡ってみると
    元々一つの履歴項目であったという情報は消えてばらばらの行になってしまっている。
    つまり、shopt -s lithist をしたとしても改行を含む履歴項目が bash_history に記録されるわけではない。

    従って ble.sh では今までと同様に独自の eval -- 形式で改行を含む履歴項目を記録するということで良い。
    cmdhist, lithist のオプションに関しても、ble.sh では複数行の履歴に元から対応するということで振る舞いは変えない。
    或いは、文法に従った accept 拒否については cmdhist で振る舞いを変更するという手もある。

2017-10-23

  * 時々 kcode と keymap の不整合が起きてキーが効かなくなるのは何故か? [#D0546]

    keymap は bash version 依存がある様だ? と思ったら、
    default.sh のタイムスタンプで keymap/vi.sh のキャッシュを更新していたのが問題だ。
    default.sh から生成されるキャッシュは bash の version によって個別に生成しているので、
    そのタイムスタンプで更新する必要がある。

    local dump="$_ble_base_cache/cmap+default.$_ble_decode_kbd_ver.$TERM.dump"

    と思ったけれど本当だろうか。というか、_ble_decode_kbd_ver 3 と 4 で
    kcode は共有されているのだろうか。うーん。見てみたが共有されているはずである。
    従って bash version によらずに不整合は起こらないはずなのだが…。
    もしかすると過去に default.sh に問題が合ったというだけなのかもしれない。

    と思ったらやはり再現する。これは原因を調べて解決する必要がある。

    多分原因は分かった。default.sh が初期化される前に vi.sh が読み込まれるとなる。
    と思ったら default.sh を先に呼び出しても default.sh の中の最初の ble-bind から
    DEFAULT_KEYMAP の解決のために vi.sh が読み込まれてしまう。
    そして initialize が二重に呼び出されてしまう。
    取り敢えず直した。様子を見る。

2017-10-22

  * 2017-09-11 vi-mode: ESC の問題 (reported by cmplstofB) [#D0545]

    [原因調査]

    | ノーマルモードから挿入モードに移った直後くらいに C-c、C-m 等及び通常のキー入力が「そのようなキーは
    | 設定されていない」という警告とともに無視される時がある。

    * 可能性1

      自分で試していて思ったのは、無意識で clear-screen しようとして C-l を押してしまい、
      ノーマルモードに戻ってしまうことがあるということである。
      ノーマルモードに戻ると C-c は定義されていないので警告が出る。
      また通常のキー入力も何らかのコマンドとして解釈されてエラーになる。
      何か入力して oOiIaA などが入るとそれ以降は入力できるようになる (母音なので確率は高い)。
      "直後" というのはそういうことなのではないかという疑い。

      問題は現在のモードが表示されていないことにあるのではないかという気がする。
      モードが切り替わった時に簡単に表示する仕組みにしてみたが、微妙である。
      切り替わった瞬間には -- INSERT -- と表示されるが、
      補完などによって書き換えられた後は残らない。

      ble-edit/info で恒久的に表示する内容 (default) と、
      一時的に表示する内容を管理できるようにすると良いのではないだろうか。
      結局新しい仕組みを整えることになった。

    | * 2017-09-07 vi-mode: 現在のモードや引数の状態を表示する?
    |   info に表示するか新しく別の status line を追加するか。
    |   info に追加するというので良い気がする。

    実際に C-l を vim で試してみると動かない。
    vimindex を調べると insertmode が設定されているときにのみ C-l は normal-mode だそうだ。
    Qiita の記事の方を見ると C-l は再描画になっている。
    zsh で試してみると C-l は clear-screen である。
    従って C-l は clear-screen である方が妥当である。

    2017-09-13 追加の報告が来た。

    | どうも私の端末の問題でした。Vim で Esc キーを多用するので Esc キーが押下された時 "Meta-"
    | に続く文字をなるべく待たないようにしているのですが、その設定を無効にすると発生しなくなり
    | ました。厳密な再現条件は未だ不明ですが、一応の解決を見たので取り下げます。

    うーん。もしかすると、これは keymap を途中で切り替えた時の話かもしれない。
    一回コマンドを処理した時に残っているキーをどの様に処理するのだったか。
    というか、最近 ble-decode-key の何処かでミスを埋め込んで更にそれを修正したような気がする。
    12f3329 これだ。恐らく現状では直っているのではないかと期待する。

    やはり解決していないそうだ。どうも話を見るに寧ろ連続して文字が来たときではなくて、
    逆に時間が立ってキーが届いた時の問題のようである。
    しかし、それは寧ろ ble.sh としては変なことが起こりにくい状況のはずである。
    先の推理では C-M-m などを ESC + C-m に分解して処理するときに一度に ESC と C-m が来るのが問題かと考えたが、
    どうもそういう訳でもないようだ。

    あー。なんか分かった気がする。vi-mode では M-* を ESC * に分解していない。
    つまり ESC が二重になると失敗する。

    更に ESC を単体で受け取ったとしてもその場で処理されない。
    その場で処理するように ble-decode を改修しようかとも考えたが、
    よく考えると、それをやると矢印キーなどを認識できなくなってしまう。
    或いは、矢印キーを送るなどした場合には通常は一つのパケットで送るので、
    矢印キーの先頭が来ているときにはすでに続きも来ているはずである。
    そういう意味では既に次のキーが来ているかいないかで ESC をその場で処理するかどうかを判定するという手もある。

    取り敢えず処理するようにした。もう少し様子を見て他に問題の可能性が
    なさそうであれば改めて cmplstofB さんに尋ねることにする。

    2017-09-17 うーん。やはり駄目だそうだ。

    | すいません。まだ発生します。@akinomyoga 様の手元で発生しないということは
    | 確実に私の端末側の問題ですので、こちらで対処します。
    | どうかお気になさらないでください。

    2017-10-12 2文字のコマンドの2文字目に ESC が来る場合、
    ble-decode の枠組みでは次の文字をも食らい M-? が 2 文字目に来たとする。
    これにより余分に処理されない文字が出てくる。

    2017-10-22 どうやら ESC 単体を押した時点で元に戻って欲しいようだ。

    * ESC 単体で受け取る方法についての考察

      調べると stty time 0 及び tmux set -sg escape-time 0, screen maptimeout 0 など、
      通過経路全てで timeout を設定するようにすることができる。
      この時、ble.sh でも ESC の次に文字が既に来ているかどうかで単体の ESC かどうかを判定できる。

      % と思ったが実際に実装しようとすると問題があるということが分かった。
      % 現状では bind によって ESC を単体で受け取ることに成功していない。
      % 試しに bind.sh の ESC に関係する work around を bash-4.4 で全て外してみたが、やはり動かない。
      % カーソルキーや Function キーだけでなく、個別に ESC h と入力しても駄目である。
      %
      % と思ったが、bashrc でいきなりロードすることにすれば ESC h だけは動くようだ。
      % カーソルキーの類は動かない。ESC [ だけ定義すればカーソルキーの類も動くようになるようだが、
      % そうすると ESC 単体ですぐに受信できなくなる。
      %
      % 結論: bash readline の bind の仕組みを改修しなければどうにもならない
      % 元々 bash の bind は色々駄目駄目なので、
      % それらの改善も含めて提案してしまえば良い気がする。

      カーソルキーの類が動かなかったのは bleopt_decode_isolated_esc=raw
      の実装が不完全だったからの気がする。しかし、それを除いても (1B5B に bind しなくても)、
      ESC 単体ではすぐに受信できないようだ。と思ったが、事情は複雑である。
      CSI decoder の方が止めている可能性が出てきた。
      これはやはりキーロガーを導入するしかない。

      導入した。しかし、どのタイミングで受信したのかは分からない。
      やはり [[ $bleopt_decode_isolated_esc == meta ]] || ble/util/is-stdin-ready
      の条件をちゃんとした物にする必要がある。あるいは、もっと手っ取り早く確認する方法?

      調べてみると ESC はその場では受け取っていないようだ。
      何かが前にいて止めているように思われる。
      暫くしてから入力すると同時にキーが来る。
      screen で画面を切り替えてから入力すると
      bash_execute_unix_command で見つからないという事になってエラーになる。
      これは screen が何か噛んでいる気がする。

      また ESC を間隔を空けて入力したときには

      整理する

        screen, esc1BXX=0, ESC (wait) h
          → 大丈夫。但し、h を受け取った時に一緒に ESC も受け取る
          どうやら screen が勝手に ESC を待つようなので、
          取り敢えず screen のない環境でテストするべきである。

        esc1BXX=0, ESC (wait) h
          → bash_execute_unix_command error
          h だけが受信される。

    * 0.4 sec 以上間隔を開けると処理されないということについて。
      これは変である。再現しない。

    * 0.4 sec 以上間隔を空けて ESC を連打しても何も起こらない
      これは変である。しかし再現した。

    先に screen の外での振る舞いを正すべきである。
    というか screen の外で正しくなればあとは maptimeout を 0 にするなどすれば良いはずだ。

    再現した…。screen の中でやっていたのが悪かったようだ。
    screen の中でやっていると ESC が次の文字とくっついてからしか送られてこない。
    従って、単体で送られてくることがなかったのだ。
    そして、もし単体で送られてくると bash は解釈できずに駄目。

    [修正1]

    * 修正: \e? に bind しているときは \e 単体には bind しない。

      これをしないと ESC が単体で送られてきたあとに ? が送られてくると、
      bash_execute_unix_command のエラーが発生する。

      これは 0.4 sec 以上間隔を開けると処理されないというエラーと関係していると思われる。
      例えば tmux で escape-time 400 になっていると仮定すると、
      0.4 sec 以内であれば h が入力されたときに ESC h の組で送られてくる。
      0.4 sec 経過すると先に ESC だけが送られてくる。次に h が送られてくる。
      この時点で bash が内部で bash_execute_unix_command エラーを吐いていたのだろう。
      (しかし、何故そのエラーが表示されなかったのかというのは不思議である。
      と思ったがこのエラーメッセージは bash の標準エラー出力に出されるものだから、
      ble-decode ではなくて ble-edit の方から出てきているはずである。
      と思って調べたが check-stderr は無条件に visible-bell を呼び出しているので、
      やはりエラーメッセージが表示されているはずなのである。)

    [確認1]

    o さて、ESC を 4 回押さなければ駄目だったのが 2 回で済むようになった。
      @cmplstofB さんの手許でも 4 回だったので、恐らくこれで多少なりとも改善はしたはず。

    x 但し、間隔を空けて入力するとやはり認識されない。
      何回押しても挿入モードのままである。うーん。これは何だろう。

      調べてみる。

      esc1BXX=1, ESC (wait) ESC (wait) ESC (wait) ESC (wait) h
      → bash_execute_unix_command error になる。h だけ受信する。
      esc1BXX=1, ESC (wait) ESC h
      → bash_execute_unix_command error, ESC h を受信する。
      esc1BXX=1, ESC (wait) ESC (wait) h
      → bash_execute_unix_command error, h だけ受信する。

      esc1BXX=0, ESC (wait) h
      → bash_execute_unix_command error, h だけ受信する。
      esc1BXX=0, ESC h
      → ESC h h を受信する。key は何故かちゃんと C-[ h になる。
        これは ESC h の ESC だけが一致して、その後で再度 h を処理しているからである。

      うーん。間隔を開けると ESC 単体で受信できないようだ。

      ESC を bind -s '"\e": "\xC0\x9B"' で受信するようにしてみたところ動くようになった。
      つまり、その場で直ぐに受信することができるようになる。
      →試してみた所、実は bash-3.1 - bash-4.4 まで全部これで動く。bash-3.0 は動かない。

      うーん。ところで read -n 1 を使えば ESC はその場で受信できるようだ。
      →bind の仕方で ESC 単体で受信することができるらしいと分かったので、これは考えない。

    [修正2]

    * 修正: ESC は bind -s で UTF-8 のエラー表現に移せば良いと分かった。
      この時、ちゃんとその場で ESC を受け取ることができるようになる。

    試してみる。取り敢えず動く?

    * 孤立 ESC はちゃんと C-[ と解釈されているが、
      bash-4.3 以上では timeout を待つ様になっている。
      調べると bash-4.3 では 'keyseq-timout' というものが追加されたようだ。
      何の効果もない。うーん。と思って keyseq-timeout にしてみたら動く様だ。
      単位は恐らくミリ秒である。bind 'set keyseq-timeout 1' などとしておけば良い。

    * 孤立 C-[ はちゃんと処理されているが、
      カーソルキーも誤って孤立キーと判定されている。
      これはどうした物だろうか。というか何故? 貼り付けなどは正しく処理できているのに。

      実際に試してみると確かに is-stdin-ready ではない様だ。
      そして貼り付けを行ったときにはちゃんと is-stdin-ready になっている。
      改めて矢印キーについて調べてみる。全ての文字が is-not-ready である。
      うーん。どうしたものか…。

      これは別のターミナルでやると違うなどということがあるだろうか。
      →mintty でやっても同様だった。矢印キーは is not ready で貼り付けは ready
        従って、これは Poderosa が悪いのではない。
        途中の端末ハンドラが怪しいのではないか。

      或いはやはり ESC * も bind するという方向で動いたりしないか?
      →試してみたが駄目だった。

      screen 越しにやってみても駄目だった。
      つまり、やはり端末ハンドラが悪いということを示唆する。
      というのも screen は完全にキャッシュしてから送る設定に今はなっている。
      ということは、screen と bash の間にある端末ハンドラが悪い。

      んー。或いは。read -n 1 してしまうという手もなくはないが…。
      →read -n 1 で実装してみたが動かない。というか、何故か順序が変更されている気がする。
        | if ((char==27)) && [[ $bleopt_decode_isolated_esc == esc ]]; then
        |   function ble/util/read-byte-with-timeout {
        |     local LC_ALL=C
        |     IFS= read -r -d '' -n 1 -t "$1" byte; local ext=$?
        |     ble/util/sprintf byte %d "'$byte"
        |     return "$ext"
        |   }
        |   local byte
        |   if ((_ble_bash>=40000)) && ble/util/read-byte-with-timeout 1; then
        |     bleopt_decode_isolated_esc=meta ble-decode-char 27
        |     ble-decode-char "$byte"
        |     return
        |   else
        |     ((char=ble_decode_Ctrl|91)) # C-[
        |   fi
        | fi
      ということは何を意味するかというと特殊キーの場合には既にそれを構成する文字を読み取った後ということ。
      そして、現在は ble-decode-char をループか何かで回して処理しているということ。

      と思って一回の ble-decode-char 呼び出しで文字の列を処理できるように修正した。
      しかし効果はなかった。改めて ble-decode-byte+UTF-8 において出力してみると、
      実は ble-decode-byte を呼び出している時点で既に is-stdin-ready は non-ready になっていた。
      つまり、bash が内部で "ESC [ D" などの文字の列を既に標準入力から読み取って
      中で保持しているので、is-stdin-ready では判定できないということになる。
      そしてタイムアウト付きで read しても既に読み取ってしまった文字は読み取れない。

      うーん。だとすれば如何にして timeout を検出すれば良いのか…。
      基本的に現在の枠組みでは難しいような気がする。

      a 全ての可能なキーシーケンスに対して bind して、
        一度に受け取ることができるようにする?

        しかしこれは以下の点で問題がある。
        x 先ず、このキーシーケンスから外れるような入力が合った場合に、
        bash_execute_unix_command などのエラーが出るということが既に知られている。
        キーシーケンスから外れる全ての可能性について bind -x するとしても、
        大量に登録しなければならないので起動が遅くなるし、そもそも bind -x がそんなに信頼できるかも怪しい。
        x また、マウスなどの入力を受け付ける場合や、問い合わせの返答を受け取る場合を考えると、
        全てのキーシーケンスというのは無限個あることになり、全て登録するのは無理である。

      b 或いは bind から read -n 1 ループに入るか。

        それでも一番上のコンテキストで実行するためには
        ループには bind で入らなければならない。
        bind -x 'X: _ble_decode_char=X; eval "$_ble_decode_loop"'
        などのようにして、_ble_decode_loop にループを記述すれば良いだろう。

        x これの問題点は 1 文字目がカーソルキーなどの場合には、
        カーソルキーを構成する 2 バイト目以降は read では決して読み取れないという事である。
        何故なら bash が既に読み取ってしまった後になるためである。

      c 関数内で read -n 1 ループに入るか。

        x この時の問題点は実行の文脈をトップレベルにできないということである。

        x 更に、誤って C-c などを連打してそれがループに対して作用してしまった場合、
        その瞬間に ble.sh から抜けて元の bash になってしまう。
        それだけでも問題であるが、さらに、
        この時、其処までに編集した文字列などが失われるなどの実害もある。

      d ESC * も bind -s 経由で登録したらうまく行くかもしれない?

        もしくは bind '"\e\e": "\xC0\x9B\xC0\x9B"' でも十分かもしれない

      方針 d でうまく行くようになった。しかし、こうすると今度は timeout した時に、
      esc をそのまま処理するか meta として処理するかの切り替えができなくなる。
      或いは逆に C-[ を ESC に戻して処理するという具合にすることは可能か?

      元々 C-[ が \e[27:5:91~ として送られてくることはないはず。
      だとすれば C-[ を ESC に戻せばよいのではないだろうか。

      % と思ったが…よく考えたら C-[ になるのは key の段階なので、
      % ble-decode-char の段階で介入できない。
      %
      % ble-decode-char の段階で介入できるような特別な文字は存在するだろうか?
      % うーん。例えば ble-decode-byte+UTF-8 において ESC の 3 バイト表現の場合には特別なフラグを立てるようにするなど?
      % しかし ble-decode-byte+UTF-8 は文字デコーダとして独立したものにしたい。
      %
      % うーん。或いは \e[27;5;91~ は csi を通して処理されるので、
      % csi から出てくるキーについても修飾キーになる可能性を検査するように修正するという手もある。
      % と思って実装を見たら元々収書キーになるかどうかの判定は csi から出てくる物も含まれていた。
      %
      % 特別に対処する必要はなかった。

    多分解決した。未だ問題がある場合には別項目で立てることにする。

  * ble.pp: readlink -f は Linux でしか使えない [#D0544]

2017-10-19

  * vi-mode: . 実装 (1) ble/widget の終了ステータス確定 [#D0543]

    | Note: __default__, __defchar__ においては要求されたコマンドが成功したかどうか
    | (そして . に記録するに値するかどうか) というよりは、
    | そのキー入力に対する処理が見つかったかどうかという意味を持つ。
    | 見つかったならばその処理自体が無効だったりして失敗したとしても、
    | 別のハンドラーを探しに行くという様な動作は変である。
    | 或いは __default__ に登録するハンドラーについて、
    | それに対応する処理が見つからなかった場合には、単に 1 を返すのではなくて、
    | 特別な値を返すというルールにするのが良い。
    | むしろその方が自然である。
    |
    | Bash の終了ステータスの値を参考にするのが良さそうである。
    |
    | - 127 は一般にコマンドが見つからなかった時に使われる。
    |   特にコマンドが見つからなかった時は command_not_found 関数が使われるが、
    |   これは ble-decode の枠組みにおける __default__ に近い。
    |   更に command_not_found 関数もなかった場合に 127 がコマンドの終了ステータスになる。
    |   これから、__defchar__/__default__ に登録した関数によって、
    |   KEYS に対応する処理が定義されていない場合には 127 を返すというのは自然な気がする。
    |
    |   と思ったが 127 は丁度 7 bit で表現できる最大の数であることから
    |   ソースコード中に頻出する数字である。つまり検索しにくい。
    |   うーん。使われていない 125 を代わりに使うことにしようか。
    |
    | - 126 はコマンドは見つかったが何らかの理由で実行できなかった場合の値である。
    |   これは ble-decode ではするべき操作は決まったが、それが正しく実行できないときになる。
    |   つまり bell を鳴らしたりするような場面である。これは普通に 1 でも返す方が自然だ。
    |
    | - 125 は使われていない
    |
    | - 124 はプログラム補完に於いて、
    |   補完候補生成を最初からやり直すということを要求するのに使われる。
    |
    | - 128 以降はシグナルに使われる。
    |
    | - その他の 12? は特に使われていないようだ
    |
    | - 148 = 128+20 (SIGTSTP) は C-z による中断時。
    |   現在 isearch の fib には 27 を用いているが、根拠は弱い。
    |   こちらの方が説得力があるかもしれない。
    |   また 27 は別の目的でも使われるのでなかなか検索しにくいという問題もある。

    → __default__, __defchar__ の終了ステータス 125 に対応した。
    → 中断・継続のための終了ステータスは 27 から 148 に変更した。

    その他の widget についても終了ステータスについて再確認して、
    全体に終了ステータスを定義済みになるようにした。

2017-10-17

  * 2017-10-14 vi-mode: レジスタ対応 [#D0542]

    operator 呼び出しの前後で _ble_edit_kill_{ring,type}
    を入れ替える実装にする事にした。
    これは単に書き換えて行くだけである。

    * done: call-operator-*wise を改修して kill_ring, kill_type を
      復元・保存する様にする。

    * done: 現在 operator:* は _ble_keymap_vi_operator_delayed
      を用いて処理の継続の情報を呼び出し物に伝えているが、
      これは終了ステータスによる方法の方が自然なのではないかと思われる。
      →終了ステータス 27 によって続きを別のところで処理することを表す事にした。

    * done: call-operator-*wise の呼び出し元を修正する。

    * done: 以下の関数の呼び出し元の修正
      - done: exclusive-goto index flag reg nobell
      - done: inclusive-goto index flag reg nobell
      - done: exclusive-range p q flag reg nobell
      - done: linewise-goto index flag reg opts
      - done: linewise-range p q flag reg opts

    * done: 以下の関数は直接 kill-range/copy-range を呼び出している。

      - done: ble/widget/vi-command/copy-current-line
      - done: ble/widget/vi-command/kill-current-line
        上記の関数については operator 経由で呼び出す様に変更した。

      他にもあると思われる。と思ったら、他は全て operator y/d/c 経由だった。

    * done: 後は kill_ring kill_type を直接触っているコード
      vi-command/paste.impl vi_xmap/paste.impl がある。

    * done: operator:* の終了ステータスを確定させる。
      特に 27 を返すことは特別な意味を持つので。
      27 を返すもの以外は 0 を返すように修正した。

    レジスタへの追記の振る舞い

    "大文字によって既存のレジスタへ内容を追加できるそうだ。
    しかし v V C-v を混在させるとどうなるのか。

    C-v に v を追記したら C-v だった。
    ただし、v で追記した分については nfill は設定されていないようである。

    今の実装の問題点

    * resolved: "x を前置すると実際に変更がなかった場合でも
      レジスタに kill_ring kill_type の内容が登録されてしまうのでは?
      と思ったが "x を前置したときの内容は事前に "x の内容になっているので、
      変更がなかった場合は改めて "x に値を格納しても以前と変わらないので問題ない。

    * resolved: 現在は "x を指定したときにはそのレジスタだけに値を設定している。
      しかし、vim の動作を確認すると無名レジスタにも同じ値をコピーするようである。

      a これに対応するためには、例えば一つの方法は
        local _ble_edit_kill_{ring,type} を事前に設定せずにそのまま処理を実行し、
        後で _ble_edit_kill_{ring,type} の内容をレジスタにコピーするというもの。
        もし追記を指定された場合には、レジスタに追記した後で追記内容を
        _ble_edit_kill_{ring,type} に書き戻す。

        この方法の問題点は実際に _ble_edit_kill_{ring,type} が変更されたか
        どうかを検出しなければならないということである。
        もし "x を設定しても何も変更がなかった場合には、
        _ble_edit_kill_{ring,type} の内容をレジスタにコピー・追記してはならない。
        実際に試してみたが、やはり、例えば "ag~ ではレジスタに変更は起こらない様だ。

        またこの方法だと operator から見える _ble_edit_kill_{ring,type} の内容は
        無名レジスタのそれであって、ユーザが "a で指定したレジスタの内容ではない。
        % (_ble_edit_kill_{ring,type} の内容を変更した時は "a に対する変更であるにも拘らず。
        % と思ったが、これは微妙である。何故ならユーザに依る変更は "" と "a の両方に適用されるから)

      b もう一つの方法は、取り敢えず local _ble_edit_kill_{ring,type} は事前に設定し、
        それをレジスタにコピー・追記した後で、
        unset _ble_edit_kill_{ring,type} して本来の kill_ring に値を戻すというものである。
        しかし、この場合でも kill_ring に変更があったかどうかを検出する必要がある。

      c やはり一番妥当な方法は実際に .copy-range .kill-range する箇所で
        コピー・追記などの処理を行うということである。

      → c の方針で書き直した。operator:* の呼び出しは結局全て
      call-operator 経由で行うことになったので、書き換えは簡単である。
      operator 側でもレジスタに触るものは限られている。

    Note

    * done: omap では "x は使えない。つまりオペレータを入力する前に "x は設定しなければならない。
      →nmap と xmap に個別に '"' を登録することにした。

    色々書き換えたので動作確認を行う。

    * done: レジスタ追記について: (v, V, C-v) x (v, V, C-v) が正しく動作するか。
      - v v, v V, v C-v は確認した。
      - V V, V v, V C-v も確認した。
      - C-v v, C-v C-v, C-v V も確認した。

    x resolved: ysiw" の入力途中に bell がなる。動作は正しい。
      w まで入力したところでなる。どうも operator:ys で 27 を返すとなるようだ。
      →call-operator-* の戻り値をチェックして失敗したら bell を鳴らすようにしていた箇所があった。
        27 を返した時には何もせずに退出するべきである。その様に書き換えた。
        他にも call-operator-* を呼び出しているが戻り値に対応して適切な処理をしていないところが
        幾つか合ったのでそれも直した。

    * resolved: これは前からだと思うが行指向の kill_ring を最終行で貼り付けたとき、
      余分に改行が挿入されるのは何とかならないのだろうか。
      →これは直した。また `[`] で設定される範囲も直した (次の行頭には行かない)。
        両変更について確認した。

2017-10-12

  * ble-edit: 複数行編集時に .SHELL_COMMAND を実行すると、 [#D0541]
    色々と座標計算がずれている。先ず初めに編集中の文字列が残ってしまう。
    更に、.SHELL_COMMAND が出力した内容が上書きされて消えてしまう。

    座標計算は合っている。みたところちゃんとした場所に移動してから実行しているように見える。
    と思ったら分かった。端末の一番下にいるときに起こり、端末の上の方に煎る時には起こらない。
    つまり、描画領域の高さの確保がちゃんとできていないことが原因である。
    取り敢えず一時的に端末の高さを 0 にするということが必要である。

  * vi-mode (visual mode): J gJ [#D0540]

    これは試してみた所 block, char かどうかとは関係なく、常に行指向で処理するようだ。
    これの対応は簡単だった。

  * vi-mode: (insert) で C-c すると表示は (insert) のまま [#D0539]
    ノーマルモードに戻っている気がする。
    よく分からないので、ble.sh では C-c で
    単にノーマルモードに戻ることにする。

  * `[ `] は挿入モード中でのカーソル移動でも途切れるが、 [#D0538]

    % そのようなものにまで対応していると遅くなると思われるので今は対応しない。

    もしかすると white_list に載っていないコマンドで
    dirty-range#clear すれば良いだけかもしれないが。
    いや、移動した後で何も変更しないということも考えられるから、
    end-edit-area, start-edit-area を実行するべきだろうか。

    しかし white_list に含まれるかどうかのチェックには時間がかかるのではないかという心配がある。
    現在の設定では挿入の引数が設定されていない限りは white_list のチェックは行っていない。
    `[`] を設定するためにこれを利用するというのは、常に white_list のチェックを行うという事に等価である。
    self-insert は特に頻繁に通過するだろうから、特別に対処するというのは妥当である。

    さて、結局 `[`] の挿入モードにおける厳密な振る舞いに対応することによるオーバーヘッドは、
    .before_command における white list チェックのオーバーヘッドのことだと考えられると分かった。
    現在の実装では特に white list の使用は繰り返しが指定されたときだけにしているが、
    実のところ将来的に undo を実装する際には結局同様にチェックしなければならない気がする。
    結局、white list のチェックを免れられないのであれば、ここで対応する。

  * vi-mode (xmap I): より vim に違い動作 [#D0537]

    どうも色々ためすと切り出し位置の決定はそんなに簡単ではないようだ。
    現状では行を覚えておいた内容と比較して一番初めに変更の合った点からとしているが、
    これはたまたま挿入した文字列が元々合った内容と一致している場合に切り出し内容がずれて問題になる。
    vim で詳しく調べてみると、どうやら I が始まって以降の変更範囲を覚えているようである。
    どこから開始点よりも前 (前の行での変更も含む) で変更があれば (変更前と変更後が同じだったとしても)、
    切り出し位置は開始点になる。もし変更が開始点よりも後にあれば変更はそこからになる。
    さて、変更範囲は何処に記録されるだろうか。挿入モードによる `[`] はどうか。

    - 試してみた所 C-o から復帰した時点で新しい `[ が始まるようである。
      但し何も入力しない場合には最終的に抜けるときに `[ `] は設定されない。
      これは通常通りに入るときと少し異なる動作である。

    - さて、もし I の InsertLeave が `[ `] を使用しているのだとすれば、
      途中で C-o を挟めば以前の編集について忘れてその点からの挿入になるはずである。
      →試してみた所 C-o をした瞬間に InsertLeave が消去されてしまう。
      因みにこの動作は現在の ble.sh でも同様である。

    従って、`[ `] を用いて変更範囲を決定することが可能である。

    - と思ったが、vim の動作を調べてみると挿入モードの中であっても
      カーソルキーなどを用いて移動したりするとその都度 `[ `] が設定されるようである。
      つまり、正しい実装の `[ `] に頼る訳には行かない。

    - 更に、現状の実装では挿入開始点の記録に `[ を使用しているがこれも正しくない。
      より前に変更があったりすると `[ もずれてしまう。
      別の mark を設定する必要がある → これには特別な mark 1 を用意することにした。

    - 矩形挿入を開始して以降の "変更" を累積して記録するにはどうすればよいか。
      現状の `[ `] はそれに近いが挿入モード開始時に開始点に "変更" を記録してしまうのでこれは微妙に違う。
      更に将来的に vim と同じ `[ `] の動作にしたときに、動作が変わってそれも問題になるだろう。

    結局矩形挿入モードのときだけ更新する dirty-range をもう一つ用意するしかないのだろうか。

  * 2017-10-05 vi-mode (visual): p P [#D0536]

    前回 p または P 消したものを覚えていて、それを貼り付けている気がする。
    vimindex のページには書いていない。ページが古いのかもしれない。
    :help v_P とすると v_p または v_P の説明を見ることができる。

    1 help には挿入してから削除すると書かれているがこれは嘘だ。

      ABC
      ABC

      に対して

      e
      e

      を、初めの B 1文字を矩形選択して p すると

      AeC
      AeBC

      という結果になる。これはつまり選択範囲 B を削除してから e を挿入していることを意味する。
      カーソルは最初の e

    2 文字ビジュアルに矩形を貼り付けるとどうなるか。

      12345
      67890
      xyzwt

      abcde
      fghij

      これについて C-v b → g を v 2 → 9 に対して貼り付けると次のようになる。

      1b0
      xgyzwt

      カーソルは b
      これも先に削除してから貼り付けが起こっていることを示唆している。

    3 文字ビジュアルに改行を貼り付けるとどうなるか。

      ABCDE
      FGHIJ

      の v C → D に行を貼り付けると以下のようになる。

      AB
      12345
      67890
      E
      FGHIJ

    適当に既存の機能の組み合わせで実装した。
    テストする。C-v → C-v は確認した。
    上記のケース 1 2 3 は何れも再現した。

    4 V を C-v に貼り付ける場合

      ABCDE
      FGHIJ

      の C-v B → G に p で貼り付ける場合。

      ACDE
      FHIJ
      12345
      67890

      更に P で貼り付ける場合には前に貼り付けられる。
      現在の実装だと以下のようになってしまう。

      A
      12345
      67890
      CDE
      FHIJ

    5 v を C-v に貼り付ける場合

      A12345CDE
      F12345HIJ

      文字列 12345 を C-v B → G に貼り付ける場合には、各領域に繰り返し挿入される。

      A45
      678CDE
      FHIJ

      貼り付けられる文字列に改行が含まれる場合は、繰り返しは行われない。

    これはどう理解したら良いだろう。
    貼り付けられる対象が C-v のときには特別な対処が必要ということか。

    あとカーソルの位置に関しても確認しておく必要がある。
    1 と 2 は合っている。3 はカーソル位置が違うというか…行末に来ている。
    通常の行指向の p P は行末に来ていない…と思ったが、
    実際に v_p の実装では文字指向の p P を使っているので、この動作は別の問題である。

    結局、3x3 のパターンについて個別に paste の仕方を変えて実行することにした。
    色々と引数を与えた時の動作などを観察するとこの方法で良かったようだ。
    簡単に各場合の動作の確認もした。大丈夫。

2017-10-11

  * isearch が動かなくなっている。 [#D0535]
    リファクタリングの過程で条件が反転していた。

  * complete: complete -p -D が働いていない気がするが… → 124 に対応 [#D0534]

    % complete.sh を見ると対応しているように見えるし、
    % 過去の記録を見ても動いていた様子がある。

    どうも前から動いていなかった疑いがある。
    先ず初めに compgen に -D オプションが混入するとエラーになって、
    そもそも補完関数も呼び出されない。

    さて、無事に補完関数は呼び出されるようになったが、何も候補が生成されていない。
    どうやら __load_completion では定義をロードするだけで候補生成は行わない様だ。
    一方で、素の bash でやるとちゃんと候補が生成できている。
    これが意味するところは素の bash は、もし候補生成がされなかった場合は、
    新しく追加された定義を用いて再度候補生成を行うということである。

    何と。マニュアルに書かれていた。
    -D による補完関数が 124 を返したとき、
    再度補完が試みられるのだと。対応した。

    * git 補完関数の末尾空白の問題

      | * 2015-11-23 プログラム補完: 末尾空白の問題点
      |
      |   現在 git 補完関数に合わせる形で勝手に末尾の空白を除去している。
      |   しかしこれで良いのか? これだと空白で終わるファイル名などがあった場合に問題になる。
      |   (その様なファイル名は滅多にないとは思われるが…。)

      % git の補完関数は変なことをする。候補の末尾に空白を付加し compopt -o nospace を指定する。
      % ble.sh の complete は末尾の空白をエスケープする仕様になっている。
      % これは compgen -A file の空白を含むファイルとの一貫性のためである。
      % 従って git の補完関数の場合には sed で末端の [[:space:]]+ を除去する必要がある。

      git の時にだけ work around を追加しようと思ったが、
      どうやら bash-completion は一般にそのような設計になっている疑いがある。
      分からないので取り敢えず現在の仕様を保持することにする。
      と思ったが、やはり末端に空白のあるファイル名を補完するときに問題になる。

      うーん。やはり git だけ特別扱いすることにする。

    そういえば、やはり git は以前問題になったのだから、
    以前は complete -D が動いていたという事になる。
    恐らく bash の version によって compgen に -D があった時に
    エラーになるかどうかが違うということなのだろう。

    * しかし、不思議なのは素の bash ではこの問題が発生していないということである。
      つまりファイル名の末尾の空白はちゃんとエスケープされるが、
      git subcommand の末尾の空白はエスケープされないというようになっている。

      もしかして git の補完関数はファイル名を補完しているときには
      nospace を指定せずに末尾空白も付加せずに候補を生成するのではないかという説を思いついた。
      つまり nospace は末尾空白をエスケープしないというサインになっているのではないかという説である。
      しかし試してみると、常に nospace を指定している。

      うーん。しかし /usr/share/bash-completion/completions/git に
      compopt -o filenames +o nospace という行がある。この行が実行されているときには、
      ファイル名末尾の空白がちゃんとエスケープされるようになるということではあるまいか。
      そして自前のシェル関数の compopt は実行されないということなのではないだろうか。

      そう思って適当なコマンドを作って試してみた所、
      ちゃんと自前のシェル関数が呼び出されるということが分かった。

        function _alpha { compopt +o nospace; }
        function alpha { echo "$@"; }
        complete -F _alpha alpha
        alpha hello.txt

      ということはやはり git の補完では実際には compopt は呼び出されていないのだろう。
      やはり素の bash で正しく動作できている理由が不明である。

      更に素の bash の補完の振る舞いについても調べてみたが、

        function _alpha { compopt -o nospace; local w=${COMP_WORDS[COMP_CWORD]}; for a in hello world 'abc efg'; do [[ $a == "$w"* ]] && COMPREPLY=("$a "); done; }
        function _alpha { compopt +o nospace; local w=${COMP_WORDS[COMP_CWORD]}; for a in hello world 'abc efg'; do [[ $a == "$w"* ]] && COMPREPLY=("$a "); done; }

      特に -o nospace / +o nospace でエスケープをしたりしなかったりという事はないようだ。
      というか、基本的に補完関数によって生成された候補はエスケープしないようである。

      ということはスペースを含むファイル名を補完した時にエスケープしているのは誰なのかという謎が生じる。
      実のところ、bash は直接 compgen を呼んでいるのではなくて、
      内部的な処理の一環としてファイル名を候補に生成しているので、
      それがファイル名による候補かどうかを知っていて、
      その内部的にしか知り得ない情報を用いてエスケープするかしないかを決めている可能性がある。

      % 面倒なのでここまでにして深入りしない事にする。

      と思って ble.sh でやってみたらいつの間にかに正しく動くようになっている。
      つまり __git* の生成するものについてはエスケープせず、
      ファイル名候補の場合にはエスケープする。
      どうやら git はサブコマンドしか候補を生成しない様だ。
      そして一致するものが見つからない場合には自前でファイル名候補を生成するなどのことはしない。
      これによって ble.sh の通常のファイル名候補にフォールバックする。
      結果としてファイル名候補の場合には正しくエスケープされるという動作になる。

      取り敢えず OK ということにする。

  * 2017-10-10 vi-mode (mark): < > ` ' " . などの設定をそれぞれ実装する必要がある。 [#D0533]

    - done: [] は直前の変更または yank 範囲 → #D0529
    - done: <> は前回のビジュアルモードの選択範囲 → #D0531 で同時に対応
    - `' は最後のジャンプ前の位置

      ジャンプには以下の種類がある。
      - done: 新規ファイル作成 → これは新しい行のロードと解釈して良いだろう
      - done: `x 'x / ? n N L H % G (last-line)
      - 保留: M ( ) [[ ]] { } :s :tag これらのコマンドはそもそも未対応 → #M0006 に記録

      どうやらオペレータによって移動する場合にはジャンプ元の設定は行われない様だ。

    - done: " は最後の終了時の位置
      これはシェルにおいては履歴項目を移動する直前の位置とするので良いだろう。
      しかしどのタイミングで記録するのが良いだろうか。

      a 一つの方法は _ble_edit_str.reset を通して呼び出される
        update-dirty-range の hook でそれを検出して実行することである。
        と思ったが、その呼出のタイミングでは既に元の文字列が失われている可能性がある
        (確認してみたら reset のときはそうではないと分かったがこの仮定に依存することは危険である)
        ので、もっと他の方法があると良い。

      b 或いは、ble-edit 側で history を移動する、もしくは、
        新しい行に移動するときの hook というのを用意するという手がある。

    - done: . は最後の編集位置
    - done: 現在 `[ `] は yank の効果を入れていない。
      yank (copy-range もしくは block copy) があった時にも更新するように設定すべき。
      実のところコピーをしているのは .copy-range を呼び出している箇所か、
      或いは operator:y のみである。他の操作は全ては快適変更を伴うので自動的に登録されている。
      対応した。

  * vi-mode (visual block): 元から行末にいる時に $ を押しても末尾拡張が表示に反映されない。 [#D0532]
    内部的にはちゃんとできているはずだが、描画部に状態変化が伝わらないので、
    表示が更新されないのが問題である。これに対応するためには、
    末尾拡張も _ble_edit_mark_active を使って表現するしかない?

    その場合には従来の _ble_edit_mark_active を参照している箇所も書き換える必要がある。

    →その様に修正した。元々使っていた _ble_keymap_vi_xmap_eol_extended という変数は廃止した
    ble/widget/vi_xmap/linewise-operator.impl の辺りで保存される矩形の種類についても修正した。

  * 2017-10-08 vi-mode (visual): I A [#D0531]

    振る舞いを調べる。先ずは I について。

    | - 矩形ビジュアルのときだけしか特別な動作はしない。
    |   行ビジュアルでもコピーは起こらない。
    |
    | - 先ず途中でカーソルを中で移動しても大丈夫。
    |   これは引数による繰り返しとは振る舞いが異なる。
    |   更に中で動かすのではなくて一回外に出て戻ってきても OK
    |
    |   - 別の行を弄って戻ってきても大丈夫。
    |     行の数が変化すると駄目。行を挿入して削除して合計で変わらなければ OK。
    |     と思ったが範囲よりも後に行を追加しても大丈夫。
    |
    |   - というか同じ行の前後もいじっても大丈夫?
    |
    |   - 同じ行の前を幅が変わらないように弄るとベルが鳴って行頭に移動する。
    |     幅が変わっても何か動く。開始点はずれる前の位置で決まり、終了点は最後に挿入した文字列になる。
    |     重要な結果。
    |
    |     | AAABBB -> AAA123BBBaaa -> AAA123BBBaaa
    |     | AAABBB    AAABBB          AAA123helBBB
    |     | AAABBB    AAABBB          AAA123helBBB
    |
    |     どうやら行内の%%文字数%%幅を数えて増分を計算しているようだ。
    |
    |   - 抜けるときに、挿入文字列の途中にいても大丈夫。但し、外にいると駄目。
    |
    |   - 行の数が変化すると駄目だったが、
    |     もし行番号だけを見ていてカーソルが同じ番号の行にいれば動くということだと、
    |     行の数が変化した分だけカーソルの位置をずらして元々別の行だった所で挿入モードを抜ければ、
    |     同様に働くのではないかと考えた。が、試したら動かなかった。
    |     やはり vim では行は追跡されている気がする (mark の振る舞いを見ると)。
    |
    | - 途中で改行を入れると動かない。I でも A でも。
    |   前に一回動いた(選択領域のかかっている行たちの次の行に新しい内容が挿入されるような動き)
    |   ような気がしたけれどなんだったのだろう。
    |   しかし実際にそのような動作が起こる場合があるとしても分かりにくいので取り敢えず実装しない。
    |   というわけでこの振る舞いに関しては取り敢えずは考えないことにする。
    |
    | - I に対する引数に依る繰り返しが適用されてから、
    |   他の境界に対するコピーが起こる。

    この時点での仮説では I は以下のように動く

    1 矩形範囲の先頭行の行番号と表示横幅と矩形の左端の位置を記録する。
      更にその行自体も覚えておく。
    2 挿入モードから抜けるときの処理として次に続くものを登録する。
      挿入モードから抜けるときは先に引数による繰り返しを実行する。
      これは引数による繰り返しがない場合や、引数に依る繰り返しが無効になった時も含む。
    3 カーソルのある行が 1 で記録したものと一緒でなければキャンセル。
      カーソルのある行の行番号が 1 で記録したものと一緒でなければキャンセル。
    4 表示横幅の変化量を測る。これが正でなければキャンセル。
      変化量の分だけ 1 で記録した左端の位置から文字列を切り出す。
    5 その時点での続く行の、記録した左位置に 4 の文字列を挿入する。
      新しく行が挿入されていたりしても関係なく、
      その時点での先頭行からの相対位置で挿入行が決まる。

    | 矩形範囲の先頭行を覚えておくのには ble.sh の実装では _ble_edit_mark でも使えば良い?
    | ただ挿入モードの操作の途中で _ble_edit_mark が書き換えられることもあるので別に用意するべき
    |
    | ? 途中で行分割が起こった場合は 1 で記録した行はどうするのか。
    |   また分割された行に対して挿入が行われたりするのだろうか。
    |
    |   →試すと行頭に紐付いている気がする。また分割された行に対して挿入が行われる。
    |   うーん。行分割した上で矩形左位置の内容を元と同じにすれば動くが、
    |   行分割した上で矩形左位置よりも前の内容が異なると起動しない?
    |   これは行分割を行わなかった場合と様子が異なる。
    |
    |   うーん。よく分からないのでこれについては無視でも良い気がしてきた。
    |   行分割を行わなかった場合と同じ処理にすれば良い。
    |
    | ? 試すと 以下で C の列で C-v I して、G の後に平仮名を入れて、
    |   それから抜けると以下のようになる。行の内容を記録しておいて、
    |   一番初めに変更のあった位置を検出しているのか?
    |
    |   | ABCDEFGH -> ABCDEFGあH
    |   | ABCDEFGH    ABCDEFGあH
    |   | ABCDEFGH    ABCDEFGあH
    |
    |   うーん。しかし、矩形左位置より前で変更が起こると、
    |   矩形左位置からのコピーになる。
    |
    | - 中途半端に全角文字に被っているとき、
    |   全角文字の前で挿入が開始される。
    |   コピーは矩形範囲内に入った文字列だけ行われる。
    |
    |   挿入した文字列に含まれる全角文字が、
    |   元の矩形の左端に中途半端に被っているときは、
    |   その全角文字全体がコピーの対象になる。
    |   コピーの終端がそれに応じて移動するということはない。
    |
    |   挿入した文字列に含まれる全角文字が、
    |   元の矩形の右端に中途半端に被っているときは、
    |   何か文字が分解されて変なことになる。
    |
    |   | echo hello world
    |   | echo hello world
    |   | echo hello world
    |
    |   | echoあい hello wld
    |   | echo あ<e3><81>hello world
    |   | echo あ<e3><81>hello world
    |
    |   コピー先に全角文字が鎮座しているときの振る舞いはどうか。
    |   →その全角文字の手前に挿入される。
    |   全角文字が鎮座していないその他の行については影響はない。

    以上のことから手順に以下の変更を加える。

    1a 行の内容も記録する
    4a 行の内容を比較して一番初めに変更の合った点を求める。
      この点が矩形左端より左にあれば矩形左端を切り出しの開始点とする。
      もしこの点が矩形左端より右にあればこの点を切り出しの開始点とする。
    4b 切り出し範囲に被る全角文字があればその全角文字も取り込む。
    5a コピー先に全角文字が鎮座しているときには、
      その全角文字の前に挿入する。
      タブが鎮座しているときにはタブは空白に変換する。

    上の手順の 5a での挿入は p による挿入と同じ気がする。
    と思ったが p の場合には全角文字の前に空白を挿入して位置を調整してから
    挿入するのであった。つまり、微妙に振る舞いは異なる。

    % 実装するとすると先に set-mark を統一的に実装しておく必要がある。
    % 1 の開始位置を覚えておくのに使うのは `[ が良いと考えていたが、
    % 実は `< の方が適切なのでは? と思ったが I ではそれで良いが A だと駄目なので、
    % このままで良い。

    - 因みに末尾拡張の状態で A をしてそれから実行するとちゃんとそれぞれの行末に追記される。
      空白が挿入されて桁が合わせられるなどのことは起こらない。
    - また、挟まれた行で短い行があった場合には (末尾拡張でないとき)、
      ちゃんと空白が挿入されて桁が合わせられる。

    取り敢えず実装した。取り敢えず動く。

  * vi-mode: dd を続けて行うと "bash: index: substring expression < 0" というエラーが出る [#D0530]
    これは ble/keymap:vi/mark/end-edit の中の条件式を間違えていた。

  * vi-mode (mark): `[ `] [#D0529]

    直前の変更範囲または yank 範囲と help には書かれている。動作を調べる。

    - 挿入モードの範囲も登録される。
    - 実際に何も入力しなかった場合でも登録される
    - C-o すると `[ は既に設定されていると分かる。
      2回目の C-o でも同じ点のようなので C-o によって挿入モードの範囲が途切れたりはしない。
      一方で、`] に関しては C-o する度に新しく設定し直されている気がする。
      と思ったが、1回目の2回目の C-o の間に何も入力しなければ `] は最初の C-o と同じになる。
      つまり、`] は C-o の度に設定されるのではなくて文字が挿入される度に毎回設定されていると考えるべきだろう。
      一方でその実装は効率が悪いように思われるので、ble.sh の実装では C-o の瞬間に実行することにする。
      振る舞いが多少異なることになるが、これについては何処かに説明を書いておくことにすれば良い。

    取り敢えず operator 呼び出しの箇所と、挿入モードに入る、または出る箇所での `[ `] の設定は書いた。

    - done: x s X delete Y S D C p P J gJ r gr でも set する必要がある気がする。要確認
      ビジュアルモードの各演算子も同様である。他にもバッファ内容に変更を齎すコマンドは全て対象である。

      これは _ble_edit_str/.replace-range 及び _ble_edit_str/.delete-range を全て確認して対応した。
      _ble_edit_str.{reset,replace} は直接は触っていない。
      実のところ殆どの操作は operator の中で行っているので、変更点はそれほどなかった。

      - rx grx に関しては ble/widget/self-insert を介して挿入を行っていたので、
        これは気づきにくかった。他に self-insert を介して nmap から変更を行うものはなかった。
      - Y S D C の内、ble/widget/vi-command/kill-current-line これも見落としていた。直した。
      - x s X delete の類はオペレータを介して操作しているので対策は必要ない。
      - p P J gJ は既に直した。

    - done: operator で beg の更新はしているが end の更新はしていないという場合があるかも。要確認

      というか、そもそも中身を書き換えたりすると end は意味を成さなくなっているのではないだろうか。

      a 一つの手は operator を呼び出す前に beg - end を設定してしまうというものである。
        この時の問題点は2つある。

        x 先ず領域拡張を行って変更した場合に end が beg に落ちてしまうということ。
        x もう一つの問題は end が末端ではなく最後の文字を指していることにより、
        中身に対して変更を行った場合やはり end が beg に落ちてしまうということである。

        だとすると各 operator に対して end を正確に計算してもらうという手しかない。

        x 更に試してみて気付いたことは operator 操作後のカーソル位置と、
        operator による変更位置は必ずしも一致しないということである。
        例えば矩形選択で先頭に全角文字が跨っている状態で d で削除すると、
        全角文字は空白に置き換えられてカーソルは残った空白の後に配置される。
        一方で `[ による変更開始位置は空白の前に設置される。
        実は、既に beg は変換後のカーソルの位置を指示するために使用している。
        ということは、変更範囲を調べるためには別の方法が必要になる。

      b 或いは、変更操作の開始前に空の dirty range を用意して、
        後は shift-by-dirty-range において、その dirty range も一緒に更新する。
        更に変更操作の終了時にその dirty range を元にして mark を設定する。

        この方法を用いれば end が beg に落ちてしまう問題も発生しない。
        各 operator で操作を指定する必要もない。

        効率的には不満な点もあるかもしれないが、複雑さの度合いから言って妥当に思われる。
        或いはもっと良い効率的な方法が見つかればその方法でも良いが…。

      結局 b の方法で再度実装し直すことにする。

  * vi-mode 引数を指定した挿入モードを抜けた時の動きが変だ。 [#D0528]

    先ず初めに繰り返し回数を正しく反映できていない。
    次にカーソル位置が正しくない。
    特に、次のコマンドでカーソルが変な動きをする。

    →decompose-meta で分解される前の M-h が記録されていた。これは駄目だ。直した。

2017-10-10

  * 2017-09-08 vi-mode: gi [#D0527]

    変数 _ble_keymap_vi_insert_mark だけ用意した。

    これは本来は mark を実装してから考えるべきである → #D0526

    次に `^ の設定を実装する。

    - 先ず繰り返しを行っている場合には繰り返しを行ったあとの位置が記録される。
    - C-c で中止をした場合でも記録される。
    - C-o で入ったときは現在地に移動するだけである。つまり、C-o に入る瞬間に記録される。
    - 未だ `^ が設定されていないときは gi はその場で挿入モードになる。

  * vi-mode: mark 実装 [#D0526]

    vim で mark について振る舞いを確認した所、
    行と列をそれぞれ覚えているようだ。
    文字の挿入・削除を行っても列の修正は行われない。
    行の挿入・削除を行うとそれに応じて行は修正される。
    行が削除されると mark も消滅する。

    この振る舞いを厳密に再現する必要があるかは分からない。
    もし厳密に再現するとなると .kill-range / .delete-range に介入して、
    既存の mark について毎回複雑な計算を実行する必要があるということになる。

    また mA と ma の振る舞いの違い (履歴項目ごとのマークかグローバルなマークか)
    の実装についても考える必要がある。履歴項目ごとのマークの場合には、
    履歴項目を移動する毎に保存・復元をするかあるいは履歴番号に紐付いた記録の方法を採用しなければならない。

    a 毎回保存・復元をするとなると色々問題がある。
      先ず初めにどのタイミングで保存・復元を行うかである。

      history/goto で保存・復元を行うとすると何らかの hook の機構を用意するか、
      保存・復元の対象となる変数のリストを外部から指定できるようにする必要がある。
      しかし、何れにしてもこれは遅そうである。

      よく考えてみれば mark に触る機会というのは少ないのだから、
      いざ記録または読み出しを行おうとした段階で、
      現在の履歴項目に対応するものをロードするようにすれば良い。

    b 履歴番号に紐付いた記録の方法の場合には記録に使用する文字を制限すれば (Unicode は使わず ASCII に制限すれば)、
      "256 * 履歴番号 + 文字" のような感じの index で配列に記録すれば良い。
      実際に vim で試してみると "mあ" などはエラー (bell) になる。

      マークを大量に設定すると配列アクセスが遅くなってしまうが、
      そんなに大量のマークを設定することもないだろうからこれは気にしなくても良い。
      或いは処理の時間が気になるのであれば
      bash-4.0 以上では連想配列を用いるように実装を切り替えても良い。

    これは b の実装の方が良いだろう。

      根拠は先ず単純であること。
      また a が現実的であることは履歴項目に対するアクセスが少ないということに立脚しているが、
      もしそうならば b も同様にアクセスが少なければ問題にならない。
      a が b よりも効率的になるのは或る特定の履歴項目に対して連続で mark を大量に呼び出す
      というような場合しか無いがそのような状況は考えにくい。

    mark として使える物にはどの様なものがあるか確認しておく。

      global A-Z    m で設定可能
      local a-z     m で設定可能
      local 0-9     .viminfo で設定する?
                    最後に訪れたときのカーソル位置と思えば良さそう。
      local [ ]     m で設定可能。最後に yank した範囲
      local < >     m で設定可能。最後にビジュアルモードで選択した範囲
      local ' `     m で設定可能。最後のジャンプ前の位置
                    ジャンプリストと関係。
      local "       最後のバッファ内の位置。
      local ^       最後に挿入モードを終了した位置
      local .       最後に変更された位置

    これらの文字の分布には一貫性はない。
    格納する時のインデックスはそもそも密にする意味もないので
    128 (もしくは G0 の 96) をフルに使ってよいのではないかという気がする。

    取り敢えず mark は実装した。

    * resolved: 問題点: 現在の実装では history を load せずに幾つかコマンドを実行して行った時に問題が生じる。

      LINENO を記録するなどして対処するべきなのではないか。
      但し、LINENO が増えたからと言って history にそれらが登録されているとは限らない。
      ということは未だ load していない時の、history に登録したカウントを ble-edit の方で記録するべきではないか。

      うーん。調べてみると HISTCONTROL が設定されていない時には、
      _ble_edit_history_count をインクリメントしているが、
      HISTCONTROL が設定されているときには ignoredups などによって、
      history を実行しても実際には登録されない可能性があるということで、
      _ble_edit_history_count はクリアしている。

      history を調べてみると最新の番号は history 1 で取得することができる。
      これを呼び出すのはそんなに大変ではないので、実のところ、
      これを呼び出して番号を取得しても良いのではないかという気がする。
      と思ったら、既に存在する ble-edit/history/getindex という関数ではこれをやっている。

      1 done: 先ず、ble-edit/history/getcount 及び ble-edit/history/add を変更して、
        毎回 history 1 を実行するのではなくて変更の可能性のある操作をしたときに history 1 を実行するようにする。

        と思ってよく見たらそのような実装になっている。
        寧ろ変更があった時にキャッシュをクリアし、そして getcount における遅延評価になっている。
        寧ろ現状の実装の方が優れていた。1点、ble/util/assign を利用するように変更はした。

      2 done: ble-edit/history/getindex で得られる値を使用して、
        _ble_keymap_vi_mark_local_history を更新するように再実装する。

      という具合にすれば良い。対応した。
      しかし実際に動かすと history/goto の中で呼び出している
      _ble_edit_str.reset で shift が発生してしまいずれてしまう。
      history/goto における reset では shift が起きない様にするにはどうしたら良いか。

      似たような問題として第2のプロンプトに移行する時の reset があった。
      これについては keymap が vi_cmap である時には shift を行わないという方法で対処した。
      しかしながらもっと本質的な解決方法があるのではないかという気がする。

      取り敢えず暫定的な方法を考える。

      a 一つの方法は FUNCNAME 辺りを見て ble/history/goto がなければ良しとする方法である。
        しかしこの方法は ble/history/goto の関数名が変更されると使えなくなる。
        とはいいつつ関数名を変更する時には置換を行うだろうから、
        この関数名が変更されても問題はないように思う。

      b もう一つの方法は ble/history/goto の中で定義されている変数名として特徴的なものを使い、
        それが定義されている場合には shift を行わないというようにする。
        或いは、敢えてそのための変数名を ble/history/goto で定義するという手もある。

      c 或いは _ble_edit_str.reset 関数に、変更の理由を引数で渡すようにして、
        その理由を更に observer に伝達するという手もある。
        この方法が最も妥当な方法であるように思われる。

      上記 c の方法を用いて実装することにした。
      以前の vi_cmap かどうかの判定も渡された引数で判定する様に修正した。
      この方法で実装した所初め動いていない様な気がしたが、
      改めて試してみると動くようになった。何故かは分からないが古いもので試していたのかもしれない。

    * resolved: 問題点: 書いてみたけれどやはりこれは遅いような気がする。

      特に . < > [ ] などは常に記録されていくので使い続けて行く程に
      _ble_keymap_vi_mark_local は肥大化していき、
      文字を入力する度に全てスキャンすることになるので、重くなっていく。

      従って _ble_keymap_vi_mark_local は常に「現在の履歴項目」の情報を保持するようにして、
      更に、履歴項目を切り替える際に _ble_keymap_vi_mark_local を
      _ble_keymap_vi_mark_local_history に退避するなどの処置が必要になる。

      更に言うと各要素を line:bytes としているので、
      これを分解する為の操作も馬鹿にはならない気がする。
      別の配列にして管理するという手も考えられるがそうすると bash の実装のせいで遅くなる。
      一つの配列の偶数番目と奇数番目でそれぞれ情報を格納するという手も考えられる。
      しかし、基本的には疎な配列なのでそれも分かりにくい。

      →これは上記問題点の解決と同時に再実装した。

2017-10-09

  * bash-3.0 local -a arr=() 対策 [#D0525]

    bash-3.0 で local -a arr=() を使うと要素の単語分割がクォート除去よりも後で実行されるようだ。
    調べてみると今の所は要素に空白を含むような場合に使っていないので問題になっていないようだが、
    これについては適宜別の形式に書き換えるなどして、この書き方自体を追放するのが安全である。

    - ble.sh/check に追加した。
      実のところ、この check 用コマンドを詳細に指定すれば
      local -a name=(...) が使える箇所は増えるのであるが、
      複雑な規則になっていると人間の側が間違える可能性が大きくなるので、
      やはり一律に禁止する方が懸命であると思われる。

    - と思ったがやはり local -a arr=() を使えないのは辛いので、
      check の条件を詳しくすることで、特定の local -a arr=() についてはそのまま使えるようにした。

  * vi-mode (visual block): < > [#D0524]
    振る舞いが違う→実装した。

  * vi-mode: indent の幅を設定できるようにするべきなのでは。 [#D0523]

    8 は大きすぎるので既定で 4 にして、自分で 2 に指定するなど。
    というかこれは vi-mode 特有の設定というよりは全体の設定でもある気がする。
    全体の設定に追加することにする。
    bleopt_shell_indent などの変数名が良いだろうか。

    変更対象は vi.sh 及び vim-surround.sh の indent 関係の所にある。
    →対応した。

  * vim-surround.sh: xmap S, gS [#D0522]

    S と gS の振る舞いを調べると、S は v, C-v に対しては ys と同様に働き、
    V に対しては yS と同様に働くようだ。

    %%gS はその振る舞い (ys vs yS) を反転させた物になる。%%
    surround.vim を簡単に見てそう判断したが実際に読んでみると分からない。
    :help surround を見てみると vgS は vS と同じで、VgS は VS のインデントを行わない版で、
    <C-v>gS は末尾拡張した領域に対して囲みを適用するということの様だ。
    <C-v>gS は Vim script からは末尾拡張かどうかが分からないために必要と書かれているが、
    実は ble.sh vi-mode の枠組みでは自然にこれは対応できてしまうので
    敢えてその様に動作させる必要はなかったりする気がする。
    それでもその様に対応することにする。

    その為には先ず yS に対応しなければならない。yS は行指向の動作である。
    囲まれる文字列の前後に改行を挿入してインデントするという動作の様だ。
    因みに空白を指定すると <left><LF><SP><indent>content<LF><SP><indent><right> という感じになる。
    インデントがある場合には空白を前後に置かないのが自然なのではないかと思う。

    実装した。チェックする。

    yS は動いている。ySS も動いている。xmap S も動いている。xmap gS も動いている。
    但し、何れについても再インデントには対応していない。

    序に cS も実装したらどうか。調べてみると cs と殆ど同じで挿入するものが異なるだけだそうだ。
    これは簡単に実装できると思う。実装した。

  * vi-mode: bug: g? を set-operator rot13 にしていたが、 [#D0521]
    これは数字が入っているので使えないのでは?
    →実際にやってみたら使えなくなっていた。修正する必要がある。

    というか、これを機に _ble_edit_arg に全て入れるのを止めた方が良い気がする。
    set-operator も operator 辺りに改名する。
    _ble_edit_arg の形式で場合分けをしているが、これは kmap を以て場合分けするのが良い。
    また、本当に omap の時にしか _ble_edit_arg が存在しないのか確認する必要がある。

    →オペレータの記録の方法を作り直した。
      元々今の仕組みはオペレータの枠組みの全体を知らずに適当に作った物を騙し騙し使っていた物だった。
      今となっては一つの変数で全てを記録するのは辛いし、
      また _ble_edit_arg の形式が本体の ble/widget/ の想定するものと異なる点も良くない。
      _ble_edit_arg は空か数かのどちらかでないと都合が悪いのだ。
      作り直した。余り大きな変更もなく作り直すことができた。

  * vi-mode (normal mode): C-d で抜けても良いのでは。 [#D0520]

    そもそも vim では C-d は何に割り当てられていたのだったろうか。
    →スクロール用のコマンドの様だ。これは滅多に使わないので、
    zsh と同様に C-d でシェルを抜けるようにしても良いように思われる。

    と思ったが、よく考えたら空文字列の時にはそもそもスクロールもしようと思わないだろうから、
    空文字列の時に限り抜けるようにして、それ以外の時にはスクロールという様にすることも可能のはずである。

  * magic-space: 現状の実装では空白を入れてから展開しているが、 [#D0519]
    :s/ などが終端していない状態でこれを実行すると空白が余分についてしまう。
    →修正した。更に dirty-range も最小限になるように修正した。

  * vi-mode (insert): @norepeat [#D0518]

    実は norepeat でないコマンドは数える程しかないのだから、
    それ以外全てで norepeat を実行するように __before_command__ に書くほうが懸命なのでは。

    実装した。動いている。これにより @norepeat は改名対象ではなくて削除対象になった。
    master へ merge する直前に適用することにする。

  * vi-mode (cmap): / ? n N [#D0517]

    * C-c で抜けても実行されてしまう。キャンセルするべき。
      →これは単にバグだった。直した。

    何もないときに DEL を押したときもキャンセルにする?
    これは試してみると / や ? ではキャンセルになるが、
    surround.vim の < ではキャンセルにならない。
    実装によるということである。
    だとすると、(surround.vim で > を打つと終わりになることを含めて、)
    cmap のキーマップに介入できるようにする仕組みを整えたい。

    例えば cmap/__before_command__ で外部関数を呼び出すようにして、
    その外部関数の名前を登録できるようにしておく。
    __before_command__ で好きに処理をして、
    もし元から設定された動作をキャンセルするときには、
    COMMAND= としてしまえば良い (ble-decode.sh の側で次に実行する widget は COMMAND に入れている)。
    というかこれは WIDGET に名称を変更した方が良い気がする。
    と思ったが、-cf で通常のコマンドを呼び出すときにもこれは使っている
    更に、widget を呼び出すときも zsh の所謂 widget ではなくて、前に ble/widget/ の prefix がついている。
    やはり COMMAND で良いような気もする。と思ったが、COMMAND は他の用途にも使われるので、
    後で一括で置換したいときなどに不便である → と思ったが COMMAND という変数はこの用途でしか使っていなかった。

    - 取り敢えず COMMAND はそのまま。__before_command__ で COMMAND= を実行することでキャンセルできる。
    - シェル変数 _ble_keymap_vi_cmap_before_command で async-commandline-mode で呼び出される cmap に介入できるようにした。
    - vim-surround.sh のタグ名入力で > で確定するように修正
    - search / ? で、空文字列で  DEL or C-h することでキャンセルするように修正
    - 序に ble-bind -L で . を含む関数名を表示しないように修正


2017-10-07

  * 2017-10-01 vi-mode (visual mode): r s C S R x D X Y p J U u I A ^] [#D0516]

    done: J gJ → これは別項目 #D0540 で処理
    done: u U r s C S R X D x Y
    done: I A #D0531
    done: p P #D0536
    保留: ^] これは何処で見たものか何故か書かれていたが実際対応しなくて良い。
      b4b4r07/zsh-vimode-visual で見たかと思ったが、改めて確認したところない。

    C は char のとき一旦行指向になってから .save しているようだ。1v などとすると分かる。

    いろいろ試してわかったこと。

    - 矩形モードで C を押すと次に 1v を実行したときに末端までの拡張状態になる。
    - 矩形モードで $ を押すと末端までの拡張の状態になる。
    - 普通の移動の方法では末端までの拡張にはならない。
    - 末端までの拡張の状態で、行末にいる状態で "13|" などとして
      動かないようにしても末端までの拡張モードは解除される。
      つまり位置の移動を監視して末端までの拡張かどうかを切り替えるのではなく、
      移動に関するコマンドが実行されたかどうかで末端までの拡張かどうかが切り替わる。
    - 更に v で $ に行ってから C-v としてもちゃんと末端までの拡張になっている。
      それどころか v $ を復元するときも本の列ではなく末端になるようだ。
    - さすがに OO を押して端点を交換すると末端までの拡張は解除される。
      従って、端点毎に "末端拡張" かどうかの状態があるのではなくて、
      端点の座標とは独立に "末端拡張かどうか" という情報が記録されていると思われる。

    つまり、何か別の変数があって移動すると切り替わるようだ。


    * done: 先ず、現在末端拡張の状態かどうかを保持する変数を用意する。
    * done: 先ず extract-block の末端拡張のときの振る舞いを実装する。
    * done: それから save/restore の振る舞い。
      末端拡張が有効の時は char として $ を記録するようにする。
    * done: 移動コマンドが必ず呼び出している関数として adjust-command-mode がある。
      これに手を入れて末端拡張かどうかを弄るようにしたらどうだろうか。
    * done: また $ のコマンドを弄って xmap のときは adjust-command-mode より後に、
      _ble_keymap_vi_xmap_eol_extended=1 を設定するようにする。

    取り敢えず現状で push することにした。

  * 2017-10-01 vi-mode: 前回からの動作の修正 [#D0515]

    - vi-mode bug: 行単位のインデントオペレータ (`>>` など) でエラーが出るバグを修正
    - vi-mode bug: オペレータ `g~` を呼び出せないバグを修正
    - vi-mode bug: `k` `-` `G` `gg` などで履歴項目を移動したときに(最後の文字でなく)行末にカーソルが来るバグの修正
    - vi-mode bug: オペレータ `>` および `<` で空行が消滅するバグの修正
    - bug: "ble-bind -d" の内部でパス名展開が起こって出力が正しくないバグの修正

    - vi-mode change: `c{linewise}` (`{linewise}` = `j` `k` `H` `L` `+` `-` `gg` `G`) のとき空行を挿入するように修正
    - vi-mode change: `d` で最終行を削除したとき前の行に移動するように修正
    - vi-mode change: `f` `F` `t` `T` `r` `gr` に C-? の形式で文字を指定できるように修正
    - vi-mode change: `dd`, `yy`, etc. および `D` は最終行で 2 以上の引数を与えるとエラーにするように修正

    - vi-mode: _ g0 g<home> g^ g$ g<end> gm go g_ ge gE / ? n N :
    - vi-mode: ビジュアルモード (char, line, block)
    - vi-mode: vim-surround.sh にて囲み文字として t T < を指定したとき、タグ名の入力を受け付ける
    - edit: 複数行編集時スクロール

  * 2017-09-18 vim-surround: ds cs テキストオブジェクト [#D0514]

    - done: pst に対応する。これは本体のテキストオブジェクトを先に対応させる必要がある。
    - done: 更に t に関しては第2のプロンプトを表示できるように改修する必要がある。
      → 第2のプロンプトに対応したので対応した。

  * vi-mode: 正規表現検索 [#D0513]

    | 2016-07-07 isearch: 正規表現検索?
    |
    | incremental にするのは難しい。というのも正規表現の内容を変えると一致位置が戻ってしまうかもしれないから。
    | 例えば abc|def として検索した時に abc まで入力した時に文字列 "def" を通り越して
    | "abc" に一致したとする。すると、続いて |def を入力した時に、通り越した "def" をどの様に処理するのかという問題が生じる。
    | その正規表現に対する "直近の一致" に拘るのであれば、一旦通り越した "def" を拾う為に、再度検索を一からやりなおす必要がある。
    | 或いは、emacs の様に現在の位置から検索の続きを開始するという方法でも良いがこれは直観的でない。
    |
    | 最終的にもし incremental にするとしたら Emacs の様な方式になるだろうが、
    | 必要が生じるまでは incremental な search は提供しなくても良いだろう。
    | というかそもそも正規表現検索自体必要なのか分からない。
    |
    | 正規表現による置換などについては需要があるかもしれない。
    |
    |
    | 更に組み込みの正規表現を用いて一致を行うにしても問題がある。
    | 組み込みの正規表現では途中からの一致に対応していない。
    | 従って、文字列の部分文字列を作成する事によって途中からの一致に対応する事になるが、
    | その様にすると ^ や $ の意味が変わってしまう。そこで、途中で文字列を切った場合には何か padding の様な物を付加するとしても
    | 今度はその padding に一致してしまう事を阻止できない。
    | また %%padding の内容をどうするかによって \b や \B の意味が変わってしまう。%%
    | →これについては隣接する文字をそのまま padding として採用すれば良い。
    |   が、隣接文字に対する一致を阻止できないので、結局文字列を切らずに一致を試みるのと大差ない。
    |
    | - 因みに正規表現の一致位置を探すのはそんなに面倒ではない。正規表現の先頭に ^(.*) などと付加しておけば、
    |   ${#BASH_REMATCH[1]} が一致開始位置になる。ただキャプチャの番号が一つずつずれる事に注意すれば良い。
    |   →と思ったが、これだと .* が greedy に文字を消費してしまう。
    |     それよりは正規表現末尾に (.*)$ を付加した方が精確である。
    |     それにより開始位置は $((${#target}-${#BASH_REMATCH})) になる。
    |     キャプチャグループの番号もずれないのでこれが良い。
    |     但し、一致文字列全体の長さを得る時に $((${#BASH_REMATCH}-${#BASH_REMATCH[n]})) などとする必要がある。
    | - これを応用すれば例えば位置 14 から一致を試みたい時には、正規表現の先頭に
    |   ^(.{14}.*) などという物を付加すれば良いのではないか。
    |   しかしこれだと先に述べたのと同様に .* が greedy に文字を消費してしまう。
    |   それよりは .{14}(rex)(.*)$ 等の様にするのが良さそうだ。

    * 2017-10-07 気付いたのだが実は後方参照 \1 が使える。
      ということは rex を () で囲む為には後方参照の番号のずれも考慮にいれなければならない。
      rex を直接使うのは難しい。何故なら rex=A|B の構造になっているかもしれないから。
      なので、何れにしても .*(rex) または (rex).* などのようにしなければならない。
      そうしないと一致位置を取得するのが難しい。実際できるのか?

      もし () で囲んで後方参照の面倒も見るとすれば、更に余分に () を増やしても構わない。
      なので気にせず色々弄ることができる。

      forward に位置 14 から検索するときは

      rex=".{14}($needle)(.*)\$"

      などとする。backward に位置 len-14 から検索するときは

      rex="^(.*)($needle).{14}"

      などとすれば良い。最初または最後の .{14} は、検索対象の文字列を 13 文字削るなどすれば
      . にまで縮めることができる気がするが、
      それによって特に効率的になるとも思われないので、このままで良い。
      寧ろ検索対象の文字列を削るか削らないかなどの場合分けが面倒である。


      $needle に含まれる後方参照をシフトするためには、
      $needle を簡単に parse しなければならない。
      先頭から順に見ていく。

      '\\.|\[^?\]?(\[:[^]:]*:\]|\[\.[^].]*\.\]|\[=[^]=]*=\]|[^][])*]'

      '\\.'
      '\[^?\]?
      (
      | \[=[^]=]*=\]
      | \[\.[^].]*\.\]
      |
      |[^][])*]'


      - 試してみると [.<collating-char>.] にも対応しているようだ。
        rex='[[.a.]]' ; [[ a =~ $rex ]] # sucsses
        rex='[[.a.]]' ; [[ . =~ $rex ]] # fail

      - [[=<c>=]] にも対応している。
      - \< \> にも対応している。\b も。[[:<:]] などは対応していない。

    * 取り敢えず incremental な検索は現実的ではないが、
      通常の検索として実装するのはそんなに問題はない。

      - done: 先ず検索部分のコードは分離した。
      - done: 後方参照のシフトがちゃんと動くかを確かめる必要がある。

        動いていない。使っている正規表現が正しくないと出ている。確かめる。以下のものが使われている。
        ^(\[^?]?(\[[:][^]:]+[:]\]|\[[=][^]=]+[=]\]|\[[.][^].]+[.]\]|[^][]|\[[^]:=.])*[?\]|\\[^1-8])*\\[1-8]

        ^(\[\^?]?(\[[:][^]:]+[:]\]|\[[=][^]=]+[=]\]|\[[.][^].]+[.]\]|[^][]|\[[^]:=.])*\[?\]|\\[^1-8])*\\[1-8]

        - 一箇所直した [? は \[? であるべきだった。しかしこれは正規表現が正しくない理由にはならない。
        - どうやら \[[:][^]:]+[:]\] が駄目と言っている → と思ったら勘違いだった。
        - 分かった。 ^? ではなくて \^? としなければならない。

        取り敢えず一番簡単な場合で動くことを確かめた。
        色々動かしてみたが、恐らく大丈夫だろう。

    * vi.sh に実装してみたが色々変だ。動作確認する。

      x fixed: n で前の検索を繰り返そうとすると何も起こらない。
        →これは前の検索文字列をロードし忘れていたために空文字列で検索していた。

      x fixed: 一致位置が変だ → 正規表現一致後の範囲の計算が誤っていた。修正した。

      x fixed: 表示が崩れる。これは / ? で第2プロンプトを使用したときでもなるが、
        n N で前の一致を繰り返した時でもなる。つまり第2プロンプトは関係ない。
        更に、何れも2回目以降の一致で変なことになる。

        これは不思議だ。表示と検索機能は完全に直行しているはずなのに起こっている。
        しかも、表示位置が先に進むのではなくて逆方向に戻っている。1文字ずつ戻っている。
        つまり、何か余計な文字列が出力されているという訳ではなく、座標計算の方が怪しい。

        C-l で再描画すると直るが n で検索し直すと再度発生する。
        つまり、検索の関数の中で何か誤ったことをしている。
        もう一つの手がかりは更新される内容がずれているということである。
        region layer が怪しい。umin umax の問題か、或いは buff の繋ぎ変えに失敗しているか。

        うーん。S-left に依る移動などでも再現することが分かった。
        つまり、これは region レイヤーでの buff の繋ぎ変えが怪しい。
        しかし、改めて試してみると変な状態になっているときには S-left は不味いが、
        検索機能を使っていない限りは S-left が変なことになることはない様だ。

        search を実行することによって何かの機能が破壊されている。
        うーん。正規表現かどうかは関係なく発現するようだ。
        調べてみたら、なんと plain_buff が滅茶苦茶なことになっている。何故?
        あー。分かった。。plain_buff が textarea の復元の対象になっていないということか。

        ところがちゃんと復元リストの中には入っているようだ。
        と思ったがそもそもこの復元リストも変だ。何か重複があるし、復元しなくても良いものまで入っている。
        よく見たら ${!_ble_highlight_layer_$layer*} とするべきところが ${!_ble_highlight_layer_$name*} になっていた。
        そしたら直った。何故だろう。前のミスでは過剰に復元変数が列挙されていたのが問題だった。
        今回の修正で復元対象の変数は減少したはずなのに正しく復元できるようになったのは不思議だ。

      - done: 一致している状態で次の一致を探して失敗したとき、
        今一致している状態を保持したい。

      x fixed: 範囲がずれている。

      x 履歴後方で末端で一致したときに再一致できない
        これは行の最後の文字にカーソルがいるときに一致しないということだろうか、と思ったら違った。
        調べると .call-search の中で範囲を調整する条件がいけなかった。
        同じものに再一致することを防ぐための条件がいけなかった。

      x fixed: というか G で編集文字列の行末に移動できる

      x fixed: 履歴検索に時間がかかった後、progress が表示されたままになっている。

      x fixed: 履歴検索の progress で検索文字列が表示されていない。
        これは変数 _ble_edit_isearch_str を指定しなければならない。

      x fixed: progress の表示間隔が短いのは何故だろう。
        forward search 時に 1項目ごとに表示されている気がする。
        従来の isearch ではちゃんと期待通りに 1000 項目ごとにしか表示されていない。
        従って、コードが破壊されたとかそういうことではないはず。
        と思ったら stop_check のときにしか isearch_time を incr していなかった。修正した。

      後は空一致のときに何がおこるのかという事である。
      現在の実装では空一致のときには一致しなかったのと同じ状態になる。
      この時 n や N をしても次の空一致に移動するということが起こらない。
      というかむしろ backward に検索するときには逆方向に移動していく気がする。

      念のため vim でどういう振る舞いになるかを確認することにする。
      と思ったら vim は空一致の場合にはパターンが見つからなかったと勘違いするようである。
      もしもっと前に進めば非空な一致を見つけることができるとしても、
      途中で空一致にぶつかってしまったらそれ以上探すのをやめ、見つからなかったという扱いの様だ。
      (これは例えば h? のような正規表現で確認することができる)

      →対応した。

    * done: 次に引数に対応しなければならない。これは繰り返し一致させるというようにするしかない。

      さて、{count} 番目の一致が見つからないときの動作はどうするべきか。
      vim で試してみるとまた buffer の先頭に戻って続きを検索するので、
      1 つでも一致するのであれば、必ず一致する。

      ble.sh でどうするか。また履歴の最初に戻るというのはとても分かりにくい。
      従って、取り敢えず一番最後に一致したものということで問題ない気がする。
      そう考えれば、単に繰り返し回すだけで良いので実装としても楽だ。

      取り敢えず対応した。

    取り敢えず現在の問題点を解決したら commit する。

    x fixed: オペレータから呼び出せない → これは omap にも登録しなければならないからだった。

    x fixed: 引数を指定しようとすると一致状態が解除されてしまい、ずれる。

      →やはり matched の状態を設定・解除するのは adjust-command-mode のタイミングであるべき。
      その様に修正した。同時に他のモードに移行するなどの場合に _ble_edit_mark_active を解除する必要がある。

    x fixed: 今度は最後に一致した状態で次の一致が見つからないときに、
      一致状態が解除されてしまう問題について。
      これは新しい _ble_edit_mark_active の設定・解除にしてから起こるようになった。
      →どうやら adjust-command-mode が search.impl の中から複数回呼び出されているのが行けない。
      唯一回だけ呼び出されるように修正した。直った。


2017-10-05

  * vi-mode: dd yy ... の最終行での振る舞い [#D0512]

    行数が足りないときにはエラーになる。
    他のオペレータについても一様に同じようだ。

    % 更に D は dd と違って末尾にいても行を削除しないようだ。
    % D も行数が足りないときにはエラーになる。
    % と思ったらこれはそもそもぜんぜん異なる働きをするコマンドだった。

    D は 1 より大きい引数を指定して一行も動けないときエラー。

    実は dd や yy の場合も同様のようだ。直した。

  * vi-mode (visual mode): S [#D0511]

    何やら次の引数を読み取ろうとしている気がする。何故か。
    と思ったら、これは surround.vim の仕業だった。

  * vi-mode (visual block): 行末にいるときの範囲がずれている。 [#D0510]
    行末から右に1文字のところが境界になる。

  * vi-mode (visual): vim では | で行末に行けるようだ。 [#D0509]

  * 2017-09-12 表示レイアウト管理の方法について [#D0508]

    | これは現在問題になっている、一番下の行で info が表示されなくなってしまうこととも関連する。
    |
    | presentation : form
    |  \_ textarea : control
    |  |   \_ content : ble-edit/content
    |  |   \_ prompt : ble-edit/prompt
    |  |   \_ layout : ble/textmap 文字の配置
    |  |   \_ render : ble-edit/layout
    |  \_ info : control
    |
    | もし本格的なウィンドウシステムを実装するとしたら、
    |
    | 1 textarea は一つのコントロールとして管理するべきである。
    | 2 textarea 毎に _ble_edit_str などの content が存在するべき。
    | 3 着色の設定も textarea 毎に管理するべきだ。
    |
    | 4 全ての入力は textarea を一回経由してから処理する。
    |   というのも処理対象の _ble_edit_str を選択するため。
    |   というかそもそも keymap だって textarea に紐付いているのではないか。
    |
    |   と思ったが、これは少し違う。
    |   ウィンドウは単一で機能を持つこともあれば、
    |   一つの機能を提供するために複数のウィンドウを組み合わせることもある。
    |   現在ある info や将来実装するかもしれない補完候補のメニューなどは、
    |   固有の機能を持っているものではなくて、textarea と組み合わせて使うものである。
    |
    |   そのように考えるとウィンドウの集合と keymap は対応付けられるべきである。
    |   .NET Frameworks の類推で親ウィンドウを form と称して
    |   子ウィンドウを control と称して考えると分かりやすそうだ。
    |
    | 何か話がとんでもない方向にそれている。元々は関数名の話だった。
    |
    | これは別の話として切り離すべきだ → #D0439 から切り離した。

    #D0505, #D0507 取り敢えず ble/textarea として分離して実装し、
    第2のプロンプトを表示できるようにした。
    ble/textarea としての振る舞いを観察して、
    また需要が出てきたら control などの仕組みについては再度考え直す。

  * 2017-09-17 第二のプロンプト・編集文字列を出すということについて。 [#D0507]

    info の上で表示する様に再実装しても良いが、
    やはり似たようなコードが重複して存在するのは気になる。
    将来的にも必要になると思われるので、現状の ble-edit の仕組みを
    複数の編集文字列に対して適用できるように拡張する方が自然なのではないだろうか。

    更に info はカーソルの位置に関しては管理しない。
    カーソルの位置は現在全て本体の編集文字列の描画で設定されている。

    さて、複数の編集文字列を取り扱えるようにするには何が必要であるかを考える必要がある。

    | * 先ず初めにどの変数を差し替えれば
    |   別の編集文字列を取り扱えるようになるかを調べる必要がある。
    |
    |   それらの変数をひとまとまりとして textbox 的な概念にまとめるのが良い。
    |   もっというと、今回の第二の編集文字列を出すということに特化したものではなくて、
    |   一般に textbox としての component を独立させるとしたらどうなるかという事を意識して
    |   実装したほうが汎用的で整理された実装になる気がする。それを目指す。

    → これは ble/textarea としてまとめることにした。状態の保存・復元にも対応した。#D0505

    * 序にいうと表示の幅や高さも管理できるようにしたい。

    * 実は ble-decode の decode 状態も textbox 毎に用意するべきなのではないか。
      だとすると先ずは ble-decode について切り替える仕組みを整える必要が出てくる。

    % うーん。思ったのだが、面倒なので第二のプロンプトなどと言わずに read -e -p / で良いのでは?
    % →と思ったが bind で全て上書きしているのが祟って動かない。
    % これは read -e も再実装する必要があるということを意味する。

    [実装]

    取り敢えずは decode 状態については考えないことにする。
    textarea を切り替えると同時に keymap も変更するということにする。
    動いた。取り敢えず : を簡単に実装してみた。動く。

  * _ble_bash_loaded_in_function 条件が反転している [#D0506]

  * 2017-09-17 第二のプロンプト・編集文字列を出すということについて (1) 状態を保存・復元する仕組み [#D0505]

    1 存在する変数について整理する。

      _ble_edit_prompt=("" 0 0 0 32 0 "" "")

      ble/textmap#
        _ble_textmap_*

      ble-highlight-layer
        _ble_highlight_layer_RandomColor2_buff
        _ble_highlight_layer_RandomColor_buff
        _ble_highlight_layer__list
        _ble_highlight_layer_disabled_buff
        _ble_highlight_layer_disabled_prev
        _ble_highlight_layer_overwrite_mode_buff
        _ble_highlight_layer_overwrite_mode_index
        _ble_highlight_layer_plain_buff
        _ble_highlight_layer_region_buff
        _ble_highlight_layer_region_osel
        _ble_highlight_layer_syntax1_table
        _ble_highlight_layer_syntax2_table
        _ble_highlight_layer_syntax3_list
        _ble_highlight_layer_syntax3_table
        _ble_highlight_layer_syntax_buff

        誰も使っていない _ble_highlight_layer__buff=() は削除することにした。
        _ble_draw_trace_{brack,scorc} は関数内で定義することにした。

      % ble-edit/text/update
      %   _ble_line_text_buff=()
      %   _ble_line_text_buffName=
      %
      % ble-edit/render/*
      %
      %   _ble_line_cur=(0 0 32 0)
      %   _ble_line_scroll=
      %   _ble_line_gendx=0
      %   _ble_line_gendy=0
      %   _ble_line_dirty=-1

      ble/textarea
        _ble_textarea_buffer=()
        _ble_textarea_bufferName=
        _ble_textarea_cur=(0 0 32 0)
        _ble_textarea_scroll=
        _ble_textarea_gendx=0
        _ble_textarea_gendy=0
        _ble_textarea_invalidated=1
        _ble_textarea_cache=()

      ble-syntax
        _ble_syntax_text=
        _ble_syntax_stat=()
        _ble_syntax_nest=()
        _ble_syntax_tree=()
        _ble_syntax_attr=()

        _ble_syntax_attr_umin=-1
        _ble_syntax_attr_umax=-1
        _ble_syntax_word_umin=-1
        _ble_syntax_word_umax=-1
        これらの変数は ble-highlight-layer:syntax から参照するためにある。

        _ble_syntax_vanishing_word_umin=-1
        _ble_syntax_vanishing_word_umax=-1
        これは ble-highlight-layer:syntax/update-word-table の暫定的(?)な実装に使っている。

        _ble_syntax_dbeg=-1
        _ble_syntax_dend=-1
        これは ble-syntax/parse 解析中断をした時に復元するためにある。
        但し現在は解析の中断の対応していないので、常に -1 である。

        因みに文法を指定しているのは ble-syntax/parse 中の以下の行である。

          ctx="$CTX_CMDX"

        他の文法にも対応するためにはこの値を何らかの変数を用いて初期化する必要がある。
        例えば、_ble_syntax_lang=bash としておいて、

          ble-syntax:$_ble_syntax_lang/initialize-context

        のような関数を呼び出すと ctx に呼び出しが入るなど。

      こうして見てみるととても沢山の変数が存在している。
      これらをえいやと切り替えるのはとても大変そうだ。

    2 ble-edit/render 統合

      ble-edit/text/update は ble/textarea#update-text-buffer とすることにする。
      ble-edit/render/* は ble/textarea#render/* にする。
      ble/textmap#slice は実のところ ble/textarea#slice-text-buffer が良い。

      ble-edit/render/update-adjusted では、
        $bleopt_suppress_bash_output であっても念のためと称して
        READLINE_LINE, READLINE_POINT を設定していたが、
        何か問題になるとも思われないので、
        $bleopt_suppress_bash_output の時には適当な値を設定して抜けることにした。
        また、関数名は ble/textarea#adjust-for-bash-bind とした。

      _ble_line_dirty
        現在 _ble_textarea_dirty は -1 か空文字列かのどちらかの気がする。
        と思ったが、一応 _ble_edit_str.replace で設定はしている。
        一方で、実際に使っているのかどうかは怪しい。
        結局、_ble_edit_dirty_draw_beg と役割が重複しているので、
        _ble_textarea_dirty 改め _ble_textarea_invalidated は、
        完全再描画の要求がされたかどうかだけの状態を保持することにした。

      現在以下の変数が存在している。

      _ble_textarea_buffer=()
      _ble_textarea_bufferName
      _ble_textarea_cur=(0 0 32 0)
      _ble_textarea_scroll=
      _ble_textarea_gendx=0
      _ble_textarea_gendy=0
      _ble_textarea_invalidated=1
      _ble_textarea_cache=()

    3 切替方法について

      何処に値を保存しておくかということ。
      そのまま保存すると沢山の変数を汚すことになる。
      何処か一つの変数に保存しておいて eval するだけで復元するということにならないか。

      | a "declare -p" の出力を利用する方法
      |
      |   但し、直接使うとローカル変数に勝手になってしまったり、復元できなかったりするケースがあるので、
      |   出力は可能しなければならない。その為に以前書いた関数 ble/util/declare-print-definitions を見てみると、
      |   これは出力を整形するために awk を使っている。遅い。頻繁に呼び出せるものではない。
      |
      | 或いは、テキストボックスのフォーカスが移動するのはそんなに頻繁ではないはずだから、
      | 毎回瞬間的に切り替えるのではなく、現在フォーカスが当たっているものが常に表を占拠するようにすれば良い。
      | だとすれば多少重くても良いかもしれない。しかし重くても良いのであれば、やはり沢山の変数を汚しても良い?
      | と思ったけれど、むしろローカル変数で瞬間的にというわけではなく、まとめて退避するということから、
      | やはり一つの変数に記録する方が良い。
      |
      | さて declare や typeset を用いるとごみが入る。set だとごみが入らない。
      | と思ってマニュアルを探したが set で指定した変数だけ出力するということはできない。
      | というか declare でも引数を指定せずに呼び出すとごみは入らない。
      | declare -p のようにするとゴミが入る。typeset -p でも同様。
      | local -p とすると何も表示されない。何故?
      |
      | b ローカル変数にコピーして local する案
      |
      |   所で、local とすると現在のフレームの変数だけ出力されるようだ。
      |   最終的にはこれを使うという手もある…と思ったが、
      |   同じ変数名で local a=$a として外の値を継承できるのか? bash-3.0 で試してみると
      |
      |   - local a だと変数は空になる。
      |   - local a=$a だと外の値を持つ (bash-3.0-4.4)。
      |   - local -a a=($a) だと空になる (bash-3.1, 4.3-4.4)。外の値を持つ (bash-3.0, 3.2-4.2)。
      |
      |   最後の項目に関しては興味深い。実は同じスコープで既に local となっていても空になる。
      |   うーん。従って。一旦、別の変数にコピーして、それから改めて同名の local 変数に書き戻して、
      |   その上で local を実行するか。
      |
      |   或いは、変数名を   __to_remove___ble_edit_str などのようにして、そこにコピーして、
      |   それから local を実行してから、変数の中身の __to_remove__ を削除するか。
      |   但し、それだと変数の値に __to_remove__  が含まれているとそれが消滅する。
      |   特に、これの動作のテストのために丁度コマンドラインに同じ文字列 __to_remove__ が含まれる可能性はある。
      |   何れにしても、恣意的に構成されたコマンドラインで問題になるので一種の脆弱性になるかもしれない。
      |
      |   何れにしても、この方法だと全変数を一旦 local 変数にコピーするという操作は不可避なので、
      |   単に全変数を直接退避する方法と比べると、変数を減らすということ以外に利点がない。
      |
      | c 或いは手動で生成できるか。
      |
      |   すぐに eval できる形にするのは難しい。
      |   それに一発で eval できなくても良いのではないだろうか。
      |   そう考えると
      |
      |   aaa=(_ble_edit_str content
      |     _some_array[3] hello1 hello2 hello3
      |     _some_scalar value)
      |
      |   などの形に配列に格納するというのも手である。
      |   と思ったが、これは構築も復元もいかにも遅そうである。
      |   すぐ eval できる形に手動で整形するのは難しい。printf %q には古い bash でバグが有るし、
      |   もし printf %q を用いるとしても 文字列の結合を繰り返さなければならないことに変わりはない。
      |
      |   ただ、awk を起動するよりは速いかもしれない。
      |   (それでも長い編集文字列を扱うとこれは格段に遅くなるだろう)

      うーん。結局単一の変数にコピーするのは難しそうである。
      方法があるとすれば一旦ローカル変数にコピーしておいて、
      そこで local を実行するという方法しか現実的なものはないと思われる。

      取り敢えずは変数の集合として保存するという方法で我慢することにする。

    取り敢えず ble/textarea の状態を保存・復元する仕組みは整えた。
    見た目は動いているように見える。取りこぼしの変数はあるかもしれないが、それは後で考える。

2017-10-04

  * 2017-10-02 vi-mode (visual block): 矩形選択から text/update/position を呼び出せるようにする [#D0504]

    連続して入力をしたときには配置情報が更新されていないことがある。
    その様な場合には現在は論理列による矩形にフォールバックしているが、
    これは直感的ではないので問題になる。

    従って text/update/position を外部から呼び出せるようにして、
    配置情報が更新されていない場合にはこれを呼び出すようにする必要がある。
    しかし、現在は text/update/position の更新範囲は、
    着色の更新範囲と一緒に管理しているがために、
    text/update/position を単体で呼び出すことができない。
    更新範囲の情報を分離する必要がある。

    * 同時に _ble_line_text_* の変数名を何とかする。案を考える。

      _ble_line_text_cache_length=  -> _ble_textmap_length
      _ble_line_text_cols=80        -> _ble_textmap_cols
      _ble_line_text_cache_pos=()   -> _ble_textmap_pos
      _ble_line_text_cache_cs=()    -> _ble_textmap_glyph
      _ble_line_text_cache_ichg=()  -> _ble_textmap_ichg
      _ble_line_text_begx=0         -> _ble_textmap_begx
      _ble_line_text_begy=0         -> _ble_textmap_begy
      _ble_line_text_endx=0         -> _ble_textmap_endx
      _ble_line_text_endy=0         -> _ble_textmap_endy

      | うーん。text_layout よりも良い名前はないか。
      |
      | - 文字の配置を素直に英語にすると character arrangement になる。長い。
      |
      | - .NET では Sysmtem.Drawing.Graphics に MeasureString および MeasureCharacterRanges がある。
      |
      | - _ble_text は既に s2c などの名前空間として使用されている。
      |   従って、_ble_textbox, _ble_textarea, _ble_line を使う必要がある。
      |   _ble_line は今まで使ってきたものだが実態に合わないので変更したい。
      |   textbox だと任意の場所に任意のサイズで表示できそうな気がするのでよくない。
      |   (或いは将来的にそのような機能を実装するかもしれないが)
      |   よく考えたら現状の配置情報の計算は textbox かどうかなどとは直交する実装になっている。
      |   現に render/update でスクロール機能を実装したときも _ble_line_text 側には何も変更はなかった。
      |
      |   従って、_ble_textbox や _ble_textarea というのも微妙である。
      |   或いは、_ble_graphics_textlayout_ などにするか。
      |   短くすれば _ble_draw_textrange もしくは _ble_draw_txtlayout。
      |   うーん。もはや draw/graphics とか要らないかもしれない。
      |
      |   _ble_textlayout_ とするか。_ble_textrange_ でも良いかも。
      |   TextRange については調べてみたが色々と意味が違うような気がするのでやめる。
      |
      |   うーん。実際には glyph などの描画に関する情報も保持している。
      |   なので単に layout という訳でもないのではないか。
      |   但し着色などについての情報は持っていないので、やはり layout に近いというべきか。
      |
      | _ble_textlayout に収束しつつある。
      |
      |   少し変種を考えてみる。_ble_txtlayout, _ble_txtout, _ble_txtpos,
      |   _ble_charpos, _ble_txtarrange, _ble_txtconfiguration, _ble_txtdisposition,
      |   _ble_txtgeometry, _ble_txtgeo, _ble_txtmetric, _ble_txtmeasure,
      |   _ble_txtmap, _ble_textmap.
      |
      |   良さそうなのは、_ble_txtpos, _ble_txtmap, _ble_textpos, _ble_textmap 辺りである。
      |   取り敢えず _ble_textmap にする。

      _ble_textmap に統一した。

    * 次に _ble_textmap 用の dirty-range を新設することにする。
      現在は外部から指定した BLELINE_RANGE_UPDATE を使用している。
      これは ble-edit/render/update で設定される変数で、
      dirty-range _ble_edit_dirty_draw_* を元にしている。
      従って、_ble_edit_dirty_draw_* の複製を作れば良いのである。

      今までは外部からこれらの変更範囲について管理して、
      BLELINE_RANGE_UPDATE などの変数を介して指定できるようにしていたが、
      今回の変更のように内部で保持するようにしてしまって問題ないだろうか。

      恐らく問題ないという気がする。
      但し、これらの変数の更新はそれ専用の関数を用いて行うようにした方が良い気がする。

    * うーん。問題がある。

      | ble/textmap#update では "再描画の必要がある範囲" を POS_UMIN, POS_UMAX で返す。
      | これは別の場所に記録して置かなければならない。
      | ところが、ble/textmap#update を呼び出した後で
      | 更に文字列に更新があった場合はこの更新範囲がどうなるかは非自明だ。
      |
      | (dbeg dend dend0) のペアを用いて範囲を更新することはできるがそれで十分だろうか。
      | - umin-umax で変更範囲より前にある場合はそのままで良い。
      | - umin-umax で変更範囲より後にある場合は…その分だけ index をシフトすれば良い。
      |   もし変更範囲の長さが変わらない場合や変更範囲での違いが改行で吸収できるときは、
      |   umin-umax の変更範囲はそのままシフトするだけで良いし、
      |   もしそれで不充分であるのであれば次の ble/textmap#update でそこまで umin-umax が拡張されるはずである。
      | - 変更範囲が被っている場合には削って良い。
      |   変更範囲の領域はどうせ次の更新で再描画の対象になるだろうから。
      |
      | →_ble_edit_str の更新をする度に毎回 _ble_textmap の更新もするべきかと思ったが、
      |   ble/textmap#update を呼び出したときに、蓄積した dirty-range を用いて
      |   _ble_textmap_u{min,max} を shift して更新すれば良いのだと気付いた。
      |   _ble_textmap_u{min,max} で公開するのであれば飽くまで最後の配置計算の際の更新必要範囲で良いのだ。

      配置情報に関連する umin,umax は独自に管理し、
      _ble_textmap_umin, _ble_textmap_umax に蓄積することにした。
      これは修正した。OK

    * ble/textmap#update のインターフェイスに疑問が生じてきた。

      外から呼び出す時にグローバル変数と密結合にならないように、
      text BLELINE_DIRTY_RANGE POS_UMIN POS_UMAX などの変数を介して呼び出すようにしてきた。
      しかしながら現在の実装では不可避的に _ble_textmap_* という内部状態を持つので、
      完全に外部から自由に取り扱うためには _ble_textmap_* の変数を宣言して呼び出す必要があった。

      一方で、今回の書き換えによって BLELINE_DIRTY_RANGE やら POS_UMIN POS_UMAX などの変数も全て、
      _ble_textmap_* で管理するようにした。これは順当な書き換えである。
      現在残っている変数は text x y である。
      一方でこの text というのはそれまでに渡した _ble_textmap_d* と符合するものでなければならない。
      ここで _ble_textmap_d* と独立に渡せるようになっているのは不自然である。
      それよりは寧ろ update-dirty-range を呼び出すときに一緒に text も指定する方が自然である。
      しかしそれはそれでデータが巨大になってくると無駄な気がする。
      やはり text というローカル変数で再計算の時に受け渡しするというのが良いのだろうか。

      だとすると ble/textmap#update を呼び出す側で現在どのような目的で textmap#update を呼び出すのか
      ということを承知で行わなければならない。ということは簡易な ble/textmap#update-auto 的な関数で、
      local text=$_ble_edit_str x=... y=... して呼び出すのは変だということになる。
      或いは、これは widget として提供するべきか。

    * さてここまでの書き換えによって ble/textmap#is-up-to-date でなくても、
      ble/widget/.update-textmap を呼び出せば最新状態になるということになった筈だ。
      しかし本当にちゃんと動作するのかについては謎だ。確認方法がない…。

      一つのテスト方法は _ble_edit_str.replace の中で毎回 ble/widget/.update-textmap を呼び出すことだ。
      とても遅くなるが取り敢えず動作することを確認する上ではこれで良いだろうという気がする。
      →遅いが、何事もなく動作した。本当にこれで大丈夫なのだろうか…。
        分からないが取り敢えず暫く動かしてみることにする。

  * vi-mode: ge gE [#D0503]

    簡単かと思ったらちょっとよく分からなくなった。

    - 先ずカーソルが単語の中に載っているときは前の単語の末端に行く
    - 実は [[:alnum:]]+ と [^[:space:][:alnum:]]+ の間も単語の境になりうる。
    - 実は二重改行にも止まる
    - それ以上後ろに進めないときはバッファの初めに行く

    % 要件 1 を満たすようにするためには以下をすれば良い。
    %
    %   ${str::ind+1} =~ (wb+w*){0,arg}$
    %
    % 但し、w が単語を構成する文字で b がそれ以外の文字である。
    % 問題は空行である。Bash 正規表現には当然前方先読みなどは存在しない。
    % 従って、これを用いない形式に変換する必要がある。
    % 用いない形式で初めから考えようとしたがよく分からなくなった。
    %
    % % 仕方がないので、取り敢えず用いる形で書いてみることにする。
    % %
    % %   ((w|(?<=n)n)(b|(?<!n)n)+w*){0,arg}
    % %
    % % 但し n が改行を表す。さて、(b|(?<!n)n)+ は、
    % %
    % %   (b|(?<!n)n)(b*|(?<!n)n)*
    % %
    % %   b(b+n)*b* | bn(b+n)*b* | (?<!n)n(b+n)*b*
    % %
    % %   (bn?|(?<!n)n)(b+n)*b*
    % %
    % % と変形される。一方で (?<=n)n は苦しい。というか1文字戻り読みしないときつい。
    % % 繰り返しになるとどうすれば良いのだろうか。
    % %
    % % % 前回の最後は (bn?|(?<!n)n)(b+n)*b*w* と分かっている。
    % % % これを最後が n のものとそれ以外のものに分類できれば良い。
    % % % 最後が n のものは以下の形をしている。
    % % %
    % % %   (bn?|(?<!n)n)(b+n)+ | (bn|(?<!n)n)
    % % %
    % % % 最後が n 以外のものは以下の形をしている。
    % % %
    % % %   (bn?|(?<!n)n)(b+n)*b*w+ |
    % % %   (bn?|(?<!n)n)(b+n)*b+ |
    % % %   b
    % % %
    % % % と思ったが、これは使わない気がする。
    % %
    % % あと思ったのは、さきに (?<!n) を消去した方が良い。
    % % 改めて
    % %
    % %   (w|(?<=n)n)(b|(?<!n)n)+w*
    % %   = (w|(?<=n)n)(bn?|(?<!n)n)(b+n)*b*w*
    % %   = (wbn?|wn|(?<=n)nbn?)(b+n)*b*w*
    % %   = (w(b|b?n)|(?<=n)nbn?)(b+n)*b*w*
    % %
    % % これに後ろから (?<=n) をかけるとどうなるか。
    % %
    % %   (w(b|b?n)|(?<=n)nbn?)(b+n)*b*w* (?<=n)
    % %   = (w(b|b?n)|(?<=n)nbn?)(b+n)+ | (wb?n|(?<=n)nbn)
    % %   = (?<=n) nbn? (b+n)+ | (?<=n) nbn
    % %     | w(b|b?n)(b+n)+ | wb?n
    % %   = (?<=n)(nb)(n? (b+n)+ | n)
    % %     | w(b|b?n)(b+n)+ | wb?n
    % %
    % % 何かおかしい。二重改行の後には空白は必要ないはずだ。
    %
    % 初めの時点で間違えている。修正する。
    %
    %   (w (b|(?<!n)n)+w* |(?<=n)n (b|(?<!n)n)*w*){0,arg}
    %   :
    %   : w(b|(?<!n)n)+w*
    %   : = w(b|b?n)(b+n)*b*w*
    %   :
    %   : (?<=n)n (b|(?<!n)n)*w*
    %   : = (?<=n) n(b+n)*b*w*
    %   :
    %   = ((?<=n) n | w(b|b?n)) (b+n)*b*w*
    %
    % うーん。これを見るに変換は厳しい。
    % (?<=n) は前のループの最後の文字を見るが、
    % n 自身がそれになっている。うーん。よく分からない。
    %
    % 取り敢えず後ろから (?<=n) をかけてみる。
    %
    %   ((?<=n) n | w(b|b?n)) (b+n)*b*w* (?<=n)
    %   = ((?<=n) n | w(b|b?n)) (b+n)+
    %     | ((?<=n) n | wb?n)
    %   = (?<=n) n (b+n)+ | w(b|b?n) (b+n)+
    %     | (?<=n) n | wb?n
    %   = (?<=n) n (b+n)* | wb (b+n)+ | wb?n (b+n)*
    %   = (?<=n) (nb+)* n | wb b+(nb+)*n | wb? (nb+)*n
    %   = ((?<=n) | wbb+ | wb?) (nb+)*n
    %   = ((?<=n) | wb*) (nb+)*n
    %
    % 或いは、後ろから (?<!n) をかけてみる。
    %
    %   ((?<=n) n | w(b|b?n)) (b+n)*b*w* (?<!n)
    %   = ((?<=n) n | w(b|b?n)) (b+n)*b*w+
    %     | ((?<=n) n | w(b|b?n)) (b+n)*b+ | wb
    %   = (?<=n) n (b+n)*(b*w+ | b+)
    %     | w(b|b?n) (b+n)*(b*w+ | b+) | wb
    %   = (?<=n) (nb+)*n (b*w+ | b+)
    %     | w(b|b?n) (b+n)*b*w+
    %     | wn b+(nb+)*
    %     | wb nb+(nb+)*
    %     | wb b+(nb+)*
    %     | wb
    %   = (?<=n) (nb+)*n (b*w+ | b+)
    %     | w(b|b?n) (b+n)*b*w+
    %     | wn? b+(nb+)*
    %
    %     w(b|b?n) (b+n)*b*w+
    %     = wb    b* w+
    %       | wbb+ (nb+)*n b* w+
    %       | wb   (nb+)*n b* w+
    %       | w    (nb+)*n b* w+
    %     = wb+ w+ | wb* (nb+)*n b* w+
    %     = w (b+ | b* (nb+)*n b*) w+
    %     = w (b|b*(nb+)*n) b*w+
    %
    %
    % % やはり駄目だ。一つの希望は (?<=n) の部分と最後の文字に対する要件を分離できれば、
    % % (つまり "((?<=n) ... | ...) (1文字以上)" の形になれば順番を反転させることができたが、
    % % 今回の場合については2の累乗でパターンが増えるので駄目の気がする。)
    % % 正規表現ではやはり不可能と結論付けるべき気がする。
    %
    % しかしやはり変だ。やはり、明らかに DFA なのでそれに対応する正規表現があるはずだ。
    % と思ったが、問題は個数を {0,arg} で制限していることになる気がする。
    % これの所為で実質的に状態を数え上げなければならない。
    % これに対応して大体 2 * (arg+1) の状態が生まれる。
    % しかしそれでも有限個である。うーん。
    %
    % また、思うにもし無限個だったとしたら OK なら、
    % 無限個だったときの正規表現をまずは考えるべきなのでは。
    % うーん。今回の場合は NFA になって、更に面倒なことになりそうだ。
    %
    %   (?<=n) (nb+)*n                             (?<=n)
    %   any    wb* (nb+)*n                         (?<=n)
    %   (?<=n) (nb+)*n (b*w+ | b+)                 (?<!n)
    %   any    w (b|b*(nb+)*n) b*w+ | wn? b+(nb+)* (?<!n)
    %
    % とここで気付いたが w には二種類あって wW の境目には空白がなくても良い。
    % また完全に考え直しになった気がする…。

    うーん。結局単語の種類があるとなると単語を左右に分割するわけには行かない。
    つまり、単語はやはり1単位として読み取るしかない。
    やはり、今までの実装と同じように厳密な正規表現の実装は諦めて、
    貪欲な一致で初めに一致するものが正しくなるように構成するしかない
    (或いは方法もあるかもしれないが人の手には負えない程複雑になりそうな気がする)。

    取り敢えず後方に単語を探索することにする。

    :w[nb]* 但し二重改行は含まない (:w は単語の正規表現とする)
    = :wb*(n(b+n)*b*)?
    = :wn?(b+n)*b*

    (?<!n)n [nb]* 但し二重改行は含まない
    = (?<!n) n(b+n)*b*

    常に最長一致するようにしていれば前の単語が終了するのは、
    二重改行のあとか次の :w が始まるところだけのはずである。
    従って、これで問題ないはず。

    (:wn?|n) (b+n)*b*

    但し、一番最初の一致点を制限する方法が必要である。
    特に一番最初を二重改行以外とする場合にはどうするのか。。
    うーん。結局 backward-word で使われている正規表現と同じものになるのか…。

      (:wn?|b+n?|n) (b+n)*b*
      = (:wn?|n) (b+n)*b*
        | b+ (b+n)*b*
        | b+n (b+n)*b*
      = :wn? (b+n)*b*
        | n (b+n)*b*
        | b (b+n)*b*
        | b+n (b+n)*b*

    しかし、これの問題点は arg 回一致したのかそれ未満で終わったのかが分からないということである。
    うーん。文字列先頭でのεを許して {0,arg} から　{arg} に変えてはどうだろう。

      ((:wn?|b+n?|n) (b+n)*b* | ^)
      = (:wn?|b*n?|n|^) (b+n)*b*

    もっというと b+n が親として現れるのは文字列先頭のみである。

      = (:wn?|n|^(b+n|b+)?) (b+n)*b*
      = (:wn?|n|^((b+n)?|b*)) (b+n)*b*
      = (:wn?|n|^) (b+n)*b*

    うーん。こうしておいて一番初めの一致だけを切り出しておけばよいか。
    本当にこれで問題ないか? 本当に一番はじめの一致が空になるのだろうか。
    というのも数が足りない場合にはどういうことになるかというと、

      [[ abcd =~ ((:wn?|n|^) (b+n)*b*){4}$ ]] → (a)(b)(c)(d)

    ということも可能だからである。繰り返し回数の少ないものから順に一致するというようにすればOK?
    そうすればできるだけ少ない数で一致するようにできる。

      [[ abcd =~ ((^|:wn?|n) (b+n)*b*){4}$ ]] → ()()()(abcd)

  * 2017-10-03 vi-mode (visual block): 行折り返しがあるときの着色がおかしい。 [#D0502]

    振る舞いは正しい。一度折り返しがあると、
    その後で画面を大きくして折り返しを解消しても振る舞いはおかしい。

    そもそも sub_ranges は正しく計算されているのだろうか。
    振る舞いが正しいので sub_ranges 自体は問題がなくて、
    それよりは着色の方の問題のような気がするのだが、確認はしておく。
    やはり sub_ranges 周りは問題ないようだ。
    というより計算結果の _ble_highlight_layer_region_buff の中身まで問題ない。

    これは ble-highlight-layer:region/getg を複数の範囲に対応していないのが問題だった。
    対応した。同時に中の処理も整理した。

2017-10-03

  * vi-mode (visual): 前回のビジュアルモードの復元について [#D0501]

    | 2017-09-17
    | * ビジュアルモードに入る時の動作を調べる。
    |
    |   v, V, C-v はそれぞれ charwise-visual-mode, linewise-visual-mode,
    |   blockwise-visual-mode と名前をつけることにする。
    |
    |   引数を指定したときは v V C-v は何れも同じ動作になる気がする。
    |
    |   前回のビジュアルモードが v/V/C-v の別も含めて記録されている。
    |   但し、C-c などで終わったビジュアルモードは記録されていない。
    |
    |   - blockwise-visual-mode は行と列をそれぞれ別々に記録している。
    |   - 実は v で記録したときも行と列が別々に記録されている。
    |     異なる行に移動するときには列は相対値ではなくて固定値で解釈される。
    |     引数の倍率は行だけにかかる。起点の次の行に終点があるとき行数は 2 と解釈され、
    |     引数の倍率はこれに乗算される。
    |   - V を記録したときには恐らく列の情報は使用されない。
    |     復元するときも列は復元されず、ただ j で行を移動しているように見える。
    |   - 負の方向に選択したかどうかは記録されていない。
    |     つまり、常に現在位置を左上の基点として復元される。
    |
    |   オペレータを指定した場合はどうなるかと yv などを試すと、
    |   どうも全然違う機能が呼び出されているような気がするが一体何かは分からない。
    |   何れにしても v は omap ではなくて nmap に追加されるということ。

    取り敢えず現状で簡単に実装してみることにする。

    複数行に跨っているときの相対位置は表示位置の
    y*cols+x による比較で問題ないように見える。
    行末に行送りの全角文字がある場合でも表示位置に依る差である。

    実装した。

  * 2017-10-02 vi-mode (visual block): 貼り付け時に貼り付け先にあるタブは空白に変換されるようだ。 [#D0500]

    | 2017-10-02 タブも機械的に押し出されるのか?

  * bash-3.0: up down が bind できていない。 [#D0499]

    - うーん。手で bind するとちゃんと bind できている。
    - ble_bind_keymap=vi_insert を通して keymap を指定した場合もできている。

    だとすると dump 結果がおかしくて駄目なのだろうか。

    - ble-bind -d で出力するとちゃんと登録されているのが確認できる。
    - ble-decode/keymap/dump vi_insert で見てみると登録されている。
      と思ったが複数の異なる特殊キーで登録されている。変だ。
      改めて ble-bind -d で確認してみると f4 に何故か割り当てられている。
      更に f1 - f5 に本来別のキーに割り当てられるべきものが登録されている。

    一つの可能性は keymap を生成したときの kcode と現在の kcode がずれているということである。
    しかし vi.sh は頻繁に更新している一方で kcode はそんなに変更していないので、
    これは余り考えにくい → と思って vi.sh を touch してみたら直ってしまった。
    一体何だったのだろう。これはもしかすると先に直した ble-bind -d の問題?
    でも同関係してくるのか謎。

    或いはキャッシュからキーマップを読み取ると駄目ということなのかもしれない。
    と思って再度 bash-3.0 を起動して試してみたが問題は再現しない。
    確かに、新しくキーマップを生成してはいないのでキャッシュから読み取っているはずである。
    結局問題はよく分からず消滅したようだ。

    先程までは何度再起動しても問題だった一方で、
    今は再起動しても何も問題は起こらないので何かの拍子で直ったと考えて問題ないだろう。

  * ble-decode: bug [#D0498]

    vi_digraph の binding でグロブ展開が起こっている。
    と思ったら、ble-bind -d の表示するときのバグだった。直した。

  * vi-mode: ble/string#split arr $'\n' "$text" などが用いられているが、 [#D0497]
    これらは非空行について処理したい場合は良いが、
    行の数を保持したい場合には使えない。

    改行で分割するための特別な関数を用意する必要がある。
    改行で分割する良い方法はあるだろうか。

    a 一つの方法は改行を一旦別の文字 @ に置き換えてから処理する方法である。
      しかしこれだとその文字 @ について事前に escape しなければならない。
      しかし \@ のようにエスケープしても意味が無いので、完全に別の文字に置き換える必要がある。
      つまり、\ → \A, @ → \B, 改行 → @ としてから分割を実行する。
      その後で、\A → @, \B → \ というように元に戻する必要がある。
      @ が含まれていない場合には幾らか工程をスキップすることができるが、
      面倒な方法であることに変わりはない。

    b 或いは正規表現などを用いて手で刻んでいく方法である。
      これの欠点は大量の行が存在するときに遅くなってしまうということである。

    c もう一つの方法は mapfile <<< $text を用いるというものである。
      これは古い bash では使えないので実装の切り替えが必要になる。

    bash の version に応じて c または a ということになるだろうか。
    取り敢えず今の所は ble/string#split arr $'\n' を用いて実装する。

    というか、調べてみると例え空白類で分割していなかったとしても、
    ble/string#split では、末尾にある sep は無視されるようだ。
    但し、数が一定している場合には特に問題にはならない。
    更に、最後の sep 一個だけが無視されるようなので、
    手で初めから最後に sep を追加しておけば問題ない。
    →実装した。期待通りの動作になった。

    更に改行で区切る関数も実装する。

    split1.measure (改行を別文字に置換してから)
      time 242.40 usec/eval
      time 728.20 usec/eval (分割に用いる文字が重複しているとき)
    split2.measure (正規表現で切り出す)
      time 1502.40 usec/eval
    split3.measure (mapfile を用いる)
      time 135.40 usec/eval
    split4.measure (グロブで切り出す)
      time 895.40 usec/eval

    取り敢えず mapfile を用いて正しく実装でき、さらに速い。
    bash-4.0 以上では mapfile を用い、それ未満では別文字に置換してから split する方法で実装した。

  * 2017-10-02 vi-mode (visual block): 矩形選択が遅い。 [#D0496]

    行が増えてくるとやはり遅い。

    * get-index-at の最適化?

      get-index-at は二分探索を行っているが、
      この範囲を最初から行内に制限する方が良い。

      更に、get-index-at を観察して気づいたが、
      getxy.cur を使用している。一方で、
      現在の矩形範囲の実装は getxy.out を用いている想定で行っていた。
      この辺りの動作の違いがどのような影響を受けるか再度考える必要がある。
      →実は大した影響はない? ような気がする。
        が、それでも getxy.out を用いる方が速いのでそちらを使うものを用意する方が良い。

      更に、思うことは get-index-at を実行した時点で、
      それが厳密一致かそれとも前方に戻ったかは分かるし、
      更にいうと隣接する次の文字の位置も分かるはず。
      これらを全て一挙に取得する generic な get-index-at があっても良い気がする。

      ※同様の探索を paste.impl でも実施している。
      他にも色々あるのではないか。

    ble-edit/text/hit という関数を用意した。配列アクセスが遅くならないように、
    内部では配列として _ble_line_text_cache_pos しか触らないようにした。

    さらにこれを利用して extract-graphical-block を再実装する。

    % 実装の都合で vim の不自然な動作の再現は諦めた。つまり、
    %
    % |1234567>|
    % |あ89ab$ |
    % |stuvwxyz|
    % |lmnop$  |
    %
    % において C-v で 8 から z を選んで y すると、
    %
    % | あ8|
    % |zlmn|
    %
    % になる。vim では "あ" の前に空白は付加されず、ずれる。

    やはりこの振る舞いは関係ない?
    現状の実装では全て out で計算しているので、
    > の位置から文字があると勘違いする。
    従って、切り取られる内容で左側に空白は付加されない。
    ということは、新しい実装でも左側に空白は入らないはずである。

    実際に試してみるとそもそも色々表示がおかしい。
    これは表示のバグなのかそれとも範囲切り出しのバグなのか。
    →これは折り返しがあるときの座標計算のずれが悪い気がする。
      一度折り返しを作って、その後で画面のサイズを変更すると変なことになった。
      特にサイズに変更のあった文字が絡んだ時に文字の幅と座標の幅がずれているのだと思う。
    →これは別項目で対策する #D0502

    どうも表示が悪いだけの気がするので、先に振る舞いを確認してから、
    表示に関しては後で処置することにする。

    x done: 先ず矩形の左端について。行送りがあるときに行送り前の位置からになっている。
      これは vim の振る舞いと異なる。修正した。
    o 行送りされた文字が消滅するとき、行送りの分だけ空白が残るという動作は正しい。
    o 切り取られる内容について、行送りに代わる空白は補填されないという振る舞いも一致している。
    o 現状の実装だと行送りされた文字が被っていないのに空白に変換されてしまうという問題 (以下)
      があるのではないかと思ったが、vim で試してみた所全く同じ動作だったので気にしないことにする。

      |abcd>| → (c から i までの矩形) d → |ab  x|
      |あx  |                               |efjkl|
      |efghi|
      |jkl  |

    多分、特別に変な処置はしなくても現状の実装のままで vim の動作と区別がつかない気がする。

    改めて速度について確認してみる。やはり遅い。が、以前よりはましになった気がする。
    (もしかして extract-graphical-block 単体が律速しているわけではないのかもしれない。)

  * 2017-10-01 vi-mode: 最終行で dd としたらその行を消して一つ上の行へ移動する [#D0495]

    引数を指定して一番下の行まで全て削除する場合も同様
    dj で一番最後の行まで消すときも同様。
    これは operator:d (type=line) を修正する。

  * 2017-10-02 vi-mode (block): 貼り付け時に全角文字が邪魔な時はどうなるのだろう。 [#D0494]

    | aa → ahelloa
    | あ     helloあ

    空白が補填されて邪魔だった全角文字は右に押し出されるようだ。

    ここで当初の計画の矩形選択の貼り付けには対応することにする。

    | 2017-09-17
    |
    | * C-v の矩形選択について。どの様な範囲が選択されるのだろうか。
    |
    |   - 先ず全角文字の幅は考慮される。つまり見た目の幅で矩形になるように選択される。
    |     また、一部でも全角文字にかかればその全角文字は範囲に含まれる。
    |     開始点と同じ列かより右側の全角文字の上にカーソルがある場合は、
    |     その全角文字の終端までを矩形の右端とする。
    |   - 次に行折り返しになっている場合は、論理行での矩形選択になる。
    |
    |   矩形選択のときのオペレータの動作はどうなるだろうか。
    |   これは kill-range, delete-range, copy-range 辺りを修正すれば簡単かもしれない。
    |
    |   矩形選択のときの表示はどうすれば良いか。
    |   実のところ、全体を反転表示している場合との違いは、
    |   途中に着色されない部分があるということだけなのではないか。
    |   だとすれば着色の処理はそんなに難しくないのでは。
    |
    |   →と思ったが左下から初めて右上に進んだ場合や、
    |   右上から初めて左下に進んだ場合には、
    |   _ble_edit_ind, _ble_edit_mark の範囲外に着色がはみ出るのではないか。
    |
    |   a これに対応するためには着色範囲の決定に直接 _ble_edit_ind, _ble_edit_mark を用いるのではなく、
    |     それを修正した値を用いるようにするという手がある。
    |
    |   b 或いは別の方法として _ble_edit_ind, _ble_edit_mark を移動する毎に補正するという手もある。
    |     ただこれだと現在のカーソルの位置が正しくないことになるので、
    |     (overwrite mode でやっているように) カーソルを消して代替表現を使う必要がある。
    |     更に移動コマンド全てについてこの調整を呼び出すようにしなければならない
    |     (これは __after_command__ でできるかもしれない)。
    |     この方法は汚い上に色々辻褄を合わせるのが大変そうなので、良い方法ではない。
    |
    |   後、各オペレータを矩形選択に対応させる必要がある。
    |   更に paste の際に矩形選択されたものがどう貼り付けられるのかも調べる。

    [動作確認]

    貼り付けを実装した。取り敢えず動くことをみた。
    これから細かく動作確認する。

    o fill が働くか。
    o 行末では fill は入らない。
    o 中途半端な全角文字は空白になって貼り付けられる。右端も左端もOK

2017-10-02

  * 2017-10-01 vi-mode (visual mode): ビジュアルモードでオペレータに引数を指定したときはどういう動作なのだろう。 [#D0493]

    少なくとも v で試してみた所は引数を指定しても何も効果はないようである。
    もし引数に意味があるのであれば ble/widget/vi-command/set-operator を書き換える必要がある。

    うーん。3> とすると 3 回インデントを深くするという動作が例示されている。
    これは同じ範囲に対して > を 3 回呼び出していると解釈できる。
    だとすれば y や d や c も繰り返しされているということなのだろうか。
    うーん。試しに 2~ を実行してみると小文字から大文字になったので、
    ただ愚直に繰り返されるわけではないようだ。
    或いは、寧ろオペレータに対する "引数" のようなものが指定されると考えるべきか。

    オペレータに第4引数を渡して、それを繰り返し回数か何かとして取り扱ってもらう。
    取り敢えずオペレータに引数を渡すようにした。
    更に < > についてはインデントの幅を指定するものとして処理するようにした。
    現状で対応している他のオペレータ (y d c u U ~ ?) については全て引数は無視するようである。

  * vi-mode: 履歴項目を移動したときのモードおよびモード表示 [#D0492]

    - done: ノーマルモードは保持するべき。但しカーソル位置の補正が必要になる。

      履歴の移動は .history-relative-line で起こる。修正した。

      履歴検索をする時も常に気にする必要がある。
      →現在は履歴検索はノーマルモードから呼び出せないので関係ない。
      (逆に言えば将来的に対応する場合には注意が必要ということになるが。)

    - ok: 挿入モードは保持するべき

    - ok: オペレータ待機モードは解除されるはず

    - resolved: ビジュアルモード・選択モードは解除するべき
      現状では解除されずに変なことになる。
      というか履歴移動が起こるようなコマンドを登録しているのが悪い。
      初めから履歴移動が起こらないようになっていれば解除だのを考えなくて良い。

      →これは forward-line, backward-line において、
        _ble_decode_key__kmap=vi_command の時にのみ、
        履歴項目の移動をするように変更することで対処する。変更した。
        他にも .history-relative-line を呼び出している箇所を修正した。

  * 2017-10-01 vi-mode (visual mode): 範囲の表示 [#D0491]

    * done: _ble_edit_mark_active=line, block の時の着色。
    * done: 範囲の表示 charwise であったとしても右に 1 文字拡大しなければならない。

    色々試したが、どうも範囲の表示と矩形領域の決定を独立に計算するのはよくない。
    ということなので矩形範囲の計算方法をここで調査する。

    | ★矩形選択の実装でよく分からない動作を発見した。以下の様に入力しておいて
    |
    | | あa
    | | aaa
    | | aあ
    |
    | 1 行目の行頭で C-v して jj とすると、以下が選択(ハイライト)される。
    |
    | あ
    | aa
    | aあ
    |
    | この状態で y として適当なところに移動して p をすると
    |
    | あ
    | aa
    | a
    |
    | が貼り付けられる。もう少し幅のあるもので試してみる。
    |
    | あいうえお
    | aaaaaあaaa
    | aaaaaaせそ
    |
    | これにおいて、選択範囲と貼付け結果は以下のようになる。
    |
    | | あいう      あいう
    | | aaaaaあ  → aaaaa
    | | aaaaaa      aaaaaa
    |
    | |  えお    えお
    | | あaaa →  aaa
    | |  せそ    せそ
    |
    | と思ったら、中途半端になっている文字に関しては空白で埋められている様である。
    |
    | ★更に試すと
    |
    | | あ
    | | a
    |
    | 上に対して 1 行目の先頭から C-v jly とすると、p で以下が貼り付けられる。
    |
    | | あ
    | | a
    |
    | "つまり始点・終点のうちより右にあるものの右端" が矩形の右端になるのではなく、
    | "始点の右端・終点の右端のうちより右にあるもの" あ矩形の右端になるのだと思われる。
    | しかしながら a の後に空白が入るのは行の途中に挿入されたとき、
    | 続きに別の文字がある場合に限られるようである。
    | 先程との違いはそこに実際に文字があるかどうかである。
    | 先程は "あ" という文字が中途半端に切り出されて空白になっていた。
    | 一方で、今回は元々そこに文字がなくて空白で埋められていた。
    |
    | ★貼り付け時または読み取り時にタブは
    | 空白に変換するべきなのではと思ったが、
    | 実際に試してみるとタブはそのまま切り取られそのまま貼り付けられるようだ。
    | 従って、タブが含まれている場合は貼り付けの時に幅はばらばらになる。

    分かったこと。

    - 矩形の左端としては 始点・終点 のうちより左にあるものが選ばれる。
    - 矩形の右端としては 始点・終点 の右端のうちより右にあるものが選ばれる。
      (左端がより右にあるものの右端というわけではない。)
    - 中途半端な位置にある全角文字は空白に置き換えられる。
    - 貼り付け時には幅を合わせるように空白が追加される。
    - タブに対して "幅を保持するように空白に変換する" などの操作は特に行われない。

    折り返しになっているときの動作はどうだろう。
    特に行末に全角文字が入り切らずに文字送りされた場合。
    試してみた所、

    - 表示の行での矩形ではなくて論理行での矩形である。
    - ただし、列は文字の幅の勘定ではなくて行頭からの相対表示位置に従って列が決定される。
      (これは特に行末に入り切らない全角文字が合って文字送りされたときに違いが出る。)
    - この状態で切り取って、貼り付けを行うと以下のように挿入される。

      *hello heあlo*
      *hello hello h*

      つまり、貼り付け時に矩形になるようにする調整は切り取り時の表示幅
      で計算されていて、貼り付け時の表示幅で計算されるわけではない。

    - 更に末尾の空行もちゃんと記録される。

    矩形範囲の各断片の決定のときに計算するべきことは何か。以下を計算すれば良い。

    1 各断片について
      1 開始位置と終了位置 (これは範囲表示用なので中途半端な全角を含む)
      2 切り取る場合の文字列 (中途半端な全角は空白に変換)
      3 貼り付け時に矩形になるようにするために必要な空白の数
    2 最初の非空白断片の番号・最後の非空白断片の番号
      (これは範囲表示用である。もしかすると直接 rmin, rmax でも良いかも)

    * 切り取り時に境界の上に載っている全角文字があるとき、
      境界の外に出ている部分に関しては空白に置き換えられる。
      その全角文字が行送りされているとき、
      行送りの幅についても空白に置き換えられる。

      例えば以下は C-v で "o" から "x" を切り取ったときの変化である。
      元々行送りマーク ">" のあったところに空白が付加される。

      |.....>|    |..... |
      |あxyz$| -> | yz$  |
      |....he|    |....he|
      |lopqr$|    |lqr$  |

2017-10-01

  * vi-mode (visual mode): ビジュアルモードの間の切り替え [#D0490]

    visual mode で v とすると visual mode を抜ける。
    この時、抜けた瞬間の状態は記録されるのだろうか。
    試してみた所記録されなかった。つまり、キャンセルに相当する。

  * vi-mode: ビジュアルモード 第一実装 [#D0489]

    そもそもビジュアルモードと選択モードの違いは何なのか。

    zsh の vivis の実装を見れば最低限の雰囲気は分かるかもしれない。

    _ble_edit_mark_active で区別する?

    例えば単に _ble_edit_mark _ble_edit_mark_active を指定して、
    少数のコマンドにおいて kill ring に何かを設定するように改修すれば良かったりしないだろうか。

    取り敢えず初めて visual mode を使ってみることにする。
    オペレータを入力するとその場で現在の範囲を確定させるようだ。

    * ビジュアルモードを抜けるのはどの時か確認する必要がある。

      - done: 先ずオペレータを実行した時。
      - v V C-v などを指定したときは別のビジュアルモードに切り替わったり今のビジュアルモードを抜けたりする。
        これは別項目を立てて処理することにする。 #D0490
      - done: C-c をすると現在のビジュアルモードをそのまま抜ける

      C-o v として入った後に抜ける時、
      - done: オペレータを実行する場合には元の挿入モードに戻る。
      - done: C-[, ESC をすると元の挿入モードに戻る。
        "前回のビジュアルモードの情報" は記録しない。
      - done: C-c をすると全て忘れてノーマルモードになる。
        この時、当然、カーソル位置の行末補正は起こる。
        行末以外の場所にいるときは後退するなどの動作はしない。
        "前回のビジュアルモードの情報" は記録しない。

    * done: カーソルの動作

      - done: 行末に移動することは可能である。
        つまり needs-eol-fix は false を返すべき。
        →そのようにした。

      - done: 既存の nonbol-eolp の判定の部分はそのままで良いだろうか。
        つまり ^ などで行末に移動しなくて良いだろうか。

        - ok: ^ の場合はそのままで良い。移動しない。元から visual mode では、
          現在のカーソルの右にいる文字も取り込むようになっているので、
          わざわざ行末に移動しなくても行末まで範囲に含まれる。

        - done: forward-char m (SP) で nonbol-eolp 補正をしているが、これは xmap では使わないと思う。
          と思って試してみたら xmap でも使うし、更にいうと行末まで移動した。
          これについては実装しなければならない。

          % というか single-command-mode でも SP の動作が誤っていたりするような気がする
          % →と思って試してみたら single-command-mode での SP においては、
          % 次の行頭に移動するようだ。つまり、xmap の時にだけ nonbol-eolp に移動するという事になる。

          forward-char m (SP), backward-char m (DEL) について
          個別に vi_xmap の時の条件分岐で修正を加えた。

        - ok: 他は、行単位の移動だけれどこれはどうだろうか。
          例えば preserve_clumn のような移動をした時にどうなるか。
          試してみるとより短い行に移動するときに行末にも止まるようだ。
          これについてもちゃんと実装しなければならない。

          →これは .relative-line を呼び出し最終的には needs-eol-fix
            に帰着するので特別に対応する必要はなかった。

    * done: 更に挿入モードで C-o v として入ると入れ子になる。

      これは _ble_keymap_vi_single_command{,_overwrite} 変数をそのままにしておけば良い。
      その後で set-operator だか何だかで xmap を抜ける時に復元を行えば良い。

      動作を確認した。動いている。OK

    [実装]

    後の細かいことは実装しながら調べていくことにする。
    先ず初めに実装するのはビジュアルモードに入る時の動作である。

    取り敢えず "前回のビジュアルモードを復元する" というもの以外は実装した。
    ビジュアルモードの種類は _ble_edit_mark_active に設定した文字列 char/line/block で区別する。
    また C-c, C-[ (ESC) によりビジュアルモードを抜ける動作についても実装した。
    オペレータに対応する前にこの状態でカーソル移動などの動作試験を行う。

    取り敢えず動くことだけは確認した。

    x done: ESC で抜けられないと思ったら Meta 修飾になっていた。直した。
      また ESC の動作はハードコードするのではなくて keymap を通して解決する様に修正した。
    x done: また、ble/keymap:vi/setup-map において
      M-left M-right が束縛されていたのを削除した。
      これらは ESC left, ESC right の動作を上書きしてしまっていた。

    次にオペレータの呼び出しを実装する。

      取り敢えず cc dd などの行単位の操作を統合する形で ble/keymap:vi/call-operator-linewise を実装した。
      と思ったら cc dd が動かなくなった。と思ったら get-arg を呼び出すのが抜けていた。直した。
      また、cc dd の振る舞いについても修正を行った #D0488。

      次に ble/keymap:vi/call-operator-charwise も実装する。実装した。

      他にオペレータを呼び出している箇所は ble/widget/vi-command/linewise-range.impl である。
      これはオペレータ作用後の位置の移動が単純ではないので call-operator-linewise に統合するのはやめた。
      但し、[cd] を特別扱いしていた部分を整理して最小限にした ([cd] は、常に first-non-space に移るという点で特別である)。

      ble/keymap:vi/call-operator-linewise においては完全に [cd] は他のオペレータと同様の取り扱いに統合した。

    更にオペレータを呼び出した後に元のモードに戻るのを実装する。

      これは多分 vi_xmap/exit を呼び出せば良いだけではないか?

    さて動作確認をする必要がある。

    o オペレータ呼び出し後にちゃんと正しいモードに戻るか。
      OK 通常通りに呼び出した時はノーマルモードに戻り、
      挿入モードから C-o v を呼び出した時は上書きモードに対応する挿入モードに戻る。

    o y の動作 d の動作 c の動作

    x done: 範囲が足りていない。カーソルの右の文字も含めなければならない。
      更に vim で確かめてみると行末にあるときには更にその次の改行も含められるようだ。
      但し、一番最後の行の行末にいるとき (行末に行くことが出来る) には改行が付加されたりはしない。

      そのような動作に修正した。確認した。

    o 様々の移動コマンドを使うことができているか。特に引数付きで。

    o 通常の文脈での c や d を書き換えたが、ちゃんと動いているだろうか。
      dw と cw で確認した。動いている。

    x done: cj dj は動いている。と思ったら cj の後に行末 (インデント) に来ていない…。
      .relative-first-non-space の中の nonbol-eolp を needs-eol-fix に直した。直った。

    o cc と dd もちゃんと動いているように見える。

    x ok: 何だか分からないが上下に移動できなくなっている。
      と思ったら最新版ではなくて古いので試していた。

    o 範囲が反転しているときには大丈夫か。大丈夫。

    まあ恐らく大丈夫だろう。取り敢えずこの時点で commit しておくことにする。
    今までのメモで考慮するべきものに関しては分割して議論することにする。

  * kill-current-line (dd), kill-current-line-and-insert (cc) の動作が違う気がする。 [#D0488]

    先ず kill-current-line は first-non-space に移動しなければならない。
    kill-current-line-and-insert は新しい行を挿入して挿入モードにならなければならない。
    しかも元々あった行 (1行目) のインデントを保持しておかなければならない。

    - dd で first-non-space に移動するように直した。
    - cc で元のインデントを保持して新しい行を挿入するように修正した。
    - cj でインデントを保持するのは未だ直っていない。直した。
      というか cj で行を消していたが実際には
      1 個新しい行を入れなければならなかったのだ。

2017-09-28

  * ble-edit: 貼り付け対策のせいで RET を押しっぱなしにした時に [#D0487]

    改行が入力されてしまう。これはそもそも自分の悪い癖なのであるが、
    似たようなことをする人は幾らかいると思われるし、
    編集文字列が空のときにはそのまま改行を実行と解釈しても問題はない。

    従って編集文字列が空の時には次に文字が来ていたとしても
    そのまま実行と解釈して良いということにする。

2017-09-27

  * 2017-09-06 ble-edit: BASH_REMATCH 復元について [#D0486]

    任意の配列 BASH_REMATCH を、[[ some =~ some ]] を用いて復元するのは難しい。

    % だとすると一つの方法は local BASH_REMATCH を ble-decode/.hook で定義することである。
    %
    % - 但し、exec:exec の場合には関数の内部でユーザコマンドを実行するので、
    %   その際に unset BASH_REMATCH を実行する必要がある。
    %   そしてユーザコマンドを呼び出した後で、適切な位置で再度 BASH_REMATCH を呼び出す必要がある。
    %
    %   関数 ble-decode/EPILOGUE の以下の行の直後で良いだろう。
    %
    %   "ble-edit/exec:$bleopt_exec_type/process" && return 0
    %
    % - また exec:gexec の場合には ble-decode/.hook の外側でも処理を行うので、
    %   その外で呼び出されうる全ての関数について local BASH_REMATCH を指定する必要がある。
    %   外で呼び出されうる関数に関しては変数 _ble_decode_bind_hook に設定されうる関数を調べれば良い。
    %   _ble_decode_bind_hook に対する値の設定は現状でただ一箇所 ble-edit/exec:gexec/.setup の中である。
    %   ここで指定される関数として以下のものがある。
    %
    %   - ble-edit/exec:gexec/.eval-prologue
    %   - ble-edit/exec:gexec/.save-params
    %   - ble-edit/exec:gexec/.eval-epilogue"
    %   - ble-edit/exec:gexec/.end
    %
    % - 他に trap を通して呼び出される関数がある。
    %
    %   - ble-decode: ble-stty/TRAPEXIT これは単純な関数なので中で正規表現を使わないことは自明である。
    %   - ble-edit: ble-edit/attach/TRAPWINCH 必要
    %   - ble-edit: ble-edit/exec:exec/.eval-TRAPDEBUG 不要
    %   - ble-edit: ble-edit/exec:exec/.eval-TRAPINT 不要
    %   - ble-edit: ble-edit/exec:gexec/.eval-TRAPDEBUG 必要
    %   - ble-edit: ble-edit/exec:gexec/.eval-TRAPINT 不要
    %   - ble-edit: ble-edit/bind/stdout/TRAPUSR1 不要
    %   - ble-edit: ble-edit/bind/.exit-TRAPRTMAX 不要
    %
    % また将来的に trap や _ble_decode_bind_hook を追加するときのために、
    % どの様な関数において local BASH_REMATCH をつける必要があるかについて
    % Note にまとめておく必要がある。

    とここまでまとめて気付いたが local BASH_REMATCH を実行しても
    読み取り専用の変数ですと表示されて怒られる。
    更に、BASH_REMATCH に対する変更の影響は結局関数の外でも残る。
    つまり local BASH_REMATCH としても効果はなくエラーメッセージが表示されるだけである。

    一番理想的な方法は正規表現の一致に使用された文字列と正規表現を特定することだがそれは難しい。
    もし一致全体 ${BASH_REMATCH[0]} のことを気にしないで良いのであれば、
    ${BASH_REMATCH[i]} に対して (.{${#BASH_REMATCH[i]}}) を一致させるようにすれば良い。
    問題は一致全体である。結局一致全体は不動なので [[ $BASH_REMATCH =~ 某 ]] とするしかない。
    この時各子一致は独立ではなくて overlap があることに注意する。

    特に、各子一致は入れ子構造になっていなければならないという制限が存在する。
    さて、問題は子一致の内容が指定されたときに入れ子構造を再現することができるのかということである。
    また各子一致の順序も保持しなければならない。

    1 各子一致について先頭から順に見ていくとする。
      或る子一致について、先ず既存の子一致に対する入れ子関係を決定する。
      一般に複数の可能性がある。つまり、全体一致の部分列として複数の位置に存在する可能性があって、
      更に既存の子一致に対する入れ子関係と矛盾しない (既存の子一致の終端を跨がない) という条件を課しても、
      複数の候補が残る可能性がある。

    2 この時、一番初めの (即ち、一番内側の入れ子になるような) 可能性を選んでも問題は起こらない。
      何故ならば後続の子一致は、現在処理している子一致に完全に含まれるか、
      或いは現在処理している子一致より明確に後に位置するかであるため、
      本来の一致位置より左側に平行移動する分には何も問題が起こらないからである。

    この手順によって各子一致の開始位置を決定することができる。
    その後に対応する正規表現を () と .{幅} の組み合わせで構築すれば良い。
    後は $BASH_REMATCH と構築した正規表現を何処かの変数に保存しておけば、
    [[ $saved_rematch =~ $saved_rex ]] でいつでも BASH_REMATCH の状態を復元できる。

    [実装]

    取り敢えず実装した。動いている気がする。実装している途中に気付いた点として、

    - 一致に失敗すると BASH_REMATCH は空になる。
    - 初期の状態では BASH_REMATCH は unset の状態になっている。
    - BASH_REMATCH を手で unset することはできない。

    初期の unset の状態には戻せないので ble.sh では BASH_REMATCH を空にする
    (具体的には [[ '' =~ none ]] を実行する) ことにした。

  * 2017-09-25 ble-edit: 貼り付け対策 [#D0485]

    % 誤って貼り付けを行ってしまってあらぬコマンドが次々に実行されてしまうという事故がある。
    % 実はこれは検出可能なのではないだろうか。
    % 前の入力に対して間髪を入れずに改行が入力された場合は怪しい。
    %
    % ただ IME を通して日本語を大量に入力して、その処理が終わっていない内に改行を押すこともあって、
    % そのような場合に改行として入力されてしまうと分かりにくいので、複数行編集の表示はやはり必要である。
    %
    % また isearch で処理に時間がかかっているときに改行を押す場合も考えられる。
    % この場合には accept するか無視するかにした方が良い。
    % 現在は accept になっているが本来は無視するのが正しい気がする。
    %
    % これの判定は以下のようにする
    % - self-insert に引き続いて改行を入力したときは、改行を挿入する
    % - それ以外に引き続いて改行を入力したときは、bell
    % - idle 時に改行を入力したときは accept-line または複数行編集ならば改行挿入

    実は、その改行が前の文字に間髪入れずに入ってきたとかではなくて、
    単に改行に引き続いて何かが入力されているという判定で良いのでは?

    できるかと思ってやってみたができない。
    貼り付けているとしても改行を処理しているときには次の文字は未だ来ていないのだろうか。
    と思ったが、よく見ると実行の遅延はちゃんと処理できている。
    ということは ble/util/is-stdin-ready は真になっているはずである。
    なのに accept-single-line-or をすり抜けるのはおかしい。

    と思ったら accept-single-line-or を通過していない。何故?
    実は vi-{command,insert}/accept-single-line-or の方は独立した実装になっていた。
    これらも同時に修正する必要がある。修正した。ちゃんと動くようになった。

  * 2017-09-25 ble-edit: 複数行編集のスクロールについて [#D0484]

    現状の実装では端末の高さよりも高くなると変な表示になることを甘受している。
    zsh で試してみたら ... と表示して前方の行を省略するようである。
    これは ble.sh でも実装可能のはずである。

    描画範囲を制限する様にすれば良い。
    描画は関数 ble-edit/render/update で行っている。
    幸い現在の実装では描画内容の決定と実際に描画を行う部分が分離されている。
    この実際に描画を行う部分の改修で済めば嬉しい。

    実際に何に気をつけなければならないかというと、

    1. 現在の先頭行の行番号を保持するということ、
      現在の先頭行の行番号は現在のカーソルの位置に依存して修正する必要があること。
    2. 先頭行の行番号を変更するときにはスクロールを伴うこと、
      特に、スクロールにより隠れていた部分は再描画が必要になる。
    3. 実はスクロール処理と変更部分の更新描画は分離できるということ。

    恐らくスクロールがある場合には先にスクロール処理をしてしまってから、
    変更部分の描画を行うようにすれば良い。

    * ところで、スクロールによって再描画された部分については後で再度描画する必要はなかったりする。
      下手すると完全に 2 度描画してしまうということも考えられる。
      これについてはどのように処理すればよいかは微妙。
      と思ったが、再描画範囲は現在単一の range で管理しているのだから、
      実はスクロールによって再描画範囲を削るというのの実装はそんなに難しくないのでは。
      →実際に観察してみると umin, umax で再描画範囲を管理している。
        スクロールによる描画でこれらの境界を踏む場合には umin, umax を狭めることで対処できる。

    * と思ったけれど info が複数行ある場合などを考えると全体で収まるように調整しなければならない。

    [実装]

    * コメントアウトされている古いコードで
      - プロンプトは更新しないけれど編集文字列は全描画するものと、
      - 全体描画後にカーソル位置を設定するときに SC/RC を利用するものは、
      コードの管理・維持が面倒になったし今後使われるとも思われないので削除する。
      前者については、今後必要になったらその時に新しく書き起こせば問題ない。
      後者については、わざわざカーソル位置で表示文字列をスライスしなければならないので、
      処理としても無駄が多いし、ユーザの設定する SC/RC と干渉するのも嫌である。

    [動作確認]

    x resolved: カーソル位置が二重になっている。これはどういうことか。
      _ble_line_cur に収めるカーソル位置の値は実際に表示されている位置であった。
      修正したらこれは直った。

    x resolved: スクロール状態になっているとき、最下行にいたとしても margin が加えられている。
      カーソル位置に対応するスクロール量の上限・下限の値の計算方法を書き直した。直った。

    x resolved: 一番上の行に移動するとき、上へのスクロールが実施されていない気がする。
      シフト量の符号が逆転していた→直した。

    x resolved?: X座標の位置計算をミスっている。
      スクロール時に常にカーソル位置が左端になっている。
      →スクロール量の修正をしたあとで再度確かめてみたら直っていた。
      結局、何が行けなかったのかは謎。

    x resolved: C-l で clear-screen すると表示されてはならないところまで全部表示されてしまう。

      % これは、実際に描画内容を出力している部分を全部列挙して、
      % 全ての箇所に対してスクロールの対応を加える必要がある。
      % 取り敢えずは、これについては保留として、
      % 初めに通常編集時の表示のずれを修正する。

      確認してみたら単に render/update の全体描画の際の、
      スクロールがあるかないかの判定の部分が反転していただけであった。
      と思って直したら、今度は何も表示されないしカーソル位置がずれている。

      うーん。と思ったら部分描画の部分のコードが色々間違っている。
      存在していない変数を使って計算していた。これを直したら直った。
      恐らく描画範囲が負になったりしていたのだろう。
      それで位置がずれたりしていたのだと思われる。
      修正した。直った。

    + done: history-forward で編集文字列の末端に移動するのはどうだろう。
      これは編集文字列の一行目の末端に移動するのが良いのではないだろうか。
      振る舞いを修正した。OK

    + done: [[ ! $bleopt_suppress_bash_output ]] のときに使われる
      ble-edit/render/redraw-cache の中での再描画は、
      現状では全体再描画になっていてスクロールに対応していない。
      仕方がないので [[ $_ble_line_scroll ]] の場合には最初から全部描画することにした。
      しかし、これはちらつきの原因になる。

      現状では ! $bleopt_suppress_bash_output はデバグ用途でしたか使われないとはいえ、
      中途半端な実装になっているのは気分が悪いので後で対応を考えることにする。

    x resolved: 弄っていたら何故か履歴項目を移動したときに
      スクロール領域を制限せずに全てぺろりと表示されるようになってしまった。何故か。

      色々調べた結果、get-index-at の内部で
      _ble_line_begy _ble_line_endy を使っているのにも拘らず、
      これを更新する前に get-index-at を使用していたからであった。
      しかし、もし get-index-at の内部でこれを使用するのであれば、
      寧ろ _ble_line_{beg,end}{x,y} は ble-edit/text/update の中で更新するべきなのではないだろうか。

      → ble-edit/text/update/position の中で更新する様に変更した。
      更に変数名をそれに合わせて _ble_line_text_* に変更した。動作している。
      また勝手に中身をクリアしたりしている箇所でもクリアしないことにした。
      更新は ble-edit/text/update が呼び出された時に行われるであろう。
      逆に言えば ble-edit/text/update が呼び出されていない状態で
      _ble_line_text_{beg,end}{x,y} を使用することは不正である。
      これについても確認してみると、何れの場合でもちゃんと
      ble-edit/text/update が呼び出されていることをチェックしてから使用していたので、問題ない。

    取り敢えず複数行編集のスクロールの対応は一段落したことにする。
    これからまたバグや不整合が出て来る気がするが、それはその都度対応することにする。

2017-09-25

  * bleopt での値チェックを実装する [#D0483]

    これは以前発案の onchange と合わせて考察する。

    | * 2015-11-18 bleopt コマンド: onchange
    |
    |   変数の値が変わった時に onchange イベントを起こす仕組みを整えても良い。
    |   これは変数の内容変更にともなって処理が必要な変数が出てきてから考える。

    或いは値を設定する関数を定義できるようにするのが一番柔軟だろうか。
    しかしそれは変数としての実体が存在しないものに対しては良いが、
    そうでないもの (bleopt 変数) に関しては適していない気もする。

    value というローカル変数を設定してから関数を呼び出してチェック・修正してから、
    値を設定するというようにするのが良い気がする。


2017-09-24

  * vi-mode: 前回からの修正: [#D0482]

    - vi-mode: 行単位の操作 (2yj など) をするとエラーになるバグの修正
    - vi-mode: 現在位置よりも先に操作対象があるとき (yib など) 位置の移動が起こらないバグの修正
    - vi-mode: isearch の途中でノーマルモードに移行すると選択状態がそのままになるバグの修正
    - char_width=emacs のとき、★などの文字 (U+2000 - U+2600) の文字幅が常に 1 になっていたバグの修正
    - $? 及び $_ の再設定が動かなくなっていたバグの修正
    - vi-mode: {count}L で現在行より上に行く場合、{count}H で現在行より下に行く場合などで範囲が裏返るバグの修正
    - vi-mode: + - H L yib などで非空白行頭に移る条件の修正
    - vi-mode: オペレータを指定したときの gg G は現在のコマンド内の移動だが、引数省略時に引数 1 と解釈していたバグを修正

    - vi-mode: rx grx で上書き対象を着色
    - vi-mode: imap: C-m, C-h, DEL; nmap: o, O でインデントを特別扱い

    - テキストオブジェクト [ia][pst]
    - コマンド % {count}%
    - vim-surround.sh: 設定 "bleopt vi_surround_45", etc. に対応

  * 2017-09-22 vi-mode: "-- NORMAL --" という表示をした方が良いか? [#D0481]

    zsh vi-mode で検索したら以下のような記事を見つけた。
    -- NORMAL -- を表示している。色も変えられる様にしている。

    https://qiita.com/b4b4r07/items/8db0257d2e6f6b19ecb9

    或いは (複数行編集のときのために) ~ を表示するようにするのが分かりやすい気がする。
    やはり現在複数行編集なのかどうかが分からないので ~ (もしくは -- NORMAL --) は表示するべきの気がする。

    これは既定で ~ (太字) とし、設定項目で指定できるようにした。

  * 2017-09-08 vi-mode: % [#D0480]

    引数を指定した時の動作についてはよく分からない。
    括弧の上にいるときは対応する括弧の上に移動する。
    括弧の上にいないときは同じ行内で右に向かって括弧を探し、
    最初に当たった括弧に対応する括弧に移動するようだ。

    <> は括弧として認識しない。[] () {} は括弧として認識する。
    引数を指定した時の動作は不明である。

    cmplstofB: 2017-09-17 要望が入った。

    | Vim のノーマルモードにおいて % は「対応する括弧(もしくはそれに準ずるもの)の対に飛ぶ」
    | という機能が割り当てられています。(:help %) 実装していただくととても嬉しいです。

    * :help % で見てみると引数は許されないと書かれている。
      {count}% で count % だけ次の行に行くそうだ。
      成る程。確かに試してみるとそうなっている。
      :help N% というので説明が見られるようなので調べると、式も与えられている。

        ({count} * number-of-lines + 99) / 100

      count% だけ下に移動するのではなくて、 count% の位置にある行に移動するようだ。

    * matchpairs という変数で指定できるということになっている様だが、
      どのように指定するものなのかは :help % には書かれていない気がする。
      :help matchpairs で見てみると default "(:),{:},[:]" と書かれている。

    まあ取り敢えずこれの事は考えないことにする。

    初めの括弧に関しては行内での探索のようである。

  * vi-mode: o O でもインデントは認識する [#D0479]

    O は一つ前の行のインデントではなくて、現在の行のインデントを継承する。

  * vi-mode: 空白だけの行でインデントは有効か? [#D0478]
    → 有効である。C-m でも継承されるし、DEL でも一度に消せる。OK

  * 2017-09-23 vi-mode (text object ?s): どうも実装が不完全だ。 [#D0477]

    - 先ず yas yis で引数を指定したとき、段落を越えて範囲は拡大する。
    - 更に、初めに空行にいた時の動作も引数が指定したときに対応できていない。

    連続改行は一つの文として取り扱われている気配がある。

    正規表現を改良すればなんとかなるかもしれないしならないかもしれない。
    よく分からないが取り敢えず先に p を実装する。実装した。

    * 先ずは段落を跨ぐように改造する必要がある。

      少なくとも段落の終端は使わないようにする必要がある。
      更には段落の先頭も使う必要がない可能性がある。
      これについては先ずは段落の終端を使わないように修正し、
      その後で更に段落の先頭も使わないように変更できるかを考察する。

      取り敢えず段落の終端を越えて当たるように修正する。
      段落の境界の取り扱いがどうなっているのかについては、
      yis を使って調べることができる。

      以下 @ がカーソルの位置で、
      数字は "{数字}yis" とした時に何処まで範囲とするかを示したものである。

      | @echo hello.1 2echo world.34
      |
      |
      | 56
      | echo hello.7 8echo world.9

      % これを見るに、恐らく本来は
      %
      % | @echo hello.1 2echo world.3
      % | 4
      % |
      % | 5
      % | 6echo hello.7 8echo world.9
      %
      % の様になっていて、但し補正されて上記のようになっているのではないかと思われる。
      % ここで疑問となるのが 5 が何故補正されないのかということである。うーん。
      %
      % - 前の行の内容が存在している時には補正する (4)
      % - その行の内容が存在している時には補正する (6)
      %
      % という規則を考えれば良いだろうか。
      %
      % 更に、この補正前の 3456 の動きについて考える。
      %
      % (1) 3->4 に関しては行末にいて、
      %   現在行が非空行であれば次の行頭に行くということになろうか。
      %
      %   もう少し検証する。行末に空白があるときの動作はどうだろう。
      %
      %   | @echo hello.1 2echo world.3   (←空白がある)
      %   | 4
      %   |
      %   | 5
      %   | 6echo hello.7 8echo world.9
      %
      %   変わっていないように見える。
      %   うーん。空行にいない限りは通常の空白探索の動作ということにして、
      %   更に通常の空白探索では連続する LF の内 2 番目のものを受け取らないという事にするべきか。
      %
      % (2) 4->5 に関しては、
      %
      %   1 空行にいるときに \n の連続を読み取る。
      %   2 最後の \n だけは読み取らずに一つ戻る。
      %
      %   と理解できるだろうか。しかし幾つか疑問点が残る。
      %   先ず間に空行が1個しかない場合の動作はどうなるのか。
      %   その場で動かないのか、或いは、次の段落の頭に移動してしまうのか。
      %
      %   →試してみた所以下のようになった。
      %
      %   | @echo hello.1 2echo world.3   (←空白がある)
      %   | 45
      %   | 6echo hello.7 8echo world.9
      %
      %   これは変だ。ということはやはり 45 のどちらかは補正前でも
      %   別の場所にあると考えるべきなのだろうか。うーん。
      %   所が、3-6 の間にカーソル位置は 3 つしかない。
      %   その中に 4 つの停止点があるということは、
      %   他の内部状態が存在するか (exclusive inclusive など)、
      %   或いは、実は停止などしていなくて arg を
      %   2 消費する移動が存在するかのどちらかである。
      %
      %   うーん。2消費する移動だと解釈することにする。
      %   どちらであったとしても区別可能であるとは思えないので。

    もう分からないのでまた vim のソースコードを見ることにした。
    どうやら文の終端は /[.!?]\s/ ではなくて /[.!?][])'"]*\s/

    うーん。どうも "現在空白" と "現在文" という二つの読み取りを交互に行っている様だ。
    そして、空行の集合のスキップは "現在文" の状態の時に行われる。

    多分以下のようになっている。
    偶数番から奇数番の時にだけ空行を跨ぐことができると思われる。

    | @echo hello.1 2echo world.3
    | 4
    |
    |
    | 56echo hello.7 8echo world.9

    他の場合にも調べることにする。
    空行で初めた時には、試した結果、恐らく以下のようになっている。

    | @
    |
    | 0
    | 12echo.3

    うーん。結局実装し直しということになりそうだ。
    実装し直した。動作確認する。

    o 空行しか無い時に全てを取り尽くすことを確認した。
    o これ。
      | @echo hello.1 2echo world.3   4(←空白)
      |
      |
      |
      | 56echo hello.7 8echo world.9
    o これ。OK
      | @
      |
      | 0
      | 12echo.3 4world.
    x 行末に空白がない時に backward に空白を取るのができていない。
      →LF, HT の定数が定義されていない状態でそれを使って正規表現を構築していた。直した。
    x 今度は段落を越えて backward に空白が取られている。
      この正規表現の場合には一番最初に当たるのは $LF$LF だと思ったのだが…。
      →正規表現が悪かった。二重改行があったとしても終端 $ に接することを要求していたのが悪い。修正した。
    x 段落の末端にいるときに前方の空白を取り込んでくれない。
      →どうも試してみると正しく取り込めている。
      どうやら linewise で実行されると first-non-space に移動しているというだけだった。
      しかし vim では行頭に移動する。これは新しい linewise のオプションを追加する必要がありそう。

      うーん。これは…。このまえ修正した linewise は正しくない気がする。

    linewise を大修正した。これで再度チェックをやり直してみる。

    o "@echo hello.1 2echo world.34^J^J^J^J56echo hello.7 8echo world.9" OK
    o "@echo hello.1 2echo world.3   4^J" OK
    o "@^J^J0^J12echo world.3^J" OK
    x yis で何故か前方の空白を取り込んでいる?

      うーん。これはよく考えたら実装の過程では考えなかったことである。
      つまり、文の区切りは "二重改行" または "句読点+空白" ではなくて、
      "二重改行[+空白]" または "句読点+空白" なのである。修正する。

      →修正した。yas yis の動作確認もした。
        最終行の時、次に空行があるときのそれぞれについても確認した。OK
    o 段落を越えて前の空白を取り込むということはない。
    o 単一行段落の末端にいるときの yas で前方の空白を取り込んでかつ、
      行頭に移動するという動作に関しては、既に試したようにちゃんと実装できている。

    恐らくだいたい大丈夫であろう。

  * vi-mode (linewise-range): bug in reverted [#D0476]

    linewise-range.impl の実装を調べていて気がついたが。
    例えば一番下から 2 つ目の行で 5yL などとすると、
    linewise-range.impl の中の reverted の判定に失敗する。

    結果として "先頭行の末端" から "最終行の先頭" までが切り取られ、
    更に切り取り後のカーソル位置は先頭行ではなくて最終行になる。

    現在のインターフェイスを変えるのも面倒なので、
    linewise-range.impl の reverted の計算を厳密にやるようにするか。
    或いは、呼び出し元で全て解決してから渡すようにするという手もある。
    →呼び出し元で処理する場合には、それぞれで両端の前後関係に応じた場合分けが必要になり面倒である。
    その辺りのごちゃごちゃも一緒に統一したのが linewise-range.impl であった。
    従って、やはり linewise-range.impl の中でごちゃごちゃと計算したほうが良い気がする。

    実装した。結局その場で各先頭行と最終行の行頭を計算するようにした。

    # 合成する際に各実装の最適化をそのままにくっつけたのが混乱の原因だ。
    # もし初めからこの様にくっつけて実装するのだとしたら、以前のような変なことにはしない。
    # (或いは、もっと上等な遅延評価の仕組みを整えてから実装する必要があるだろう。)
    # 整理されたコードというのはその分だけ非効率的な部分も許容しなければならないのである。

    次に動作チェックを行う必要がある。

    - 特に実装の過程で require_multiline の辺りのコードも一緒に整理された。
    - また y オペレータの後に非空白行頭に行く処理も変更があったが、
      これはその処理の修正をこれからするところなのでそれが終わってからチェックすれば良い。

    % x 2行目で 3yH を実行すると 3 行目に移動してしまう。これは変だ。
    %   と思ったら修正までのコードで動かしていただけだった。問題なかった。
    % x 下から 2 行目で 5yL を実行すると、下から3-4行目だけが切り取られ、
    %   下から2行目に現在位置は留まる。この動作を直す為に修正したはずなのに直っていない。
    %   と思ったらこれはまた古いコードで動かして試していた。

    x 下から2行目で5yLを実行したら以下のようなエラーが発生した。
      ((: 48:-4: 式に構文エラーがあります (エラーのあるトークンは ":-4")
      →これは reverted かどうかの判定で直接 p q を用いていたのがいけない。直した。
    o 下から2行目で4yLを実行して正しく動作することを確認した。

    [require_multiline の確認]

    o 一番下の行で yj y+ をしてエラーになること
    o 一番上の行で yk y- をしてエラーになること
    o それ以外の場合にはエラーにならないこと


  * vi-mode (linewise-range): #D0470 の修正はやはり変だ。 [#D0475]

    % relative-line では行を移動しない場合はないと書いたが、
    % y+ のように下に移動するときには beg は初めと同じ行にある。
    % この時のどの位置に移動する(移動しない)のかというのは非自明である。
    %
    % - 更に ygg としたときに nol が ind よりも後にある場合には ind は動かない。
    %   これは個別に動作を考えたほうが良いような気がしてきた。
    %   先ず初めに言えることは従来の実装では ind は
    %   必ず beg-end の範囲に入っている (はず) ということである。
    %
    % 更に ind!=beg のときだけ処理を行うということになっているが本当だろうか。
    % これは preserve_column など各々の動作で異なるのではないだろうか。
    % →各処理法毎に判定することにし、外側では ind!=beg の判定はしないことにした。

    修正した。と思って動作確認をしようとしたらやはり実装を間違えている気がする。
    一旦動作について整理する必要がある。

    % y+, 2yH とすると非空白行頭へは行かないが 1yH とすると非空白行頭へ戻る。
    % つまり + - H G L などでは、先頭行が行き先の行であるときには非空白行頭へ移動する。
    % 先頭行が行き先の行でないときには、ind が先頭行にいないときに非空白行頭へ移動する。
    % それ以外の (先頭行が行き先ではなく、かつ ind が元からそこにある) ときは、動かない。
    %
    % "+ - H G L" の動作について整理する。
    %
    % - 先頭行が行き先の行であるとき
    %   - 現在行が他の行にあるときは非空白行頭に移動する
    %   - 現在行が先頭行にあるときは、現在位置が非空白行頭より後にあるときに限り非空白行頭に移動する
    % - 先頭行が行き先の行でないとき
    %   - 現在行が他の行にあるときは非空白行頭に移動する
    %   - 現在行が先頭行にあるときは、動かない
    %
    % これはもっと簡単にできる。
    %
    % - 現在行が先頭行にあるとき
    %   - 先頭行が行き先の行であるとき、現在位置が非空白行頭より後なら非空白行頭に移動する
    %   - 先頭行が行き先の行でないとき、動かない
    % - 現在行が他の行にあるときは非空白行頭に移動する

    - 現在行が他の行にあるか先頭行が行き先の行であるとき、
      - 現在位置が他の行にあるか非空白行頭より後なら、非空白行頭に移動する

    動作確認

    - yib (block.impl) の動作確認
    - yis の動作確認 → これは現在実装している途中なので後でチェックするので今はいい。

    o 2行目で 3yH, y+ を実行して動かないこと、
    o 2行目で 2yH を実行して非空白行頭に後退すること
    o 2行目の行頭空白で 2yH を実行して動かないこと

    [yib の動作確認]

    o "(^J  echo hello^J  echo world^J)" に対して、
      ちゃんと vim の動作と同様に、中身の行頭に移動することを確かめた。

2017-09-23

  * memo.txt: ユーザ名 B-bar を cmplstofB に統一した [#D0474]

  * vi-mode: by cmplstofB [#D0473]

    | Bash の vi-mode にはないのですが、テキストオブジェクトを実装して欲しいです。
    | Zsh の vim-mode では実装されています。

    これは実装したい。が、コマンド体系がよく分からないのでどのように dispatch するのが良いか微妙。
    vimindex に色々なテキストオブジェクトについて記述がある。
    [ydc] が設定されている時に [ia] が来たら、その時点で別のキーマップに切り替えるなどすれば良いのだろうか。

    更に ysiw" は体系としてかなり謎である → これは独立した項目 #D0446 を立てて対応することにした。

    現在未実装なのは [ia][pst] である。

    * t は #D0461

    * s は #D0472

    * p について調べる。

      これまで試した様子からいうと二重改行なのではないかと思われる。
      と思ったが、間に空白だけの行が含まれていても段落の分割になるようだ。

      ip と ap は区別はないような気がする。
      と思ったが dap と dip を比べると dip は段落の次の空行を残すようだが、
      dap は段落に続く行たち (複数可能) も一緒に削除する。

      また行指向の切り取りになっている。

      1 つまり段落は1つ以上の空行 (空白だけの行) で区切られる。
      2 ap は段落に後続の空行たちを含む。
        後続の空行がない場合には前にある空行たちを含むようになる。
        ip は含まない。

      うーん。これについても詳細に動作を調べる必要がある。
      sentence の動作に大分似ている様だ。

      調べて実装した。

      [確認] 動作を確認する。

      o yap で段落の数を指定して選択し、
        yip で段落または空行たちの個数を指定して選択する。
      o yap で最後に空行のない段落の場合に前方にある空行たちを取り込む
      o 空行しか無い場合の yap, yip の動作も大丈夫。

      取り敢えずは OK ということにする。

  * vi-mode: text object is as [#D0472]

    s について調べる。先ずは as

    - "日本語。abc. 日本語。" を試すと
      "日本語。abc. " と " 日本語。" になる。
      日本語の句読点は認識していないということと、
      前後の空白も含まれるということ。
    - "Hello, i.e., this is a test. This is Q.E.D."
      これは "Hello, i.e., this is a test. " と " This is Q.E.D." になる。
      思ったよりは賢い。仮説: . の後に空白があれば文が切れると判定している。
    - 前後の改行も含まれるようだ? しかしよく分からない。
      1. 先ず行末の . でも良いということ
      2. 更に行末の . であり次の行頭にすぐ文字がある場合は、
         前の行の空白も含むようだ?

    実は改行か空白かは余り区別していない気がする。
    先ず初めに一番最初の非空白文字から . 後の空白までを範囲とする。
    途中に連続改行がある場合はそこで終わるように範囲をせばめる。
    更に末端に改行があればそれを除くように範囲をせばめる。
    もし . が一番最後の文字になっている場合は、文の先頭にある空白を取り込む。
    これは前の行にも遡り、前の行末に空白がなくても改行だけを取り込む。

    % 以下の方法で文の範囲を決定する。
    %
    % 1 どうも先ず二重改行で区切られている領域 (段落) を決定し、
    %   更にその範囲の中で探索を行っているようだ。
    %   二重改行は空白行を含んではいけない、厳密な二重改行である。
    % 2 その範囲の中で "最初の単語から . に続く空白類" までを文の範囲とする。
    % 3 範囲末端に改行がある場合にはそれを除くように範囲をせばめる
    % 4 もしこの時点で . に続く空白類が一つも範囲に含まれないのであれば、
    %   文の前にある空白類(改行も)を範囲に入れるように拡大する。
    % 5 但し、先頭の改行は除外するようにせばめる。
    %
    % 文の区切りは "! " "? " でも良い。 ": " や "; " は駄目。
    % [!?.] の前に非空白文字があるかどうかは問わない。
    %
    % is についてはどうだろう。これは空白類を除くだけのようだ。
    % つまり [!?.] の類は含まれる。
    %
    % 取り敢えず実装したと思って今度は yis を実装し始めたら思わぬ動作をする。
    % 空白の位置にカーソルがある場合には空白が対象になる。

    - これは実装方法を間違えたかもしれない。
    - しかも引数のことも完全に忘れていた。
    - linewise になる条件はよく分からない。
      改行が含まれていれば linewise になるという訳でもない。
      恐らく行頭から行末までを切り取った時に限り
      linewise になるのではという気がする。

    実装し直した。

    [確認]

    動作確認をする。

    x yis も yas も後方に向かって空白も取り込んでいる。何故?
      → backward-extend を確認したら空白の幅を足し忘れていた。直した。
    x 文の真ん中の空白で実行するとそこから文が始まると勘違いする。
      →よく考えたら backward-extend で空白かどうかだけを見るのでは駄目だ。直した。
    x 丁度行全体を捕まえるときカーソルが移動しない。オペレータは動作している → #D0470
    x 一番最初の空行が段落に含まれてしまっている → これは直した。
    x 空行だけで構成されているとき ${str:offset:len} で len が負になるエラーが出る
      範囲拡大の起点が piv ではなくて _ble_edit_ind になっていた → これも直した。
    x 空行だけで構成されているとき対象となっている行数が少ない?
      これは空行だけで構成されているかどうかの判定が誤っていた → s/_ble_edit_ind/piv/ 直した。
    x 空行に続いて段落がある場合にカーソルが移動しない → #D0471
    o yis yas のそれぞれについて引数は試した。
      yas が後方の空白を取り込むことも確かめた。
    o 後方の空白が次の行にある場合にも取り込むことを確かめた。
    x 同じ行内の後方の空白が取り込まれていない…
      いや、空白は取り込まれているけれど何故か前方にも空白を取り込んでいる。
      →改めて末尾に関する条件を見たら良くわからない条件になっていたので直した。動作確認した。
    o 段落の末端または行末に達する場合に、
      前方の空白を取り込むことも確認した。
    o 前方の空白が改行だけの場合それを取り込まないことも確認した。
    o 前方の空白が前の行の末尾にある場合それを取り込むことも確認した。

  * vi-mode: linewise-range.impl において [#D0471]
    現在位置が作用対象よりも前に存在するときに、
    作用後に非空白行頭に移動しないのは変なのではないか。

    これについては vim の動作を調べる。
    - "カーソル ( 改行 echo 改行 )" のときに yib とすると
      vim では echo の先頭にカーソルが移動する。
      ble.sh ではカーソルは移動しない。
    ^ その他の既存のものでは現在位置が作用対象よりも
      前に来ることはなかったはずである。

    直した。

  * vi-mode: linewise-range.impl において [#D0470]
    行を移動しないときに非空白行頭に移動しないのは変なのではないか。

    実際にこれを呼び出している各機能の振る舞いについて vim で再度確認する。
    - yib は vim では行頭に移るが ble.sh の現在の実装では移らない。
    - nth-line, nth-last-line, last-line に関しては、2行目にいるときに
      vim で 2yH とすると行頭に移るが ble.sh で 2yH としてもそのままである。
    - relative-line などでは行を移動しない場合はないので、これは気にしなくて良い。

    以上の調査の結果、linewise-range.impl では、
    preserve_column でないとき行を移動しない時でも行頭に移動するべきである。

  * 2017-09-17 vi-mode: 改行挿入時 [#D0469]

    前の行のインデントを引き継ぐようだ。
    但し何も入力しない場合はインデントは消滅してなくなる。
    面倒なので何も入力しないときにインデントが消滅することには対応しない。

    C-m でも C-j でも同様に動作する。
    更に気付いたことは BS, C-h でインデントが削除されるということ。
    (インデント以外であればちゃんと一文字ずつ削除される。)

  * 2017-09-19 起動して未だ初期化している途中に入力した文字列が下に押し出されてしまう。 [#D0468]
    起動した瞬間の ble-form/panel の状態を別のものにした方が良いのかもしれない。
    →対策した。

  * 2017-09-23 ble-edit: [bug] ble/util/c2w: 何か ★ の幅の計算が間違っている気がする。 [#D0467]
    emacs, screen (修正済), poderosa のどれにおいても★で変な動作になっていないが、
    ble.sh で★を入力した時にずれる。
    実際にやってみると 1 と表示される。これは変だ。

    $ ble/util/s2c ★; echo $ret
    9733
    $ ble/util/c2w 9733
    1

    自前の screen では 2 になっているのではないかという気がする。ずれていないので。
    しかし同じ表を使って計算している筈なのに変だ。
    もしかすると表の引き方を間違えているのではないかという疑惑がある。

    9733 は表の 1797 に対応して、その周辺では 1776 1797 1799 となっている。
    試してみると 9732 9733 9734 9735 と全部試しても 1 になる。変だ。

    調べてみた所 9733 が tIndex=1797 に修正されるべきところで、
    そのまま透過して tIndex=9733 になっている。
    なんと! tIndex の値を折角計算したのに上書きしていた…。修正した。動作確認した。

  * 2017-09-20 今気づいたのだが実は現状で exit status の復元に失敗している? [#D0466]
    →やはりそうだ。またコードを確認する必要がある。

    コードの編集に明らかに失敗している。
    そして確かめてみたところ $_ は同じ関数呼び出しレベルにおける最後の引数を指すようだ。
    ということは今まで通りに eval の中に設定する必要がある。

    終了ステータスと最後の引数を同時に設定するためには
    ble-edit/exec/.setexit "$_ble_edit_exec_lastarg" とするしかない。
    と思って実際に試してみたところ $_ が常に /usr/bin/bash になってしまった。
    うーん。試してみたが関数だと /usr/bin/bash になってしまうということもないようだ。
    と思ったらそれまでに一度も引数ありでコマンドを実行していなかったために、
    最初の値の /usr/bin/bash が受け継がれて中に入っていただけだった。
    現状の実装でちゃんと復元はできている。

  * 2017-09-19 bash -v で起動すると恐ろしいことになる。 [#D0465]

    これは [[ -o verbose ]] で確認することができて、
    また set +v / set -v で切り替えられるはず。

    必ずしもすべてのコマンドが出力されている訳ではない様だと思ったが、
    どうも eval ごとに実行したコマンドが出力されている気がする。

    →取り敢えず対策した。[[ -o verbose ]] の状態を記録・復元することにした。
    それでも未だ色々と変な者が出力されている。
    もちろんこれらを完全に解決することは難しい。
    しかしながら、できるだけ出力内容が少なくするようにすることはできる。

    そもそも何故 prologue, setexit, save-params, epilogue の 4 つに分かれていたのか。
    save-params と epilogue については理由はある。
    コマンド本体は文法がおかしい場合に後段の処理が潰れないように eval で囲む必要があった。
    しかしそうすると $_ が取れなくなってしまうので save-params だけは
    同じ eval の中で評価しなければならなかった (そうしないと eval に渡した引数が $_ に入ってしまう)。
    といってもコマンド本体に文法のおかしいものを指定したときに実行されなくなるのは困るので、
    重要なものに関しては eval の外に置かなければならない。

    今一つの案は

    1. prologue と setexit をくっつけ更に eval の中に移動する。
      (正しく実装している限りは prologue/setexit の中で失敗することはないと期待する)
    2. save-params の中で -o verbose の記録・無効化を実行し、
      もしそれに失敗したときのために念のため epilogue でも
      実行済みかチェックした上でこれを実行する。

    修正した。現状では .save-params だけ余分に出力されている状態である。
    これに関してはこれ以上どうしようもないが名称を変えることはできる。

    * .save-params 名称を変えることにする。どのような名称が良いか。

      ble-edit/exec:gexec/ の部分は変えようがない。
      .save-params よりも何のために表示されているかが分かりやすい1つの単語が良い。
      うーん。考えるに現在の名前が的確である。これの存在意義は $_ を保存するということ1点のみにある。
      序でに $? も保存しているがこれは続く epilogue で改めて保存し直すのでおまけである。
      そう考えると .save-last-arg が的確な気がしてきた (readline 関数に yank-last-arg がある)。

      →関数名は変更した。OK

    * exec:exec の方でも動作しているか確認する。

      確認した。実はそのままでも動いているようだ。
      関数内で実行しているのでそもそもそんなに出力の機会が多くはないようだ。

  * 2017-09-22 vi-mode: bug: isearch から C-c などで戻ると選択状態がそのままになる。 [#D0464]

    何らかの方法で選択状態を解除するようにした方が良いのでは。
    或いは、挿入モードのみで isearch をするのだとすれば、
    normal-mode など vi で追加した機能に対して
    全て選択状態をクリアするようにしても良い。

    取り敢えずのところは normal mode に入る時に選択状態をクリアするようにし、
    また他に類似の修正が必要であれば修正する。

    思うに今まで何故問題が起こらなかったのかというと、
    emacs の移動は全て marked/nomarked で登録していたからであった。
    vi-command は当然 nomarked を明示的に指定するということはしていないので、
    カーソル移動などをしても選択が解除されないのである。

    vi/vim mode ではビジュアルモードまたは選択モードのみで
    選択状態になるという制限を設けると考えることにすれば良い。
    或いは、_ble_edit_mark_active の時を選択モード・ビジュアルモードと解釈することにする。

  * 2017-09-15 cmplstofB: C-@ と accept-and-next に関する提案 [#D0463]

    C-@ を accept-and-next にすることについて考察する。
    これは README.md あたりに書くということでも良いかもしれない。

    →これは gh wiki に書いたのでよしということにする。

2017-09-22

  * vi-mode: r gr で次の文字を待つまでは overwrite で色をつけても良いのでは。 [#D0462]

  * 2017-09-11 vi-mode: text object: it, at [#D0461]

    t について調べる。

    どうやらちゃんとタグ名が一致するかどうかも見るようだ。
    また現在位置から左に < を検索して一番最初に当たったものについて、
    タグ名を読み取ろうとするようである。
    一番最初に当たったものが不正なタグで、
    それよりも前に正しいタグが合ったとしても失敗になる。
    タグの入れ子には対応している。

    引数を指定すると 2 つ外側のタグに行く。

    - 途中で不正なタグが存在する場合には、失敗する。
      目的地よりも外側に不正なタグが存在する場合には大丈夫。
    - 対応する終わりタグのないものは無視される
      (<br> などのためだろう。勿論、実際にはタグ名には関係ない)。
    - 途中に改行が入っていても問題ない。
    - <a> A <a> B <br> C </a> </a> </br> に対して、
      - <br> ... </br> は正しいタグということになる。
      - C の位置で 2yat とすると <a> B <br> C </a> になる。これは </br> がなくても同様
      - <br> の位置で 2yat とすると <a> B <br> C </a> になる。これは </br> がなくても同様
        このことから引数を指定したときに飛ばす始まりのタグに関しては、
        対応する終了タグがあるかどうかの確認を行わないということが分かる。
    - <a> A <b> </b> <c> </d> <p> </a> に対して、
      - A の位置で yat とすると全体を捕まえる。
        これにより同じ名称のタグしか数えていないということが分かる。
    - < a> hello </a> に対しては失敗する。
      つまりタグの形式は意外と厳密に調べられる。
    - <a href="<a"> helo </a> </a> を実行すると、
      中にある <a"> には決して引っかからない。
      <a href="<a"> helo </a> でひとまとまりであると認識される。
      href の位置にカーソルがある場合でも中の a の位置にカーソルがある場合でも同様である。
      エラーにもならない。

    | - <check x="
    |   <a href="<a "> helo </a> </a> だと <a "> に引っかかる。
    | - <!--<check x=" -->
    |   <a href="<a "> helo </a> </a> でも <a "> に引っかかる。
    | - <check x="
    |   <a href="<a"> helo </a> </a> だと <a"> には引っかからない。
    | - <a href="<a"> helo </a> </a> だと <a "> に引っかかる。

    →初めは <check x=" に続く引用符の入れ子を考慮に入れているのかと思ったが、
      実は全然関係なくて <a" だと引っかからないが <a "> だと引っかかるということの様だ。

    % 従って以下のような実装になるだろう。
    %
    % 1 引数の回数だけ繰り返し実行するようにする
    % 2 それぞれのステップでは先ず < を backward 検索する。
    %   次にその < のタグを読み取り、タグ名を取得する。
    %   もし正しいタグならば続ける。
    % 3 2 を引数の回数分だけ見つけたらそれが始まり。
    %   そこから forward に終わりタグを見つける。
    %   同じ名称のタグだけを数えて終わりタグを見つける。

    - <a> < </a> 改めて。"<a> " の何れかにカーソルがある時は成功する。
      "< " の何れかにある場合は失敗する。"</a>" にある場合は成功する。
    - <a> <> </a> これの場合には何処にカーソルがあっても成功して全体に一致する。
    - <a> <b> <c> </c> </b> </a> hello
      " hello" の上で yat すると失敗する。
      "</a>" の上で yat すると成功する。
      "</a>" の上で 2yat すると失敗する。
      "</b>" の上で 2yat すると "<a> ... </a>" に一致する。

    これから分かることは現在終わりタグの中にいる場合はそのタグに対応する始まりのタグを探すということ?
    更に、引数は始まりのタグを見つけてからそこから外側に向かって探索するということ。
    現在の < がタグとして成立していない時にはエラーになり、
    タグとして閉じてはいるが不正の場合は更に前の < を見つける?

    - <a> <b> <b> </c> </b> </a> において "</b>" の上で yat すると何故か "<a> ... </a>" が選択される。
    - "</c>" の上で yat すると "<b> </c> </b>" が選択される。
      これは <a> <c> <b> </c> </b> </a> としても同じ。
      <a> <b> <c> </c> </b> </a> とすればさすがにどこでやっても期待する結果になる。

    少なくとも正しいことは、タグ名は必ず対応するように取られるということ。
    どのタグが選ばれるのかという規則は不明。
    また <c> <b> </c> </b> で </c> にいるときに "<b> </c> </b>" にあたる事から、
    "終わりタグを先に確定させてからそれに対応する始まりのタグを見つける" という動作ではありえない。
    常に始まりのタグを先に確定させると考えなければならない。

    % - なんと <a> <b> <b> <c> </b> </a> で "</b>" でやると
    %   "<c> </b> </a>" が選択される。ついに異なるタグ名で一致する例が見つかってしまった。
    % と思ったら違った。次の行まで探索していって複数行で一致していたのだった。

    これは vim のソースコードを見るしかない。
    さて git clone した。何処に対応するコードがあるだろうか。
    ファイルを眺めてみたら tag.c というまさにそれっぽいファイル名があった。
    と思ったら駄目だ。違う。これは関係ない tag だ。
    "text obj" で検索してみると以下の 2 行しかない。

    ./normal.c:9023:    /* in Visual mode and after an operator "a" and "i" are for text objects */
    ./search.c:4501:             * target text object. */

    前者を見ると nv_object という関数を呼んでいる。
    nv_object の関数の定義は normal.c:9185 に存在する。
    というか vim はキー操作がハードコーディングされているのか…。
    何れにしても normal.c:9236 で current_tagblock という関数を呼んでいる。
    current_tagblock は search.c:3908 に定義が存在する。
    https://github.com/vim/vim/blob/0263146b5dbbb6c120ce2e7720256503b864425d/src/search.c#L3828-L4111

    実装を見るとたぶんこんな感じになっている:

    1 後退して <.*> を探す。ただしそれよりあとに </.*> があることが条件。
      この時点ではタグ名が一致しているかどうかについては問わない。
      細かい動作は do_searchpair の中を見ないと分からない。
      これを count 回繰り返す。もし途中で見つからなくなったら失敗。

    2 更にタグ名を読み取って (空なら失敗)、そのタグ名で do_searchpair を前進で実行し直す。
      これで終わりタグの位置を見つけることができる。
      見つかった組が現在地よりも前で終わっているときには更に後退する。
      恐らく do_seachpair は入れ子をカウントする仕組みになっているのだろう。

      # ところで search.c:4033 の r < 1 は制御の流れ的に
      # 絶対に満たされない気がするが…

    これにより今までの動作は大体説明がつくが以下の動作については不明

    - <a> <b> <b> </c> </b> </a> の "</b>" で yat すると全体に一致する。
      →あー。これは初めに <a> の直後の <b> が見つかって、
      その後で終わりの対応する </b> が見つからずに後退したという動作だ。
      これは理解できる。

    - <a> < </a> の "< " で yat → 失敗。"</a>" で成功する。

      うーん。謎だ。<a><</a> でも同様に駄目だ。
      →これは以下の in_html_tag 関数に依る処理が犯人だった。

    % タグの正規表現について調べる。うーん。謎。
    % これを見ても孤立した < で引っかかる要素がない気がする。
    %
    %   <[^ \t>/!]\+\%(\_s\_[^>]\{-}[^/]>\|$\|\_s\=>\)
    %   </[^>]*>
    %
    %   vim の正規表現は以下にあった。
    %   https://qiita.com/kawaz/items/d0708a4ab08e572f38f3
    %
    % うーん。ビルドして動かす?
    % ビルドして何処で失敗したかを調べると、一番最初の後退で失敗している。
    % つまり、正規表現で駄目…。分からない。
    %
    % その場で改めて do_searchpair を実行してみるとちゃんと一致する。
    % ということは何らかの理由で位置がずれているのか?
    % →curwin->w_cursor = old_pos; を直前に実行したら動いた。
    %   ということは 1 で後退する前にカーソルの位置が調整されていることになる。
    % →初めに < の中にいる場合には > まで移動するようだ。
    %   そうすると <a> < </a>★ の位置にまで移動する。
    %   ここで yat を実行しようとすると外側にタグが必要になるので失敗する。

    正規表現の問題ではなくて、最初にカーソルの位置を調整するというのの問題だった。
    in_html_tag 関数で判定が行われている。
    in_html_tag は現在位置の右が < か見て、或いは行内で <> を後退して探して判定する。
    つまり以下の手順を加えれば良い。

    0 現在の位置の右に < があれば html タグ内にいるとする。
      現在位置から行内で後退して [<>] を探して < があれば html タグ内にいるとする。
      html タグ内にいるときはそれが開始タグならば前進して > の直前まで行き、
      終了タグならば後退して < の直前まで行く。
      開始タグかそうでないかは次の文字が / かどうかで判定する。

    it の方の動作も調べる。
    - at のときと同じタグを捕まえる。
      終わりタグや始まりタグの上に載っていたとしても、
      その中身になる。つまり、初めのカーソルの位置を含まない形になりうる。
    - タグの内側にある空白・改行の類は削除されない。
      特に終わりタグの最後に改行があっても削除されないし、
      また改行が含まれていても linewise になることもない。


    [確認]

    vim のソースコードを見て動作が分かったので実装した。
    正しいタグの場合の動作の確認は行った。引数も確認した。
    次に今まで試した色々のケースをチェックする必要がある。
    以下に試すべきことをまとめる。

    以下 @ の位置にカーソルがあった時に yat をしたときの期待動作を示す。

    1 @<@a@aa@>@hello@<@/@a@aa@> → 全部成功
    2 <a> @A <b> </b> <c> </d> <p> </a> → 全体
    3 < a> @hello </a> → 失敗
    4 <a href="<a"> @helo </a> </a> → 最初から一つ目の </a>
    5 <a>@ < @</a> → 成功
    6 <a> @<@ </a> → 失敗
    7 <a> <b> <b> </c> </@b> </a> → 全体
    8 <a> <b> <b> </@c> </b> </a> → 二つ目の <b> から </b> まで

    早速 1 で引っかかった。一番初めの <aaa> の中で実行すると失敗する。
    →直した。開始タグの中にいるときに開始タグの終端に行く所、
    貪欲に全てのタグの終端に行っていた。

    他は期待通りに動いている。OK


2017-09-18

  * cmplstofB: vim-surround.sh: $( \r ) $(( \r )) [#D0460]

  * vim-surround: 実は ys の引数も / ./ の形式で指定できる。 [#D0459]

  * cmplstofB: vim-surround.sh: ds cs [#D0458]

    ds の振る舞いについて調べる → #D0456
    surround.vim と vim-surround.sh の実装の違いについてまとめる → #D0457

    cs の振る舞いについて調べる。
    引数は / ?./ の形式である。
    後は ys の時と同じな気がする。
    取り敢えず実装した。

  * vim-surround: ds 実装について surround.vim との違いについてまとめる [#D0457]

    以下の項目がある。

    * surround.vim には引用符に引数を指定した時のバグがある

      | "A "B "C D" E" F"
      |                ^
      | 2ds"
      |
      | "A "B "C D" " F" E

      | A "B "C" D"
      | ^
      | 2ds"
      |
      | A  C"B "

      vim-surround.sh では引数は無視することにした。

    * surround.vim には閉じ括弧が行頭にある時のバグがある。

      | (A (B (C
      | ) E) F)
      |
      | C の上にカーソルを置く。ds( とする。
      |
      | (A C F)

      このバグは以下で報告されているが取り込まれていない。

      https://github.com/tpope/vim-surround/issues/232
      https://github.com/tpope/vim-surround/pull/217
      https://github.com/tpope/vim-surround/issues/215

      vim-surround.sh ではちゃんと対応する括弧だけを削除する。

    * surround.vim ds* では現在位置より前に * がないときにバグがある

      | A *B*
      | ^
      | ds*
      |
      | A

      vim-surround.sh では ** 対の探索に失敗させる。

    * surround.vim では /* だけがあるときに失敗するが、カーソル移動する

      | /* hello
      |        ^
      | ds/
      |
      | /* hello
      | ^

      カーソル移動しない方が自然なので、vim-surround.sh では移動しない。

    * surround.vim では囲まれた部分が改行を含むときにインデントを行うが、
      vim-surround.sh では未対応である。その内に対応する予定。

    * surround.vim では ** や () を ds* や ds) で削除できないが、
      vim-surround.sh では削除できる。

    * surround.vim では /**/ においてカーソル位置が先頭にあると削除できないが、
      vim-surround.sh では削除できるようにする。

      | /* a */
      | ^
      |
      | /* a */
      |  ^
      |
      | surround.vim では ds/ で削除できない。

  * vim-surround: ds [#D0456]

    取り敢えず先に ds の動作を調べてそれを実装することにする。

    当初行内での削除に限られるようだと思ったが、
    これは ds に続いて入力する囲みの種類に依存するようだ。

    [引用符の時の動作について]

    | 2ds" は謎。3ds" としても同じ動作に見える。
    | 1つ目の " を残して、そこから2つ目の " までを削除するようだ。
    | 具体的な動作について調べる。
    |
    |   前
    |
    |   | "A "B "C★ D" E" F"
    |
    |   ds" 後 (これはOK)
    |
    |   | "A "B C D E" F"
    |
    |   2ds" / 3ds" / 4ds" 後 (謎)
    |
    |   | "A "C D" F"
    |
    |
    |   前
    |
    |   | "A "B "C D" E" ★F"
    |
    |   2ds" 後 (beep が鳴る) (謎)
    |
    |   | "A "B "C D" " F" E
    |
    |   →これは d2i" によって "...F" が削除された後に、
    |     カーソルが E の手前に移動してしまって、そこで空白を挿入し、
    |     更に削除するべき引用符が見つからずに beep を鳴らして、
    |     その後に改めて " F" が挿入されるということが起こった結果である。
    |
    |   前
    |
    |   | ★A "B"
    |
    |   ds" 後: これは理解できる。前方に見つけた " を先頭とする。
    |
    |   | A B
    |
    |   前
    |
    |   | ★A "B "C" D"
    |
    |   2ds" 後: これは理解できない。謎。そもそも順番が変わっている…。
    |
    |   | A  C"B "
    |
    |   →これは surround.vim の中で
    |   以下のような手順によって発生している。
    |     ★A "B "C" D"
    |     (d2i")     → A ★C" D" (clipboard = "B ")
    |     (i \ed2i") → A  C★
    |     (""p)      → A  C"B "
    |
    | よく分からない。これは surround.vim を読むしか無いのか。
    |
    | surround.vim を観察した結果、ds は dosurround を呼び出している。
    | cs も最終的には dosurround を呼び出しているが、
    | dosurround に対する引数の指定の仕方で cs と動作を変えている。
    |
    | さて、どうやら受け取った文字によって text-object または、
    | 独自の方法で範囲を計算・削除しているように見える。
    | " の場合には text-object i" を用いているようだ。
    | 恐らく 3ds" とすると、内部的には d3i" が呼び出されている。
    | 更に、その後で空白を一旦挿入して、それから再び da" を呼び出す。
    | 更に、その後で貼り付け p を行っている。
    | 何を貼り付けるのかの制御をどのようにしているのかは謎だが、
    | これは一番最初に切り取った内容をもとに戻しているということだろう。
    |
    | 結局 {count}ds" は exe 'norm! ""d'.count.'i"i \<Esc>d2i""p`[' に翻訳される。

    引用符に関する振る舞いについては surround.vim の中を調べることによって解決した。

    * Note: 問題は引数を指定している時には i" が a" と同じ動作になっていることにある気がする。
      →やはりそうだった。つまり、これは surround.vim のバグである気がする。
      これは報告したほうが良いのだろうか。

      これについては GitHub vim-surround の Issue には登録されていなかったが、
      Issue に大量のものが報告されて５つもそれらが放置されているのを見ると報告しても仕方がないだろう。
      これについては放置することにする。

    * done: 更にそれと共に現在の ble.sh の text-object で i" は引数を無視しているので修正したい→修正した。

    * done: また、注記すべきこととして 3ds2" などの指定の方法も可能のようであるということ。
      この引数の読み取りは surround.vim において inputtarget() という関数で独自に実装されている。
      つまり共通の枠組みとしてそういうものがあるというわけではないので安心して新規実装できる。


    [括弧の動作について]

    | 2ds) は二つ目の括弧と対応する括弧を削除する。
    |
    | と思ったら括弧の場合には同じ行内に見つからない場合には一番外側の括弧を削除する?
    | いや、何だか良くわからない。どうやら1つ目の () から 2つ目の () までを削除するようだ。
    | この場合は1つ目も 2つ目も削除してしまう。よく分からないので改めて試して整理していくことにする。
    |
    |   前
    |
    |   | (A (B (★C
    |   | D) E) F)
    |
    |   ds( 後
    |
    |   | (A (B C
    |   |     D E) F)
    |
    |   前
    |
    |   | (A (B (★C
    |   | ) E) F)
    |
    |   ds( 後 → これは謎である。
    |
    |   | (A C F)
    |
    |   →これも分かった。
    |
    |     (A (B (★C
    |     ) E) F)
    |
    |     (A (B ★(
    |     ) E) F)
    |
    |     (A (B★ (
    |     ) E) F)
    |
    |     (A ★ F)
    |
    | どうやら ds( は以下に翻訳されるようだ。
    |
    |   norm! ""di(
    |   call search('\m.', 'bW')
    |   norm! da(""p`[
    |
    | ここで行末になった時に問題が生じる。
    | norm! ""ci(\<Esc> とすれば一文字戻る必要があるときにだけ戻るし良いのではないだろうか。
    | というかそもそも戻る必要はあったのだろうか?
    |
    |
    | 次に 3ds( とすると3階層目の括弧が削除されるものの、中身がインデントされる。
    |
    |   前
    |
    |   | (A (B (C
    |   | ) E) F)
    |
    |   3ds( 後
    |
    |   | A (B (C
    |   |      ) E) F
    |
    |   前
    |
    |   | (A (B (★C
    |   | )
    |   | E) F)
    |
    |   3ds( 後
    |
    |   | A (B (C
    |   |      )
    |   |                 E) F
    |
    | うーん。これはインデントの規則さえ分かればそんなにはおかしくはない気がする。
    | あと、明示的にインデントを調整している箇所があるのだろうか。うーん。
    | どうも surround.vim の中に call s:reindent() という行がある。これだろう。
    |
    |
    | 後実装を観察していて思ったのだが、行末にある括弧で ds( を実行するとずれる気がする。
    |
    |   前      | A(★B)
    |   ds( 後  | AB
    |
    | あれ。正しい結果になっている。pP の切り替えによるものか。
    | よく考えたら p は後ろに挿入するもので、P が前に挿入するものだ。
    | なので p を使っている限りはこれは大丈夫。
    | 恐らく判定も大丈夫。念のため試す。
    |
    |   前      | (★A)B
    |   ds( 後  | AB
    |
    | 正しい結果になっている。問題ない。

    * done: 先ず yi( は囲む対象の末端が改行の場合はその改行は含まない。
      これは現在の ble.sh の振る舞いと異なる。修正が必要だ。
      これには対応した。

    * note: 更に surround.vim は 1 文字戻るといって戻っているところが怪しい。
      これもバグなのだろうか。

      報告しようと思って GitHub の vim-surround に行ったら、
      大量の Issue と PR が溜まっている。vim-surround は駄目だ。
      そして既に報告されていた。

      https://github.com/tpope/vim-surround/issues/232
      https://github.com/tpope/vim-surround/pull/217
      https://github.com/tpope/vim-surround/issues/215

      つまりこれはバグだと思って良いだろう。

    * done: 文字が [ ( { < T の何れかのときには前後の空白を削除する。

    * note: surround.vim では改行が絡むとき s:reindent を呼び出している。
      これにより括弧の階層によってインデントが付加される。
      これは 3== を実行した時と同じ結果になった。
      つまり = によるインデントを実装しておけばただそれを呼び出すだけである。

      →これについては別項目で議論することにする。

    更に以下の機能もある。これらは今既に実装した分のテストが
    終わってからにするのが良いだろう。

    * done: / を指定すると /**/ を捕まえる。
      cs の第2引数に / を指定した場合は単に / で囲む。

    * done: 他の文字を指定すると行内で検索する。引数は認識しないようだ。

    [実装]

    * done: 取り敢えず実装した部分 ds(text-object) の動作確認をする。

      ds" を試したが動かない… → 直した。
      exclusive-range.impl の終了ステータスが問題だった。

      2ds( は動いている。

      ds( において空白がある場合に中身が消えてなくなる。
      → ble/string#trim の誤りだった。直した。

      ds( と ds) の振る舞いの違いは正しく動いている。
      2ds( と 2ds) も動いている。

      2ds" もちゃんと ds" と同じ動作になっている。
      2ds " と 2ds" の違いも動いている。

      wW は何も変化が起こらない筈である → 宜しい。
      これは csw/ などでテストするべきである。

    * done: / を指定した時の動作を実装する。

      動作を調べると先ず、★/★**/ の ★の位置にいるときに ds/ としても効かない。
      また、それ以降の位置にいればいつでも効く。
      /**/ の外側にいても効くし、更に次の行にいても効く。
      恐らく現在位置以前の最近の /* を先ず初めに探して、
      その後で対応する */ を見つけるのだろう。

      () との対称性を考えると先頭にいるときでも見つけられるようにして良いのではないか。

      surround.vim では arg は最初の /* を見つけるときに ({arg}[/ として) 使っているようだ。
      ということは [/ の振る舞いを調べてから実装した方が良い。
      vimindex に載っている (vimindex の後方・前方は分かりにくい。forward/backward の訳と考えれば分かる)。
      これを見ると引数は N 個前の /* を見つけるという意味に解釈されるようだ。

      [/ の振る舞いを調べてみると引数の数より少なくしか見つからない場合には、
      一番最後に見つかったものに一致するようだ。
      つまり現在の ble/string#last-index-of ではなくて正規表現を用いた実装にするべきである。

      実装した。

    * done: / の動作確認を実行する。

      ds/ としてもエラーになる → 直した。古いコードが残っていた。
      しかし変な部分が消される → end の計算を修正した。2 足し忘れていた。
      2ds/ とすると期待通りに動く。2ds / の方も期待通りに動く。
      取り敢えず OK

    * done: 次に行内の文字検索を実装する。
      先ず初めに backward search で文字を見つける。
      次に forward search で文字を見つける。

      surround.vim は変な動作しかしないので模倣は諦めた。

      取り敢えず実装した。

    * done: ds* の動作確認をする。

      *★* を ds* で消そうとしたが消せなかった。
      これは _ble_edit_ind+1 から last-index-of で検索しているために、
      2文字目の * を最初の文字と勘違いすることによって起こっている。
      先ず初めに現在のカーソル位置が開始に含まれているかどうかを確かめて、
      その後で _ble_edit_ind+1 から backward 検索するべきだ。

      と思ったが問題はそういうことではない気がする。
      問題は +1 してしまうことによって図らずも終端の文字を拾ってしまう事にある。
      しかし何故そもそも +1 していたのかを考えると、
      現在位置が元から開始文字に含まれている場合を考慮してのことである。
      うーん。初めに現在位置が開始位置に含まれているかを確認し、
      そうでなければ +${#del} するというようにするのが正しい?

      例えば del が3文字あるとする (現状の実装では1文字のはずだが汎用性を持たせるため)
      この時、調べなければならない範囲は現在位置より (3-1) = 2 文字手前の位置から、
      現在位置より 3 文字あとまでである。

      うーん。本質は「現在位置より forwad 方向に対しては index-of で、
      現在位置より backward 方向に対しては last-index-of」で検索するということだ。

      | del="===" だとする。以下 ^ をカーソルの位置とする。
      |
      | ===== hello === ... この場合は色々な解釈方法が可能である。
      |   ^
      | ====== ... この場合は可能性としては "===" + "==="と解釈するしかない。
      |   ^        できるだけ組を見つけられるようにするには ind-(${#del}-1) から検索するのが良い。

      →対策した、と思ったら動かない。よく考えてみたら本質と違うことを考察していた。

      問題は、現在開始文字の上にいるときではなくて、
      現在終了文字の上にいるときに起こるのであった。
      うーん。ということは base を ind - (${#del}-1) にするのではなくて、
      ind - (2*${#del} - 1) にすれば良いということなのだろうか。。
      うーん。色々曖昧性はあるけれどもその実装が妥当に思われる。

      と思ったら、今度は *hello★* において ds* が使えなくなった。駄目だ。
      これの場合 * を開始位置と勘違いしている。本来は終端位置と捉えるべきである。

      うーん。手順を逆転するべきだろうか。
      先ず初めに line::ind に対して検索を実行し、
      もし見つからなかったら、前方に検索を実行する。
      これを直したら、雰囲気動いている気がするので良いことにする。

    * Note: 以下も surround.vim のバグである。

      | というか以下のようになる。この動作はおかしい。
      | 前     | ★A *B*
      | ds* 後 | ★A

    * Note: あと surround.vim は /* が孤立して存在するときに
      ds/ とすると / の位置にカーソルが移動してから失敗する。
      元の位置には戻らない。

    * Note: surround.vim では ** の様な空の場合には認識されない。
      これは () で試しても同様だった。
      ble.sh の実装では () や ** も削除できることにしたい。

    * done: surround.vim との動作の違いについて纏める。
      これは vim-suround.sh のコメント内に書けば良いだろう。

  * cmplstofB: テキストオブジェクトに対する c の振る舞い [#D0455]

    | テキストオブジェクトに対する c (削除後挿入モードに移行) が、 d と同じ振舞いになります。

    本当だ…。何故だろう → vi_omap を追加したのに .insert-mode でそれが pop されていないのが問題だ。
    今までは adjust-command-mode でそれを調整していたが、.insert-mode を先に実行すると駄目なのだ。
    今回は対策として .insert-mode の中で vi_omap を pop するようにしたがこれが正しい解決法かは分からない。

    本来であれば vi_omap に紐付けられたコマンドについては全て実行直前に vi_omap を pop するのが良さそうだが。
    但し __before_command__ で pop する訳には行かない。引数などの場合には pop しないからである。
    結局 adjust-command-mode を呼び出しているのと同じタイミングで vi_omap を pop する必要があるのである。
    しかし、現状では adjust-command-mode に先立って .insert-mode が呼び出されることがあり問題になった。

    - 一般に keymap に関連するコマンドにおいてこのような不整合が生じる。
      取り敢えず keymap を push, pop しているところに関しては確認した。

    - 更に ble-decode-key などで新たなキーを処理したりしている場合には、
      vi_omap を pop した上で ble-decode-key を呼び出す必要があるのではないかという気がする。
      そのような事をしているコマンドは現状では… __default__ と、vi-insert の中のコマンドのみである。
      今の所は問題がないが、実のところ将来的に不意に追加してしまう危険性もある。

    うーん。原則を考える必要がある。先ず問題が発生するのは omap 周りだけである。
    omap に登録されているコマンドは 引数・motion・text-object・set-operator である。

    - 引数の場合はそのまま透過して良い
    - motion の場合は基本的には最終的に adjust-command-mode する。
      但し、その前に c (.insert-mode) などを実行すると normal mode になってしまって駄目。
    - text-object は motion と同様である。
      ただ、これは omap にくっついているのでそんなに意識しなくても変な改変はしないと思う
    - set-operator
      これは既に vi_omap にいるのに更に vi_omap を積み重ねる危険性がある。
      実際には _ble_edit_arg の中身の状態が vi_omap と対応しているはずだから起こらないはずだが、
      何らかの拍子に変なことになるかもしれないということである。
      念のためチェックをしてから vi_omap を積み重ねるようにする。

2017-09-17

  * vi-mode: imap C-k [#D0454]

    ところで C-k は元々 (readline でも) kill-line だったところを digraph にしてしまってよかったのだろうか。
    そもそも digraph を使う機会なんてそんなになさそうだし、kill-line の方が便利なのではないだろうか。
    これはやはりマニュアルに記述して、実際には対応しないという方法のほうが良いのではないだろうか。

    bash が C-k を kill-line にしているので、やはり C-k は kill-line であるべきだ。

  * cmplstofB: f が失敗した時にも検索を記録する。 [#D0453]

    更に提示された :help f を見ると digraph や Unicode 結合文字にも対応しているようだ。

    | digraph には対応できるけれども、Unicode の結合文字についてはそもそも現状の ble.sh の枠組みで取り扱えていないので駄目。
    | さて digraph http://vim-jp.org/vimdoc-ja/digraph.html を参照すると普通のアルファベットの組で digraph が登録されている。
    | 更に :help r などを参照してみるとこれも digraph を受け取るようになっている。
    | :dig を参考に試しに rNU として見たが、N が入力されて "U" によって undo されてしまう。
    | 引数に指定する場合には digraph-arg というのを参照しなければならないということか。
    | と思ったら C-k に続いて入力しなければならないようだ。
    |
    | さて、digraph に対応するにはどうしたら良いか。
    | _ble_decode_key__hook だと問答無用で一文字だけ取ってしまうので駄目だ。
    | 或いは、_ble_decode_key__hook のチェーンを作って無理やり処理するか。
    |
    | それよりは cmap を登録した方が良い様な気もする。
    | しかし個別に登録すると大変である。
    | といっても結局はテーブルを作って処理することになるのだから、
    | 余り変わらないのかもしれない。
    |
    | 或いは新しい keymap を追加してしまうことにするか。
    | と思ったら、よく考えると :help f に lmap が効くと書かれている。
    | lmap と言っているのは lang-arg といっているもので、
    | もしかするとこれが一文字引数を受け取るための keymap なのではないだろうか。
    |
    | 更に vi_digraph のような感じの keymap を用意するのが良さそうだ。

    先に digraph に対応してから考える。対応した。

    fFtT については取り敢えず修正だけ先に行う。
    その後で digraph の対応について考える。
    当初は一文字読取るだけのために lmap なる keymap を作成する事を考えていたが、
    よく考えてみると C-k に対応するだけであれば
    別に fFtT 内で vi_digraph keymap に入れば良いだけのような気もする。

    →結局 aread-char-arg という仕組みを整えて
    fFtT 及び r gr はこれを呼び出すことにした。
    現在のところ動作している。

  * vi-mode: digraph 対応 [#D0452]

    先に #D0453 で考察したように keymap を生成するのが良いだろう。

    digraph の一覧は http://vim-jp.org/vimdoc-ja/digraph.html を wget して加工する。
    HTML 実体参照 (&nbsp;&lt;&gt;&quot;) を戻して適当に列を切り出す。
    keymap/vi_digraph.txt に保存した。

    vi_digraph の keymap は巨大なので vi.sh が更新される度に再生成するのは損である。
    という訳で vi_digraph.sh に分離して頻繁に更新しなくても良いようにする。
    通常文字にしか依存しないので [[ $fname_keymap_cache -nt $_ble_base/cmap/default.sh ]]
    のキャッシュ更新用のチェックも外して良いだろう。

  * 2017-09-04 vi-mode: 全てのキー入力を横取りできているかどうかを確認する [#D0451]

    → bind -p, bind -s, bind -X を見る限りは大丈夫に見える。

  * 2017-09-11 vi-mode: by cmplstofB [#D0450]

    | 複数行編集において、最初の行を削除した後に移動モードが機能しない。

    これは分からない。再現しない。

    2017-09-17 取り敢えず現在は再現しないということ。

    | これは 1b9e2a4 において発生しませんでした。ありがとうございます。

    本当に解決したのかどうかは謎だが、取り敢えずは解決したことにする。

2017-09-16

  * dd の引数が効かなくなっている。 [#D0449]
    これは勘違いで追加した行が原因だった。

  * vim-surround.sh において bBra は )}]> の aliases である。 [#D0448]

  * vim-surround.sh について C-] / C-} に対応する。 [#D0447]

  * cmplstofB: vi-mode ysiw" [#D0446]

    | 更に ysiw" は体系としてかなり謎である。
    | と思って vim で試してみたら動かない。ys まで打った時点でエラーになる。
    | もしかしてビジュアルモードの機能なんだろうか。と思ったけれどそうでもないようだ。
    | 調べてみると surround.vim というのがあるようだ。拡張?
    | そうだとすると恐らく "ys" に対して直接 bind しているのだろうと理解できる。
    | - [surround.vimの使い方 | Memo on the Web](http://motw.mods.jp/Vim/surround.html)
    | - [What does the "y" stand for in "ysiw"? · Issue #128 · tpope/vim-surround](https://github.com/tpope/vim-surround/issues/128)
    |
    | でもそれをやると "yy" がその場で実行されなくなる。"yy" に対しても同時に bind することを考慮する必要がある。
    | が、もっと体系的なやりかたはないのだろうか。
    | →よく考えたら "y3y" などにも対応しなければならないので単に "yy" に bind するだけでは駄目だ。
    |
    | surround.vim を除けば i の直後には引数などが来る余地はないようなので (試した)、
    | 単に次のキーを一つ読み取るという具合にすれば良い。下手に keymap を追加すると
    | insert-mode で単に ble-decode/keymap/pop などとしているのがずれて問題になるので、
    | 下手に insert-mode を呼び出せない (もしくはその追加した keymap に追加する widget では必ず最初に pop をすれば良い?)。
    |
    | 取り敢えず入れてみた。結局日本語のページは古くて使い物にならなかった?
    | よく分からないので surround.vim 本家に書かれている方法でインストールした。
    |
    | | surround.vim インストール
    | |
    | | $ mkdir -p ~/.vim/autoload ~/.vim/bundle && curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim
    | | $ (cd ~/.vim/bundle && git clone https://github.com/tpope/vim-sensible.git)
    | | $ (cd ~/.vim/bundle && git clone git://github.com/tpope/vim-surround.git)
    | |
    | | ~/.vimrc に以下を追記
    | |
    | |   execute pathogen#infect()
    | |   filetype plugin indent on
    | |
    | | vim を起動して以下を実行
    | |
    | |   :Helptags
    | |   :help surround
    |
    | 試しに y3y としても問題は起こらない。ysiw" も動いている。
    | 更に y3ys でも y3y + s と解釈されているようだ。
    | どの様に処理しているのかは気になる。中を覗いてみる。
    |
    |   nmap ys  <Plug>Ysurround
    |
    | という所が怪しい。更に、Ysurround は以下の行にしか現れない。
    |
    |   nnoremap <silent> <Plug>Ysurround  :<C-U>set opfunc=<SID>opfunc<CR>g@
    |   nnoremap <silent> <Plug>YSurround  :<C-U>set opfunc=<SID>opfunc2<CR>g@
    |
    | どうやら opfunc=... となっているのでオペレータとして実装されている?
    | 更に s:opfunc, s:opfunc2 という関数が内部で実装されているので、これが本体だろう。
    |
    | しかしやはり ys から直接束縛している。そして問題は起こっていない。
    | これが意味するところは nmap に対する設定は、
    | オペレータが設定されている時の動作には影響を与えないという事である。
    |
    | 後気付いたことは引数を認識していない気がするという事。
    | 2ysiw" も ys2iw" も変わらなかった。
    | 更に y2s はエラーになったのでやはり "ys" の組で登録されているという事。
    |
    | うーん。調べると nmap (normal-mode map) と
    | omap (operator-pending mode map) という二種類のモードに対する map が存在して、
    | 更にそれぞれ独立に設定を行うことができるようだ。
    | 更に同時に設定ができるコマンドも用意されている。
    |
    | うーん。vi_omap を新しく導入することにするか。
    | 何が必要か。keymap を作ること自体はそんなに難しくはない。
    | さて問題なのは元の状態に戻るというのをどのように実装するかだ。
    | check-single-command に類似のものを更に用意しなければならないのか。
    | と思ったが、check-single-command に追加の実装をすれば良いだけの気もしてきた。
    |
    | 後、念のため現在のモードの表示については vi_omap も vi_command と同じ扱いにするという事。

    [結論] vim には nmap の他に omap という独立した keymap が存在して、
    それぞれ独立に設定を行うことができる。ble.sh の実装でもこれにならう必要がある。

    http://vim-jp.org/vimdoc-ja/map.html
     \_ map           ... normal, visual, select, operator-pending
     |   \_ nmap      ... normal mode
     |   \_ vmap      ... visual/select mode
     |   |   \_ smap  ... select mode
     |   |   \_ xmap  ... visual mode
     |   \_ omap      ... operator-pending mode
     \_ lmap          ... lang-arg, insert, commandline
         \_ map!      ... insert, commandline
             \_ imap  ... insert
             \_ cmap  ... commandline

    ys は nmap にだけ設定を行う。これにより yy などと矛盾しなくて済む。

    [変更]

    * done: 先ず初めに omap を追加する必要がある。

    * cancel: 次に外部ファイルを読み込む仕組みを整える必要がある。
      或いは、取り敢えずは単に source "$_ble_base/lib/vim-surround.sh" を実行してもらうか。
      結局現状では ble-source または ble-import を実装するとしても $_ble_base/lib を前置するぐらいしかない。
      直接指定してもらうので問題ない気がする。

      いよいよ ble-import などが必要になるのは複数のライブラリの間で依存関係が合って、
      更にそれぞれのライブラリを何処にインストールしているかを事前に決定できないときである。
      現状では全て $_ble_base/lib に放り込むので問題ない。

    * done: 取り敢えず ys/yss だけ実装する。実装した。

2017-09-15

  * vi-mode: operator: < > [#D0445]

    オペレータの >< の動作について調べている。
    次の行の非空白行頭に行くときは前の行に範囲が縮まる。
    非空白行頭よりも後に行くときはその行も処理対象に含まれる。
    現在よりも前の行に移動するときはどうだろう。
    前の行の最後の文字に移動する時は、前の行も含まれる。
    現在の行は現在の行の行頭にいたときには対象にならない。
    現在の行の非空白行頭にいたときは対象になる。

    < > で行頭の8空白はタブに変換される。
    また [空白][タブ] となっていると表示上はタブ一個と変わらない。
    この時に < > を実行するとはじめにあった空白は消える。
    つまり、最初に "表示" に従って全てタブに変換されてしまうようである。

  * 2017-09-08 vi-mode: ~ [#D0444]

    大文字小文字を変換する。ydc の引数には対応していない。
    また変更範囲に大文字と小文字が混在している場合には、
    それぞれの文字について大文字・小文字を反転する。
    同じ行内で移動する。

    2017-09-15 要望が入った by cmplstofB

    移動先は l と同じ扱いで良いのだろうか。試してみた限り同じように見える。
    但し一番右に行ってカーソルが動かなかったとしても bell は鳴らない。

  * cmplstofB: iw aw の違い [#D0443]

    これは対応したつもりで対応できていなかったと思ったが、
    改めて調べてみると aw の動作は思っていたよりもずっと複雑だった。

    - 先ずカーソルの位置が空白の場合にはそれに続く単語の末端までを範囲とし、
      このとき単語に後続の空白は含まれない。引数が複数ある場合についても同様である。
      一番最後の単語に後続の空白は含まれない。先頭の空白には改行が含まれていても良い。

    - 一方で、カーソルの位置が単語の内部にある場合には、
      一番最後の単語に後続の空白は含まれる。
      また後続の単語に改行は含まれない。

    これに基いて正規表現を改定する。

2017-09-13

  * ble-edit: 補完候補の表示で座標計算がずれる。 [#D0442]

    info を通して表示しているはずだから、info 周りの座標系参加 ble-form#panel が悪い。
    これは書き換えのケアレスミスだった。

  * ble-edit: info が表示されているとき一番下の行で、上の行に侵食する。 [#D0441]

    ind の数が足りていないのではないかという疑惑がある。
    と思ったら set-height の方では ind していたけれども、
    set-height-and-clear の方では ind するのを忘れていた。追加した。

2017-09-12

  * ble-edit/info が一番下の行で消える問題 [#D0440]

    ターミナルの一番下にいる時に C-q C-j で本体の行数を高くした時に info が消える。
    これは、render/update が info の高さを認識していないということと、
    行数が変わった後に info を再描画していないことのどちらかまたは両方がいけない。

    本来どのようにするべきかはもう少し考える必要がある。
    render/update は描画領域を確保するために IL してから NL を行数分発行する筈である。
    この時、 IL で一番下の行に表示されていた info は消滅する。
    行数が変化した時には info も再描画すべきなのだろうか。
    だとするとそもそも IL して表示を消さないようにしていた意味がなくなる。
    表示が消えないことを保証できないということなのだから。

    うーん。現在のレイアウト (種類+行数のリスト) を管理するための仕組みを追加するほうが速いかもしれない。
    これは将来的なレイアウト管理への布石にもなる。取り敢えずファイルを追加してみるのが良い。

    ble-form.sh を追加した。取り敢えずすこしずつ機能を移行していくことにすれば良い。
    先ずは高さに応じた領域を確保すること。

    取り敢えず簡単に実装した。ble-edit.sh も大分すっきりしたような気がする。

  * ble-edit: 新しく追加した関数の ble-edit/text/find-* という関数名は正しくない。 [#D0439]

    今調べた所、従来の配置計算のための ble-edit/text/* という関数群は、
    _ble_edit_str とは独立に動作する物であった。
    つまり、他の文字列の配置計算にも転用できるようになっているのである。
    (ただ、その為にはどの変数に結果が格納されるかなどの情報をちゃんと調べて、
    それらの変数を対比する仕組みも作る必要があるが。)

    従って、_ble_edit_str に対して様々な情報を取り出すための
    新しく追加した関数群には別の名前をつけるべきである。
    既存の関数を観察すると _ble_edit_str に対する操作は、以下の様になっている。

    - _ble_edit_str.*
    - _ble_edit_str/*
    - ble/widget/*

    今回の場合は特に公開する編集関数に直接に紐付いたものではないので、ble/widget/* は適当ではないだろう。
    一方で、_ble_edit_str.* のような関数名は他の関数との整合性が取りにくいので本当は廃止したい。
    しかしながらこれは大きな変更になると思われるから、取り敢えずはそのままが良いのではないか。
    というか、_ble_edit_str だけでなく _ble_edit_ind にも関わってくる関数の場合は、
    やはり _ble_edit_str.* は余り良くないのではないだろうか。

    後でよりまともな関数名に変えるとしたらどのようなものになるかについては今此処で考えておく。
    比較のために既存の他のモジュールの名前も考慮する。


    | ble-edit/prompt : これは _ble_edit_PS1 を元にプロンプトを更新する仕組み。
    |
    |   内部状態の記録に使用している変数は恐らく以下のみである。
    |
    |   _ble_edit_prompt=("" 0 0 0 32 0 "" "")
    |
    |   参照している変数は以下の通りである。更に、他にも様々なシェルの状態をを参照している。
    |
    |   _ble_edit_PS1
    |   _ble_edit_LINENO
    |   _ble_edit_CMD
    |
    |
    | ble-edit/text : これは文字列の中の文字の配置情報を計算・キャッシュする仕組みである。
    |   外部から初期位置 (プロンプト末端の座標) と文字列を受け取って配置情報を計算する。
    |   内部状態の記録に指定している変数は以下の通り。
    |
    |   _ble_line_text_cache_pos=()
    |   _ble_line_text_cache_cs=()
    |   _ble_line_text_cache_ichg=()
    |   _ble_line_text_cache_length=
    |
    |
    | ble/widget : これは ble-decode の ble-bind から使うことを想定した関数群をいれておく場所である。
    |   ユーザが自由にここに関数を追加して良い。但し、実際には更にshチアの階層を作って使うのが望ましい。
    |
    | _ble_edit_str : これは実際の編集文字列の管理をするところ。
    |
    |   _ble_edit_str=
    |   _ble_edit_ind=0
    |   _ble_edit_mark=0
    |   _ble_edit_mark_active=
    |   _ble_edit_overwrite_mode=
    |   _ble_edit_arg=
    |
    |   _ble_edit_dirty_draw_beg=-1
    |   _ble_edit_dirty_draw_end=-1
    |   _ble_edit_dirty_draw_end0=-1
    |
    |   _ble_edit_dirty_syntax_beg=0
    |   _ble_edit_dirty_syntax_end=0
    |   _ble_edit_dirty_syntax_end0=1
    |
    |   _ble_edit_kill_ring=
    |   _ble_edit_kill_type=
    |
    |   _ble_edit_line_disabled=
    |
    | ble-edit/render : 編集文字列の表示にまつわる機能
    |
    |   これは雑多な他の機能をまとめて描画を行っているところ。
    |
    |   _ble_line_cur=(0 0 32 0)
    |   _ble_line_x=0 _ble_line_y=0
    |   _ble_line_begx=0
    |   _ble_line_begy=0
    |   _ble_line_endx=0
    |   _ble_line_endy=0
    |   _ble_edit_dirty=-1 -> _ble_line_dirty に改名
    |
    |   _ble_edit_render_caret_state=
    |   _ble_line_cache=()
    |
    |
    | ble-edit/info : 追加情報を表示するところ。
    |
    |   これは更に ble-edit/render の管理外で、
    |   ble-edit/render の表示内容の下に表示を行う。
    |
    |   _ble_line_info=(0 0 "")
    |   _ble_line_info_default=(0 0 "")
    |   _ble_line_info_scene=default

    どうも変数名は _ble_line_* と _ble_edit_* が混ざり合ってしまっているが、
    関数に関しては ble-edit に統一されているように見える。

    うーん。ble-edit/content にするのが良いような気がしてきた。
    →変更した。

    更に、ble-edit/text は ble-edit/layout にするのはどうだろうか。
    と思ったが、将来的には pane の配置も考えたいので、単に layout というのは余り好ましくない。
    しかしだからと言って ble-edit/text-layout というのも長い。
    更に ble-edit/text は配色情報のかんりもしているし、
    ble-highlight-layer の呼び出しも行っている。
    つまり、単にレイアウトというよりは文字列描画一般の機能を担っている。
    ble-edit/textbox だとか ble-edit/text-rendering だとかそういうのが適切だ。
    うーん。然し実際に描画をおこなっているのは ble-edit/render の方である。

    うーん。色々考えると現在の構成は割りと現実的になっている。
    本来は以下のようになっているべきなのだ。

    presentation : form
     \_ textarea : control
     |   \_ content : ble-edit/content
     |   \_ prompt : ble-edit/prompt
     |   \_ layout : ble-edit/text
     |   \_ render : ble-edit/layout
     \_ info : control

    この話は別項目として切り離す事にした。

  * ble-edit/info/default [#D0438]

    実はその場で表示しなくても良いのではないだろうか。
    一回のコマンドの中で複数の書き換えがあった場合にちらつきが気になる。
    default は常に bind/.tail で更新するように修正することにした。

  * vi-mode: operator ydc... 再編 [#D0437]

    このページを見るとどうも ydc に対してどの様に動作するかというのはいくつかの種類があるようだ。

    - linewise
    - characterwise inclusive
    - characterwise exclusive

      "移動後に列1" のとき前の行の行末に移動する。

      →これは w で試したが再現しないと思ったが、dw cw とやると確認できる。

      "最初に first-non-space またはその直前にいて、移動後に同じ行の列1" のとき行単位になる。

      →これは h で試してみても再現しない気がする。
        exclusive-linewise とマークされているコマンドだけという事か。

    現在の実装を調べてみると inclusive/exclusive の区別がついていない。
    改めてどの様な振る舞いの違いが起こるべきかをマニュアルで見て、
    更にそれを実際に動かして見てそれから判断する必要がある。

    どうも inclusive/exclusive の違いは ydc で処理する範囲の取り扱いのようである。
    exclusive だと終端の文字は対象ではなく (境界指向)、
    inclusive だと終端の文字も対象になる (文字指向)。
    殆どが exclusive であるが fx tx が inclusive である。
    vi.sh を読んでみたが対応していないように見える。と思ったら対応している様に見える。何故?
    と思ったら以下の行によって対応されているようだ。

      [[ $flag ]] && ((index++))

    これで良い理由は以下の通り。

      $flag がある場合には先頭に移動するか (y)、
      そもそも範囲内の文字列を削除 (c d) するので移動しなくても良い。
      なので index を弄ってしまっても問題ないのである。

    では、新しいオペレータを追加してもこの方策で良いのかというのは疑問である。

    - g~ gu gU g? → 先頭に移動する。
    - ! > < → これは行を丸ごと変更して先頭に移動する。
    - = も ! と同じと思われる。
    - zf も行単位である。但し複数行以上の場合でないと無効。
    - gq g@ は分からない。gq は行単位の疑いがある。
    - g@ は見ると行単位か文字単位か矩形単位かは文脈で変わる (恐らく y や g~ などと同じ)。

    どうもこれで問題ない気がする。
    つまり inclusive のときは $flag が立っている時に終端を ++ する。

    何れにしても現在の実装では operators の処理を個別に実装しすぎている。
    これらの実装を統合したい。

    1 先ず inclusive-goto-char.impl を exclusive-goto-char.impl に対する補正として実装する。
    2 次に forward-eol の実装については inclusive-goto-char.impl に置き換えた。
    3 更に common-goto-line と .relative-line と .relative-first-non-space は実装が似る。
      これらを統合することを考える。

      いきなり全体をくっつけることができるのかどうかは不明なので、
      取り敢えず $flag が立っている場合だけを統合することを考える。
      特に三者から呼び出すことのできる共通の関数を定義することが目標になる。

    滅茶苦茶に書き換えたので改めて各コマンドについて動作確認する必要がある。
    チェックが必要なのは ^-+jkHLG である。
    それぞれについて ydc と組み合わせての確認も必要である。
    更に ftFTeE$ も inclusive の動作について確認が必要である。

    確認事項 preserve_column require_multiline
    確認済み H L yH dH c2L
    確認済み j k yk dk ck yj dj cj
    確認済み + - y+ y- d+ c+ d- c-
    確認済み ^ $ d^ c^ y^ c$ d$ y$
    確認済み e ce ye de
    確認済み fx yfx cfx dfx tx ytx

    恐らく問題ないだろう。

2017-09-11

  * ble-edit: stty sane をしなくて済む方法? [#D0436]

    ble-edit/bind/.check-detach を見ていて思ったこと…
    もしかして stty sane はシグナルハンドラで実行すれば良いのではないだろうか。
    これは後で試してみる。

    どうも試してみると stty sane を実行しなくても問題ないようになっている気がする。
    それよりも、readline が PS1 が体と思っていることによる表示のずれがあるので、
    何でもいいからコマンドを一回実行する必要があった。
    stty sane はそれを実行させるための茶番の様だ (当初は意味もあったのだろうが)。

    面倒だし ble-detach することも余りないだろうから、
    これはこのまま茶番として残しておく。

  * clear-screen 直後に info が表示されない。 [#D0435]

    直した。

  * vi-mode: C-o の復帰位置 [#D0434]

    現在のアルゴリズムは以下の通りである。

    - コマンド実行直後の位置 (eol 補正される前の位置) で復帰する。

      Note: p, P の "eol 補正" は挿入文字列の末端から最後の文字に移動するものである。

    - C-o 時点での位置が行末であり、コマンド実行直後の位置が最後の文字のとき行末に移動する。

    以下の動作は現在再現している。

    - 同じ長さの行が並んでいるとき、$ i C-o k は最後の文字であり、A C-o k は行末である。
    - A C-o y l で行末に行く
    - 6文字の行で A C-o 6 | とすると行末に行く
    - A C-o r 8 で行末に行く

    しかし以下の動作は再現していない。

    - 空白だけの行で A C-o ^ とした時の位置は (行末ではなく) 最後の文字でなければならない。

      Note: ^ は空白だけの行において最後の文字に移動する。

    色々試すと first-non-space (^ + - や行単位の p P など) は例外のようである。
    取り敢えず個別規則ではあるが追加した。
    他にも何か vim との振る舞いの違いがまだあるのではないかと思われるが、
    それらは発覚してから対処するということにする。

  * 初回起動時の INSERT がずれるようになった。何故? [#D0433]

    ble/widget/vi-insert/.attach で呼び出すのは default ではなくて set-default であるべきだった様だ。

    % 何故かは詳しく考えていないが、初期化と描画の順序の問題だろう。

    ble-decode-attach より後に、プロンプトを表示する位置が確定する。
    先に info を描画してしまうと表示がずれることになる。初めは set-default で内容だけ指定しておいて、
    プロンプトの表示位置が確定した後に info も描画させるようにする必要がアアル。

  * vi-mode: by cmplstofB [#D0432]

    | ble.sh における vi-insert モードでの C-o は "accept-and-next" となっていますが、
    | vi/Vim の標準では「次に入力される「一回」のキー[^1]をノーマルモードに対する
    | キーとして解釈し実行した後、再び挿入モードに移る。

    これはあとで実装する。

    # C-o http://qiita.com/takasianpride/items/6900eebb7cde9fbb5298

    動作を確認する。

    - R や gR で C-o して戻るとどうなるのか。i と同じになる可能性はあるのか。
      試してみた所また元の R, gR の状態に戻る。
      表示もそれに応じて (replace) や (vreplace) になる。

    - C-o した上で更に i, a などで挿入モードに入るとどうなるのか。
      どんどん入れ子で C-o できるのだろうか。
      試してみた所、R C-o i ESC l としても REPLACE に戻るということはなかった。
      つまり i, a などをすると C-o した効果は消える。

    - 行末で C-o するとどうなるのか。
      A C-o y y としたら一時的にノーマルモードに戻っているときは
      行末から一つ戻った位置にカーソルが移動するが、終わるとまた行末に行くようだ。
      勿論いつでも元の位置に戻る訳ではなくて C-o のあとに移動コマンドを挟むと元の位置には戻らない。
      また $ i C-o y y としても行末には行かずに直前の位置に戻る。

      % これは厄介な動作である。vim は内部的には "insert での位置"
      % と "normal での位置" を二重に管理している可能性がある。
      % だとすると現在の実装では色々と問題が残る。
      %
      % - うーん。A C-o y l をやっても行末に戻った。
      %   不思議だ。内部的には y l をした時点で yank した範囲の先頭に移動してもおかしくない。
      %
      %   a 可能性1: 移動先が現在位置よりも前方にある時には、内部的な移動は起こらない。
      %   b 可能性2: 実は内部的な位置というものは元から存在していなくて、
      %     単に C-o する直前の位置と直後の位置を記録しているのに過ぎないのかも知れない。
      %     しかしそれは妙だ。編集によって行の中身が変わったときなどに困る。
      %
      % - 念のため A を使わずに $ i right C-o y l としても同じだった。
      %
      % - 次に "echo 6" という内の行で A C-o 6 | としてみた。
      %   何と修了後に行末 (位置 7) に移動した。
      %
      % ここから結論付けられることは、内部的な位置というのは実は存在していなくて、
      % やはり C-o した時の位置を記録していて、
      % 位置が変わっていなければ元に戻すということのようである。
      %
      % さて、では行の内容が変わっている場合にはどうなのであろうか。
      %
      % - A C-o r 8 としたがやはり行末に戻った。位置しか見ていない?
      %
      % では行の長さが変わっているときにはどうなるのだろうか。
      % しかし位置を変えずに行の長さを変えるコマンドが思い浮かばない。
      % y l で一文字だけ貼り付けになるとき P をすれば位置が変わらずに行の長さが変わるのではないか。
      %
      % - 0 y l A C-o P を試してみた所それでも行末に移動した。これは不思議だ
      %
      % - 同じ長さの行が並んでいるところで A C-o k としたところ上の行の行末に移動した。
      %   $ i C-o k としても行末には移動しない。
      %
      % つまり位置を記録しているのではなくて C-o した時点で行末にいたかどうかを記録し、
      % C-o から抜けた時点で行末の一つ手前にいる場合に復元するという方針なのではないか。
      %
      % と思ったが P で行の長さを変えた実験からそれはおかしい。
      % やはり内部的な位置を二重に管理していて k を実行する時には両方移動しているのだろうか。
      % しかしそれは | の実験と矛盾する。或いは、| で 6 | とした時は実際の位置が変わらないということで、
      % 実際の処理としては無視されたことになっているという可能性もある。

      % うーん。P の動作はそもそも不自然な気がするし、
      % 取り敢えず "行末にいたかどうか記録" 方式でいい気がする。
      % P の件に関しては別個に質問することにする
      %
      % - というかそもそも I C-o P としても次の文字に行くようだ。
      %
      % - 0 4 y l I C-o p でも同じように "貼り付けた内容の最後の文字" ではなく、
      %   "更にその次の文字" の位置で INSERT に復帰するようだ。
      %
      % つまり p, P は内部的には一旦貼り付けた内容の末端に位置が移動して、
      % しかしノーマルモードに移る際に一つ戻るという動作をしているということに思われる。

      % "行末にいたかどうか記録" という仮説が合っているのか確かめる。
      %
      % - 以下の内容で、文字 2 の位置にいる時に i C-o k としたら行末に移動した。
      %
      %   echo 1
      %   echo 12
      %
      %   % つまり "行末にいたかどうかを記録" という仮説は間違っている。
      %   これは勘違い。行末にいたかどうかが効くのはコマンド実行後に行末直前にいたときのみ。
      %   コマンド実行後に行末にいた場合はそのまま行末になる。
      %
      % 代わりの仮説として "各コマンドを実行した直後の位置" というのが実はあって、
      % ノーマルモードにいるときには更にその位置から補正が起こるというものを立てる。
      %
      % しかしこれによると A C-o y l で行末に移動するというのは、
      % y l を実行した直後の位置が行末にあるということを示唆するが、
      % 複数文字の y l の動作からすると変だ。念のため複数文字の y l を試す。
      %
      % - $ h i C-o y 2 l → 別に行末に移動するということはない。

      [結論] つまり、以下の通り。

      - C-o をした時点で行末にいたかどうかを記録する。
        コマンドを実行直後 (行末補正前) に行末にいた場合は、そのまま行末に行く。
        行末直前にいた場合は、"C-o をした時に行末にいた" 場合に行末に補正する。
        それ以外の場合にはそのままの位置に行く。

      - p, P の "直後の位置" は貼り付け範囲の末端である。
        ノーマルモードではその後で最後の文字に補正される。

    - R C-o から抜けるのに c を使うとどうなるか?
      ただの INSERT になった。つまり i や a と同じ。

    - d 3 l で行末まで丁度全ての文字を消すと復帰した時の位置はどうなるか?
      行末になった。つまり c を使うのと同様である。
      但し c と違って R C-o d 3 l としたらちゃんと REPLACE に戻る。

    - I C-o back は前の行の行末に移動する
    - I C-o 2 r x は 2 文字目に移動する。
    - 空白だけの行において I C-o ^ は行末ではなくて最後の文字に移動する。
      これは I c ^ としても分かる。最後の空白が残る。
      +, - も同様。つまり ^ + - は行末には一時的にも移動しない。
    - 一方で I C-o $ は行末に移動する。
    - 6文字の行において c 7 | は最後の文字を削除しない。つまり | は行末には一時的にも移動しない。


    実装した。しかし微妙に振る舞いが異なる。

    - 空白だけの行において A C-o ^ とすると vim では最後の文字に行く。
      変だ。今までの実験では最後の文字にいる時には修正されるはずだったのではないのか。

    うーん。面倒だ。これは別の問題として残すことにする。

    > * p の動作が正しくない気がする。 → 条件が反転していた。直した。
    > * あとカーソルの位置がおかしい。 → 条件を修正するべきところ eol 補正を完全に削除していた。直した。

  * 2017-09-05 vi-mode: gR? [#D0431]

    http://qiita.com/sfuta/items/0de4ead865c15e9e9b68

    overwrite mode には R/gR の区別があるようだ。
    さて overwrite mode まで来ると複雑である。
    特に self-insert が複雑になる。
    これは再実装すると面倒なので何らかの変数を用いて vi/emacs を内部で
    判定して動作を微妙に変えるという様にするのが良いのではないだろうか。
    ところで self-insert に関しては emacs/vi で動作の違いはあっただろうか?

    実際に vim で試してみると gR と押しても何も起こらないどういうことか?

    これは vi ではなく vim で起動しなければならなかったという話だった。


  * 2017-09-09 テストユーザ (vim) に説明すること [#D0430]

    - 編集文字列内に改行 LF が含まれないとき単一行編集と呼び、あるとき複数行編集と呼ぶことにする。
      単一行編集のとき LF を挿入して複数行編集に移るには C-v C-j (または端末のフロー制御を無効にしていれば C-q C-j でもよい) とすれば良い。
      複数行編集のとき RET (C-m) はコマンド実行ではなく改行挿入になる (ノーマルモードでは次の非空白行頭に移動になる)。
      この時コマンドの実行は RET (C-m) ではなく C-j で行う。
      複数行編集では端末の表示行数よりも多くの行を含むコマンド編集は想定していない。

    実装の仕様(または妥協点・疑問点)

    - gr が vim で動かないこと。gR が動かないこと
    - H L が現在の履歴項目内の移動で、G gg が履歴内の移動であること。
    - jk+- で現在の履歴項目の上下を踏み越えると次の履歴項目に移動すること。

  * vi-mode: vi.sh から keymap/isearch を使っているが [#D0429]
    keymap/isearch は emacs.sh の中で定義されている。
    どうやら現状では .inputrc で vi が設定されていたとしても、
    ble.sh をロードした段階では -o emacs であり、
    後で -o vi になる様である。

    % どうも .bashrc の中では殆ど -o emacs のようである。
    % ところが何処かの時点で -o vi に変わる様である。
    % 調べてみると ble-decode-attach の
    % eval -- "$(ble-decode-bind/.generate-source-to-unbind-default)" で結果が変わっている。
    % つまり初回の bind 実行で変化しているように思われる。
    % 試してみるとどうやら単に "bind" としただけでも readline が呼び出されるようである。
    % なので -o emacs/vi を最初にチェックする前に bind を実行すれば良い。
    % # さて、不思議なのはこの仕様の場合、ble.pp の最初のチェックをすり抜けるのではないかということ…。
    % # やはりすり抜けていた。このチェックの時点で readline をロードすれば良いだろう。

    [結論] 最初に -o emacs/vi を参照する前に "bind &>/dev/null" を実行すれば良い。

    さて、この時 keymap/isearch はどうなるだろうか。
    調べてみた所、何も操作できない状態になった。

    二つの変更を加える必要がある。

    1. 先ず初めに isearch.sh を分離するということ。
      それでも、キャッシュが複数に分かれるのは得策でないので
      キャッシュは emacs.sh, vi.sh で出力するようにする。

    2. 次に ble-decode/keymap/push する時に keymap の存在をチェックするということ。
      もし keymap が存在しない場合にはそのキーマップに移行するべきではない。
      keymap の存在判定で色々手間取ったがなんとかできた。

2017-09-10

  * 2017-09-07 vi-mode: C-c ESC C-| の違い。 [#D0428]

    http://d.hatena.ne.jp/yuta84q/20101216/1292508997

    引数を保存して繰り返し適用する? しかし途中で変な操作があると難しい。

    % どうも途中で矢印で移動すると無効になるようである。
    % backspace で内容を削除する場合には問題は起こらない。
    % つまり許容できる操作に制限があるということだろう。
    % そして制限された動作を用いている限りにおいては、
    % 編集によって追加された文字列は、
    % 編集開始点から編集終了点までということが保証される。
    %
    % もう少し調べてみる。backspace の場合には引数は無効にならない。
    % では元々あった文字数よりも少なくなった場合にはどうするのか。
    % →どうやら backspace が繰り返し実行されるようである。
    % 更にこの backspace は (挿入モードの性質として) 行を跨って実行されるようだ。
    %
    % さて、backspace 以外の削除するコマンド (例えば前の単語を削除するコマンド) を実行した時にどうなるかは気になる。
    % 単語単位で削除した回数を覚えておいて引数の数だけ掛け算してそれを適用するのか、
    % 或いは減少した文字数だけを覚えておいて引数の数だけ掛け算したぶんだけ更に文字数を減少させるのか。
    % 実装としては文字数を記録するだけの方が自然である。行った操作の履歴を保持するのは大変である。
    % と思ったが、よく考えてみたらそもそも挿入モードで単語単位で削除するような操作があったのかどうか怪しい。
    %
    % そう思って vimindex を眺めてみたら C-w でそれを行うことができる様である。
    % 実際に試してみた所、ちゃんと C-w を行ったのだということを覚えているようだ。
    % ということはどの様な編集を行ったのかという履歴を残すということになる。
    % 寧ろマクロの一種と考えるほうが良いということである。
    % さて、ということであればこの機能に対応するならば先にキーボードマクロに対応する方が先である。

    どうも途中で行った操作を全て記録しているようである。
    また、矢印などで移動をしたりするとキャンセルされる。

    これはキーボードマクロの仕組みを整えてから対応した方が良い。

    →より汎用的に ble-decode.sh を拡張するとしたら、__defchar__ や __default__ の様に、
    keymap に __before_command__ のような特殊バインディングを用意するのが良い気がする。
    そしてキーボードマクロその他の仕組を整えるのに利用できるようにする。

    しかしよく考えたら単にキーボードマクロとする場合、
    その時の背景の変数の状態などを記録しなくても良いのだろうか。
    というのもノーマルモードでキーボードマクロを記録している時にどのように処理されるのかが気になる。
    ノーマルモードの __before_command__ でキーボードマクロを記録しているときに
    挿入モードに入ると、その間記録がされないことになってしまう。それはおかしい。
    つまり、今回追加した仕組みは実はキーボードマクロの仕組みには使用できない。
    キーボードマクロにしたければ実は keymap に依存しない hook を取り付ける仕組みを追加するべきだ。
    更に入れ子になっている場合なども考えれば複数取り付けられるようにするべきかもしれない。
    何れにしてもキーボードマクロは今回の仕組みとは独立に用意しなければならない。
    この事はキーボードマクロの計画の方に追記しておくことにする。

  * vi-mode: C-home C-end は現在の編集文字列内の移動としても良いかもしれない。 [#D0427]

2017-09-09

  * vi-mode: f F t T ; , [#D0426]

    bash の動作を確認してみると同じ履歴項目の中だけを検索するようである。
    vim で試してみる。同じ行内でしか一致しない。
    現在位置にある文字には一致しない。
    t T では一つ先の文字に一致するので何回も一致する。

    ycd は効く。f t は終端までを範囲とするのが他と少し異なる。
    つまり空一致は存在し得ない。
    引数を指定すると n 個目の文字に移動できる。
    n 個目がない場合には何もせずに bell である。

  * ble-edit: 下キーなど履歴項目を移動するもの全般に… [#D0425]
    現在一番下の行にいるということが分かっているのであれば、
    下に行こうとした時に history/load する必要はないのではないだろうか。

  * ble-edit, ble-decode: declare で宣言しているグローバル変数は [#D0424]

    何も指定せずにただ代入するべきなのではないか。
    なぜならば関数内から source などした時にローカル変数になってしまうので。

    定数として宣言するために declare -ir しているものもあるが、
    これらは結局 ble.sh を複数回ロードしたときのために定義されているかどうかを確認してから
    declare -ir するのなどの面倒な処理の原因になっている。
    やはり勝手に書き換える人が悪いという事にして、declare -ir は除くのが良いだろう。

    問題になるのは declare -A である。declare を使わずして配列が連想配列であることを指定する方法はない。
    bash-4.2 移行であれば declare -gA で解決するが bash-4.0, 4.1 ではそれができない。
    bash-4.0, 4.1 では bash-3.* 用の declare -a を用いる fallback を使うという手もあるが、速度が遅くなってしまう。
    実のところ、関数内からロードするという事は現在考えていないし、
    また 4.0, 4.1 はまだまだ現役だと思われるので速度を重視したほうが良い気がする。
    という訳で今の所は 4.0, 4.1 に関しては関数内からロードする時に問題になるとしても取り敢えず放置することにする。

    或いは現在関数内からロードしているかどうかを判定して、
    declare -A を行うかどうかを切り替えるという手もある。
    どうも関数内にいるかどうかは ${FUNCNAME+set} で判定できるように思う。
    但し FUNCNAME がユーザにより勝手に unset されていないことが前提である。
    従って、関数内にいてかつ bash-4.2 未満の場合には配列実装に fallback すれば良い。

    * 確認: 関数内から source したとき source されたスクリプトの中からそれを判定できるのだろうか?

      もしかすると source した時点で関数でないという様に解釈されて
      FUNCNAME が見えないという可能性も否定できない。

      以下のようなファイルを用意しておいて、

      ```bash:a.bash_source
      # bash_source

      if [[ ${FUNCNAME+set} ]]; then
        echo 'source from a function'
      else
        echo 'source from out of functions'
      fi
      ```

      bashrc から呼び出して正しく判定できるか確認する。

      ```bash:~/.bashrc
      function atest1() { source ~/prog/ble/a.bash_source; }
      atest1

      source ~/prog/ble/a.bash_source
      ```

      どうやら正しく判定できる様だ。

    * 確認: 既に同様の仕組みによって ble.sh を関数内からロードしている場合に警告を発したりしていないか。
      もしそうであればわざわざ関数内からロードした時について対応するのは無駄である。
      少なくとも FUNCNAME で検索した限りにおいてはそのような判定は行っていないようである。

      というより実際に関数内からロードしてみれば確認は済む。
      試してみた所ロードできた。動作している。

  * vi-mode: J gJ o O [#D0423]

    J は行末に LF がある場合にはそれを SP に変える。
    それ以外の場合には bell を鳴らして移動もしない。
    gJ は SP に変えるのではなくて単に削除する。

    o は行末に改行を挿入して挿入モードに入る。
    O は行頭に改行を挿入して挿入モードに入る。
    o O は共に新しい行の先頭にカーソルをおく。

    これらの J gJ o O のコマンドは何れも、
    引数に ydc が含まれる場合は bell で、
    引数の数字は単に無視されるように思われる。
    →o O に関しては挿入モードを抜けるときの繰り返し回数を指定するようだ。

  * そろそろ leak variables を再度チェックする。 [#D0422]

    ble-syntax.sh で rex がリークしていた。
    単にロードしただけでは他にリークは見つかっていない。

    本来はもっと長時間使用した後で leak を確かめるべきである。
    という訳で ble を編集しているシェルで試してみた。
    他に complete.sh で compgen がリークしていた。直した。

  * vi-mode: r [#D0421]

    f や F でも同じことであるが、引数をどのように受け取るかが問題である。

    % quoted-insert の場合には ble-decode に特別な項目を設定して処理した。
    % 同じ仕組みを採用しようとするとキー入力ではなくて生の文字を受け取ることになる。
    % 一方で rx fx Fx などでは通常の文字を引数に取ることを想定するので生の文字を受け取る必要はない。
    % 寧ろ変な操作を検出するために生の文字ではなくて生のキーコードを受け取るようにしたい。
    % そのためには ble-decode に同様の仕組みとして生のキーコードを受け取るようにすると良いだろうか。
    % しかしよく考えてみるとそれ専用の keymap を定義することができるのだから ble-decode を弄る程でもない気がする。
    %
    % 念のため quoted-insert の利用している ble-decode の機能について確認し、
    % どちらの実装にするほうがきれいになるかを判定してから処理するようにする。
    % quoted-insert では _ble_decode_char__hook=ble/widget/quoted-insert/.hook を設定し、
    % ble-decode にこの .hook 関数を呼ばせている。
    % 更によく見ると既に ble-decode に _ble_decode_key__hook という変数が用意されている。
    % 因みに誰も使っていない。
    %
    % さて既にその仕組が整っているのだとしたら、_ble_decode_key__hook を利用したほうが簡潔なのではないだろうか。
    % keymap を自前で定義するにしてもコマンド毎に定義するのは変だし、
    % だからと言って一つ keymap を用意して _ble_keymap_vi_hook などの変数に操作を記録するという方式にすると、
    % 既にこれは汎用の _ble_decode_key__hook と同様な仕組みになってしまっている。
    % もしそうだとしたら _ble_decode_key__hook の方が keymap を通さないだけ素直な実装になっているので良い。

    [結論] これには既存の _ble_decode_key__hook の仕組みを利用すれば良い。

    実際の実装では overwrite をするのでその仕組を既に持っている self-insert を用いる。
    但し、2つの点において self-insert を改修しなければならない。

    - 先ず 1 つ目に引数を用いて繰り返し self-insert を行うということ。
      効率の面から言って一気に複数文字を挿入するようにした方が良い。
      また、emacs 用の .get-arg を用意する必要があるのでは。

    - 次に overwite する時に表示幅で overwrite するのか、論理列数で overwrite するのかということ。
      これは r gr で異なるので両方に対応しなければならない。
      これは _ble_edit_overwrite_mode=R というのに対応する必要がある。
      先ずはどこで _ble_edit_overwrite_mode が使われているかを調べる。

    変更を実施する。

    * self-insert の実装をいじっていて思ったこと。
      delta の実装はこれで良いのか。
      delta は変更範囲より後ろにある _ble_edit_mark の位置を更新するのに使っている。
      しかし _ble_edit_str.replace で _ble_edit_mark は更新されないのだろうか。

      →今確認してみた所 _ble_edit_mark だけでなく _ble_edit_ind も更新しないようだ。
      これは _ble_edit_str.replace を呼び出した後で結局再び _ble_edit_{ind,mark} を移動するなどの場合があって、
      そのような時に無駄な計算をしないための効率によるものと思う。

      つまり、呼び出し元で両者とも管理しなければならない。

    * さて、現在の self-insert の delta はどのようなものになっているだろうか。
      特に全角文字を空白文字で置き換えた時に delta を 1 だけ増やすのは何故だろうか。
      repw-w でないのには理由があるのか、それとも単なるミスだろうか。
      (或いは全角文字は幅 2 という仮定があればこれで問題ないが、
      それだとわざわざ挿入する空白の数を repw-w と計算している理由がわからない。)

      更によく見てみるとこれは実際に使用するところで
      delta=${#ins}-(iend-ibeg) として計算すれば良いだけの気がする。
      今まで delta を別に計算していたのはそちらの方が速いと判断からなのだろう。
      しかし現状の実装ではむしろ複雑になっている気がするので、
      delta の値はその場で計算することにして delta 自身は廃止することにする。

      一応テストする。挿入・上書きのそれぞれで全角・半角を書くのを試した。
      全角半角で半角・全角を上書きするのも試した。問題ない。OK

    * _ble_edit_overwrite_mode=R には対応した。

    * その他の _ble_edit_overwrite_mode を参照している箇所は、

      overwrite mode の設定、caret_state の保存・復元、表示時の着色を除けば
      ble/widget/.delete-backward-char のみである。
      これについては _ble_edit_overwrite_mode=R に対応した。
      (引数には対応していない。引数は今後少しずつ対応していく予定である。
      というかそもそも keymap emacs では引数を導入できない。)

    * r gr した後のカーソルの位置が異なる→直した。

    * r gr ではその行内に既に足るだけの文字数がない時 bell である。

    * vim で試すと gr は必ず bell になる。
      何か使い方が間違っているのだろうか。
      これは vim ユーザを見つけて相談するべきである。
      取り敢えず有効にしておくことにする。


2017-09-08

  * vi-mode: G H L gg [#D0420]

    元々の vim では H L は現在画面に写っている範囲での移動である。
    また G は全体の行番号を指定して移動するものである。
    引数を省略した場合には一番最後の行に移動する。
    gg は引数省略時に一番最初の行に移動することの他は G と同じ。
    何れも非空白行頭に移動する。

    ble.sh の実装では H L は現在の履歴項目の中での移動とし、
    G/gg は履歴の番号を指定した移動とするのが良さそうである。
    但し ydc が指定されているときには gg/G は H/L と同様に現在の項目の中で処理する。

  * vi-mode: K [#D0419]

    vim ではデフォルトでは現在の単語について man を呼び出すようである。
    ble.sh では丁度 command-help というものを既に用意している。
    これは現在のコマンドラインのコマンド名で --help または man を呼び出す。
    vim の動作とは異なるが引数について man を呼び出しても仕方がない気がするので、
    ここは寧ろ command-help の動作で問題ない気がする。

  * vi-mode: 編集文字列に改行が含まれるときの RET の動作 [#D0418]

    編集文字列に改行が含まれるとき、
    現在 insert mode に戻って改行を挿入する操作になっているが、
    これは下に移動する動作にするべきなのではないかという気がする。
    実際に試してみると + と同じ動作になっている様に思われる。

2017-09-07

  * ble-edit: ble-edit/text/getxy は ble-edit/text/getxy.out に改名する。 [#D0417]

  * vi-mode: accept-line したら vi_insert に戻るべきなのでは。 [#D0416]

  * vi-mode: yh でカーソルは動かなければならない [#D0415]

    yh でカーソルは動く。yl でカーソルは動かない。
    どうもコピーした領域の先頭に移動するということかもしれない。
    また共に範囲が空のときには kill ring の内容も空になる。

    dl dh で領域が空の時には kill ring の内容は変更されない。

  * vi-mode: vim の dd dj yy yj などは行単位でコピーしたということを覚えている。 [#D0414]
    つまり貼り付けの際に行頭に移動してから行単位で挿入を行うのである。

    現在コピーした内容は _ble_edit_kill_ring という変数に記録している。
    これとは別に _ble_edit_kill_type などの変数を用意して
    其処に行単位かどうかの情報を記録するのはどうだろう。

    これに関しては後で実装する→と思ったが結局 yy と同時に実装する事にした。

  * vi-mode: 先に dd yy cc を実装する。0 も実装する [#D0413]

    これは arg の実装の特殊なケースなので現状で中途半端になっている。

  * ble-edit: 履歴の初期位置がおかしい。 [#D0412]

    これは先程 ble-edit/history/load は ble-edit/history/goto
    でどうせ使うから呼び出さなくても良いとして削除したのがいけない。
    goto の引数に渡している値を取得するのに load が必要である。

  * ble-edit で ble-edit/text/update/position が実行済みかのチェックを入れたら [#D0411]
    history-next, history-prev を実行した後の
    forward-line, backward-line で引っかかる様になった。

    当初は一つの入力に対して forward-line, backward-line のみを呼び出すならば、
    編集文字列の変更はなく常に配置情報は最新になっているはずに違いないと考えたが、
    よく考えたら stdin に入力が溜まっている場合には配置計算を省略するようにしているので、
    上下のキーを連打すると容易に配置情報が更新されていない状態で forward-line/backward-line が呼び出される。

    これは今までもチェックしていなかったために気付いていなかっただけで、
    今までも getxy.cur や get-index-at の計算が誤っていた事になる。
    実はこれが今までの _ble_edit_ind out of range のエラーの原因だったのではないか。
    これについては再現するかどうかを確かめた後に検証する必要がある。

    →修正した。配置情報を使うコマンドに関しては
      ble-edit/text/update/position の結果が最新の場合とそうでない場合で
      動作を切り替える様に改修した。

    →検証するのは面倒なのでやめた。
      今までの assertion failure は全て履歴の移動の後に起こっていたので
      もうこれが原因だということで恐らく間違いないだろう。
      取り敢えず今までの assertion failure の報告は全て解決済みとする。
      その上でまた assertion failure が出たらその時に改めて調査する事にする。

    | 2016-09-14
    |
    | * stackdump がまた出た。
    |
    |   | stackdump: 0 <= beg=28 <= end=29 <= len=1; beg=28, end=28, ins(1)=e
    |   |   @ /home/murase/prog/ble/ble.sh:5133 (_ble_edit_str.replace)
    |   |   @ /home/murase/prog/ble/ble.sh:-2006 (ble/widget/self-insert)
    |   |   @ /home/murase/prog/ble/ble.sh:33 (ble-decode-key/.invoke-command)
    |   |   @ /home/murase/prog/ble/ble.sh:22 (ble-decode-key/.invoke-partial-match)
    |   |   @ /home/murase/prog/ble/ble.sh:37 (ble-decode-key)
    |   |   @ /home/murase/prog/ble/ble.sh:92 (ble-decode-char/.send-modified-key)
    |   |   @ /home/murase/prog/ble/ble.sh:50 (ble-decode-char)
    |   |   @ /home/murase/prog/ble/ble.sh:-966 (ble-decode-byte+UTF-8)
    |   |   @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)
    |   | stackdump: 0 <= beg=2 <= end=3 <= len=2; beg=2, end=2, ins(1)=c
    |   |   @ /home/murase/prog/ble/ble.sh:5133 (_ble_edit_str.replace)
    |   |   @ /home/murase/prog/ble/ble.sh:-2006 (ble/widget/self-insert)
    |   |   @ /home/murase/prog/ble/ble.sh:33 (ble-decode-key/.invoke-command)
    |   |   @ /home/murase/prog/ble/ble.sh:22 (ble-decode-key/.invoke-partial-match)
    |   |   @ /home/murase/prog/ble/ble.sh:37 (ble-decode-key)
    |   |   @ /home/murase/prog/ble/ble.sh:92 (ble-decode-char/.send-modified-key)
    |   |   @ /home/murase/prog/ble/ble.sh:50 (ble-decode-char)
    |   |   @ /home/murase/prog/ble/ble.sh:-966 (ble-decode-byte+UTF-8)
    |   |   @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)
    |   | stackdump: 0 <= beg=3 <= end=4 <= len=3; beg=3, end=3, ins(1)=h
    |   |   @ /home/murase/prog/ble/ble.sh:5133 (_ble_edit_str.replace)
    |   |   @ /home/murase/prog/ble/ble.sh:-2006 (ble/widget/self-insert)
    |   |   @ /home/murase/prog/ble/ble.sh:33 (ble-decode-key/.invoke-command)
    |   |   @ /home/murase/prog/ble/ble.sh:22 (ble-decode-key/.invoke-partial-match)
    |   |   @ /home/murase/prog/ble/ble.sh:37 (ble-decode-key)
    |   |   @ /home/murase/prog/ble/ble.sh:92 (ble-decode-char/.send-modified-key)
    |   |   @ /home/murase/prog/ble/ble.sh:50 (ble-decode-char)
    |   |   @ /home/murase/prog/ble/ble.sh:-966 (ble-decode-byte+UTF-8)
    |   |   @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)
    |   | (略) つづきは同様
    |
    |   1 不思議なのは _ble_edit_str.replace で修正が入っている筈なのに、
    |     エラー状態が継続している事である。
    |     よく見ると、修正によって初回よりはましな値になっていると言え
    |     end の値が文字列の長さよりも一つ多いものになっている。
    |
    |     取り敢えず、初めに発生したエラーの原因は別の所にあるとしても、
    |     修正部分のコードが間違っている可能性があるので修正する。
    |
    |     確認してみたところ、_ble_edit_str.replace は _ble_edit_ind を修正するとは言っても、
    |     その場で許容される値に修正するだけで _ble_edit_str.replace 呼び出し元での
    |     _ble_edit_ind に対する操作も含めての修正ではない。
    |     従って、_ble_edit_str.replace の中で _ble_edit_ind を修正しても仕方がない。
    |
    |     →どうも観察してみたところ、_ble_edit_str.replace の呼び出し元では、全て、
    |     _ble_edit_str.replace を呼び出した後に _ble_edit_ind を更新している様である。
    |     つまり、_ble_edit_str.replace 呼び出し時点では、_ble_edit_ind の値は
    |     文字列挿入前の値になっていると想定して良い。
    |     と思ったが、そうでは無い物もあったので、それについては処理の順序を入れ替える。
    |     という訳で、これでエラーが発生した時の _ble_edit_ind の修正は正しくなった筈である。
    |     序に _ble_edit_mark に関しても同様の修正を行う様にする。
    |
    |   2 もう一つの問題点はそもそも何故初めに変な値になったのかという事である。
    |     特に beg=28 end=28 という値になっている。
    |     因みにこの時前に実行したコマンドは "gunzip -c xp.img.gz | wc -c" の 27 文字であり、
    |     またエラーが発生したのは最新の編集行に echo と入力しようとした瞬間である。
    |     勿論、最新の編集行に入力しようとすると必ずなる訳ではなく
    |     (恐らく直前の操作手順に応じて) このエラーが発生したりしなかったりする。
    |
    |
    | 2016-06-25
    |
    | * また stackdump が出た。
    |
    |   .ble-edit/delete-backward-char および insert-char で起こっている。
    |   表示されている内容から察するに、_ble_edit_ind が変な値になっている様だ。
    |   また、履歴を上下で移動した後に起こっている事も分かっている。
    |
    |   | stackdump: 0 <= beg=10 <= end=10 <= len=8; beg=10, end=11, ins(0)=
    |   |   @ /home/murase/prog/ble/ble.sh:17 (_ble_edit_str.replace)
    |   |   @ /home/murase/prog/ble/ble.sh:11 (.ble-edit/delete-backward-char)
    |   |   @ /home/murase/prog/ble/ble.sh:1 (.ble-edit.delete-char)
    |   |   @ /home/murase/prog/ble/ble.sh:4 (ble/widget/delete-backward-char)
    |   |   @ /home/murase/prog/ble/ble.sh:-1794 (ble/widget/delete-region-or)
    |   |   @ /home/murase/prog/ble/ble.sh:16 (ble-decode-key/.invoke-command)
    |
    |   この前の修正で完全に直っていたはずだと思ったのだが何故だろうか。
    |   make を実行したら ble.sh が更新されてしまったので ble.sh
    |   が中途半端な状態にあったのかも知れない。
    |   丁度最近、検索の速度向上の為に一時的に単一の配列だけを参照する様に
    |   書き換えたりなどしていた後である。
    |   また、暫く様子を見てそれでも出る様だったらまた原因を探る必要がある。
    |
    |   或いは、今先程エラーが起こったシェルの history next 関数を調べて、
    |   その内容がどの様な状態になっているかを確認すれば、
    |   エラーが起こる様な状態に丁度編集していた最中だったかどうかが分かる。
    |   →実際のループ処理を行っているのは ble-edit/isearch/next-history-resume.fib
    |   の中である。ロードされている関数の中身を確認してみた所、
    |   ちゃんとこの前修正した二つの配列を参照して内容を決定する部分は正しい。
    |
    |   | if [[ ${_ble_edit_history_edit[i]-${_ble_edit_history[i]}} == *"$needle"* ]]; then
    |   |     ind="$i";
    |   |     break;
    |   | fi;
    |
    |   では何が悪いのだろうか。考えてみると長い履歴項目を弄った後に、
    |   一番下の (空の) 項目に戻ってきた時に起こった様な気がする。
    |   うーんそれでも再現は簡単にはしない…。
    |   又エラーの起こった状態から復帰する為に
    |   _ble_edit_ind は調整を行ってしまうのが良い。


  * 2017-09-04 vi-mode に対応する (初期計画) [#D0410]

    取り敢えずブランチを切る。

    取り敢えず vi 用の keymap に切り替える仕組みを作る。

    | - set -o vi が有効になっている時には keymap viins を使う様にする。
    | - 途中で set -o emacs から set -o vi になった時に ble.sh のモードも変更する様にする。
    | - ble-decode-attach において -m vi-insert に対して bind するようにする?
    |
    |   或いは飽くまで emacs-standard を使う様にするか。
    |   emacs-standard を使うようにしていると [[ -o vi ]] などが意図と反する結果になるので良くない。
    |   コマンドを実行する瞬間だけ戻すという手もあるがそれだと
    |   - ^C などで中断した時に set -o emacs に戻す機会が失われて、また応答しなくなる状況に陥るという問題が発生する。
    |   - ユーザが自分で定義した widget 関数の中などではやはり set -o emacs になっている様に見えてしまう。
    |
    |   従って、やはり -m vi-insert に対して設定を行う必要がある。
    |   ところで bind で設定されるのは既定ではどの keymap なのだろうか。
    |   set -o vi の時には vi-insert (vi-command ではなく) だと考えてよいのだろうか。
    |   或いは emacs-standard になってしまうという可能性もある。
    |
    | →vi_insert keymap を導入した。現在は emacs の clone である。動作している。
    |   これから vi_insert としての振る舞いになるように少しずつ widget などを実装していけば良い。

    先に mode の間の切り替えを実装する。

    次に引数を管理する仕組みを考える。

    | 初めは数字の引数を記録する枠組みを作って、
    | それを emacs と共有するようにしようと考えたが、
    | 操作体系を調べると 2d3 なども引数として処理した方が良い様に思われる。
    | というのも d3h d3l などは削除コマンド d に対する細かい動作の制御ではなくて、
    | 移動コマンド h l に対する修飾として働いている様に思われるからである。
    |
    | 引数はどの様に管理すれば良いだろうか。
    | これは単純に引数を記録しておく変数を用意すれば良い気がする。
    |
    | - ble_edit_str ble_edit_ind ble_edit_mark と同様に管理すれば良いだろうか?
    |   引数の入力状態は直接表示の仕方に影響を与えるものではないので
    |   これらと同様に管理する必要はない。
    |   つまり引数が変更されたとしても表示の更新を行う必要はないので、
    |   表示が更新されたかどうかの判定に用いる必要もない。
    | - また各履歴項目に紐付いた物でもないので、履歴を移動した時に記録する必要もない。
    |
    | さてもう一つ考えて置かなければならないのは editing-mode = emacs の時の
    | arg と統一的に扱うかどうかである。emacs の時は arg は唯の整数である。
    | しかし vi の時は上で決定したように d などの文字も含む。
    | ただ結局どのような文字を引数に入れるのかはキーバインディングに依存するので、
    | emacs でも vi でも同様に実装して問題ないように思われる。

    ところで同じ forward-char であっても emacs vi で引数の取り扱いが異なる。
    vi では右端に行ったら次の行には行かないが emacs では次の行に行く。
    従って結局 emacs と vi で別々に forward-char を実装する必要があるのではないか。

    先ずは hjkl について実装した。
    大体の仕組みは整ったので後は少しずつ実装していくだけの気がする。

  * 2017-09-05 vi-mode: forward-line-or-history-next, forward-line-or-history-next [#D0409]

    引数に対応する。そもそも emacs では引数に修飾文字が入らないことを考えると、
    共通で vi の引数の仕組みで実行するようにしてしまって問題ない気がする。
    つまり、現在 vi 専用の引数の仕組みになっているものを emacs にも拡張する。

    と思ったが、forward-line-or-history-next は修飾に対応していない。
    しかし、異なる history entry の間でコピー・切り取りに対応するのは変だ。
    従って、修飾文字が含まれている場合には現在の履歴項目の中での移動に制限するのが自然である。


    forward-line/backward-line において見た目の行を移動するか論理的な行を移動するかが問題である。
    また列も見た目の列を保持するか、論理的な列 (文字数) を保持するかが問題である。
    emacs mode の方では見た目の行を見た目の列を保持して移動する様になっている。

    vim で実際に試してみると一番最後に forward-line/backward-line
    を実行した時の見た目の列を保持している。
    また当然のことながら論理的な行を移動するようになっている。
    論理行が複数行にまたがる時、全角・半角の都合により異なる位置で改行されることがある。
    調べてみるとそのような場合でも "見た目" の列を保持しているようである。
    従って、もし厳密にこの動作に従うのだとすると、
    1. まず初めに論理行頭からの見た目の行・列を取得し
    2. 次に移動先の論理行頭の位置を求め、
      更に論理行頭を保持するということにする必要がある。

    - ble-edit/text/update/positions の問題

      所で、行の内容を変更した後に ble/widget/forward-line を呼び出す時には
      ble-edit/text/update/position を呼び出す必要があることには注意しなければならないのではないか。
      何故なら中で使用している ble-edit/text/getxy.cur などの関数は内部で
      配列 _ble_line_text_cache_pos を参照するがこの配列は ble-edit/text/update/position
      で更新される。ここで手で ble-edit/text/update/position を呼び出すというても考えられるかもしれないが、
      その為には変更範囲 BLELINE_RANGE_UPDATE (中身は _ble_edit_dirty_draw_{beg,end,end0}) が必要で、
      更にこの変更範囲は "描画" や "色つけ" と共有しているので、
      ble-edit/text/update/position を実行するためにはこれらと一緒に更新する必要がある。
      従って現状では途中で _ble_line_text_cache_pos を更新するのは難しい。

      - もし対応させようとするならば ble-edit/text/update/position の dirty range を
        描画の dirty range とは独立に管理する様にしなければならない。

      - 従って現状では変更後に forward-line は呼び出してはならないという制限を設けなければならない。
        安全の為に変更がないということを確認する必要はあるかもしれない。
        このチェックは _ble_edit_dirty_draw_beg=-1 である事を確認すれば十分である。
        →確認する様に修正する。

      [結論] dirty になっていないか確認し、dirty ならエラー。


    - ble-edit/text/getxy と ble-edit/text/getxy.cur の違い

      何であったか。memo.txt を探すと getxy は出力位置で getxy.cur はカーソルの表示位置だという。
      これは一体どういうことか。両者は同じではないのか。
      調べると _ble_line_text_cache_pos[i+1] の第3フィールドが非ゼロの時に、
      getxy.cur は次の行頭を指し示す様になっている。
      % 第3フィールドは左の文字が ASCII 表示文字以外 (isprint 以外) で、かつ、
      % その行に収まりきらない時に、非ゼロになる。
      つまり幅2以上の文字でその行に収まりきらない時に非ゼロになる。

      うーん。getxy は左側の文字の終端位置で、
      getxy.cur は右側の文字の開始位置と解釈すれば良いだろうか。

      考えていたら分かった気がする。先ず右側で折り返す文字は、
      行末の幅を補填する空白が追加される。これにより二行にまたがる文字になる。
      getxy はこの空白も含めた開始位置であり、実際に _ble_line_text_cache_cs を切り出して出力する場合には、
      この位置から出力を開始する必要がある。getxy.cur は実際に空白を除いた文字の本体が表示される位置である。
      実用的には、実際の所 getxy は左側の文字の州単一で getxy.cur は右側の文字の開始位置と解釈して問題なさそうだ。

      [結論] 分かりにくいので getxy, getxy.cur の関数に説明を追加しておく。

2017-09-06

  * ble-edit: 余分な ble-edit/history/load 呼び出しがあったので削除 [#D0408]

2017-09-05

  * ble-edit: .goto-char [#D0407]

    何やら意味のない関数のように思われたが、
    履歴を調べてみると以前は変更があったときのみ set-dirty を実行していた様だ。
    現在はカーソルの位置は別に記録してあるし表示内容の変更と
    カーソル位置の移動は別々に管理しているのでその必要はなくなったのであった。

    さて、ということはこの関数の内容は単純化できる。

  * vi-mode: (()) は bash-3.0 でエラーになる。{ :; } が意味的にも無難 [#D0406]

    →どうやら function f () (()) ならば bash-3.0 でも OK の様である。

2017-09-04

  * vi-mode: ble-edit/bind/.check-detach で編集モード切り替わり判定を行う [#D0405]

    うーん。bleopt_default_keymap=auto のとき、これも一緒に切り替える必要があるのではないだろうか。
    一方で、bleopt_default_keymap を直接指定しているときには一緒に切り替えてしまっては駄目である。
    また切り替えた場合には必要に応じて source keymap/vi.sh などが必要である。

    % うーん。しかし bleopt_default_keymap として auto を許容すると複雑になる。
    % 問題点は bleopt_default_keymap は既に別の用途で使われているということである。
    % その様に考えると bleopt_default_keymap とは別に bleopt_editing_mode のような感じの変数を用意するのが妥当である。
    % →使い方を多少変更した。改名はしないことにした。#D0402 を参照のこと。

    [変更]

    編集モードが変わった時には単に ble-decode-detach してから
    ble-decode-attach すれば良い。ble-decode-detach は前回の attach の際の編集モードで解除を行い、
    attach は現在の編集モードで設定を行うからである。

    また keymap/vi.sh は DEFAULT_KEYMAP から呼び出すことにした。
    既に呼び出し済みかどうかの判定は関数 ble-edit/load-keymap-definition:$name
    を空関数にすることによって設定する。

    vi.sh に関しては vi.sh 内部に widget を定義したいので、
    何れにしても必ず読み込むようにする。
    その場合は keymap の定義の部分のみキャッシュする。
    キャッシュがある場合は vi.sh の中から呼び出す様にする。

    Note: この動作は emacs.sh の場合と異なることに注意する。
      emacs.sh の widget は全て ble 本体の中に定義してあるので、
      emacs.sh でやることは keymap の定義のみである。
      ということはキャッシュがある場合にはそもそも emacs.sh すら呼び出さなくて良いので、
      ble-edit.sh 側の ble-edit/load-keymap-definition:emacs でその操作を定義する。

    実装した。テストした。
    問題が合ったので以下の変更も行った。

    * 変数 ble-bind: ble_bind_keymap の導入

      ble-bind で既定の keymap を指定するのに bleopt_default_keymap を local で書き換えて呼び出していたが、
      現在 bleopt_default_keymap は DEFAULT_KEYMAP を通して呼び出されるものであり、
      keymap/kmap.sh などから定義を探し出す仕組みに組み込まれているので、
      bleopt_default_keymap を任意に書き換えて実行するというのは良い方策ではない。
      従って、新しい変数として ble_bind_keymap という変数を用意した。
      ble_bind_keymap が設定されている場合には DEFAULT_KEYMAP は使用されない。

  * vi-mode: どうやら set +o emacs を検知できない。 [対処不可][#D0404]

    % set +o emacs を含む builtin eval を抜けるとそこですぐに終了してしまうようだ。
    %
    % 一応 set +o emacs を含む builtin eval の中にあるコマンドは全て実行されるようだ。
    % builtin eval の中で細工して一旦 set -o emacs に戻すことによって
    % 後処理をしてその後で抜けるという様にはできるかもしれない。
    %
    % どうやら builtin eval の中に直接 echo を書いたら実行されるが、
    % 関数呼び出しを通して echo を呼び出そうとしても駄目のようだ。
    % 関数呼び出しより後に書いても駄目のようだ。
    % もしかすると .save-params 関数が悪さをしている可能性もある。
    %
    % .save-params でなくて空の関数 function AAA { :; } を使ってみたが同様に駄目だった。
    % 関数定義が見えなくなっているのではないかと思って function AAA { :; } を eval の中に書いてみたが、
    % 関数定義を書いただけでそれ以降は実行されなくなってしまう。
    %
    % と思ったが今度は直接 echo を書いても実行されなくなってしまった。何故?
    % しかし依然として set +o emacs; echo world などとした場合の world は出力される。

    もしかして改行があるかないかが関係しているのだろうか。
    →試してみたらそうだった。何と改行があると駄目なのだ。

    でもそうだとすると実行しようとしているコマンド自体に改行が含まれている場合には、
    それ以降のコマンドは実行されないという事になる。実際に試してみた所そうなった。

    また改行さえ無ければ eval の外も実行されるのかと思いきやそういう訳でもない。

    更に .save-params を改行ではなく ; で区切れば良いのではないかと考えたが、
    それだと "echo ;" などのコマンドを実行した時に ";" の重複により構文エラーになってしまう。

    [結論]

    仕方がないので以下の制限は置く必要がある。

    - ユーザが set +o emacs を実行すると正しく ble.sh から抜けることができない。
    - 更に set +o emacs に続けて改行が含まれる場合にはコマンド自体も正しく実行されることは保証できない。

  * ble-decode: 分離: ble-decode/keymap/resolve-name 関連 [#D0403]

    他に以下のようなものが ble-edit.sh の存在・使用方法を想定している。

    - _ble_decode_key__kmap=emacs の既定値
    - bleopt_default_keymap=auto の既定値

    ble-decode/keymap/resolve-name に関しては外部で関数定義できるようにするのが良い。
    bleopt_default_keymap に関しては元々外部から設定するべきものである気がする。
    _ble_decode_key__kmap=emacs の既定値もその時に同時に指定するべきな気がする。

    →整理した。

    1. ble-decode/keymap/resolve-name は外部から上書きして使う事にした。

      またこれを機に外部から上書きして設定を行うことを目的とする関数を "設定関数" とし、
      またその名前をできるだけ "モジュール/大文字名" の形式になるようにした。
      ここで "モジュール" とは ble-decode などのことである。
      現在以下の設定関数が ble-decode.sh には定義されている。何れも ble-edit.sh で上書きされる。

      - 設定関数 ble-decode/PROLOGUE
      - 設定関数 ble-decode/EPILOGUE
      - 設定関数 ble-decode/DEFAULT_KEYMAP -v varname
      - 設定関数 ble/widget/.SHELL_COMMAND command
      - 設定関数 ble/widget/.EDIT_COMMAND command

      またこれに伴って ble-decode-byte:bind も ble-decode/.hook に改名した。
      使われていない ble-decode-char:bind 及び ble-decode-key:bind は削除した。
      (これらの関数は恐らく初期の実装のときのテストに使われたものであった。)

    2. bleopt_default_keymap は ble-edit.sh 側で管理することにした。ble-decode.sh は関知しない。

    3. _ble_decode_key__kmap=emacs の既定値は ble-decode.sh を単体で読み込んだ時には何れにしても
      (例え動作しないとしても) 何らかの値を設定しておく必要があるので現状通り取り敢えず emacs を設定することにした。
      同様に既定の ble-decode/DEFAULT_KEYMAP も emacs を設定するようにする。

  * vi-mode: bleopt_default_keymap [#D0402]

    % 結局、ble.sh で編集モードに対応しているのは bleopt_default_keymap である。
    %
    % 更に具体的な emacs keymap の定義は ble-edit/load-default-key-bindings から
    % source "$_ble_base/keymap/emacs.sh" を通して読み込まれている。
    % この時 bleopt_default_keymap などは参照せずに直に emacs.sh が指定されている。
    %
    % この辺りは bleopt_default_keymap を参照するようにして良いのではないか。
    % 或いは bleopt_default_keymap は動的に変わったりする物であっただろうか。

    [現状]

    改めて bleopt_default_keymap がどの様に使われているかについて確認しておく。

    - 先ず ble-decode において _ble_decode_key__kmap が空の時の既定の keymap 名として使われている。

      これについては _ble_decode_key__kmap による。調べてみると
      _ble_decode_key__kmap は最初は中身は空のようである。
      先に中身を設定してしまうと、ble の設定箇所で bleopt_default_keymap が変更された場合に対応できないからであろう。
      これに関しては ble-attach のタイミングで _ble_decode_key__kmap=$bleopt_default_keymap を実行するようにすれば良い。

    - また ble-bind において既定の keymap として使われている。

      これは、その時の _ble_decode_key__kmap がどうであれ bleopt_default_keymap に設定を行いたい。

    - keymap/emacs.sh で ble-bind を呼び出す時の bleopt_default_keymap を上書きしている。

    こう調べてみると bleopt_default_keymap は (_ble_decode_key__kmap さえ正しく設定されていれば)
    単に keymap の構築時に使用されるだけであり実際の処理に使われる訳ではない。

    [変更]

    結局 bleopt_default_keymap は改名しないことにした。
    但し特別な値 auto が入っている場合には、実際に bleopt_default_keymap の値を読み出す時に、
    現在の [[ -o emacs/vi ]] の状態に応じて値を解決するというようにした。
    これらの処理は素朴に考えると ble-edit.sh にあるべき気もするが、
    取り敢えず暫定的な実装として ble-decode.sh の方に配置することにした。

  * vi-mode: 次に ble-edit-attach を改修する [不要][#D0401]

    中で何をしているかというと

    1. 先ず初めに ble-edit/attach を呼び出している。

      中ではどうも大したことはしていない。
      attach, detach で PS1, IFS の保存と復元を行っている。

    2. また履歴の再読込の設定を行っている。

    他は特に何もしていない。keymap に関する設定は別の関数で行っている様だ。
    つまり、この関数は何も変更はいらない。

  * 所で set -o vi してから source ble.sh した時に動かなかったというのは何故なのか。 [#D0400]

    % GitHub #1 によるとそのように報告されていた。
    % しかし ble-decode-attach の現状の実装方法で特に問題がないように思われた。どういうことか。
    % これはよく分からないので改めて set -o vi で source ble.sh して動作を確認してみる必要がある。
    %
    % うーん。動いているような気がする。
    % よく考えてみたら set -o vi にしてから source すると死ぬのではなくて、
    % .inputrc に記述して ble.sh つきで起動すると駄目だということだった様にも思う。
    %
    % さて .inputrc に vi を使うという事を指定するにはどうしたら良いのか。
    % http://d.hatena.ne.jp/yamazakiccs/20081207/1216817670
    % → set editing-mode vi と記述すれば良いようだ。
    %
    % さて実際にやってみると特に問題もなく ble.sh が読み込まれている。
    % 変な動作も簡単に見た感じでは現れていない。
    % (もしかすると或る種のキー入力に関しては入力を奪いきれていないという可能性も残っているが、
    % それらの検証は後回しにして良いだろう。)
    %
    % 改めて #1 を読んでみると "無効になる" としか書かれていない。
    % もしかして無効になるとは set -o vi をした時と同様に反応がなくなるという意味ではなくて、
    % 単に set -o vi (の動作) が無効になるという意味なのではないだろうか。
    % だとするとこれには対応していないのだから当然のことである。
    % 実はこれについては対策しなくても良かったのではないかと思われる。

    "無効" というのは #1 の報告者の苛立ちというか "いやみ" が入った表現で、
    実際に動かないということではなかった。気にしなくて良い。

    因みに inputrc に set editing-mode vi とした場合でも、
    ちゃんと [[ -o vi ]] に反映されるので inputrc で指定されたかどうかなどのことは意識しなくても良い。

  * vi-mode: まずは ble-decode-attach を改修する。 [#D0399]

    取り敢えずは ble.sh を起動している最中に set -o emacs/vi が切り替わる場合については考慮しないで良いだろう。
    切り替わった時にするべき操作は別に実装することになるだろうからである。
    そして切り替わった時にするべき操作が具体的に何になるかは、ble-decode-attach の内容に依存する。

    [現状]

    どのような変更が必要になるのか改めて調べるために取り敢えず現在の実装について観察しておく。

    1. ble-decode-bind/.generate-source-to-unbind-default

      先ず初めに現在の bind の状態を調べてそれを .save ファイルに記録する。
      そして ESC に関しては unbind するためのコードを生成する。

      この .save ファイルはキャッシュするような性質のものではなく、
      ble-decode-bind を実行する度に毎回生成するものである。

      これは set -o vi でも同じ動作で問題ないだろうか。
      つまり vi と emacs で .save のファイル名を切り替えなくても良いのではないか。
      一度に両方の keymap を上書きしていると混乱の元だし状態の把握が面倒である。
      一度に片方しか上書きしないのだとしたら同じファイル名でも問題ないように思われる。

      但し、「現在どちらのモードに対して上書きを実行しているか」の状態を管理する変数は別に保持する必要がある。
      これは実際 _ble_decode_bind_attached が担っている。現在は「上書きを実行しているか」「していないか」の2状態だが、
      emacs として上書きしているか vi として上書きしているかの情報を持たせるようにすれば良い。

      →取り敢えず現状のままで問題ないだろう。

    2. 次に source "$_ble_base/bind.sh" を呼び出す。

      ここでは ble_decode_bind.40412.bind (40412 は実際は bash の version) を生成する。
      このファイルの中にはその bash の version において、
      キー入力を全て横取りする為に必要な bind の列が含まれる。

      実はこれについても set -o vi と set -o emacs で違いはないように思われる。
      念のため bind.sh の中身についても確認しておく。やはり vi/emacs に依存する処理は行っていない。

    [変更]

    従って、変更は _ble_decode_bind_attached の管理だけである様に思われる。
    _ble_decode_bind_attached は他に ble-decode-detach が参照している。
    他の箇所からは参照されていない。

    ble-decode-attach ではどのモードで attach したかを記録しておくだけで良い。
    ble-decode-detach では _ble_decode_bind_attached の内容に応じて、
    set -o vi/emacs で attach した時のモードに戻しておいて、
    その状態で bind を復元してから元のモードに戻るようにすれば良い。

    (モードを復元している最中に ^C で中断などが入ると変なことになるがそれは仕方がないだろう。
    ただ簡単に状態を復元する方法というのを実装しておいても良いかもしれない。)

    この変更により ble-decode-detach を呼び出す時の編集モードは気にしなくて良くなった。
    つまり、先の変更により ble-decode-detach を呼び出す前に set -o emacs に戻していたが、
    ble-decode-detach の中で適切な編集モードに切り替えるので、外でその操作をする必要はなくなる。

    取り敢えず変更は実施した。


2017-09-03

  * ble-syntax: here string が here document と解釈されている。 [#D0398]

    これは ble-syntax.sh の .check-delimiter-or-redirect の中の判定の順序であった。

  * 2017-09-01 permission のないディレクトリで補完しようとすると以下のメッセージが表示される。 [#D0397]

    ヒアドキュメント用一時ファイルを作成できません: 許可がありません
    -bash: ヒアドキュメント用一時ファイルを作成できません: 許可がありません

    % TERM に依存して出たり出なかったりする様だ。
    % 現在 tkyntn の上でしか再現していない。
    % 元々 tkyntn は色々とおかしいのでもしかすると他では再現しないのかもしれない。
    %
    % どうも TERM ではなくてログインシェルかどうかで変わるようである。
    % ログインした後に bash として入ると大丈夫である。
    % 一方で、bash --login とすると駄目である。
    % TERM=xterm-256color でも再現することを確認した。
    %
    % どうやら ble の中で起こる問題というわけでもない様だ?
    % bash --norc で入って cd ~yabe して cat <<< hello とするとエラーを吐く。

    更に以下のコマンドだけでエラーが再現する。

    $ bash -c 'cd ~yabe; cat <<< hello'

    これは ble.sh の問題ではなくて bash の問題かもしくは tkyntn の問題である。
    特に tkyntn は最近様子がおかしいので高確率で tkyntn が悪いのであろう。

    % 何れにしてもエラーメッセージがそのまま外部に漏れるというのは変な気がするので、
    % これについては何処かで対策をしたほうが良いだろうか。
    % うーん。どのタイミングでエラーメッセージを無視するのが良いかは微妙である。
    % というよりエラーメッセージをそのまま握りつぶして良いのだろうかという問題もある。
    % もしかすると ble.sh 専用のログファイルを何処かに用意してそこにエラーを出力するようにする方が良いのかもしれない。
    % ただし、もしそうするのだとすると、これは今回の問題だけでなくて ble.sh 全般に関わることなので全体的に整備しなければならない。

    改めて問題になっている ble-complete/source/argument/.compgen の ble/util/assign の中のヒアストリングの周りを見る。
    丁度一つ上の行で 2>/dev/null でエラーをそのまま握りつぶしているので、
    問題になっている行でも同様に握りつぶすという対策で問題ないだろう。

2017-08-30

  * GitHub で Issue が来た。set -o vi の人だ。 [#D0396]

    以下の点について修正する。

    - [[ -o vi ]] の時は ble.sh をロードしない

    - コマンドの実行の結果 -o vi になった時は ble-detach する。

    - ble-detach する時には本来の emacs keymap に対して実行するために
      一時的に現在の編集モードを退避して後で復元する。

      将来的に set -o vi に対応した時には両方で keymap を復元する様に
      ble-detach の中を書き換えるか、emacs/vi mode に拘らず
      常に bash "set -o emacs" の上で ble.sh "emacs/vi" の動作を実装すれば良い。

    - ble-attach の時に [[ -o emacs ]] をチェックする。


2017-08-19

  * ble-edit: C-x C-x で内部的なカーソル位置は変わっているが表示に反映されない。 [#D0395]

    →どうも反映されないというよりは移動前の位置にカーソルが表示される様だ。
    C-x C-x を二回実行すると分かる。これは何故だろう。
    ble/widget/exchange-point-and-mark では単に _ble_edit_ind と _ble_edit_mark の内容を交換している。
    その他の箇所からはこの関数は参照されていない。という事はこの関数の問題というよりは表示の問題だろう。

    そもそもカーソル位置の更新は何処で実行されているだろうか。
    ble-edit/render/update が怪しい。この関数の先頭で _ble_edit_ind/_ble_edit_mark
    がどのような状態になっているか確認する。
    どうやらこの関数を呼出した時点では _ble_edit_ind 及び _ble_edit_mark は更新前の値になっている様だ。

    % もしかして exchange-point-and-mark が呼び出されていないのでは? と考えたが、
    % 実際に入力すると期待する位置に文字が挿入されるため、exchange-point-and-mark は呼び出されているはずだ。
    % もしかすると bash が入力を食らっていて C-x C-x をユーザ側で入力しても未だ処理されていないのかもしれない。
    % しかしそうだとすると C-x C-x を入力した時に ble-edit/render/update がちゃんと2回呼び出されている事と矛盾する。
    % よくわからないので exchange-point-and-mark の中で鳴く様にしてちゃんとこの関数が呼びだれているか、
    % 呼び出されているとすればどのタイミングで呼び出されているかを確認する。

    →どうやら exchange-point-and-mark が呼び出されていない。
    疑わしいのは decode の方である。もしかすると C-x C-x ? の様な形のコマンドが登録されてしまっているのかもしれない。
    或いは ble-decode が壊れていて C-x ? の様な形のキーシーケンスがその場で呼び出されない可能性もある。
    →これについては C-x C-v が即座に実行される事から考えにくい。
    何れにしても C-x C-x ? の様な紛らわしいコマンドが登録されていないかを確認する必要がある。

    →ble-bind -d で確認してみた。C-x C-x が曖昧になるようなキーシーケンスは登録されていない。
      と思ったら ble-bind -k 'CAN @ h' などが怪しい。CAN は C-x に一致するはずなので、
      バイト C-x が単体で来た状態の場合にはそれがキー C-x なのかキー hyper, etc. なのかの判断が付かない。
      これが怪しい。これについては試しに CAN @ の bind を削除してみれば分かる事である。

    取り敢えず "CAN @ ?" を削除してみたら動くようにはなった。
    しかしそれでも微妙な遅延が見られる。emacs では遅延がないのでこれは端末の設定だろう。
    少し stty 周りを見ても分からないし大きな問題でもないのでこれは後回しで良いだろう。

  * [2017-06-12] ble-edit: 選択した状態で self-insert したら選択した範囲の文字列は消えてほしい。 [#D0394]

2017-06-09

  * bash-4.2 で何か入力しようとすると segfault する。 [#D0393]

    初めは mathieu の上で気付いたが padparadscha でも再現する。
    bash-4.0, bash-4.1, bash-4.3, bash-4.4 では大丈夫。
    これは bash-4.2 の算術式のバグを踏んでいる可能性が高い。

    grep で '],' を探してみる。
    2015-02-23 04:46:57 ble-edit.sh:1286:     if ((ichg=old_ichg[j],
    2017-03-01 10:09:47 ble-syntax.sh:1401:         ((_ble_syntax_attr[i++]=_ble_syntax_attr[inest],

    二つ目が怪しい → 修正したけれど治らない。
    これはクラッシュする箇所を少しずつ絞り込んでいくしかない。
    怪しいのは self-insert の前後と、描画部分である。
    しかし、描画部分に関してはプロンプトは表示されているのだから、
    大体大丈夫なのではないかという気がする。
    或いは文法に従った着色の部分が怪しいか、文法の解析部分が怪しいか。
    一番怪しいのは文法周りなので、先ずはそこを囲んで print してみる事にする。

    ble-syntax/parse を呼び出しているのは function _ble_edit_str.update-syntax だけである。
    _ble_edit_str.update-syntax は ble-syntax.sh:3830 と complete.sh から呼び出される。
    complete.sh は今回の場合は使っていないので、これは関係ない。
    ble-syntax.sh では関数 ble-highlight-layer:syntax/update から呼び出している。
    更にこれは ble-edit.sh の関数 ble-edit/text/update から
    ble-highlight-layer/update を呼び出しているのが引き金になっている。
    更に呼び出し元は ble-edit/render/update である。
    取り敢えずこの関数で echo をしてみる事にする。

    -> ble-edit/text/update の中で起こっている
    -> ble-highlight-layer/update の中で起こっている
    -> ble-syntax/parse の中で起こっている
    -> ble-syntax:bash/ctx-command の中で起こっている
    -> ble-syntax:bash/ctx-command/.check-word-begin の中で起こっている
    分かった。(((wtype=_ble_syntax_bash_command_bwtype[octx])||(wtype=ctx))) だ。
    修正したら大丈夫になった。念のため、類似の危険な箇所がないか確認する。

    $ grc '\]\)[^)]'

    ./ble-core.sh:713:      if (((time2[0]-time1[0])*1000+(10#0${time2[1]::3}-10#0${time1[1]::3})>=msec)); then
    ./ble-syntax.sh:720:    ((onest[3]<0?(parent_inest=onest[3]):(parent_inest-=onest[3])))
    ./ble-syntax.sh:2585:      (((klen=stat[k])<0)) && continue

    bash-4.2 のバグは式の構造だけに依存しているので、文脈によらずに実際のその式を実行してみれば良い。
    現に問題になっていた式をそのまま bash-4.2 の対話シェルから実行してみると segfault が再現する。
    上で見つかった物についてチェックする。1つ目の式構造は大丈夫だった。2つ目も大丈夫。3つめも大丈夫。OK

    因みに一番最初に見つけて修正した ble-syntax.sh:1401 についても bash-4.2 はクラッシュした。
    結局 2 箇所修正が必要だったという事である。

2017-05-20

  * ble を再度 source すると history を再度読み込む様になるのは何故か。 [#D0392]
    既にロードされている時は無視するのではなかったか。

    恐らく ble-attach を呼び出しているせいである。
    既に ble-attach されている状態で再度 ble-attach している場合何が起こるのか。
    現在は状態のチェックを行っていないがこれには理由はあっただろうか。

    ble-decode-attach は内部で現在の状態を記録しているので
    重複して呼び出しても実際には処理は実施されない。

    ble-edit-attach は内部でのチェックは行っていない。
    ここで history の情報を初期化しているので、
    これが原因で再度読み込む様になっているのだろう。
    history を再度読み込む必要があるのは、
    detach している間に実行したコマンドがあるかもしれず、
    その為に history と ble の管理している履歴情報に
    ずれが生じているかもしれないためである。
    なので既に attach しているかどうかの情報を保持する必要がある。

    ble-attach 自体で既に attach しているかどうかの情報を管理する様にしたい。
    既に _ble_edit_detach_flag という変数がある様だがこれは何のために使っているのだろう。
    →これは次にキーに対する処理が終わる時にシェルを終了するかどうかを管理するのに使う。
      通常時は常に空欄になっている変数である。この変数は使えない。
    従って新しい変数を導入する必要がある。ble-decode-attach と同様に管理すれば良いだろう。
    そして ble-decode-attach の使っている変数 _ble_decode_bind_attached は単純に局所的に
    使われているだけであるのでこれで問題ないだろう。


2017-04-21

  * [2017-04-15] bash-4.4: C-x ? のキーバインドができなくなっている? [#D0391]

    bash-4.2 以下と同様に C-x ? だけ特別に処理する様に戻した。
    結局、C-x ? に特別な処理が必要ないのは bash-4.3 だけということであった。

2017-03-13

  * [2017-03-11] LANG=C./a 等の様に locale に変な文字列があると毎回エラーメッセージが表示されてうるさい。 [#D0390]
    エラーは抑制するべきではないか。

    概ね、LC_COLLATE=C command &>/dev/null とすれば良い様だが、
    function ble/util/is-stdin-ready { IFS= LC_ALL=C read -t 0 &>/dev/null; }
    としてみたが LC_ALL に変な値が入っている時のメッセージは抑制できなかった。
    function ble/util/is-stdin-ready { IFS= LC_ALL=C read -t 0; } &>/dev/null
    の様にすれば大丈夫だった。

    # そもそもの問題として read -t 0 の仕様として
    # IFS や LC_ALL を設定する必要があるのかどうかは分からないが。

2017-03-05

  * complete.sh: bug 補完対象に ` \n \t が含まれる場合にエスケープされていなかった。 [#D0389]

  * ble-core: ble_util_upvar_setup で local ret するべきなのでは。 [#D0388]
    ble_util_upvar で $ret を参照しているので。

    調べてみた所、全ての ble_util_upvar_setup 使用箇所で結局 local ret を宣言している。
    また、ちゃんと ble_util_upvar_setup は ble_util_upvar と対になって使用されている。
    従って local ret を ble_util_upvar_setup の中に入れるのが適切である。


  * syntax: ヒアドキュメント: << <<- の違いや EOF 'EOF' の違いが働いているかどうか確認する。 [#D0387]

    <<- が効いていない。というか nparam のフラグが I になっていない。
    と思ったら参照している ctx が nest-pop 後の ctx だった。
    nest-pop 前の ctx を octx に保存して、その octx を用いて判定する事にした。

    EOF と 'EOF' の違いに関してはちゃんと期待通りに動いているので良かった。

  * color: 古い仕組みの layer とそのアダプターの機能は流石に削除してよいのではないだろうか。 [#D0386]

    ble-syntax-highlight+* 云々という関数は全て古い仕組みである。
    また変数 bleopt_syntax_highlight_mode は古い仕組みに置ける highlighter 選択の為に用いられる。
    これらの仕組みはアダプター ble-highlight-layer:adapter/* から参照され、
    アダプターは _ble_highlight_layer__list=(plain adapter) 等とする事で登録される。

    一方でアダプターは zsh 方式の highlighter を import するのにも使えるのではないか?
    という気がしないでもない。これ自体そんなに長いコードでもないので残しても良いかもしれない。
    しかしその様に考えると実装例も一緒に残しておいた方が良いという事になり、
    結局古い仕組みも残しておくという事になりはすまいか。
    だとすれば思い切って此処で捨ててしまうのの方が良いようにも思う。

    うーん。highlighter のサンプルとして別ファイルに残しておくという手もあるかもしれない。
    というかそれが良いような気がしてきた。

  * IFS guard [#D0385]

    所でよく考えてみたら IFS をユーザが変更した場合には色々と大惨事が起こるのではないか…
    bind 及び exec の部分でちゃんと local IFS=$' \t\n' を設定する様にしなければならない。
    →試してみた所やはり大変な事になる…。これは後で最優先で対処しなければならない。

    何処で対処するのが良かろうか。
    例えば関数内で local IFS= を設定する様にするというのが一つの手である。
    もう一つはコマンドを実行する直前に IFS を戻して、
    コマンドを実行した直後に IFS を保存するという様にする方法である。

    シグナルハンドラを設定する場合はどうだろうか。
    シグナルハンドラの中ではユーザの設定した IFS が見えて欲しい。
    そういう事を考えると local IFS= が良い様な気がする。
    一方で exec:exec では結局 IFS を保存・復元しなければならない。
    実際の所シグナルハンドラの中にいる時は LINENO 等の値も変な物になっているので、
    IFS だけに拘っても仕方がないかもしれない…と言いつつ IFS は影響範囲が大きいので
    やはりシグナルハンドラの中であってもユーザの期待する物になっているべきである。

    うーん。以下の項目について対処すれば良いだろう。

    - 関数内で local IFS= を設定する。
      1. bind から呼び出される関数
      2. _ble_decode_bind_hook から呼び出される関数
      3. シグナルハンドラから呼び出される関数
        → これは trap を検索すれば良い。
      4. 初期化時に呼び出される関数 (ble-attach 及びロード時に強制的に実行する関数たち)
        →これは漏れがあると行けないし汚くなるのが嫌なので、
          ble.pp で IFS を保存して自分の物に設定し最後に復元するというので良いだろう。
    - exec:exec では IFS の保存・復元を実行する

    [書き換え]

    - ble-decode-byte:bind
    - ble-edit/exec:gexec/.begin
    - ble-edit/exec:gexec/.eval-prologue
    - ble-edit/exec:gexec/.eval-epilogue
    - ble-edit/exec:gexec/.end
    - ble-edit/exec:gexec/.eval-TRAPDEBUG
    - ble-attach

    以下の関数は明らかに影響がないので IFS の設定は省略する。
    - ble-stty/TRAPEXIT
    - ble-edit/exec:gexec/.eval-TRAPINT
    - ble-edit/exec:exec/.eval-TRAPINT
    - ble-edit/exec:exec/.eval-TRAPDEBUG
    - ble-detach

    ble.pp では ble/.check-environment の直前で IFS を設定し、
    ble-attach の直前で IFS を復元する。

    exec:exec は関数内でユーザコマンドを実行するため IFS を復元・保存しなければならない。
    _ble_edit_PS1 と同じ箇所で同様に復元・保存すればよいだろう。
    但し ble-edit/attach, detach に関しては bleopt exec_type=exec の場合のみに
    _ble_edit_IFS への保存と復元を行う事にする。

    - ble-edit/attach 保存
    - ble-edit/detach 復元
    - ble-edit/exec:exec/.eval-epilogue (保存)
    - ble-edit/exec:exec/.eval-recursive (復元)

    取り敢えず動いているので良い事にする。
    未だ何処かに漏れがある可能性もあるが、
    IFS に変な値を入れる人もそんなにいないだろう。

  * memo.txt: 項目に番号を振っても良いのではないだろうか。 [#D0384]

    過去の項目について参照する機会も度々ある。
    少なくとも Done に送られた項目に対して番号を振るというのはありなのではないだろうか。

    いま確認してみると比較的複雑な問題解決に関しては、ごく初期の頃に X1-X6 の番号を振って記録している。
    しかしより単純な物については番号が振られていないし、また X1-X6 の番号づけもすぐに廃れている。
    今度改めてこれらを整理し、大小に拘らず番号を機械的に振っていくというので良いのではないだろうか。
    また過去の記録の形式と現在の記録の形式を合わせるというのにも役立つ。

    取り敢えず番号を付けた。この項目は #D0384 である。

  * syntax: select name [in ...]; do ... done [#D0383]

    考えてみたら select には対応していなかった。

    試してみると select name do ...; done の形式でも OK の様だ。
    また select name; { ... } の形式も可能である。
    マニュアルには書かれていないが。
    実の所 for と殆ど同じである。
    違うのは単語が一つ以上必要という事と、
    for ((;;)) の形式がないという事である。

  * syntax: bug 6b84ee7 の修正はバグである。元々 CTX_ARGX0F という特殊な文脈値を用いて [#D0382]

    特別に { を受け付ける様にしていたのであった。なので、CTX_CMDXE にするのではなくて、
    CTX_ARGX0F の処理の方で do も受け付ける様に修正するべきであったのである。

    と思って CTX_ARGX0F の方で { に一致しなかったら CTX_CMDXE にする様にしてみたが、
    いろいろ考えて見るに CTX_CMDXE と同様に処理する CTX_CMDXD という物を用意する方が良いという事になった。
    結局 CTX_ARGX0F を CTX_CMDXD という名前に改めて実際の文脈値として取り扱う事になった。

  * syntax: ヒアドキュメント (here documents) 対応 [#D0381]

    > * [2015-02-16] ble-syntax.sh ToDo
    >
    >   - Here document
    >     Here document は次の行から始まるというのが厄介である。
    >
    >     一旦始まってしまえば Here Document の処理は比較的簡単であろう。
    >     <<EOF の形式では $() 及び `` だけ特別に処理を行えばよい。
    >     <<'EOF' 等の形式ではそのまま EOF を探せばよい。
    >
    >     始まる迄は何処かで待ちになっている HEREDOC の情報を記録する必要がある。
    >     そして改行が現れた際にヒアドキュメントを開始するのである。
    >     ヒアドキュメントは quote の中などでは始まらない。
    >     結局 CTX_CMD, CTX_ARG 等で改行が来た時にヒアドキュメント開始を調べる感じだろうか。

    [考察]

    何処に開始待ちになっている HEREDOC を記録するか。新しい変数を導入するのか。
    或いは、既存の変数またはネストに記録を行うのか。

    a ネストに記録するのだとすると新しく HEREDOC を導入する為だけに新しいネストを
      導入しなければならない。文法構造の変化がどの様になるかはちゃんと考えていないので分からないが、
      本来あるべき構造と離れるために変なことになりそうに思うのでこの方法は良くない。

    b だとすると新しい変数を導入して状態を記録するしかないように思われる。

    因みに現在使っている変数としてどの様な物があるか改めて確認してみる事にする。
    結局 stat (ctx wlen wtype nlen tclen tplen) に格納される情報が全てである。
    その他の情報は復元の対象にならないから、これに依存した解析にはできない。
    stat の各要素に対応する変数は実際には関数 ble-syntax/parse/generate-stat にて
    変数 ctx wbegin wtype inest tchild tprev から生成される。

    ctx wbegin wtype 等はヒアドキュメントとは異なる寿命を持つ構造なのでこれにヒアドキュメントの情報を格納する事はできない。
    inest tchild tprev は何れも位置を表す変数であるからこれにヒアドキュメントの文字列を格納する事もできない。
    ただ、文字列を格納する代わりにヒアドキュメントの word の位置を記録するというやり方もある。
    その方がシフトも簡単だろう。更に、入れ子構造も考慮に入れて改行が現れたらヒアドキュメントを開始するという事にするのだとすれば、
    tprev と同様の取り扱いにするのが良いようなきがする。シフトについても tprev と同様で良いのではないだろうか。
    やはりこの様に考えてみると解析用の変数を追加する事は免れない。

    a 新しい変数の値を文字列で記録するのだとすれば shift の必要性はない。
      また、後々にヒアドキュメント以外の情報を格納したくなった時の拡張も比較的簡単にできる様になると思われる。
      同じ変数の中に文字列として連結して情報を格納できるからである。

    b もしヒアドキュメントの単語の位置を記録するのだとすれば shift は tprev と同様にすれば良い。
      しかしよく考えてみれば単語の内容に依存するのであるから stat が一致しているかどうかを判定するために、
      その位置にある単語の内容に関しても一致するかどうか判定しなければならなくなる
      (丁度 inest から nest を辿っていって全て一致しているかどうかを確かめる時の様に)。
      更に毎回単語を読み取ってそこから終端の記号を確認しなければならない。大変である。

    この様に考えると直接文字列で保持するのが良い。単語の内容に依存した参照である必要は全くない。

    | 実は nest もこの様に保持するという手があったかもしれない。ただそれだと複雑なネストの場合に、
    | ネスト構造を記録する変数の内容がどんどん長く・複雑になっていくという問題があったという事だろうか。
    | 或いは、ネスト構造を判定する度に情報を毎回抽出するのが面倒?という事だろうか。
    | しかし、思うに nest で重要なのはその時点での状態だけであって、
    | nest の開始位置というのは実はそれ以降の解析に影響を与えない。
    | 更に shift の必要もないし、やはり nest も文字列情報として記録したほうが良かったのではないかという気がしてくる。
    | 現在 nest 構造を記録する度に 7 つの変数を記録しているが、
    | 別に一回の nest で 7 個ずつ変数を使うというので問題ない気がする。
    | うーん。これに関しては以下で考察を与える:
    |
    | cf. #D0377 "2017-03-04 syntax: [考察] _ble_syntax_nest の取り扱い。"

    さて変数を追加する場合には何処を修正しなければならないだろうか。
    先ず stat と nest のフィールドの数は増加させなければならない。

    nest に関しては _ble_syntax_nest を参照している箇所を確認すれば良い。
    stat に関しては沢山ある…。
    面倒なので先に変数を増やししまってから少しずつ変更していく事にする。

    新しく増やす変数はどの様な名前にするのが良いだろうか。

      現状の考えでは nest level に固有の文字列であり、
      nest-push すれば空になり、nest-pop すればまた復元するという物を考えている。
      (この様な動作は、将来的な do done や { } の対応を取る場合にも都合が良いだろう。)
      従って、その事を反映して n* という名前にするのが良さそうである。
      解析途中状態を記録するための一般の変数名として良いのは何だろうか。
      例えば Emacs の font-lock では文章中に text-property を設定できて、
      その text-property を様々な解析状態の記録に利用する事ができる。
      Visual Studio の AddIn を作る場合 (着色を設計する場合) はどうであっただろうか。
      これは行毎に何らかの値を保存できる様になっていたはずだが変数名までは覚えていない。
      しかし何か System.IntPtr だった様な気もする。LPARAM, WPARAM の様な物だろうか。
      その様に考えると nparam という名前で良いような気がしてきた。

    →nparam にする。

    [実装]

    1 変数の追加

      nparam という変数を導入すると共に先ずは stat 関連の修正を行う。
      比較的変更は少なくて済むような印象である。
      基本的には初期化の部分、ble-syntax/parse/generate-stat の修正と、
      ble-syntax/parse/shift.stat をすれば動作する。
      更にデバグ用の出力のために ble-syntax/print-status/stat.get-text
      (今回 stat の内容を文字列化する処理の部分を切り出して作った関数) を修正すれば良い。
      nest に関しても同様でそんなに大局的な変更は必要ないようである。
      つまり、nest-push, nest-pop, nest-type を抑えれば良い様だ。
      nest-type の実装を考えると ntype は一番最後の引数にするのが良い。
      だとすると nparam='' の時に nparam を記録する際には何か代替になる値を指定しなければならない。
      ntype と統一するのであれば none という値にするのが良い。格納する時と取り出す時に気をつければ良い。

      →取り敢えず nparam という解析状態変数の追加と stat/nest の変更は完了した。

    2 次に here documents 指定があった場合に nparam を設定するコードを追加する。

      これは特別な文脈値 RDRH を導入して処理する事にする。
      RDRH の単語の終了時に nparam を設定する。

    quote した時に指定する事のできる文字列

      | 所で here document の quote で空白を含む文字列を指定した場合はどうなるのか。
      | →試してみた所、何と delimiter に空白を含ませる事も可能な様だ。
      | もっと色々試してみるとセミコロンなども含める事ができる。
      | stat や nest に格納する場合には空白類は含められない。
      | という事は nparam に設定する際に空白類はエスケープしなければならない。
      | 或いは stat や nest に設定する時にエスケープをするか。
      | stat/nest に設定する時にエスケープをするというのだと色々の箇所で対処をしなければならず面倒である。
      | なので初めから nparam には空白類が入らない様に構成する方が現実的である様に思う。
      |
      | 更に delimiter に改行が含まれていると、
      | 2行に渡って delimiter を指定したとしてもそれには引っかからず
      | 最後まで here documents が終わらないと解釈され、警告が出る (でも警告なのでコマンド実行は為される)。
      | つまり delimiter の判定をする際には行毎に切って、
      | その上で期待する delimiter との比較を行わなければならない。
      | これは step3 で処理する。

      まとめると、何でも指定できる。
      空白を含める事もできるし改行を含める事もできる。
      但し、改行が含まれている場合には決して終端に一致する事はできない。
      どうやら終端文字列は行毎に判定される様だからである。

      nparam に delimiter を格納する為にはエスケープが必要になる。

    here documents word の bash の解析方法の確認

      | 然し、本当に bash は $ を特別扱いしないという様な parse の仕方をしているのだろうか。
      | もしかすると通常通りに parse してその上で一番外側の "" だけを除去するという事をするのかもしれない。
      | その場合にはまた一層処理が面倒である。と思って試してみた。
      |
      |   << "$(echo "lll")"
      |
      | の様に指定すると終端の文字列として '$(echo lll)' を要求する様だ。
      | つまり予想通りに $ を認識していないという事になる。多分。もうひとつ試してみる。
      |
      |   << "$(echo "(lll)")"
      |
      | もし入れ子を認識していないのであれば裸の () が現れるのでエラーになるはず。
      | もし入れ子を認識しているのであれば構文エラーにはならずに '$(echo (lll))' 全体を終端文字列として要求するだろう。
      | →何と '$(echo (lll))' を終端文字列として要求して構文エラーにはならなかった…。
      |
      |   << ""(lll)""
      |
      | で試すとちゃんと構文エラーになる。つまり、ヒアドキュメントの word には () が指定できる等ということでも無いようだ。
      | つまり、これらの動作から推測するに bash の解析は、先ず初めに $() の入れ子なども考慮に入れて解析を行う。
      | その後で $() の置換を実行せずに字面でクォート除去に進む。という事なのだろう。
      | だとすると解析時とクォート除去時で不整合が生じる様なケースを人為的に作成する事ができる様な気がする。
      | 試してみる。
      |
      |   << "$(echo "'")"
      |
      | これを実行したらエラーにはならなかったが終端文字列として '$(echo ()")"' という物を要求する様になった。
      | つまり ' の終端が欠けている形と見なされている様だ。この動作は先程の bash の動作の推測と合致する。

      まとめると bash はコマンド置換などの入れ子も考慮に入れて解析を行うが、
      最終的には入れ子構造は無視して字面で quote 除去を実行する。
      中途半端な '' "" などの quote があった場合には最後まで囲まれていると見なす。
      除去する quote は \? '' "" $'' $"" である。

    うーん。入れ子も考慮に入れた解析は実はそんなには難しくないような気がする。
    結局のところ $( が来たら対応する括弧 ) まで読み飛ばすという様に実装すれば良いのだ。
    内部の細かい文法規則まで追跡する必要はない。
    最終的には専用の文脈値を用意するという方針で行くのが良い様に思う。
    現状では、もっと素朴な実装をしてしまった。通常の RDRS と同様の実装に戻す事も可能であるが
    勿体ないので暫定的に現状の実装で進める事にする。

      もっと bash で試してみると

        << $(echo ${hello/)/))}) → 終端文字列 '$(echo ${hello/)/))})'

      という事になった。つまり、(1) quote が全然なくてもちゃんと入れ子を含めて単語を認識している。
      (2) $() の括弧の入れ子だけではなくて ${} の入れ子についても追跡をしなければならない。
      これを考えると従来の方法で解析しておいた方がやはり良いのかもしれない…。

      後で折を見て従来の方法に戻す事にする。
      取り敢えずは here documents の対応を完成させる事を目指す。

    % さてここで一つの懸念に思い至った…こうした複雑な解析の結果を nparam に指定した後で
    % 保存されてそれから shift が起こった時に変な事にならないかという事である。
    % これは考えて見るに大丈夫である。というのも結局はやはり過去の情報しか参照していないという事。
    % そして shift などが起こって word の内部で更新が起こったとしても、
    % 結果として起こるのは nparam の不位置に依る stat の不一致であり、
    % "解析が殆ど全部やり直しになる" という事以外の問題点は発生しない。
    % 解析がやり直しになることについては here documents である以上は避けられない事なので気にしなくて良い。
    % →気にしなくて良い。

    2.1 quote 除去も実装しなければならない。

      →ble-syntax:bash/ctx-heredoc-word/remove-quotes に実装した。
      簡単にテストを実行してみる。
      OK ble-syntax:bash/ctx-heredoc-word/remove-quotes fire; echo $delimiter
      OK ble-syntax:bash/ctx-heredoc-word/remove-quotes "\"\$(echo \"(fire)\")\""; echo $delimiter
      OK ble-syntax:bash/ctx-heredoc-word/remove-quotes "\"\$(echo \"(fire)\")"; echo $delimiter
      OK ble-syntax:bash/ctx-heredoc-word/remove-quotes "\"\$(echo \"(')\")\""; echo $delimiter
      OK ble-syntax:bash/ctx-heredoc-word/remove-quotes '\[\$hello\`\]'; echo $delimiter
      NG ble-syntax:bash/ctx-heredoc-word/remove-quotes '"\[\$\"\`\\\]"'; echo $delimiter
        変だ。\$ (など) が $ (など) にならない
        → OK str=${str//"$b"/$a} の様にしなければならなかった。修正した。
      OK ble-syntax:bash/ctx-heredoc-word/remove-quotes 'hello$'"'\e[1mthis\e[m'"'world'; echo $delimiter

      取り敢えず良さそうである。

      追記: 終わっていない "" or '' で中途半端な \ が末尾にある場合にはどういう扱いになるのだろう。
      試してみると…。

        $ eval 'echo << "$(echo '\''"\'\'')"\'
        bash: 警告: ヒアドキュメントの 10 行目でファイル終了 (EOF) に達しました (`$(echo '')' が必要)
        $ ble-syntax:bash/ctx-heredoc-word/remove-quotes '"$(echo '\''"\'\'')"\'; echo "$delimiter"
        $(echo '')\

      bash の振る舞いとしては終わっていない \ は消えてなくなる様である。
      一方で、現在の remove-quotes の実装だと \ が残ってしまう
      →直した。

    2.2 nparam に設定する時の escape を実装する。

      どの様にエスケープするのが良いだろうか。
      先ず除去しなければならないのは空白類である。つまり、空白・タブ・改行である。
      更に nparam 自体のフィールドセパレータも考慮に入れなければならない。
      今まではコロンをセパレータに使おうと考えていたが…。

      また復元する時に簡単にできる様にするには \\ でエスケープして
      $'' で戻すという様にするのが良いかもしれない。
      パラメータ展開の置換 ${var//a/b} を繰り返すよりは、
      一回 eval を実行してしまった方が早かろう。
      ただ、変な文字が含まれていない限りはエスケープは必要ないので、
      変換方法についてはそんなに気にする事もないかもしれない。
      然しながら何れにしても必ずエスケープ表現は定めなければならないので、
      \ でエスケープする様にすれば良いだろう。実際に復元を行う場合に、

      a if [[ $str == *\\* ]]; then str=${str//a/b}; ...; fi
      b eval "str=\$'$str'"

      のどちらが良いのかというのは表現方法に関係なく選択できる。
      但し b を選ぶとすると追加で ' もエスケープしなければならない。
      しかしそうだとしても b の方が良い様な気がする。

      また nparam 自体のフィールドセパレータに関しては、
      完全に変換を行って除去しなければならない。
      例えば 8 進数表現にするなどの方法で。
      しかし例えばコロン : を使うとなるとその 8 進表現が何であるかを確認する必要が出てくる。
      適当に ASCII C0 の FS 等を使うというのでは駄目なのか。
      しかし FS だって実際の描画文字と被るかどうかわからない…と言いつつ C0 領域が ASCII である
      事を仮定した様なコードは既に ble の中に沢山ある。という事はやはり FS で良いか。
      でも、一方でコロンの 8 進表現だって ble/util/s2c を使えば簡単に計算できる。
      何処かにキャッシュしておけば良い。或いはもう ASCII を仮定してしまっても良いかもしれない。
      うーん。まあ、取り敢えず FS を使うという方針で行くことにする。
      →FS は \034 である。もしくは ^\ である。term.sh に _ble_term_fs として追加する事にした。

      実装した。関数 ble-syntax:bash/ctx-heredoc-word/escape-delimiters である。

      更に nparam への値の設定も行う。
      ble-syntax/print-status/stat.get-text での FS のエスケープも実装する。
      ble_debug=1 bash で確認する限り、期待通りにエスケープ・nparam への設定が動いている様子である。


    3 コマンドの解析の文脈で改行が来た時に nparam に here documents が指定されていれば
      here documents の文脈値に移行する。

    3.1 先ず初めに here documents の文脈値を実装しなければならない。

      取り敢えず実装した。nparam として専用の特別な形式の値を持たせる事にした。
      ここにヒアドキュメントの属性や終端文字列を格納する。

    3.2 改行で CTX_HERE0 に入る様にする。

      これは ctx-command だけで良い?

      どのタイミングでヒアドキュメントが始まりうるのかを確認しなければならない。
      先ず \<newline> でヒアドキュメントが始まる事はない。
      ${} $() $(()) の内部で始まる事もない。
      配列の arr=() の中では始まる。

        ```bash
        cat <<EOF; \
        echo line2 ${hello#
        } line2b $(
        echo line2c
        ) $((
        1+1
        ))
        hello test1 world
        EOF
        ```

      多分、ctx-command と ctx-values で対応すれば良い。
      取り敢えず ctx-command の中を見てみる。
      ble-syntax:bash/ctx-command/.check-delimiter-or-redirect で改行を処理している。
      この関数の呼び出し元は ble-syntax:bash/ctx-command だけなので
      此処でそのまま here documents に突入して問題ないだろう。

    3.3 後は ctx-values でも同様に処理すれば良い。

      と思ったら問題が生じる。ctx-values は入れ子レベルを形成する。
      入れ子レベルを形成するのは復帰時にまた元の文脈に戻る為である。
      元の文脈は 2 種類存在する (VRHS 及び ARGVI)?
      この2種類の対応する VALX, VALI を導入しても良いが、別の方法を取る。

      nest-push nest-pop の際に nparam を持ち越す様にする。
      そのままだと規約が分かりにくいので enter/leave という関数を作って、
      それを介して nest-push nest-pop を行う様にする。

      取り敢えずは動いている様子である。

    取り敢えず動いているので、初期実装として一旦保存する事にする。

2017-03-04

  * syntax: bug: } fi done 等の直後に ; を置けなくなっている。 [#D0380]

  * syntax: 実は for name do ...; done という形式も可能の様だ。 [#D0379]

  * syntax: 実は for (()) の直後に do が来ても良いようだ。 [#D0378]
    http://qiita.com/yz2cm/items/bc5726e8aef0f2e6906e を見て気付く。

    for ((i=0;i<10;i++)) do echo $i; done
    一方で while(()) の直後は駄目。

    for (()) の直後だけは特別な文脈と考えるのが良さそうだ。
    while { true; } do done の } の直後と同様の文法的な取り扱いなのであろうか。
    取り敢えず fi を指定した時のエラーメッセージを観察してみると同じである。

    文脈的には do しか来てはならない所を他の一部のコマンドも許すというのは変かもしれないが、
    ((;;)) を抜けた直後の文脈は CTX_CMDXD という事にする。

  * syntax: [考察] _ble_syntax_nest の取り扱い。 [#D0377]

    実は nest 構造を一つの文字列にまとめてしまった方が解析が楽になるのではないか。

    - 現在は inest の情報を頼りに stat を比較する度に nest 構造を掘り出している。
      しかしそれなば flat に一つの変数に情報を詰め込んでも良いのではないだろうか。

    - shift についても複雑な処理を行う必要はない。というか shift の必要はない?
      入れ子構造の保持には shift の必要はないが、よく考えてみれば
      単語の位置などの木構造を構築するために nest の中に単語の開始位置などの情報も記録されている。
      これらを shift する必要がある。寧ろ inest の shift だけで良かった所が
      現在の全ての nest 階層でのシフトが毎回必要になる。寧ろ面倒になる可能性がある。

    - 以降の解析に影響を与えるのは nest 構造の中身だけであって inest は関係ない。
      言い換えれば、影響をあたえるのは現在どの様な入れ子になっているかの情報だけであって、
      現在の入れ子構造がそれぞれ何処で開始したのかという情報は関係ない。

    考えて見るに、初めから nest 構造を一つの文字列にまとめて実装したほうが簡単だったかもしれない。
    一方で、shift の取り扱いなどで余計なコストがかかる様になるので、
    既に nest を inest で実装する様にしてしまった現状、
    既存のコードを捨てて nest 構造を一つの文字列にまとめる様に書き換える利点はないように思われる。

2017-03-02

  * syntax: } の直後には then else elif do も来て良い。 [#D0376]
    但しこれらの直後は文脈はそれぞれの物に変化する。

  * [2016-08-06] syntax: extquote と "${}" の入れ子に関して [#D0375]
    [cf memo/D0375.quote-in-param-expansion.sh]

    "${var# ... }" などの中の '' $'' $"" は無効になる。
    では "${var:-${var: ... }}" などの入れ子になっている場合はどうなのか?
    現在の実装ではこの様な入れ子の場合には quote が有効になってしまっている。

    | どの様な状況で '' $'' $"" が無効になるのか、入れ子になっている場合も含めて調べる。
    |   少なくとも echo "${x:-${arr:'1'}}" の quote '1' は無効 (つまりそのまま "'1'" として解釈される) のようだ。
    |
    | より厳密な判定方法について調べる。
    |
    | $ hello=check-hello; echo "${hello#check}"
    | $ hello=check-hello; echo "${hello#'check'}"
    | $ hello=check-hello; echo "${hello#$'check'}"
    | $ hello=check-hello; echo "${hello#"check"}"
    |
    | 以上は全て期待通りに動作する。つまり quote 除去は実施される。result="${...}" の形式でも同様であった。
    |
    | より詳しく調査してみる [cf memo/D0375.quote-in-param-expansion.sh]
    |
    | 実は算術式として解釈する時だけの問題なのではないか。
    |
    | というか現在の実装では $(()) の中の "" や '' も許容しているが実際の bash では許されない。
    | 実際の bash で "" や '' が許されるのは (()) の時である。
    | arr['1234'] も許される。${arr['1234']} も許される。一回整理した方が良い。
    |
    | OK: (('1234')) / arr['1234'] / ${arr['1234']} / arr=(['1234']=1)
    | NG: ${var:'1234'} / $(('1234')) / $['1234']

    色々調べた結果をまとめてみる。

    - 先ず初めに算術式 ${var:...:...} / $((...)) / $[...] については、
      如何なる quote も有効にはならない。但し例外はあって、
      "${var:...:...}" でかつ shopt -q extquote の場合には $'' $"" の quote のみ許される。

    - またそれ以外のパラメータ展開の中身 (${var#...}) に関しては、
      '' と "" は何時でも有効である。そして ${} が裸の場合には $'' $"" も有効である。
      "${}" の場合には shopt -q extquote の場合にのみ $'' $"" が有効になる。

    - 更に入れ子になった場合の振る舞いはどうだろう。
      試して見た限りでは "${var#...}" / "${var:...}" の中に
      更に ${} を入れた場合は "${}" と同じ振る舞いになる様である。
      一方で "$(())" の中に ${} を入れた場合は ${} と同じ振る舞いになる様である。

    取り敢えず入れ子になっていない場合の振る舞いについて実装する。
    算術式については算術式を記述している箇所によって振る舞いが異なるので、
    その文脈を引き継げる様にしなければならない。
    現在の算術式の実装では基本的に ntype を参照しながら括弧を数えているので、
    (これまで通り) この ntype を活用して quote の有効・無効を判定するのが良いだろう。
    現在は (()) の中身と $(()) の中身で ntype を区別していないのでそれを区別する必要がある。
    同様に [] のネストと $[] の中身で ntype を区別していないのでこれも区別する。
    その為に新しい ntype '$[' と '$((' を導入する。'NQ(' も導入する。

    ここで現在の ntype について整理しておく。

    '${'      PARAM パラメータ展開の修飾 (EXPR に流れる可能性あり)
    '"${'     PARAM パラメータ展開の修飾 (すぐ外が CTX_QUOT の場合) (EXPR に流れる可能性あり)
    'v['      EXPR  パラメータ展開の配列添え字
    '$(('     EXPR  $(()) の中身 (ARGX0 に流れる可能性あり)
    '$['      EXPR  $[] の中身
    '$('      CMDX1 $() の中身
    ''        QUOT  "" の中身
    '('       CMDX  <() の中身
    ctx=?     PATN  @() の中身
    nest      PATN  @() の中身
    ''        PATN  case in () の中身
    '('/'NQ(' EXPR  式の括弧の入れ子
    '['       EXPR  式の括弧の入れ子
    ''        CONDX [[ ]] の中身
    '('       CMDX1 function f () の中身 (エラー)
    ''        PATN  f () の中身 (エラー)
    色々      RDR?  リダイレクトの右辺
                    (色々 = > &> >> &>> >| >& < <> <& << <<<)
                    (これに応じて文脈も色々 RDRF, RDRD, RDRS, )
    '('       CMDX1 () の中身
    '(('      EXPR  (()) の中身
    ''        PATN  echo ... () の中身
    'a['      EXPR  a[]= の中身
    ''        VALX  a=() の中身
    'd['      EXPR  a=([]=) の中身

    | 更に () [] のネストに際しても、$[ / $(( の中身であるかどうかを
    | 伝播させなければならないのではないだろうか。
    | (※ ${var:} の中身はネストしないのでこの点は考慮しなくて良い。)
    | →と思ったら $['1+2'] はエラーになる一方で $[a['1+2']=3] はエラーにならない様だ。
    |   つまり [] のネストに関しては必ず配列添え字であって内部ではあらゆる quote が許される。
    |   $[] の中身であるかどうかの情報は必要なく一律に今まで通りに扱って良い。
    | →逆に言えば $(()) の中身であっても途中で [] が現れたならば、その中では quote できる。
    |   現在の実装では $(()) の場合には () の入れ子だけを数え、
    |   $[] の場合には [] の入れ子だけを数えという様に取り扱っているが特別な処置が必要である様に思う。
    |
    | うーん。echo $(('1+2))')) という物を bash に食わせると
    | $(( / '1+2))' / )) というまとまりで解釈されて、
    | '1+2))' という算術式の評価の中で構文エラーになる。
    | 決して $(( / '1+2 / )) / ')) という分割になる訳ではない。
    | つまり字句レベルではやはり quote は解釈しているけれども
    | 算術式評価がその quote を受け付けないと考えるべき?
    | だとすると ble はどの様に動作するべきであろうか。
    | 自然に考えれば算術式評価に渡る前の字句的なレベルでのチェックにするのが良い。
    | もし算術式評価の際の算術式の文法について取り扱うのだとすれば別の場所で行うべき。
    |
    | 他にも解析と解釈が一致していない例はある。
    | echo "${hello:-'aa}" は構文エラーになるので quote を解釈しているのかと思えば、
    | echo "${hello:-'aa'}" で出力されるのは 'aa' であり quote 除去は為されない。
    | 一方で echo "${hello:-"aa"}" で出力されるのは "aa" であり quote 除去はされている。
    | 以前の実装で '' の quote を解釈しない様にしていたのはこれが理由であろう。
    | 因みに "${hello:-$'aa}" "${hello:-$"aa}" "${hello:-"aa}" は全て構文エラーになる。

    振る舞い云々以前に字句的な定義から言えば何れの文脈でも quote は解釈されている様だ。
    その上でその quote を含んだ文字列 (引数) について quote 除去が行われるかどうか
    が文脈に依って異なるのだという様に考える必要がある。
    - そうすると基本的な実装としては常に quote は解釈する。
    - quote が除去されない文脈では) quote の着色を外側の文脈と同じにする
    という様に実装しなければならない。

    ここで quote が除去されない文脈を判定する為に何ができるかという事である。
    但し、字句的な観点から言えば常に quote は解釈するというので間違いないのだから、
    quote 除去が実施されるかされないかについては余り実装に凝っても仕方がない気がする。
    取り敢えず現在の ntype 等の構成の範囲で対応できる所までにしておく事にする。

    - 算術式の中に直接 quote がある場合の振る舞いについて対応した。
    - "${ ... }" の中に入れ子で ${} が入る場合には "${}" と同じ扱いにする対策はした。

    そしてより凝った実装にする為にはどの様なことができるかについて記録を残す事にする。

2017-03-01

  * ble-edit: ble-edit/info/{draw-text,draw} overflow 対策。 [#D0374]

    ble-edit/info/draw-text の方は COLUMNS/LINES に従った truncate を加えた。
    一方で ble-edit/info/draw の方は truncate は加えていない。
    様々な制御機能が指定される可能性があることを考えると難しい。
    (改行や SGR だけ受け付けるという方針でまた別の draw 関数を用意するということも考えられなくはないが)。
    制御機能を受け付けるぐらいであれば、呼び出し元で高さの調整は済んでいる物と考えたい所である。

  * ble-edit: 一番下の行で複数行の編集を開始するとずれる。 [#D0373]
    これは制御機能 IL で行の挿入までは行わないという事に起因する。
    IND (LF) で行を増やしてから IL を実行する様にしなければならない。
    これで一応直った。

    然し、今度は一番下の行で行を accept した直後の動作が変である。
    直前の行を上書きしている。
    試しに ble-edit/render/update で行を追加削除する直前に各変数の値を確認してみる。

    declare -- endx="27"
    declare -- endy="0"
    declare -- begx="27"
    declare -- begy="0"
    declare -- _ble_line_endx="10"
    declare -- _ble_line_endy="3"

    変である。accept した時に _ble_line_endx _ble_line_endy の各変数の値は 0 にしている筈である。
    と思ったら、0 にしているのはカーソルの位置 _ble_line_x, _ble_line_y だけであった。

  * syntax: 実は } の直後に } が来ても良いようだ。 [#D0372]

    更に fi の直後に } が来ても良い…。同様に esac done の直後も OK の様子。
    更に } の後に done が来ても良い。fi の後に done が来ても良い。
    これらを総合すると } fi esac done は重ねる事ができるという事だろう。

    ((1+1)) の直後の場合は駄目な様だ。

    うーん。取り敢えず } fi esac done で現在 CTX_ARGX0 としているのは
    CTX_CMDX に変更すれば良い。そして更にコマンドの種類を限定する為に、
    CTX_CMDXE 的な物を用意するという様な方針でも良いだろう。
    そして同様の処理を既に CTX_CMDXC で行っているのでそれの真似をすれば良い。

    異なる点は CTX_CMDXC の状態でコマンドが終わる事はできない
    (関数の中身が指定されていなければならない) 一方で、
    CTX_CMDXE の状態でそのままコマンドが終わっても良いという点である。

  * syntax: for (()) { に対応する。 [#D0371]

    ble-syntax:bash/ctx-command/.check-delimiter-or-redirect で、
    復帰後の文脈値を CTX_ARGX0F という物に指定して、
    CTX_ARGX0F では { を受け取るかまたは CTX_ARGX1 の処理を行うかという様に処理する。

    これの対応により以下の項目については完了した。
    (残るのはヒアドキュメントのみである。)

    | * [2015-02-16] ble-syntax.sh ToDo
    |
    |   - case構文の中の文法
    |     > ;; ;& ;;& の後に case のパターンを受ける
    |   - for (()) { ...; } (obsolete)

  * syntax: ((echo)>/dev/null) を何とかする。 [#D0370]

    二種類のパターンがある。
    1. ((echo)>/dev/null)
    2. $((echo)>/dev/null)

    少なくとも文法エラーが出ない様にはするべき。

    算術式 (だと思っていた文脈) の中で単体の ) が来た場合には
    ( もしくは $( を nest-push し直す等。
    →この方法だとうまく行かない。というのも、要件として少なくとも i++ してから nest-pop しなければならず、
    また、データを格納する為には nest-push してから少なくとも i++ しなければならない。
    つまり合計で少なくとも 2 文字なければ1回の解析ループで nest-pop と nest-push を連続で行う事はできない。

    方針を変えて単体の ')' が現れたらそのまま ctx=CTX_CMDX1 に移行する事にする。
    そしてコマンドの ')' の処理において開始が '((' であった場合も考慮に入れる事にした。

  * ble-syntax: CTX_CARGI2, CTX_FARGI2, CTX_CARGX2, CTX_FARGX2 に対して補完候補として "in" を生成する。 [#D0369]
    complete.sh で "in" を生成する source を定義して、
    ble-syntax/completion-context/check-prefix と ble-syntax/completion-context/check-here において、
    CTX_ARGI, CTX_ARGX と同様に判定して、"in" を生成する source を指定すれば良い。

  * syntax: for VAR in 及び case VAL in に対応する。 [#D0368]

    | * [2015-12-24] (ble-syntax:bash): case 対応
    |
    |   case コマンドの直後は一つ単語を受け取って、
    |   次に in を受け取って更に CTX_CASE に突入する。
    |   それ以外の単語の場合には文法エラーとなる。
    |
    |   一つ単語を受け取るのは RDRF 等と同様に処理すれば良い。
    |   というか寧ろ RDRF で処理してしまっても良いのかもしれない?
    |   →それだとファイル存在チェックなどに引っかかって変な事になる。

    これは CTX_RDRS を流用する事ができそうな気がする。
    VAL に関しては補完候補の生成という側面から見ても CTX_RDRS に等価なのでは。
    VAR に関しては新しく CTX_RDRV という名前の文脈値でも定義することにすれば良いだろうか。

    しかし流用する前に確認しておくべきことがある。
    先ず初めに、リダイレクトの中で用いる事のできる文法要素と
    VAR/VAL で用いる事のできる文法要素は本当に一致しているのかという事である。
    特に VAR/VAL については素朴には CTX_ARGI と同様の扱いと考えるのが自然である。
    この時 CTX_RDRS と CTX_ARGI の扱いの差は何であるのかについて整理しておく必要がある。

    | 違い1 ble-syntax:bash/ctx-redirect/check-word-end において、
    |   プロセス置換が <() 続きにある場合には単語は続くとしている。
    |   一方で ble-syntax:bash/ctx-command/check-word-end では、
    |   プロセス置換が続きにあるかどうかは考えずに単語は終了としている。
    |
    | [bug1]
    |
    |   これは ble-syntax:bash/ctx-command/check-word-end のバグなのではないか?
    |   実際に bash で以下を実行すると、A<(echo) はまとめて一つの引数であると分かる。
    |
    |   $ printf '(%s)\n' A<(echo)
    |
    |   つまり、単語が終了するかどうかの判定を行う場合には
    |   続きにプロセス置換がないかどうかも確認しなければならない。
    |   取り敢えず単体で fix して commit する事にした。
    |
    | 違い2 ble/syntax:bash/ctx-redirect/check-word-end において、
    |   単語の終了と判定された場合には nest-pop を実行している。
    |   これは CTX_RDRS を導入する際に nest-push を伴う事に対応している。
    |
    |   何故 nest-push/nest-pop をする必要があるのかというと、
    |   元々の文脈を復元する必要があったからである。
    |   リダイレクトにおける元々の文脈は様々な可能性があるので、
    |   元々の文脈に応じてリダイレクトの文脈値を切り替える手法では、
    |   文脈値をたくさん定義しなければならず非効率的である。
    |   従って、入れ子に依って文脈を保存するというアプローチを取った。
    |
    |   ★一方で、for VAR in 及び case VAL in に関しては、
    |   抜けた後の文脈は一意に定まるのでわざわざリダイレクトの仕組みを間借りして、
    |   分かりにくくするという必要性はないのかもしれない。
    |
    | check-word-end に関してはこれ以上の違いはない様である。
    | (ctx-command の方では個別 ctx 毎に追加の処理をしているが、
    | 特に全ての文脈値に対して共通の処理をしている訳ではないということである。)
    |
    | 次に ble-syntax:bash/ctx-command と ble-syntax:bash/ctx-redirect を比べる。
    |
    | 違い3 ctx-redirect では改行やリダイレクト・コマンドの終端 (&& や | など) が来るとエラーである。
    |   コメントが其処に入った場合も駄目である。
    |   一方で ctx-command では改行やコマンドの終端が来れば単に次のコマンドに移るし、
    |   リダイレクトが来れば其処でリダイレクトを挟む事が許される。
    |   同じ理由でコメントが来る事も許される。
    |
    | [bug2]
    |
    |   だとすると既存の ctx-redirect ではコメントに対する対策をしていないので、
    |   リダイレクトの直後にコメントがあった場合にそれをファイル名と勘違いする事になる。
    |   これについて確認する必要がある…と思ったら普通に bash がエラーを吐く。
    |
    |   bash: 対応する `)' を探索中に予期しないファイル終了(EOF)です
    |
    |   何処からこれが出ているのかは分からない。いろいろ試した結果、
    |   エラーが出ているのは ctx-redirect の処理中ではなくて ble-syntax/parse の処理中ですらない様だ。
    |   恐らく tree enumerate の辺りでエラーが出ているのではないという気がする。
    |   しかし考えて見るに parse の外で tree enumerate 関係の関数を呼び出す機会はあっただろうか。
    |   →いや色付を単語ごとに実行する際に使用している筈である。
    |   もし tree enumerate 関係で出ているエラーなのだとすれば、ble_debug=1 で実行すれば
    |   より速いタイミングでエラーが出そうな物である。試してみる→特に問題はない?
    |   だとすれば着色の方が怪しい。あ、何か分かった気がする…。引数の内容を展開する時に、
    |   content=($content) 的な事をするが、その時に content が # で始まると駄目という事か。
    |   引数の内容を展開するコードは以下の2箇所にある。特に前者で問題になっている。
    |   後者に関しては問題にはならない。
    |
    |   ble-syntax.sh: eval "value=($wtxt)"
    |   complete.sh: builtin eval "COMPV=$COMPS"
    |
    |   これについても修正した。
    |
    | [bug3]
    |
    |   さて、そもそも # で始まる単語という物が生成されるというのも行けない
    |   (※よく考えたら shopt -u interactive_comments の場合にはその様な単語が生成されても問題ない)。
    |   ctx-redirect でもコメントのチェックはするべきである。
    |   そしてコメントがあった場合には delimiter の時と同様にエラーにする。
    |
    |   ctx-command と同様に comment をチェックする。
    |   コメントが有効であった場合には、そのコメント自体をエラー色にすれば良い。
    |
    | 他には本質的な違いはないようである。
    | 見た目上の違いとしては ctx-redirect では check-assign をしていないという事であるが、
    | これは ctx-command の側でも特定の ctx の場合にしか意味を持たない。
    | また、unexpectedWbegin のチェックをしていないという違いもあるが、
    | これも ctx-command で unexpectedWbegin が起こるのも ctx == CTX_ARGX0 の時だけである。
    | 従って、これらについて ctx-redirect と ctx-command が異なる点はないと考えて良い。

    まとめる。

    - 違い1 は単なるバグであったので現在は違いはない。
    - 違い2 は CTX_RDRS で引数を受け取った後に任意の文脈値に移行できるようにするための物であった。
    - 違い3 CTX_RDRS は少なくとも1つの引数を要求するので、
      単語の先頭で delimiters, comments, 改行が来るとエラーである。
      ※コメントのチェックが抜けていたのはバグであったが、修正後も取り扱いは異なる。

    結局振る舞いとしての違いは "違い3" だけである。
    一方で "違い2" に関しては CTX_RDRS の枠組みの方が柔軟であるが、
    今回の for VAR in, case VAL in の場合には不要な機能である。
    今回採用するとすれば

    - CTX_RDRS の枠組みを使えば比較的楽に実装できる。
      CTX_RDRS と全く同じ機能を持つ文脈値を増やすか、
      或いは CTX_RDRS をそのまま流用してしまって問題ない。

    - CTX_ARGX 等と同様の枠組みを使う方が仕組みとしては綺麗な気がする。
      但し、"単語を少なくとも一つ受け取る" 機能と、
      "単語が終端したら別の文脈値に移行する" 機能を
      ctx-command に追加しなければならない。

      ctx-command がまた無駄に複雑になってしまう。
      一方でこれを機に ctx-command を整理するという方向性も考えられる。

    取り敢えず ctx-command を整理してから考える事にする。
    整理した。矢張り ctx-command の枠組みで処理した方が良い様に思われる。

    1 先ずは新しい文脈値を定義して ARGX, ARGI と同様に処理する様に設定を行う。

    Note: CTX_CARGX1 によって導入される単語だけは wtype として CTX_ARGI を設定する。
      これによって case の第一引数のみが、
      case のコマンド引数として抽出されたり (in ble-syntax:bash/extract-command/.construct-proc)、
      ファイル名としての着色がなされたりする (in ble-highlight-layer:syntax/word/.update-attributes/.proc)。

    2 CTX_ARGI に対して指定されている特別の処理について一つ一つ確認し、
      必要であれば新しい文脈値にも適用する。

    3 CTX_ARGX についても同様に確認・適用していく。

    4 後は導入部分について。

      観察してみたが、思うに CTX_CMDXF と CTX_FARGX1 は同一ではないかという気がする。
      という訳で CTX_CMDXF を廃止して CTX_FARGX1 に統合する。
      取り敢えずこの時点で既に for については動いている様である。

      case についてはどうだろうか。check-word-end で 'for' の時に ctx=CTX_FARGX1 とした様に、
      'case' で CTX_CARGX1 を設定すればそのまま大丈夫だろうか。
      試してみた所ちゃんと動いている様である。
      # CTX_CASE については以前に実装していたのでそのまま通用する様だ。
      # ちゃんとパターンと esac の区別もついている。少し気になって試してみたのだが、
      # "esac)" というパターンを指定すると構文エラーになるという振る舞いも bash のそれと一致しているので OK。

    5 check-word-end において in 以外の場合にエラーを吐くようにする。
      これは意外と簡単に対応できた。

    取り敢えず動作しているのでこれで確定する。

  * bug: ((echo) >/dev/null) を入力しようとすると無限ループになる。 [#D0367]
    というか ) を入力しただけで無限ループになる。
    ごく最近の ble.sh ではこの現象は起こっていなかった。
    という事は、先程までに行った変更によってできたバグと考えられる。

    function ble-syntax:bash/ctx-command/.check-delimiter-or-redirect だった。

    ")" で閉じた時に対応する nest が存在しない場合の処理において、
    戻り値が return 1 になっていなかった。
    関数に分ける時に顕在化したバグであった。

    今までは return 1 し忘れていても次の処理へと進んでいき、
    (以降の処理では引っかからないので) 最終的に return 1 になっていた。
    これによって結果として問題になっていなかった。
    しかし、本来 delimiter が来てかつ対応する nest が存在しない時点で
    return 1 であるという事が確定しているのですぐさま return 1 するべきであった。
    つまり、これは顕在化していなかっただけであり、意図しない実装という意味でバグであった。

    然し、今回 delimiter が来た時の部分を関数に分けて、
    そのままその関数の終了ステータスで return する様に変更したことで問題が顕在化した。
    処理がなされなかった場合には return 1 する様に変更した。


2017-02-28

  * ble-edit: 関数名の整理 [#D0366]

    .ble-edit/stdout/on       -> ble-edit/bind/stdout.on
    .ble-edit/stdout/off      -> ble-edit/bind/stdout.off
    .ble-edit/stdout/finalize -> ble-edit/bind/stdout.finalize
    .ble-edit/stdout/*        -> ble-edit/bind/stdout/*

    .ble-line-text.          -> ble-edit/text/
    .ble-line-info.          -> ble-edit/info/
    .ble-line-cur.xyo        -> ble-edit/info/.put
    .ble-edit-draw.          -> ble-edit/render/
    .ble-edit-draw.set-dirty -> ble-edit/render/invalidate

    ble-edit/draw/goto             -> ble-edit/render/goto
    ble-edit/draw/clear-line       -> ble-edit/render/clear-line
    ble-edit/draw/clear-line-after -> ble-edit/render/clear-line-after

    .ble-edit.locate-forward-xword  -> ble/widget/.locate-forward-genword
    .ble-edit.locate-backward-xword -> ble/widget/.locate-backward-genword
    .ble-edit.locate-current-xword  -> ble/widget/.locate-current-genword
    単語関連については全体的に整理した。

    .ble-edit.bell -> ble/widget/.bell
    .ble-edit.*-range -> ble/widget/.*-range
    .ble-edit.quoted-insert.hook -> ble/widget/quoted-insert/.hook
    .ble-edit/delete-backward-char -> ble/widget/.delete-backward-char
    .ble-edit.delete-char -> ble/widget/.delete-char
    .ble-edit.goto-char -> ble/widget/.goto-char
    .ble-edit.forward-char -> ble/widget/.forward-char
    .ble-edit/newline -> ble/widget/.newline

    .ble-edit.default-key-bindings -> ble-edit/load-default-key-bindings
    .ble-edit-finalize -> ble-edit-finalize

  * [2016-08-08] 改行&プロンプト出力を一度に行う? [#D0365]

    唯単に RET を押すだけだと普通の bash では一気に新しいプロンプトが表示される。
    然し現状の ble の実装では一旦次の行の行頭に行ってから暫くして (計算をしてから) プロンプトが表示される。
    その為にちらつきというか変な遅延がある様に思われる。
    次の行の行頭に行くのも同時に出力するべきではないか。

    これは .ble-edit/newline の中で改行を出力してから、
    コマンドの有無を確認して…云々という処理をしているからである。
    また、プロンプトの出力部分についても確認しておく。
    ble-edit/prompt/update を呼び出している箇所は一箇所しかない。
    .ble-edit-draw.update である。
    .ble-edit-draw.update 自体は幾つかの場所から呼び出されている。

    1 ble-core に専用の buffer を作成する事にするのが良いだろうか。
      →ble/util/buffer ble/util/buffer.flush という関数を作った。
      更に ble-edit/draw/bflush で ble/util/buffer に対して内容を出力する物を用意した。
      同様に ble/util/joblist.bflush という物も用意した。

    2 .ble-edit-draw.update を直接 stderr に出力するのではなくて
      ble/util/buffer に対して出力する様に書き換える。
      同時に呼び出し元で必要に応じて flush を実行する様にする。

    3 .ble-edit-draw.update-adjusted については呼び出し元は一箇所しか無い。

    究極的には外部コマンドの呼び出し時と
    ble-edit/stdout/off の時にだけ flush すれば良いだけなのでは。
    結局、以下の箇所でのみ buffer.flush を実行すれば良い筈である。

    * .ble-edit/stdout/off
      bind の終わりで最終的に必ず (何らかの異常やシグナルで止まる事はあるが)
      この関数が呼ばれて次の入力を受け取る状態に入る筈である。
      また出力の制御という観点で密接に関係がある。
      従って、この関数の中で buffer.flush をするのが良い。

      但し bleopt_suppress_bash_output を設定していない時にはこの関数は空だったが、
      今回は bleopt_suppress_bash_output であっても .ble-edit/stdout/off で
      buffer.flush を実行する様に変更した。bleopt_suppress_bash_output の場合には
      実際 "stdout を off にする" という動作は必要としないが buffer.flush は必要である。
      その様な意味合いで .ble-edit/stdout/off という関数名は良くないのではないかという気がする。
      これは後で考え直したい。

    * ble-edit/exec の内部では直接出力を行う。
      exec を開始する直前に buffer.flush を実行すれば良い。

    * .ble-line-info.draw, .ble-line-info.clear
      これは時間のかかる計算 (isearch) の進捗状況を表示するのに用いている為。
      (実のところ、isearch の側で buffer.flush を実行しても良い様な気もする。

    * ble/widget/command-help
      これはその場で less を使って内容を表示する。
      buffer.flush をした後に less を起動する必要がある。

    * 終了コマンド
      以下の bash を終了させるコマンドを実行する時には buffer.flush を行う。

      ble/widget/delete-forward-char-or-exit
      ble-edit/bind/.check-detach (ble-edit/bind/.exit-trap をシグナル経由で呼び出して終了する)

    取り敢えず簡単な実装は終わった。

2017-02-25

  * [2017-02-14] stackdump [#D0364]

    [[ -x /home/murase ]] と入力したらなった。
    具体的には [[ -x a と入力して、x を消して再度 x を入力するとなる。
    これは再現性がある。

    | assertion failure: [[ ${_ble_syntax_nest[inest]} ]]
    | ble-syntax/tree-enumerate/.initialize/FATAL1
    |   @ /home/murase/prog/ble/ble.sh:25 (ble-assert)
    |   @ /home/murase/prog/ble/ble.sh:3 (ble-syntax/tree-enumerate/.initialize)
    |   @ /home/murase/prog/ble/ble.sh:5 (ble-syntax/tree-enumerate)
    |   @ /home/murase/prog/ble/ble.sh:5 (ble-syntax/parse/shift.method2)
    |   @ /home/murase/prog/ble/ble.sh:2167 (ble-syntax/parse/shift)
    |   @ /home/murase/prog/ble/ble.sh:-16 (ble-syntax/parse)
    |   @ /home/murase/prog/ble/ble.sh:4 (_ble_edit_str.update-syntax)
    |   @ /home/murase/prog/ble/ble.sh:-135 (ble-highlight-layer:syntax/update)
    |   @ /home/murase/prog/ble/ble.sh:4630 (ble-highlight-layer/update)
    |   @ /home/murase/prog/ble/ble.sh:4981 (.ble-line-text/update)
    |   @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
    |   @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
    |   @ /home/murase/prog/ble/ble.sh:1196 (ble-edit/bind/.tail)
    |   @ /home/murase/prog/ble/ble.sh:-4307 (ble-decode-byte:bind/EPILOGUE)
    |   @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)

    木構造の破壊が度々起こるので ble-syntax/print-status/.dump-arrays で
    構造を確認して問題がある部分を着色して表示する様に変更した。
    これによって確認してみた所、入れ子構造になっている部分の内部で
    二個目以降の単語を編集した時には大体の場合に nest の参照が壊れているという事が分かった。
    ただ単に顕在化するのが "[[ -x a" の場合だけだったという事になる。

    これは明らかに nest の shift に失敗しているのが原因である。
    現在の shift は基本的に e74c11631d62880a2600fb559e4135b8cf268110 (11ヶ月前) で作られた物である。
    長らくエラーが出た覚えもないのでもっと最近の変更によって問題が埋め込まれた可能性がある。

    その他では一番最近の 0757230b41a2adfe5eb6a52ce4c97f29734845a7 しかない。
    (実のところ、この修正と stackdump が出たのとどちらが先だったのか覚えがない…。)
    しかしこの修正は単純な物でこれで問題が起こるようには思われない。
    実際にこの修正を戻して試してみたが、同様に問題が発生するので、この修正は関係ないとして良いだろう。
    という事はこれは昔から存在していたバグと考えるべきだろう。

    % 取り敢えず nest のシフト範囲がどの様に決定されているのかについてコードを追ってみる事にする。
    % nest のシフトは ble-syntax/parse/shift.nest で行われている。
    % この関数自体が誤っている可能性について先ずは確認してみる。
    % と思ったが、よく見たら壊れているのは nest ではなくて nest の参照元である stat の方だった。

    なので見るべきは stat のシフト範囲の方である。つまり、ble-syntax/parse/shift.stat である。
    stat の他の項目に関しては特に問題も生じていない様なので、恐らくこの関数の呼び出し自体はちゃんと行われている。
    問題は nest 参照 (stat[3]) のシフト方法ではないかと思われる。
    コードを見てみると stat[1] (wlen), stat[3] (nlen), stat[4] (tclen), stat[5] (tprev) が共通のコードでシフトされている。
    これは怪しい。というのも tclen, tprev によって参照されるのは境界で、
    wlen, nlen によって参照されるのは文字であり、両者は異なる性質のものであるはずだからである。

    ? さて wlen に関する問題が発生しなかったのは何故だろう。word が stat に入る機会が少ないからだろうか。
      人為的に単語の途中に構造を導入して (例えば he"l"lo など)、word が破壊されないか確認する。
      うーん word に関しては余り遠くを参照したりしないので nest とは dirty-range との相対位置が異なる様だ。
      振る舞いが違うのはそういう事である。もしかすると特殊な状況では word にも不整合が生じるのかもしれないが、
      wlen で今まで問題が発生しなかった理由がわかったのでこれでよしとして深く追求はしない。
      nlen の修正方法が分かれば wlen の修正方法も同様にすれば良いだろう。

    変だ。ちゃんと動いているべきな気がする。
    何より同じ値なのに正しく動いている shift と動いていない shift がある。
    どうやら shift 量が過剰の様だ。もしかして複数回 shift が実行されている?
    →確認してみたら予想通り複数回の shift が実行されている様だ…。

    % 一方で全然シフトの対象でない部分についても沢山 shift が呼び出されている様な気がするがこれは何だろう?
    % と思ったら改めて実行してみた所何も起こっていない…と、よく考えたら "less ~/a.txt" と入力するのに
    % 使っているシェルがテスト用のコードを埋め込んだ後のシェルになっていて、確認のための入力をしている時に、
    % 変なごみが入力されてしまったというだけの事だった。

    さて、j は j-- としているので複数回同じ j の値で shift が実行されるというのは変である。
    誰かが j を increment しているのだろうか。或いは、j に何か値が代入されているのだろうか。

    + 誰かが j を increment している可能性が怪しい→と思ったがそうでもない。
    + どうやら "((_shift2_j=wbegin)) # skip" という行が怪しい気がする
      (※_shift2_j は j の値を退避している変数である)。
      →と思ったがこれでもない様だ…。
    + あー。なんと _shift2_j に j の値を保存していないコントロールパスがあった。これだ。

    呆気なく直った。


2016-12-21

  * $_ には前回のコマンドの最後の引数が格納されているべきである。 [#D0363]
    しかもシェルによる展開を一頻り実行した後の値である。
    現状では現在実行しようとしているコマンド自体が代入されている。

    先ず最後に実行した時の _ の値を取得する方法と、
    それからその _ を改めて設定する方法について考えなければならない。
    最後に実行した時の _ の値を取得する方法は簡単である。
    問題はどの様に _ を設定するかである。
    これについては : "$_ble_last_command_last_arg" とかいう感じにすれば良いのだろうか。

    % _ の値の取得に関しては ble-edit/exec:gexec/.eval-epilogue の中に追加する事にした。
    % どうやら関数の実行が終了するまではその関数の最後の引数は _ に設定されない様なので。
    % つまり、そのコマンドが終了した時に _ が設定されるという事である。
    %
    % 一方で同じ理由で _ の設定に関しては ble-edit/exec:gexec/.eval-prologue の中に設定しても駄目だ。
    % というのも中で _ を設定したとしても .eval-prologue 関数を出た時に
    % .eval-prologue 関数自体の最後の引数が改めて _ に設定されてしまうからである。

    実際にやってみると動かない。成る程、最後に実行したコマンドの引数が取得されるのではなくて
    最後に実行した eval の引数が評価されている。つまり、eval の内部で _last_exit 云々を取得しなければならない。
    しかしそうすると今度は lastexit 等の再設定が必要になる。いや lastexit も一緒に取得してしまえば良いという事だろうか。
    →少し汚いが $? と $_ を取得する為の関数 .save-params を作成してそれを eval の引数の中で評価する事にした。
    文法エラーになった場合にはそもそも $? と $_ が更新されないという事になるだろうがそれでも仕様がないだろう。
    →やはり $? が更新されないというのは変な気がするので外に伝播する事にする。

2016-12-06

  * プロンプトにジョブ数が表示されてなくなって変だと思っていたら、 [#D0362]
    shopt -s nullglob していると GLOGIGNORE を設定していたとしても、
    何らかのパターンがあった時に全体が消えてしまうという事が判明した。

    これを簡単に回避する方法はあるのだろうか。
    一つの方法は一旦変数の内容を取り出して、
    ?*[() その他のシェル特別文字をを全てエスケープしてしまうという事である。
    しかしエスケープするべき文字は沢山あるのでこの方法は現実的でない様な気がする。

    だとすると nullglob を一時的に解除する様にする必要がある。
    さて、よく考えてみれば分割を行っている箇所はこの一箇所だけではないはずだ。
    と思ったが、文字列の分割を目的としてこれを行っている箇所は全て
    ble/string#split に書き換えたのであった。ならば、ble/string#split だけ対策をすれば問題ない筈だ。

    →取り敢えず ble/string#split に nullglob の対策を施す事にした。

    しかし、もしかすると他にも同様の問題で項目が消滅してしまうという箇所があるかもしれない。
    他に GLOBIGNORE を ble.sh の中で使用している箇所がないという事は、その様な場所は、
    * や ? や [..] が含まれる内容を指定した時にファイル名に展開されてしまう危険がある。
    その様な事にならない様に設計しているはずなので GLOGIGNORE が使われていない場所では問題ないと考えて良い様に思う。
    つまり、論理的にはその様な場所は存在しないはずなのでここでは余り気にしなくても良い。
    その様な場所があるとすれば別のバグである。

2016-11-07

  * [2016-11-05] 半角仮名が入力できないという事に気づいた。コピー&ペーストしても駄目である。 [#D0361]
    ble-detach している時はちゃんと動作する。TAB で補完する時は入力できる。
    半角文字を入力すると変な文字に変換される。

    screen を経由していると変な文字が増える。
    これは screen が不正な文字を受信した時の処理方法の問題だろう。
    今回の問題とは直接に関係は無いはずである。

    他の文字を入力している時には何も問題は生じていないので
    これは utf-8 のデコードの問題ではないかと思われる。
    試してみると半角仮名は 3 byte 文字である。普通の漢字と同じに見える。

    UTF-8 のデコード部分を調べてみたが誤りはない様に見える。
    次に ble-decode-char 65422 を実行してみる。
    正しく処理されている。半角仮名の ﾎ が入力された。
    直接に入力してみる…あれ…入力できる。変だ。
    どうやらローカルの cygwin でやると入力できなくて、padparadscha 上でやると入力できる様だ。
    cygwin 側のロケールの設定だろうか。。
    cygwin 側で ble-decode-char 65422 としてみたら変な文字が入力される様だ。
    cygwin 上の c2s が怪しい。

    →なんと cygwin で printf '\UFF8E\n' をすると文字化けするという事が判明した。
    LC_ALL=C.UTF-8 printf '\uFF8E\n' として見ても駄目だ。version は 4.3.46 である。
    /bin/printf '\uFF8E\n' は正しく動作する。これは bash のバグなのか?
    然し padparadscha 上の bash-4.3.42 ではちゃんと動いている。

    もう少し詳しく見る。printf '\uFF8E\n' | od -t x1 とすると結果は ed 9f bf ed be 8e 0a である。
    これを UTF-8 に従って戻すと U+D7FF U+DF8E になる。サローげとペアにしようとして失敗している。
    https://ja.wikipedia.org/wiki/UTF-16 を見るとサロゲートペアの計算方法は、
      char16_t w1 = 0xD800 | ((uchar >> 32) - 1 & 0xFF) << 6 | uchar >> 10 & 0x3F;
      char16_t w2 = 0xDC00 | uchar & 0x3FF;
    である。この式を多少弄って、以下のようにしてみる。
      char16_t w1 = (0xD800 + (uchar >> 26)) - 0x40;
      char16_t w2 = 0xDC00 | uchar & 0x3FF;
    このコードで本来サロゲートペアにならない U+FF8E をサロゲートペアにしようとすると、U+D7FF U+DF8E になる。
    これは実際サロゲートペアになっていないので UTF-8 にしようとすると上記の様に 6 bytes のデータになる。

    これは誰が悪いのか? bash のソースを見る。
    builtins/printf.def:888:       temp = u32cconv (uvalue, cp);
    この u32cconv が怪しい。定義は lib/sh/unicode.c:239 にある。
    見るとサロゲートペアに変換する関数 u32toutf16 があって怪しい。
    lib/sh/unicode.c:213: u32toutf16 (c, s)
    あー。この関数にバグがある。何故か 0x0d800 未満の文字以外を全てサロゲートペアに変換している。
    bash のバグ報告に投げるべきだろうか。何処かに bash の repo は落ちていないか?

    その前に最新版をチェックしなければなるまい。最新版4.4でも直っていない。
    4.4 の patch は未だ出ていない。

    報告を提出した。accept された。恐らく 4.5 で反映されるのではないかと予想される。
    work around を ble.sh に追加する。

2016-11-05

  * 調子に乗って算術式のバグに関しても報告を行うべきだろうか。 [#D0360]

    $ bash-4.4 -c 'a=0 x="a=1"; ((0?x:0)); echo $a'
    1
    $ bash-4.4 -c 'a=0 x="a=1"; ((0?(x):0)); echo $a'
    0
    $ bash-4.4 -c 'a=0 x="a=1"; ((0?$x:0)); echo $a'
    0

    しかしできるだけソースコードのどの部分が問題であるのかも指摘した方が良い。
    「この様なケースは今まで報告されなかったので滅多にないことで対応する必要はない」等とはぐらかされる気がする。

    先ず算術式は何処で処理されているのだろう。
    builtins/let.def を見ると evalexp という関数を呼び出している。
    evalexp は expr.c:365 に定義されている。引数は文字列である。そのまま subexpr に制御が渡る。
    グローバル変数 expression に引数の文字列をコピーし、それを readtok で読み取る。
    結果は EXP_HIGHEST () で取り出している。readtok は expr.c:1230 にある。中は単に単語を一個ロードするだけの様だ。
    ということは EXP_HIGHEST() が本体という事になる。そしてマクロによって expcomma が呼び出される様だ。
    expcomma は expr.c:442 にある。其処から再帰下降解析を行っている。expassign (expr.c:457) -> expcond (expr.c:572)
    どうも cond? lhs: rhs において cond の値に応じて noeval という変数を inc/dec して評価するかしないかを切り替えている様だ。
    そして再度 EXP_HIGHEST を呼び出している。さて変数参照と noeval の関係が怪しそうだ。EXP_HIGHEST から下降していく。
    expcomma -> expassign -> expcond -> explor うーん。この exp0 というのが怪しい。辿るまでもなくこれが一番下なのでは?
    どうも既にこの時点で値が計算されているらしい? だとすると readtok で変数の中身が評価されているのか?
    調べると次のトークン (peektok) が "=" 以外の時は expr_streval (expr.c:1085) で評価を行っている。
    それで expr_streval を見るとちゃんと noeval を判定している。変だ。だとすればやはり評価されない筈ではないのか。
    変だ。bash-4.3 を見ても同様である。と思って再度 expcond を見てみる。
    おや。noeval を設定する前に readtok しているではないか。これは駄目な筈だ。

    報告を提出した。

2016-09-16

  * ble-core: bug ble/util/upvar を導入してみた所、色が全く着かなくなってしまった。 [#D0359]

    調べてみると upvar の変数名に対して配列要素 arr[index] を渡しているのがいけなかった。
    配列要素を指定した場合にどの様な動作をするのだろうか。調べてみる事にする。

    先ず local arr[1] などとするとそもそも arr という変数が関数内から見えなくなる様だ。
    関数スコープに arr という名前でスロットが作成されるが変数の実体は配置されないなどという事だろうか。
    また local arr[1]=1 などの様に値まで指定すると arr=([1]=1) の様な内容の配列が local に作成される様だ。
    引き続き unset arr[1] 等とすると、その配列要素は削除されるが配列自体は残ってしまう。

    a さて、どの様に定義するべきだろうか。
      例えば変数名が単純な変数名の場合には今まで通りに local "$var" && upvar "$var" "$value" として、
      変数名が arr[index] 等の場合には単に eval $var=\"\$value\" を実行する様にするか。
      然し、それだとローカルに arr という名前で変数が存在すると、
      その変数に新しい要素を追加する事になってしまい、変更が外に達しないという事になる。
      配列名が被ったとしても正しく外に変数を返す事ができる様にする為には、

      local "${var%%\[*\]}" && upvar "$var" "$value"

      として upvar の中でも unset "${var%%\[*\]}" 等の様にしなければならない。

    b 或いは、全く発送変えても良い。例えば export を使うとどの様な動作になるだろう。

      - 試してみた所、外側の関数で local var として内側の関数で export var=value とすると、
        外側の関数でその値を参照できると共に、更に外側の関数を抜けると変数が存在しなかった事になる。
        (少なくとも bash-4.3 ではその様な動作になっている。他の bash の version ではどの様な動作になるだろうか。)

        % ToDo: check bash-3.0, 3.1, 4.0, 4.1, 4.2 での動作確認:
        %   外側の関数で local して内側の関数で export した変数は外側の関数を抜けた時に削除されるか。
        %   もしくは export flag が削除されるか。

      x 更に重要な事は、或る関数の中で declare した変数について、
        export によってその関数の外側にまで寿命を延長させる事ができるかどうかである。
        実際に試してみた所、できない様だ。飽くまで宣言された時の寿命は変わらない様だ。

      - また、もしこの問題を解決できたとしても、他の実行形式に対して環境変数として
        変数の内容が伝播してしまうのは都合が悪い可能性がある。

      - 更に、配列要素などが指定された時の動作についても非自明である。
        結局配列要素などが指定される場合を考慮に入れれば
        upvar を使った場合と較べてコードが簡単になるという事はない様に思われる。

    結局今の所は export するしかない様だ。

2016-09-11

  * isearch: C-g でキャンセルした時に元の位置に戻る。 [#D0358]
    元々の _ble_edit_ind _ble_edit_mark の値を記録して、
    キャンセルした時にそれを復元する様に変更すれば良い。

    と思ったら元々 _ble_edit_ind, _ble_edit_mark の値は、
    一致範囲として記録されるものであった。

  * syntax:bash: $ は単体でもOK [#D0357]

    $ の直後に文字列終端・空白・改行その他の記号があってもエラーではなくて、
    単に $ という文字になるという事。

    はじめは通常文字のリストに追加しようと思ったが、
    設計上、通常文字の連続のチェックの方が先に来ている。
    これは通常文字が登場する確率の方が高いので、
    特殊文字よりも先に通常文字をチェックしたほうが高速だからである。
    従って、この順序を変更したくはないので、check-dollar の内部で処理する事にした。
    どのパターンにも一致しなかった $ は単に一文字の文字として解釈を行う。

  * edit: history の一番下で C-o した時の動作 2016-07-18 [#D0356]

  * accept-and-next: erasedup はどの様に処理されるべきか。 [#D0355]

    もし erasedups が指定されているとすれば、
    履歴に同じ内容のものが二つ以上登録されていることは無いはずである。
    という事は或る履歴項目を実行した事によって
    その次の項目が削除されてしまうという事は無いはずである。

    しかし、実行した履歴項目がその場所から削除されてしまうので、
    履歴番号がずれる事になるという事に注意する。
    これに対する対策を追加する必要性がある。

    同様に ignoredups が指定されている場合にも、
    その項目が一番最後の項目の場合には番号のずれが生じる。
    というか、ignorespace など他の指定に引っかかる事もある。

    これらをどの様に判定すれば良いだろうか。
    自前で全て判定をしなければならないのだろうか。
    或いは、履歴項目の個数を数える等して処理を簡単化できないか。
    例えば ignoredups と ignorespace の場合を考える。
    ignoredups に当たった場合は新しい履歴項目は追加されないが、
    一番最後の履歴項目が同じ内容を持っているので、その履歴項目に移動する事にすれば良い。
    ignorespace や HISTIGNORE に当たった事によって履歴項目に追加されなかった場合にはどうすれば良いか。
    実行したのが昔の履歴項目の場合にはそのまま気にせずに次の項目に移動すれば良い。
    実行したのが一番最後の履歴項目の場合には履歴項目に移動するのではなくて、
    現在の編集内容に前回の編集内容をコピーするという様に対応すれば良い。

    動作についてまとめるとどうなるだろうか。
    動作が簡単な場合から順に考えていくことにすれば良い。

    a 先ず、実行したのが昔の履歴項目だった場合には、
      基本的にその次の履歴番号に進めば問題ない。
      但し例外が erasedups によって項目が削除された場合である。
      それ以外の履歴の設定では過去の履歴が変化する事はないので気にしなくて良い。
      erasedups が設定されている場合に、
      その履歴項目の内容と実行したコマンドの内容が同一の場合には
      erase 操作によって次の履歴項目は実行したのと同じ履歴番号になる。
      (履歴項目の内容と実行したコマンドの内容は、
      過去の履歴項目の内容を編集することができるので違っても良い事に注意する。
      つまり [[ ${_ble_edit_history[index]} != ${_ble_edit_history_edit[index]} ]] かもしれないという事。)

      よく考えたら HISTIGNORE や ignorespace に引っかかってそもそも履歴項目の登録が起こらない場合は、
      erasedups に引っかかっていたとしても履歴項目の削除は起こらない。
      つまり index のずれは起きないので特別な処置は要らない。
      これを確かめる為には HISTIGNORE や ignorespace の判定を自前で行わなければならないのではないか。
      然し、二重に判定を行うのは具合が悪い。あるいは履歴項目の登録部分で履歴が登録されたかどうかの情報を返す様にするか。
      例えば [[ -v histadd_status ]] && histadd_status=$result の様にして。

      もっと良い判定方法があるのではないか。
      実行したのが昔の履歴項目だった場合に登録が起こるのはどの様な時だろう。
      HISTIGNORE に引っかからなかった場合である。
      ignoredups に引っかかる事は基本的にない、と思ったがよく考えて見れば
      同じ内容の文字列が履歴項目の一番上にある場合には普通に ignoredups に引っかかるのではないか。
      つまり、履歴登録試行後に一番上の要素が実行した文字列と同じかどうかを見るだけでは
      実際に新しく履歴項目が登録されたかどうかを正確に判定することは不可能である。

      という事はやはり history/add から結果を返す様にする必要があるか。
      実際に履歴項目の追加が発生したかどうかの判定を返すようにしても良いが、
      結局その情報が得られたとしても accept-and-next 側で、
      accept-line の内部実装に依存する様な処理を実行する必要がある。
      そのような構造になっていると将来的に history/add の処理方法を変更した時に問題が生じる。
      そういうことを考えれば、履歴項目番号の shift も含めて
      history/add の側で処理してしまったほうが良いのではないか。
      という訳で history/add の内部で shift も実行することにする。

    b 実行したのが一番最近の履歴項目だった場合には、
    c 実行したのが最新の編集文字列だった場合には、

      % 何れにしても一番最後に登録された項目に移れば良い。
      % erasedups や ignoredups の場合には、
      % 一番最後に登録された項目というのは丁度一番最後に実行したコマンドになっている筈だからである。
      % しかし、問題点は HISTIGNORE もしくは ignorespace によって、
      % 一番最後に実行したコマンド自体が履歴に登録されなかった場合である。
      % その場合には新しい編集文字列を用意して、そこに実行したコマンドの内容をコピーする事にする。

      よく考えたらこれは一番最近の履歴項目を実行した場合ではなくて、
      履歴項目を編集して実行した場合ではなくて、最新の編集文字列を実行した場合の処理である。
      一番最近の履歴項目を実行した場合には、既に履歴項目として登録されているという事だから、
      もし HISTIGNORE ignorespace によって登録されなかったとしても、単に一番最近の履歴項目に移動すれば良い。
      但し、最近の履歴項目を編集してから実行した場合にはまた異なる処理が必要になる。
      というか、最新の編集文字列を編集した時と同じ処理で良い。

      結局、一番最近の履歴項目だった場合と最新の編集文字列だった場合は処理を統合するのが良いだろう。
      取り敢えず、実行と履歴項目への登録を試行する。
      登録を試行した後に一番上にある履歴項目の内容が実行したものと同じであればそこに移動する。
      (もし内容が異なるのであれば、それは HISTIGNORE/ignorespace によって登録されなかった上に、
      一番最近の履歴項目を編集してから実行したor最新の編集文字列だったという事である。)
      もし内容が異なる場合には、最新の編集文字列に実行したのと同じ文字列を指定すれば良い。

  * [check] 複数のコマンドを一度に入力し場合に、実際の実行を遅延している。 [#D0354]
    この時に履歴番号 (PS1 の \! という指定で表示される物) と
    実際の履歴項目の番号はちゃんと一致したものになっているか。

    懸念として、実行前だから履歴番号が前のコマンドと重複してしまったり、
    或いは履歴項目の登録の際に登録が前後したりして番号がずれる事があるのではないか
    と考えたが特に問題は無いようであった。

  * ble-edit/history/add: bug HISTCONTROL=erasedups:ignorespace が指定されている時に [#D0353]
    ignorespace に当たると履歴項目が消滅する。
    ignorespace ignoredups について確認して引っかからなかった場合にのみ erasedups するべき。
    HISTIGNORE に関しては先にチェックを行っているので問題ない。

  * ble-edit: bug C-r で現在行の内容に一致しない。 2016-09-07 [#D0352]

2016-08-08

  * mintty で xenl 絡みの動作がおかしい [2016-08-07] [#D0351]
    丁度端末の横幅と同じに為る様な履歴項目が登録されている時に項目を辿るとなっている。
    後で動作を調べる必要がある。
    もしかすると mintty と同じタイプの物では全て動作がおかしくなっている可能性がある。

    というか今 screen で試してみてもカーソルの位置が怪しい。
    mintty とは又別の変な振る舞いをしているが、
    どうも ble.sh は次の行にカーソルを移しているつもりにいなっているが、
    実際には次の行にはカーソルが移っていないという事の様である。
    本来は次の行にちゃんとカーソルが移動する様にする必要がある。
    xenl 周りの計算について再度確かめる必要があるだろう。

    xenl 周りの計算は少し見た限りは問題が何処にあるか分からない。
    動作確認もしながら探す必要があるだろう…と思って何となく echo $_ble_term_xenl したら変だ。
    rosaterm (xenl なし) でも screen (xenl あり) でも常に 0 になっている。
    と思って term.sh の中を覗いたら、情けないことに ble/term.sh/tput tput xterm という具合に、
    tput に tput を渡していた。直接の tput 使用から ble/term.sh/tput 経由での使用に切り替えた際に、
    元からあった tput を削除し忘れていたということであろう。

    また他にも類似のミスがないか確認する。他にはないようだ。

    一応 _ble_term_xenl について確認:
    - _ble_term_xenl=1 ... xenl あり。tput xenl; echo $? の結果は 0 (成功)
    - _ble_term_xenl=0 ... xenl なし。tput xenl; echo $? の結果は 1 (失敗)
    echo $? の結果と _ble_term_xenl の内容が逆転していることには注意する。

    > * isearch: 検索中に長い履歴項目があるとカーソル行がずれる。 [2016-07-08]
    >
    >   このずれはカーソルが一番上の行にある場合に起こる様だ。
    >   カーソルが二行目以降にある場合は発生しない。最終行にある時でも発生しない。

    以上の問題もこの修正によって直ったと思われる。


2016-08-07

  * Windows では管理者権限があるかどうかは [#D0350]
    test -w "$(cygpath -u $WINDIR)"
    で判定することができる。

    cygpath に関してはプロセスを起動していると遅いので自前で実装する?
    変な文字が含まれていない限りにおいては簡単に実装できる筈である。


2016-08-06

  * edit: bug 履歴項目に登録されなくなる現象 [#D0349]

    突然、履歴項目に登録されなくなってしまう現象に出会う。
    但し、history -s では登録されている様である。

    調べてみると空白が登録されている様子である。
    というかこのプロセスはいつの version なのだろうか。。

    % % 更に現象の発生したシェルで調べてみると、
    % % _ble_edit_history と同じだけ要素数を持っている筈の
    % % _ble_edit_history_edit 配列の中身が殆ど空になっている。長さが 20 だ。
    % % そもそも何故その様な事態になったのかも不思議であるが、
    % % これが履歴が登録されない原因なのだろうか。
    % % 取り敢えず、問題を確認する為に _ble_edit_history_edit の内容を復元してみる。
    % % →問題は発生しなくなった様に見える。
    % % 従って、_ble_edit_history_edit さえ空にならなければこの問題は発生しないのではないかと思われる。
    % %
    % % さて、ではそもそも何故 _ble_edit_history_edit の中身が空になってしまったのだろう。
    % % 再度 _ble_edit_history_edit に変更が発生しそうな箇所を探す。
    %
    % と思ったが変だ。問題が発生した直後に実行した以下のコードではちゃんと
    % _ble_edit_history_edit の中身は沢山の項目が登録されている。
    %
    %   [murase@padparadscha 1 xgetopt]$ echo ${#_ble_edit_history_edit[@]}
    %   21034
    %
    % 登録されている項目数も前後に実行した history | tail の結果と較べても正しい物の様に見える。
    %
    % これで二つの謎現象が起こっていたという事になる。
    %
    % a 何故か分からないが履歴項目が登録されない状態になる。
    %   history -s には登録されている。
    % b 更に原因を探す為に色々実行していると、
    %   _ble_edit_history_edit の中身が空になってしまった。
    %
    % と思って再度前にテストの為に実行したコマンドを確認してみると、
    %   echo "${#_ble_edit_history_edit[0]}"
    % を実行していた。つまり、配列の要素数ではなくて配列の先頭要素の長さを確認していた。
    % ただの勘違いだった。

    さて上記の勘違いで唯一分かった事は、
    _ble_edit_history_edit=("${_ble_edit_history[@]}")
    を実行したら以上状態から直ったという事である。
    うーん。一応近辺の出力内容を記録しておく。

    | [murase@padparadscha 1 xgetopt]$ history | tail
    | 21020  git submodule --help
    | 21021  g t
    | 21022  pwd
    | 21023  less xgetopt.h
    | 21024  g add remote origin git@gitlab:akinomyoga/libmwg-xgetopt.git
    | 21025  g remote origin git@gitlab.akinomyoga/libmwg-xgetopt.git
    | 21026  false
    | 21027  true
    | 21028  g remote add origin git@gitlab:akinomyoga/libmwg-xgetopt.git
    | 21029  history | tail
    | [murase@padparadscha 1 xgetopt]$
    | [murase@padparadscha 1 xgetopt]$
    | [murase@padparadscha 1 xgetopt]$ echo ${#_ble_history_edit_dirt[@]}
    | 0
    | [murase@padparadscha 1 xgetopt]$ echo ${#_ble_history_edit[@]}
    | 0
    | [murase@padparadscha 1 xgetopt]$ echo ${#_ble_edit_history_dirt[@]}
    | 0
    | [murase@padparadscha 1 xgetopt]$ echo ${#_ble_edit_history_edit[@]}
    | 21034
    | [murase@padparadscha 1 xgetopt]$ echo ${_ble_edit_history_dirt[@]: -10}
    |
    | [murase@padparadscha 1 xgetopt]$ echo ${_ble_edit_history_edit[@]: -10}
    | history | tail echo ${#_ble_history_edit[@]} echo ${#_ble_edit_history_dirt[@]} echo ${_ble_edit_history_edit[@]: -10}

    うーん。どうやら ${#_ble_edit_history_edit[@]} の数が余分になっている様に見える。
    上記のタイミングでは本当は 21034 になっているべきである。
    何かが無駄に登録されてしまっている状態である。
    では何故その様な事になるのか?

    →原因が分かった。現在最新の行を編集してから (何か非空の内容がある状態で) 履歴項目を移動すると、
    その現在最新の行が _ble_edit_history_edit に登録される。
    これはまた最新の行に戻ってきた時に参照する為に必要になる物である。
    また、この編集仕掛の行は検索の対象でもある。
    この時点で _ble_edit_history と要素数が異なってしまう。
    →実際に試してみた所、再現した。
      編集して echo という文字列がある状態で別の履歴項目に移る。
      その後でコマンドを実行する。ずれが生じる。確かに履歴項目に登録されなくなる。

    つまり、_ble_edit_history の要素数と _ble_edit_history_edit の要素数が
    同じ筈だという仮定は成立しない物として取り扱わなければならない。
    多分、_ble_edit_history/_ble_edit_history_edit に同時に項目を登録している箇所で注意しておけば問題ない。

    + 一箇所 _ble_edit_history から項目を削除しているのに、
      _ble_edit_history_edit から項目を削除していない箇所を発見する。
      これについては修正した。
      しかし、この事によって _ble_edit_history_edit の中身が空になるとは思われない。
      寧ろ、_ble_edit_history よりも余分な要素が残留してしまうという逆の現象になるはずだ。
      更に、現在の HISTCONTROL の設定ではこのコードは実行されないはずである。

  * syntax: bug 他の問題を調査中に以下のエラーも発生した。 [#D0348]

    _ble_edit_history_edit が空になる事故を調べる為に配列 _ble_edit_history の内容を
    出力しようとしたりして試行錯誤している時に以下の stackdump が生じた。

    stackdump: unexpected ntype="${ for arithmetic expression
      @ /home/murase/prog/ble/ble.sh:1709 (ble-syntax:bash/ctx-expr)
      @ /home/murase/prog/ble/ble.sh:-16 (ble-syntax/parse)
      @ /home/murase/prog/ble/ble.sh:4 (_ble_edit_str.update-syntax)
      @ /home/murase/prog/ble/ble.sh:-135 (ble-highlight-layer:syntax/update)
      @ /home/murase/prog/ble/ble.sh:4598 (ble-highlight-layer/update)
      @ /home/murase/prog/ble/ble.sh:4933 (.ble-line-text/update)
      @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
      @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
      @ /home/murase/prog/ble/ble.sh:1157 (ble-edit/bind/.tail)
      @ /home/murase/prog/ble/ble.sh:-4279 (ble-decode-byte:bind/EPILOGUE)
      @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)

    1. echo ${_ble_edit_history_edit[@]: -10}
    2. echo ${_ble_edit_history_edit[@]: -10}"
    3. echo "${_ble_edit_history_edit[@]: -10}"

    というか直接 3. を入力してもなる。
    何と、以下を入力するだけでなる。

    $ echo "${a: -1}"

    メッセージを見るに、単に ${ に入る時に nest の値として
    " も巻き込んで登録してしまっているというだけの事だろうか。
    調べてみることにする。

    →調べてみると明示的に '"${' を nest-push している様だ。
    これは何の為に使っているのだろうか → "${...}" と ${...} では
    中のエスケープなどの取り扱い方法が異なる。これを区別する為の物である。
    更にこれを nest-push する時点では後ろで算術式 (:offset:length)が来るか
    もっと複雑な物が来るかの判定も出来ない。

    それによく考えてみれば算術式の中であっても "${...}" と ${...} で違いがあるのではないか?
    そもそも "${...}" と ${...} の中の文字列の取り扱いの違いは何だったか。
    function ble-syntax:bash/check-quotes のコメントに書かれていた。

      # "${var ～}" の中では '' $'' $"" は無効 (-u extquote の時は '' が無効) になる。

    この事は ${} の中にある算術式の中でも有効の様に思われる。
    というか良く考えてみると、それだけではなくて "${... ${...}}" の中でも有効でなければならない気がする。
    現在の判定では ${...} が始まった所の文脈が CTX_QUOT かどうかだけで見ているが、
    そうではなくて先祖に CTX_QUOT がないかどうか (但し途中に $() などがあったら其処で探索を止める)
    などのように複雑な判定をしなければならないのではないだろうか。

    取り敢えず現在の所は、算術式の中で判定として '${' だけでなく '"${' も考慮に入れる事にする。
    また、"${var: 算術式}" の算術式に含まれる '' $'' $"" についても正しく処理を行う (quote として解釈しない)。
    更に、正しい '' $'' $"" の判定方法に関しては別項目として立てる事にする。

2016-08-05

  * 実は Windows 10 で試すと /dev/tcp/0.0.0.0/80 [#D0347]
    はエラーメッセージを出力する → これは駄目だ。
    やはり Cygwin では別の方法を用いる必要がある。
    取り敢えずのところは &>/dev/null にして様子を見る事にする。

    →既に 1s 以上の場合には /dev/tcp を使わない方法を使っているので、
    いつでもその /dev/tcp を使わない方法を使用することにした。
    しかしこの方法だと子プロセスが死んだ時に sleep が動かなくなる。

    この問題を解決する為には子プロセスの pid を覚えておき、
    死んでいたら確認して再度設置するなどの処置が考えられる。
    しかし面倒である。

    % それよりは cygwin 専用の builtin sleep を添付してしまっても良い気がする。
    % cygwin/cygwin64 bash-4.1/4.2/4.3 それぞれについてコンパイルして添付する。
    % 一致する version がなければ現在の方法に fall back する様にすれば良い。
    % もし cygwin に binary を添付することを許すのであれば、
    % stty に関しても cygwin 用に builtin として提供してしまって良い。
    %
    % しかし、この事の問題点は binary を添付することを許してしまうと、
    % 今迄スクリプトで実装してきたことの意味は何なのかという事になるという事である。
    % 一応、そのバイナリが使えなくても問題なく動作するという点は有意義であるが。
    % バイナリが使えなくても動作するということを保証するのであれば、
    % 多少性能が劣るとしてもそのままで良いじゃないかという気もする。

2016-07-15

  * [保留] _ble_edit_history_edit の初期化時間について [2016-07-07] [#D0346]

    検索速度の向上の為に配列 _ble_edit_history_edit において、
    配列 _ble_edit_history と同様に完全な履歴を保持する様に変更した。
    その為に、一番最初の初期化時に _ble_edit_history_edit のコピーが必要になる。

    気になるのは初期化にかかる時間が余計にかかる様になることだが実際にやってみた所体感としては余り変わらない。
    (もし気になるのだとしたら初期化についても progress を表示する様に変更する必要がある。
    或いは edit を使用するまでは edit の初期化は遅延するなど。)
    因みに、

    $ time ble-edit/history/.generate-source-to-load-history >/dev/null
    real    0m0.600s
    user    0m0.683s
    sys     0m0.119s

    $ time eval -- "$(ble-edit/history/.generate-source-to-load-history)"
    real    0m1.210s
    user    0m1.273s
    sys     0m0.165s

    $ time _ble_edit_history_edit2=("${_ble_edit_history[@]}")
    real    0m0.320s
    user    0m0.316s
    sys     0m0.004s

    _ble_edit_history 本体の初期化時間に較べれば _ble_edit_history_edit
    の初期化時間は 1/4 程度なのでそれほど問題という訳でもない。
    また、工夫してコピー速度を向上しようにもこれ以上の工夫のしようはないと思われる。

    もし改善するのだとしたらコピー自体の速度向上ではなくて、
    コピーの遅延を行う様に修正した方が賢明である。

    [_ble_edit_history 自体の初期化高速化]

    あるいは、一番時間の掛かっている _ble_edit_history 初期化の方の改善が必要である。
    しかしこれ以上の高速化の方法は思い浮かばないし、
    また、部分的なロードをして残りは遅延にするなどの処置をするとしても、
    結局履歴を登録する際や検索を実行する際に、効率の問題から全部をロードする事を余儀なくされるだろう。

    % 本当に改善するのだとしたら、履歴項目を独自形式で保存するような .bash_history の ble 版を管理する事になる。
    %
    % a その様にすれば mapfile/readarray などを用いて比較的高速に読み込める様にできる…かもしれない。
    %   実際に mapfile/readarray などのコマンドが本当に速いのかどうか (どれだけ速いのか) は確かめる必要がある。
    %   良く考えたら複数行に渡る履歴項目も管理しなければならない。mapfile/readarray だと改行を含む要素を読み込めないので、
    %   読み込んだ後で後処理を行う様な方式にしなくては為らない。しかしこれは時間が掛かる。
    %
    % b それよりは source できる様な形式にしておく方が賢明である。
    %   或いは eval -- "_ble_edit_history=$(< ble_history)"
    %   の様にして eval で評価するか。結局今の方式と大して変わらない。
    %
    %   (今の方式の bottle neck が awk の方にあるのだとしたら
    %   現在の awk の出力をキャッシュする事によって高速化が可能という事になる。
    %   しかし bottle neck が bash の eval の方にあるのだとしたら残念ながら余り効果はないだろう。
    %   それぞれ時間を計測する必要がある。
    %
    %   eval $() にしていると非同期動作はしないので
    %   処理時間は awk の処理時間 + eval 時間という形に上乗せになっている。
    %   さて上記の時間計測を見てみると、awk に 0.6s であり、
    %   eval に 0.610 である。という事は awk の出力内容をキャッシュすることによって初期化時間を半減させる事ができるという事になる。
    %
    %   しかし問題点は awk の出力内容をキャッシュしたとして、.bash_history との整合性をどの様に保つのかという事である。
    %   a 一つの方法は .bash_history の内容は完全に無視して history で別の履歴を読み込んでしまうという事である。
    %     しかし、これは既存の .bash_history を無効にしてしまう事になるのでユーザに混乱を与える。
    %     また、終了時に ble が勝手に追加した内容が .bash_history に追記されないようにするなどの対策も必要である
    %   b もう一つの方法は .bash_history の内容は飽くまで尊重して、
    %     .bash_history に対する変更を検出して ble history cache ファイルの内容も更新する様にする事である。
    %     しかしそれは結構面倒な事の様な気がする。結局その更新には awk などで大量の処理をする必要が生じ、
    %     現在の方法と速度的に変わらなくなる気がする。。
    %
    %   やはりこの履歴項目を独自方式で保存する作戦は余りよくない気がする。

    また別の高速化手法として、起動時に非同期で履歴初期化用プロセス (awk) を起動して
    source 用のファイル (仮に history.src とする) を生成しておき、
    必要になった時に awk が終了しているのを確認して source history.src を行うという方法である。
    - 懸念の一つは起動後・履歴初期化前に追加された履歴項目をどの様に反映するのかという事であるが、
      これは初期化前に追加された履歴項目についてはその都度 history.src に追記するという方法で行ける。
    - もう一つの懸念は履歴初期化用プロセスがジョブ管理から見えてしまうことである。
      これについては disown して、wait する代わりに kill -0 && sleep で待つしかないだろうか。しかし sleep が難しい。
      或いは名前付きパイプで同期を取るという手も考えられるがそうすると初期化用のプロセスがいつまでも残存する事になるので好ましくない。

  * complete: double quotation の中で変数名の補完が起こらない。 [2016-07-09] [#D0345]
    →何でか分かった。ctx==CTX_CMDI 等の中で check/parameter-expansion を呼び出しているからだ。
    しかし、実際には "" の中に $VAR がある場合には ctx==CTX_QUOT になっている。

  * complete: というか ${...} の中でも変数名の補完が起こらない。 [2016-07-09] [#D0344]

  * complete.sh: bug 変数名の補完確定時に = の代わりに ' ' が挿入される。 [2016-07-05] [#D0343]

    実の所、挿入したいのは += かもしれない。
    また、declare の引数などの場合には = でも += でもなく ' ' を挿入したいのかも知れない。
    配列変数の場合には =( 等の様にした方が親切かも知れない。

    しかし取り敢えずは最大公約数的な補完として = を挿入する様にして良いのではないか。
    少なくとも ' ' を挿入するよりはましだし、また、変数代入においては、何も挿入しないよりは分かりやすい。
    ただ、declare の引数などに使用する際に何も挿入しない方が良いかも知れない。
    が、実際に使ってみてその辺りは判断する。

  * 以下、GLOBIGNORE が必要なのではないか。 [2016-07-05] [#D0342]

    ./complete.sh:197:  IFS=$'\n' builtin eval 'arr=($(ble-complete/source/command/gen))'
    ./complete.sh:374:  IFS=$'\n' builtin eval 'arr=($compgen)'
    ./complete.sh:385:  # * arr($(...)) としないのは IFS=$'\n' の影響を $(...) の中に持ち込まないためである。
    ./complete.sh:421:  IFS=: eval 'tmp=($FIGNORE)'
    ./complete.sh:485:        IFS=$'\n' builtin eval 'arr=($(compgen -v -- "$COMPV"))'

    また以前の GLOBIGNORE を使っている箇所も含めて ble/string#split を定義して使い回した方がよいのではないか。
    → ble/string#split を追加する事にした。

  * ble/util/joblist: 実は set -b でジョブ状態の変更が即座に出力される? [2016-07-08] [#D0341]

    →でもこれだと bash の stdout/off にしている時に出力された場合などの処理が面倒である。
    標準出力を監視して何か出力されたらそれがジョブ状態の変更に関する物であるかどうかを判定し、

    更にジョブ状態の変更に関する物であればその部分を切り出して出力しなければならない。
    しかし、切り出すと言ってもジョブ項目が何処で終端するのか分からないので確実な方法は分からない。
    途中で切れた離別の出力が混ざったりしてしまう可能性がある。

    現在の実装で問題なく動いているのだからこの方針を考える必要はないのではないか。

  * ble/util/sleep: sleepenh, usleep への fallback [#D0340]

  * isearch: backward-search で既に一致している部分を部分に持つ新しい一致がなされない。 [2016-07-07] [#D0339]
    例えば履歴に qqq が一件だけ存在する時に、isearch で qqq と入力すると一致しない。
    というのも qq まで入力した段階で qqq の内の後半二文字に一致が為され、
    新たに qqq を検索しようとしてもこの qqq は一致対象とはならないからである。

    この修正は簡単だ。と思ったらそうでもなかった。

    % 適当に検索範囲を変更したら C-r が効かなくなってしまった。
    % 今迄と同じものに一致してしまうからである。
    % 修正するべきは isMod の時の検索であった。

    さて、isMod のときの検索範囲を修正するにしてもどの様に修正したらよいのかは謎である。
    現在は isMod のときには一致開始位置を固定したままその場で文字列を伸張する方向で更新を行う。
    しかし、qqq の時の様に一致終端位置を固定したまま伸張する場合もあれば、
    また、伸張ではなくて少しずれてから一致する様な場合も考えられる。

    その様な場合も含めて考えると実は backward-search ばかりでなく forward-search にも問題がある事になる。
    例えば aba なる連なりが或る一箇所 ababac にのみ含まれていたとする。
    ここで abac を順方向に検索しようとすると一致しないという事になる。
    何故ならば aba まで入力した段階で [aba]bac に一致し、その後に c を入力したとしても、
    [abab]ac という一致と、aba[bac...] という一致しか試みられないからである。

    これを解決する為には一致位置の伸張ばかりでなく、
    多少ずらした一致も許す様にしなければならない。
    実の所、現在の isMod の部分のコードは不要で、
    唯単に検索範囲を isMod に応じて変更するだけで良いのではないだろうか。
    →いや、逆方向の探索の時は入力して行く内に今迄一致していた位置よりも範囲が戻る事がある。
      そもそもその為に isMod の時の範囲が修正されているのだ。
      なので、isMod の時専用のコード (一致範囲延長) はそのままで、
      通常の検索の部分の範囲を isMod に応じて変更する様にすれば良い。

    % ble-edit/isearch/next.fib を修正して次の様な処理を行う様に変更した。
    %
    % 0. 前提として検索中は _ble_edit_ind は一致範囲先端を表し、
    %   _ble_edit_mark は一致範囲後尾を表す事にする。
    %   順方向検索の場合は先端は範囲終端位置であり、後尾は範囲開始位置である。
    %   逆方向検索の場合は先端は範囲開始位置であり、後尾は範囲終端位置である。
    %
    % 1. もし isMod (検索文字の追加) を行う場合には現在位置に於ける一致範囲の拡張を試す。
    %
    %   例えば順方向検索で [abc]de の様に一致している
    %   (文字列が abcde で現在 abc に一致しているという意味である) 場合、
    %   初めに [abcd]e の一致を試みる。
    %   或いは、逆方向検索の場合には例えば a[bcd]e に一致している時は、
    %   初めに a[bcde] の一致を試みる。ここで一致範囲 (後尾) が後退することに注意する。
    %
    % 2. 次に通常の検索に入る。
    %
    %   但し、isMod のときとそうでない時で一致の範囲を変更する。
    %   isMod の時には自己にオーバーラップした一致を許可する。
    %   isMod でない時 (次の一致を探す時) は自己にオーバーラップしない一致を試す。
    %
    %   自己にオーバーラップしない一致を試すのは簡単で検索開始位置を先端 _ble_edit_ind に設定すればよい。
    %   自己にオーバーラップすることを許す場合は順方向検索の場合には _ble_edit_mark+1 から検索を行えばよい。
    %   但し、_ble_edit_mark が既に文字列末端に位置している場合は _ble_edit_ind (== _ble_edit_mark のはず) にする。
    %   逆方向検索の場合は微妙で、基本的には _ble_edit_mark-1 から逆方向に検索をしたいが、それだと、
    %   q[qq] だった所にを [qqq] を入力して 1 文字ずれて一致が起こる様な場合に対応できない。
    %   つまり一致先端が 1 ずれる事によって一致末端がずれないということも可能である。
    %   従って、実は _ble_edit_mark にすれば良い。それだと同じ場所に一致する様にも思われるが、
    %   実際は自己にオーバーラップする事を許すのは isMod の時のみであるので、同じ範囲に一致することはない。

    しかしながら実は上記の 1 と 2 は統一可能なのではないかという気がする。
    →統一した。実際の所現在位置に於ける一致範囲の拡張というのは、
    2. の検索範囲を一つ増やすだけで 2 の動作に含ませることができる。
    意外と簡単にすっきりとした実装にまとまった。

    rename: 今迄 isMod としていた識別子を isAdd に変更する。
      現在の実装に於いて、検索文字列の変更が実質文字の追加しかないこと、および、
      文字の追加しかないということを前提とした実装になっていることから。
      将来的に文字の追加以外の変更に対応した時に問題が生じないために。

2016-07-09

  * history: bash-3.0 で history に履歴が登録されないので、 [#D0338]

    履歴展開などの番号がずれてしまう。
    →良く考えてみたら history -r filename 等を用いて履歴を追加できるのではないか。
      実際に試してみた所期待通りに動作する様である。

    但し、history に登録できたとしても依然として終了時に履歴ファイル (.bash_history) には
    追加されない様である。というのも元からファイルから読み込んだ行なので
    敢えて .bash_history に追記する事はないという事なのだろう。
    これは今迄通りに手動で (その場で) 履歴項目を書き出す必要がある。

  * history: bash-3.0, 3.1 で履歴が登録されないだけでなく、 [#D0337]
    _ble_edit_history などにも追加されない様だ。
    history コマンドで履歴を追加できないのは以前から問題だったが、
    地震の管理する履歴に関してはどの様に処理する事になっていたのだったか。
    再確認が必要である。

    更に、コマンドを実行した直後、履歴内の位置がそのままになっている。
    一番最後に移動するべきである。最後に移動する処理は履歴に登録した後に為された物だった事を重うと、
    履歴に登録する過程で途中で抜けてしまっているという事なのだろう。

    2015-08-19 に関連しそうな議論が残っているが、同様の問題については言及されていない。
    つまりこの時点では特に大きな問題は生じていなかったという事になる。
    現在までの間に何か問題を埋め込んだという事だろう。

    →分かった。[[ -o history ]] のチェックで死んでいる。
    しかし bash のマニュアルを見ても history というのが新機能だと書かれていない。
    bash changes を見ても wiki を見ても新しい機能として history が実装されたという話はない。
    古い MANPATH で bash のマニュアルを見たが何と bash-3.1 でもちゃんと history という項目はある様だ。
    ここで set -o で現在設定されているオプションの一覧を見ることができるというので見てみる。
    何と history off になっている。つまり項目として存在していてしかも off になっているという事である。
    bash-3.0 3.1 では off になっていて、bash-3.2 では on になっている。
    さて、試しに bash --norc で起動してみると何れの version でもちゃんと初めから on になっている。
    どのタイミングで off になってしまうのだろうか。
    - --norc で起動した後に source .bashrc をすると off になってしまう。
    - というか source ble.sh すると off になる。
    - ble-detach すると on になる。
    - ble-attach すると off になる。
    - bind -x '"\C-t":set -o' して C-t をすると ble-detach していても off である。
    - --norc で起動した直後に bind -x '"\C-t":set -o' としても off である。

    つまり bash-3.0, 3.1 では bind -x のハンドラの中では常に history off という訳である。
    bind -x の中で、bind -x 以外の実行で history が on になっているかどうか確かめる方法は無さそうだ。
    それならば interactive かどうかで判断を代用するしかないのではないだろうか。
    interactive かどうかで言えば ble が起動している時点で interactive である。
    なので常に有効になっていると思って良いのではないか。

    > それとは別に気になるのが $- である。$- で表示される文字がそれぞれ何を意味するのかについて…。
    > 調べようとしたがマニュアルの何処に載っているか分からない。オプションフラグを表示するとその説明には書かれているが、
    > そもそもオプションフラグという単語がそこ意外に記述されていない。
    > →と思ったら set 組み込みコマンドの説明の下の方に現在のオプションの集合は $- で知る事ができると書かれている。
    >   明示的に書かれていないが実の所一文字オプションが定義されている項目についてはその文字が $- に含まれるということなのだろう。
    >   それとは別に bash が -i で起動された時には i が $- に含まれるとも別の箇所に書かれている。
    >   さて、実際に $- に含まれている文字で h や H は何だろう。見てみると h は hashall で、H は histexpand である。
    >   history 自体の on/off に関連する文字は割り当てられていない様だ。

2016-07-08

  * bash-3.2 補完確定した時のカーソル位置が変だ。 [#D0336]

    よく見たら shopt: autocd なんて知らない、というエラーが表示されている。
    つまり shopt -q を実行する際には 2>/dev/null にするべきという事である。
    修正した。

    さて、ble-0.1 の方ではどうなっていたかと確かめてみた所、
    なんとちゃんと &>/dev/null になっていた。その他の shopt についてもついている。
    つまり、何処かの時点で不要だと勘違いして除去したという事になる。
    blame で見てみた所 854babfc62a0d7865c5cf53db0a9c42ee8813c56 (2015-12-19)
    の大幅な整理の際に消してしまっていた。

  * prompt: PS1: PROMPT_DIRTRIM を実装する。 [#D0335]

    例えば 2 に設定すると、~/hello/test/world は ~/.../test/world になり、
    /home/foo/bar は .../foo/bar になる。
    これは param_wd の段階で省略してしまえば問題ないだろう。

    この機能は bash-3.2 以降の様だが関係なく実装してしまって問題ないだろう。

  * prompt: PS1 \n 周りの動作? → 勘違い [#D0334]

    % IND のつもりで \n を出力しようとするが \e[B が出力されている気がする。
    % これのせいで端末の最終行に何かを表示しようと言う目論見が失敗する。
    % →調べてみたが \n に対しては NEL = \r\n を出力している。
    % では何故 IND が効いていないのだろうか…。

    →そもそも PS1 に最終行を追加する為に記述したシーケンスが誤っていただけの様だ。
    \e[s, \e[u でカーソル位置を復元するとしても、画面がスクロールされてしまうと意味がない。
    そして IND の積もりで \n やら \eD を出力するとスクロールされてしまうので \e[s, \e[u
    しても画面バッファ上の同じ位置には戻ってこない事になる。
    従って、下に一行追加する為には IND RI するのが良い。

    % 所が、現実の端末では IND を実装しているとは限らないし、
    % 大体の terminfo では (端末が実際に対応しているとしても) IND に対して \n が記述されている。
    % しかし、それは仮想端末の設定で \n が \r\n に変換されない状況でしか意味がない。
    % というのも \r が混入してしまう所為で列の位置が先頭になってしまい、
    % 単に IND RI しただけでは元の位置に戻ってくる事ができないのだ。
    % まあ、元の位置に戻ってくる必要がないのであればこれで問題ない。
    % しかし元の位置に戻ってくる必要がある時にはどうするのだ?

    と思ったがよく見たら ble-edit/draw/trace/process-esc-sequence でちゃんと
    その場合の為の対策もされていた。\eD は変換されて "\n + 列の位置に移動" に変換されていた。
    つまり ble においては単に PS1 に \eD を記述しておけばよいという事になる。

    従って、プロンプトで最終行を追加する方法:
    PS1 の "末端" に以下を追加する。末端でなければならないのは PS1
    が複数行で構成されている場合を考えての事である。

    '\[\eD\eM\e7\e[${LINES}H\e[7m hello \e[m\e8\]'

    しかしこれだとコマンド実行時に最終行がごみとして残って厄介だ。
    削除できないだろうか。あるいは先頭行に表示する方が現実的かも知れない。

    '\[\e7\e[H\e[7m hello \e[m\e8\]'

    しかし、それだと以前に出力された内容を汚す事になってしまう。
    PS1 だけではどうにもならなそうだ。もしこの様な機能を提供するのだとしたら、
    RPS1 と同様に LPS1 だとか HPS1 だとか何かの変数を作って ble 側で特別に処理する必要がありそうだ。

  * prompt: 履歴番号 [#D0333]

    よく考えたら PS1 の \! の番号は履歴展開で使う為にあるのではないか。
    だとすれば、history に登録されている番号と実際の番号が一致している必要がある。
    ところが試してみると 1 ずれている。

    bash の動作をもう少し詳しく見てみる事にする。
    例えば履歴に 3 項目登録されている時に \! で表示される番号は 4 である。
    つまり \! は既に登録されている項目の数ではなくて、
    "現在の行が登録された時に登録される番号" であって、履歴項目の数より1つ多い。

    ${_ble_edit_history[]} の中身も確認してみる。番号がずれている…
    と思ったが、良く考えたら history の結果は 1 base の系列である。
    従って 1 ずれている事は問題ない。

    また isearch で表示される "現在位置" が _ble_edit_history 内の番号になっているが、
    これも履歴番号と一致させた方が分かりやすい。

    1. PS1 \! で表示されるものを現在の履歴番号に置き換える。
    2. isearch で表示される "現在位置" を履歴番号 (配列添字+1) にする。

2016-07-07

  * 2016-06-20 isearch: 検索速度の向上 (Bash 配列の workaround) [#D0332]

    進捗状況を表示する様に変更した。

    しかし検索位置によって速度が著しく異なる。
    もしかしてこれは "Bash のループの中で二つ以上の巨大配列を触ると遅くなる" という奴だろうか。
    と思って触る配列を一つに絞ってみたが違いはない様だ。
    次に検索方向を変えて試してみた…ら、凄まじく検索速度が異なる。
    また触る配列を二つに増やしたら順方向の検索でも遅くなった。

    1. 触る配列を一つに絞る
    2. ループの方向を順方向に変える

    これらの二つを満たした時の検索速度は格段に速い。

    まず実は検索は逆方向に検索する事の方が多い。
    従って 2. は実に都合が悪い。素直な実装方法は存在しないので、
    様々な対策の可能性を考えて最良の物を選択する必要がある。
    しかし、1. に関しては比較的簡単に解決できるのではないかという気がするので
    先にこちらにかたを付けてから考える方が良さそうに思われる。

    ★という訳で、触る配列を一つに絞る方法について考える。

    | a 一つの方法は、現在 _ble_edit_history_edit と _ble_edit_history に分けている配列を
    |   一つの配列にくっつけてしまう方法である。
    |
    |   つまり、現在は _ble_edit_history_edit を sparse な配列として保持し、
    |   そこに登録が為されていなかったら _ble_edit_history を参照するという仕組みにしている。
    |   案としては、代わりに _ble_edit_history_edit に完全な情報を保持するというものである。
    |   勿論、_ble_edit_history は別の場所で必要になるから、
    |   これはこれで独立に完全な情報を持つ物として記録しておく必要がある。
    |   そして、_ble_edit_history の更新に際しては同時に同様に _ble_edit_history_edit にも変更を加える様にする。
    |   実はこの案は最近別の理由で考えた。その時にどの様な理由で現状の実装で良いとしたのかを思い出す必要がある。
    |
    |   →2016-05-21 のログである。ble-edit/history/add で編集仕掛の状態をクリアする必要があるが、
    |     その際に配列を丸ごとコピーする事にしている。
    |     このコピーに時間が掛かってコマンド実行が遅くなってしまうので廃案になった。
    |     しかしこの問題は (aa) 編集仕掛の状態を完全にクリアする事を諦める (bash と同じ動作)
    |     または (ab) 編集仕掛の状態になっている項目の履歴番号を全て覚えて置いて、
    |     それについてだけ更新を実行する。という方法の何れかを取って解決する事ができる筈である。
    |
    | b もう一つの方法は _ble_edit_history (密) の内容に関しては for ent in "${arr[@]}" で取得してしまい、
    |   _ble_edit_history_edit (疎) の内容について配列添字アクセスで回すという方法である。
    |
    |   然し疎な配列のアクセス速度がどれくらいの物か実測してみないと分からない。
    |
    |   sparse_array_read.dense
    |     time 242972.10 usec/eval
    |   sparse_array_read.1
    |     time 234972.10 usec/eval
    |
    |   実測してみたが密な配列の場合と殆ど変わらない。寧ろ多少速い位である。
    |   では逆順に添字を動かしても大丈夫か。
    |
    |   sparse_array_read.1r
    |     time 246972.20 usec/eval
    |
    |   疎な場合には (殆ど) 変わらない速度で回す事ができる様だ。
    |   とここで気付いてしまったが、for arr in "${arr[@]}" だと逆順に回す事が不可能である。
    |   # 所で zsh にはこの様な操作がいかにも実装されていそうである。
    |   # 調べてみたら ${(Oa)array} (zsh-4.1.1) というのがあるそうだ。

    これは a の方針にするのが良さそうである。
    但し、編集しかけの状態になっている履歴番号を全て記録する様な仕組みにする。
    まずは、その様な実装方法によって _ble_edit_history 及び _ble_edit_history_edit
    の両方を完全な配列として maintain する様に変更を行う。

    _ble_edit_history_dirt に編集状態の項目の index を記録することにした。
    また isearch は完全に _ble_edit_history_edit だけを用いて動作する様にした。
    _ble_edit_history は使用しない。初回の動作は良好である。
    これにより順方向の検索は格段に向上した。

    ★逆方向の検索をできるだけ順方向の検索で処理できる様にする方法について考える。

    | a つまり高速な検索を実現する為には、履歴項目を逆順に格納した方が早いのではないか。
    |   と思ったが、逆方向に格納するとすると、履歴項目を追加する時に shift をしなければならず遅い。
    |   とすれば検索を開始する直前に反転した内容の配列を一気に生成すれば良さそうだ、
    |   と思う物のこれも良く考えてみれば外部コマンドを呼び出すなどして工夫しなければ難しい。
    |   内部コマンドで reverse を実現する高速な方法は存在するのだろうか。
    |
    |   reverse について時間の測定を試みた (benchmark-array.sh)
    |   外部コマンドを使用する方法だと高速な方法でも 10万要素あたり 500ms であった。
    |   また内部で処理を実行する場合には 10万要素辺り 2150ms であった。それ程の違いはない。
    |   寧ろ Cygwin で外部コマンド起動が遅くなる事を考えれば内部で処理した方が良さそうだ。
    |   しかし、いずれにしても反転だけで 2150ms かかるというのは遅い。
    |
    | b 別の方法として実際に行う検索は逆順だとしても、
    |   内部では順方向に計算を行ってしまうという手も考えられる。
    |   履歴項目の数が少ない内は愚直に逆順に探索した方が早いとしても、
    |   履歴項目が増えてくると順方向に探索を行って最後に一致した物を
    |   取り出す方が早くなるという反転が起こるはずである。
    |
    |   例えば仮に順方向の探索速度が a [s/entry] とし、
    |   また、逆方向の探索速度が位置 x について bx [s/entry] だとする。
    |   現在検索しようとしている文字列の頻度が c = 1/m [個/entry] だとする。
    |   現在位置 x から逆方向に探索したいとする。
    |   愚直に文字通り逆方向に探索を実行するとし x - m の位置で見付かるとすると、
    |   探索に掛かる時間は (bx + b(x-m))m/2 = bm (x+m/2) になる。
    |   順方向に計算して最後に当たった物を採用するとすれば、
    |   探索に掛かる時間は単に ax になる。
    |
    |   さて実際には探索を開始するまでは m が幾つになるか分からない。
    |   普通は最近実行したコマンドを呼び出す場合が多いはずだから m の期待値は小さいはずである。
    |   しかし、検索が進んで行くに連れて m が大きいという事が段々分かってくる。
    |   今 n 回外れた時の m を見積もる式 m = f(n) が与えられているとする。
    |   検索を逆順で y から始めて n 回外れて x = y - n まで来た時に、
    |   残りの検索を順方向で行うか逆順で行うかを予測処理時間で決定する。
    |
    |     ax < bm (x+m/2)
    |
    |   になっていれば其処で逆順検索はやめて順方向検索に切り替える。
    |
    |   | m (> 0) について解くと
    |   |
    |   |   -x + sqrt(x^2 + 2ax/b) < m = f(y-x)
    |   |
    |   | ここで逆探索が外れる程に右辺は増加し左辺は減少する。
    |   | つまり、どこかで両者が反転する場所が存在する。
    |   | そこで検索方向の切替を行えば良いのだ。
    |   |
    |   | では、n 回連続で外れだった時に m はどの様に見積もる事ができるか。
    |   | m もしくは c = 1/m についての事前確率を指定する必要がある気がする。
    |   | 取り敢えず考えると、二項分布で n 回連続で外れる確率は (1-c)^n である。
    |   | - これを最尤とする c は何かというと明らかに c = 0 であり、m = ∞ である。
    |   |   やはり事前確率が必要になる気がする。
    |   |   しかし実際の所検索文字列がどの様な分布を持っているかとか、
    |   |   更に過去に同じコマンドを実行した事があるかどうかとか、その分布とか、
    |   |   検索文字列についてのタイプミスだとか色々考えるとその様な事前確率を
    |   |   設定するのは困難に思われる。だとすれば、もっと別の方法に頼るしかない。
    |   | - 例えば (1-c)^n = 1/2 に為る様な c を求めたらどうだろう。
    |   |   解は c = 1 - (1/2)^{1/n} となる。
    |   |   ここから 不等式を満たす n を事前に計算するのは大変そうである。
    |   | - 或いはもっと単純に n 回失敗した時 m = n とするのはどうだろう。
    |   |   これならもっと楽に計算できるのではないだろうか。
    |   |   逆に言えばこの時点で求めるのが難しければ
    |   |   より複雑な場合は考えるのはやめた方が良い。
    |   |   一番初めの不等式に戻って x = y-n, m = n を代入すれば、
    |   |
    |   |     a(y-n) < bn (y - n + n/2)
    |   |
    |   |   これを満たす n (0<n<y) の条件は、
    |   |
    |   |     a/b+y - sqrt((a/b+y)^2 - 2ay/b) < n
    |   |     2(a/b)y / [a/b+y + hypot(a/b, y)] < n (分子の有理化)
    |   |
    |   |   さて、a/b は一体どれぐらいの値になるだろうか。
    |   |   実測してみる事にする。実際にはループに掛かる定数時間 d も合わせて、
    |   |   それぞれ (a + d)N, bN^2/2+dN という時間が掛かるはずである。
    |   |
    |   |     N=10k 順 time 223972.40 usec/eval = (a+d)M
    |   |     N=10k 逆 time 476972.40 usec/eval = bMM/2 + dM, where M=10k
    |   |     N=20k 順 time 441972.40 usec/eval = 2(a+d)M
    |   |     N=20k 逆 time 1555972.40 usec/eval = 2(bMM + dM)
    |   |     (a + d)M = 222479.3
    |   |     bMM =  602027.6, bM = 60.20276,
    |   |     dM = 175958.6,
    |   |     aM = 46520.7,
    |   |     a/b = 773.
    |   |
    |   |   今、r = a/by (a/b が y の内どれだけの割合をしめるか) を用いて n/y を表現すると、
    |   |
    |   |     n/y > r + 1 - hypot(r, 1)
    |   |     n/y > 2r / [(r+1) + hypot(r, 1)]
    |   |
    |   |   特に y >> a/b の場合を考えれば、r << 1 であり、
    |   |
    |   |     n/y >~ r, n >~ a/b
    |   |
    |   |   となる。sqrt 等の計算を bash で実行する (taylor 展開 or newton 法) のは面倒なので、
    |   |   これぐらいにしておくのがよい様な気もする。
    |
    |   [まとめ]
    |
    |   履歴位置 y から逆方向に検索を開始するとき、
    |   検索時間期待値が短くなるように途中で順方向の検索に切り替える。
    |   n 回連続で見付からなかった場合 m = f(n) = n として期待値を評価する事にする。
    |   この時 r = a/by として、
    |
    |     n/y >= r + 1 - sqrt(r^2 + 1)
    |
    |   になった時に順方向の検索に切り替えれば良い。特に y >> a/b のときは、
    |
    |     n >= a/b
    |
    |   で評価しても良い。実際に a/b を実測してみると a/b ~ 773 になる。
    |
    |
    |   しかしながらこの方法の欠点は何かというと実装が汚いという事である。
    |   途中で順方向に検索順序を切り替えるとすると、中断時に記録しなければならない項目の数が格段に増える。
    |   1. まず、現在の内部検索方向
    |   2. それから一番最後に一致した位置
    |   3. 検索の開始点(これは m の見積もりに必要)
    |   或いは順方向の検索は十分速いと考えるならば中断しないという手も考えられる。
    |
    |   更に現在の実装では _ble_edit_history_edit と _ble_edit_history の両方を参照しなければならないので、
    |   順方向の検索だったとしても結局検索に時間が掛かる事に違いはない。
    |   というか先に _ble_edit_history_edit と _ble_edit_history の
    |   両方を参照しなければならない現状について解決するべきの様な気がしてきた。
    |   →先に触る配列を一つにする課題を解決することにした。
    |
    | c 中位の大きさの buffer 配列にコピーして順次検索を実行する。
    |
    |   例えば 1000 位ずつ buffer 配列にコピーを行って、
    |   その配列から読み出しながら検索を行う。
    |
    | d あるいは部分的順方向検索にするという手もある。
    |
    |   部分的順方向検索の大きさは 2 の累乗で増加する様に設定し、
    |   但し、中断位置チェックの場所を跨がない様にその都度大きさを弄る。
    |   うーん。この方法が現実的の様に思われる。
    |
    |   この方法と較べると b の様な複雑な計算はまるで無駄なことである。

    d の方向で実装する事にする。

    実装した。良好である。以前と比べると検索速度が格段に異なる。

  * syntax-highlight: 変数の右辺の中で * や ?, @(...) などが着色されている。 [#D0331]
    しかし実際には変数の右辺では glob は無効になっている筈である。

    また bash の動作を観察すると glob pattern としての意味は失う (glob 展開はされない) が、
    文法的には extglob を認識している様子である。つまり hoge=@(1|2) などとできる。

  * 2016-06-23 ジョブ状態の変更 (suspended だとか "[1]+ 終了" とか) が出力されない様だ [#D0330]

    [状況確認]

    % これは標準出力だか標準エラーだかに出力されている筈。
    % これがそのまま捨てられているということだろう。
    %
    % 調べてみたが不思議なことに何処にも何も出力されていない様に見える。
    % 標準エラーで処理されなかった行を出力するようにして出力されたファイルの中身を見たが何もない。
    % また、標準出力の出力先のファイルを見ても何も書かれていない。
    % (中身のクリアは行っていないはずだし、少なくともタイムスタンプが変更されていない。)
    %
    % bleopt_suppress_bash_output を off にして試してみることにする。
    % なんと bleopt_suppress_bash_output にしていても何も出力されない様だ。
    % bind -x した関数の中から実行されたジョブは終了が捕捉されないという事なのだろうか。
    % と思って確かめてみたがそんなことはない様だ。
    %
    % $ bind -x $'"\eM": sleep 5 &'
    %
    % では eval にしているから駄目なのだろうか。
    %
    % $ bind -x $'"\eM": eval "sleep 1 &"'
    %
    % と思ったがそういうこともない様だ。
    % suppress output でも出力されなかった事から、fd の繋ぎ替えだとかは関係ないはずだ。
    % では stty などの設定によるものなのだろうか。と思って以下を試してみたがそれでもちゃんと出力される。
    %
    % $ bind -x $'"\eM": stty/enter; eval "sleep 1 &"; stty/leave'
    % $ function stty/enter { stty -echo -nl -icrnl -icanon kill undef lnext undef werase undef erase undef intr undef quit undef susp undef; }
    % $ function stty/leave { command stty echo -nl kill '^U' lnext '^V' werase '^W' erase '^?' intr '^C' quit '^\' susp '^Z'; }
    %
    % 何が原因でジョブ管理の出力が消えているのだろうか。jobs コマンドの呼び出しが関係しているのだろうか。
    % うーん。jobs をやってみて一つ分かった事がある。ジョブが終了して初回の
    % jobs の際に "[1]+ 終了" という内容が出力されている様だ。
    % そしてプロンプトに \j を入れていると内部で初回の jobs が実行されることになり、
    % ユーザの目には何も見えないという具合に為る様だ。
    %
    % もしかして default で終了時にメッセージが表示されるのも、
    % 実はプロンプトに \j が入っているからなのだろうか。
    % と思って PS1='\$ ' にしてみたが、それでもちゃんとジョブ終了直後にメッセージが表示される。
    % 今迄やったのと同様に stty を弄って eval するようにしたがそれでも変わらない。
    %
    % ble を読み込んでいる時とそうでない時の違いが謎である。。
    %
    % 更に ble-detach をしてみたらちゃんと出力される様になった。
    % つまり、何かが違うとすれば、ble-detach の中で行っている設定に依存している可能性がある。

    % →何と分かってしまった。通常の状態に於いてジョブ状態の変化が出力されるのは、
    % ユーザがコマンドを実行した直後である。しかし、ble を attach している時は、
    % ble の eval によってコマンドを実行しているのであって、
    % シェルの機能でコマンドを実行している訳ではない。
    % それが理由でジョブの状態変化が出力されないのである。
    %
    % 一方で、画面に出力される前に明示的に jobs を呼び出した時には、
    % 状態変化がその jobs で表示されて以降では表示されなくなる様だ。

    →と思ったが色々実行してみるとそういう訳でもないらしい。
    コマンドを空にしたまま RET を沢山押してもジョブの状態変化に
    対応するメッセージは何も表示されないが、
    一方で、何らかのコマンド (何でも良い。echo など) を実行すると
    その場でジョブ状態の変更についてメッセージが出力される様だ。

    また PS1 に \j が含まれている場合は、内部的に jobs が実行されて、
    その時にジョブ状態変更についての結果が出力されると、
    画面には表示されないという事になってしまう。

    ※何故コマンドを実行した時にはちゃんとジョブ状態の変更について出力されるのか調べる必要がある。
    調べると ble-edit/exec:gexec/.eval-prologue の中の、
    ble-stty/leave の中でジョブ状態の変更が出力されている。
    中で呼び出しているのは実質 command stty だけである。
    だとすれば、bash は "stty で状態が変更された瞬間にジョブ状態の変更を確認し出力を行う" という事になる。

    という訳で、コマンドを実行した直後にジョブ状態の変更があれば自動的に出力されることが分かった。
    明示的に対処が必要なのは、実のところ、内部的に明示的に jobs を呼び出した時だけの様に思われる。


    [方針]

    % これを解決する方法の方向性として二通り考えられる。
    %
    % a 一つはコマンドを ble.sh で実行する度に jobs を実行して状態変化のあったコマンドを調べる。
    %   特に "終了" したコマンドを検知するのに使用する。ただし、終了したかどうかを判定するためには、
    %   ロケールが設定されていると厄介である。従って LC_ALL=C jobs の様にしなければならないと思われる。
    %
    %   しかしそうするとロケールに従った状態の表示ができない。が、これは仕方がない。
    %
    %   この方法を取った時にもう一つしなければならないのは、
    %   プロンプトの計算や syntax-highlight の際に jobs を実行した時にも、
    %   状態の変更を追跡しなければならないということである。
    %   これは直接 jobs を呼ぶ様にするのではなく、
    %   jobs を呼び出すと同時にその内容を確認するような ble-edit/jobs 的関数を用意すれば良い。
    %   色々の用途に使う際にはこの関数を通して呼び出すことにする。
    %
    % b もう一つの方法は、コマンドが実行可能な状態にある時には bind を弄って、
    %   コマンド実行を引き起こす様なキーでシェルとしてのコマンド実行が為される様に構成する。
    %   しかしこの方法は基本的に無理である。
    %   というのも唯単にコマンド実行が起こる様に構成するのだとすると、
    %   シェルの標準出力・標準エラー出力などを本来のものに戻さなければ為らず
    %   (そうしないとコマンドを実行した結果が画面に出力されずに失われてしまう)、
    %   その様にするとカラーに着色した表示を無理にするためにちらつくことになる。
    %
    %   他にもコマンドが実際に実行されたかどうかの判定等々色々面倒である。
    %   この方法は駄目である。まるで枠組を一から再考しなければならなくなる。
    %
    %
    % 上記の a の方向で考えることにする。基本的にコマンド実行が終了した時にチェックを行う。
    % これはプロンプトの計算を行って、プロンプトを出力する直前に結果を出すということにする。
    % 或いは、明示的にコマンド実行が終了した時にチェックを行うというのではなくて、
    % 単にプロンプトの描画の部分で jobs を確認して出力を行うという様にすれば良い。
    % 特にプロンプトの再描画 (前回と同じ内容) などではなくて、プロンプトの再計算を行ったタイミングで出力することにしたい。
    %
    % その他の処理で jobs を呼び出してその際にジョブ状態の変更を検知した場合には、
    % 検知したということを何処かの配列にでも覚えて置いて、
    % その次にプロンプトを再計算・再描画しようという時に改めて出力する様にすればよい。

    状況に誤認が多少あった。基本的に上記 a の方針で行くが、
    コマンドの実行が合った場合 (stty で設定が変更された場合) は、
    bash が自動的にジョブ状態の変更について確認を行い出力を行う事が分かったから、
    実際に対処が必要になるのは内部で明示的に jobs を呼び出した時のみである。
    特に PS1 に \j が含まれている時の動作である。


    前準備として (既定の) jobs が一体どのような出力をするのかについて詳しく調べておく必要がある。

    - ジョブのコマンドに改行が含まれている場合は jobs の結果はどうなるのか。
      →複数の行にまたがって出力される。

      現在のジョブ数のカウントではどの様にしているか。
      →ちゃんと対策できていない。余分に表示されてしまう様だ。これは対策が必要だ。

    - "終了" "Done" などの文字列を検出する方針について

      % LC_ALL=C jobs にすると "実行中" の代わりに Running と表示される。
      % しかし "終了" は "終了" のままである。LC_ALL=C; jobs などとしても駄目だ。
      % しかし、LC_ALL=C としてから jobs とするとちゃんと Done と表示される。
      % どの様な動作基準になっているのだろうか。
      % LC_ALL=C jobs → だめ
      % LC_ALL=C; jobs → だめ
      % (LC_ALL=C; jobs) → だめ
      % LC_ALL=C eval jobs → だめ
      % どうも LC_ALL は設定してから反映される迄に時間が掛かるということの気がする。
      % 代わりに LANG を使って同様にしてみたが動作は変わらない。
      % だとすれば、bash-3.0 で C-d を捕捉する為に ignoreeof-message.txt でやっている様に、
      % Done に対応する文字列の一覧表を作る必要がある。
      %
      % 過去の記録に基づくと ignoreeof-message.txt は generate.sh で生成している。
      %
      % また修了の仕方によって様々なメッセージが考えられる。
      % 単に kill すると Terminated と表示される。
      % 他にも色々の修了の仕方に応じてメッセージが異なるのかもしれない。
      %
      % 或いは単純に jobs を二回実行して状態が変化したジョブについてのみ
      % 出力を行うという風にしても良いのではないだろうか。
      % というかもし jobs に状態変化があるのだとすれば、
      % 結局二回 jobs を実行する必要がある様な気がする。
      % こちらの方法のほうが合理的な気がする。
      %
      % 知りたいのは特にジョブが "終了" したとか "強制停止" されたとかではなく、
      % 単にジョブの実行状態の変化が知りたいというわけである。
      % だとすれば jobs によって出力される結果の変化と等価なものを提供したい。
      % これを調べるためには単に jobs の状態変化を追えば良いという訳である。

      固定文字列を使用する方法だと不安定に思われるので、
      jobs を二回実行して比較する方針で実装する事にした。
      また、ジョブの状態変化に対応するために前回の jobs の呼び出しについても記録を行っておく。

    - jobs %1 などの様に指定を行ったとしても状態変化したジョブの情報は出力されるのか?

      →なんと番号を指定していたとしても状態変化したジョブの情報が一緒に出力されてしまう様である。
      →もしかすると標準エラー出力などに出力されている可能性?
        確認してみたが普通に標準出力に混ざって出力されている様だ。

      bash の既定の動作は不思議な動作なのでこれについては模倣する必要はないように思われる。

    [実装]

    1 取り敢えず jobs の出力を解析する関数を作成する必要があるだろう。

      実装してみた → ble/util/joblist

      同時に jobs に状態変化したジョブの内容が
      報告されている可能性があるのでそれを毎回調べる必要がある。
      毎回調べる必要があるのだから、毎回二回解析を実行して差分を調べる様にしてしまっても問題ないだろう。
      終了したジョブなどに関して言えば一回目の jobs で出力されていて、
      二回目の jobs で出力されていなければそうであると判断できる。

      しかし、実行状態から停止状態に移ったジョブや、
      その逆のジョブに関してはこの方法では検知できないのではないかという気がする。
      ここで確認して置かなければならないのは通常の bash の時に、
      その様な状態変化が標準出力に報告されるのかそうでないのかという事である。
      調べてみたところ、実行状態から停止状態に移った時には報告が為されるが、
      停止状態から実行状態に映った時には何も報告が為されない。

      さて速度は気になる。

      $ ble-measure ble/util/joblist
      time 2410.60 usec/eval
      $ ble-measure 'ble/util/assign jobs jobs; GLOBIGNORE=\* IFS=$'\''\n'\'' builtin eval "jobs=(\$jobs)"'
      time 357.60 usec/eval
      $ ble-measure 'ble/util/assign jobs jobs'
      time 305.60 usec/eval
      $ ble-measure jobs
      time  11.10 usec/eval

      単なる jobs の実行とは比ぶべくもない (220倍)。
      しかし比較対象はその出力を変数に格納するときの場合である。
      単なる ble/util/assign jobs jobs と比較すると 8 倍程遅い。
      行分割も考えれば 7 倍程度の遅さである。
      うーん。まあ 2ms 程度であれば許容範囲内ではあるが、
      7倍というのは余りに大きい。まだ高速化の余地はある様な気がする。
      もし使ってみて遅い様に感じたらその時にまた高速化を考える方向で良いとする。

      ジョブを 10 個にして試してみた。
      $ ble-measure ble/util/joblist
      time 13170.60 usec/eval
      $ ble-measure 'ble/util/assign jobs jobs; GLOBIGNORE=\* IFS=$'\''\n'\'' builtin eval "jobs=(\$jobs)"'
      time 2020.60 usec/eval
      $ ble-measure 'ble/util/assign jobs jobs'
      time 729.60 usec/eval

      % 13ms というのは結構遅い気がする。何とかならないものか。やはり正規表現による一致に時間がかかるのか。
      % そう思って以下のように正規表現を使わないように書き換えた。
      %
      %   - [[ $line =~ $rex_ijob ]] && ijob="${BASH_REMATCH[1]}"
      %   + local n=${line%%']'*}; [[ $line == '['[0-9]*']'* && ${n//[0-9]} == '[' ]] && ijob=${n:1}
      %
      % それで計測してみたところ、
      %
      % $ ble-measure ble/util/joblist
      % time 12570.60 usec/eval
      %
      % 微妙に早くなった。違いは有意である。しかし絶対量としては大して変わらない。
      % わざわざこの様な分かりにくい方法を選択する程の利点はない。

      % 或いは直に正規表現を記述しておけば precompile されるだろうか。
      %
      % [[ $line =~ ^\[([0-9]+)\] ]] && ijob="${BASH_REMATCH[1]}"
      %
      % $ ble-measure ble/util/joblist
      % time 13170.60 usec/eval
      %
      % まったく変化しない。駄目だ。

      遅さの原因は for ループにある様に思われる。
      for ループ無しにジョブの分割などを実装する方法はあるだろうか。
      つまり /\n\[[0-9]+\]/ の箇所で分割を実行する。
      その時に [0-9]+ の番号の部分を保持したい。
      或いは、/\n/ で分割した後に /\[[0-9]+\]/ 以外で始まる行を潰す。

      →遅いので 1回目の jobs の時点で前回からの変化がない場合には以降の処理を省略することにする。


      遅い第一の原因が分かった。[[ $a == $b ]] の比較において二つ目の引数を quote していなかった。
      bash が二つ目の引数の中身を glob pattern として parse している事が原因だったようだ。
      これを修正したら、ジョブが 10 件ある状態でも以下の様な速度に落ち着いた。3.5倍程度である。

      $ ble-measure ble/util/joblist
      time 7220.40 usec/eval

      更に一回目の jobs の結果が前回の結果と全く同一の場合にはそもそも処理を完全にスキップできる。
      結果として以下の様になった。今まで (jobs) と殆ど変わらない速度である。
      というより今迄 (毎回 jobs + 改行で分割) より高速になっている。OK

      $ ble-measure ble/util/joblist
      time 383.90 usec/eval

      取り敢えず ble/util/joblist 完成という事でここで commit しておく事にする。

    2 ble/util/joblist で状態変化をチェックする様にしたが、
      先頭の "-+" の有無の変化も検知してしまっている。これらを無視した比較が必要である。
      →対策した。

      色々試した結果、あるジョブが終了した後に別のジョブが同じ番号に入った時、
      (同じジョブの状態が変化したというように) 誤検知してしまう。
      その様な誤検知が起こるのはコマンド実行の stty 時にジョブの変化が bash によって出力され、
      その事が ble/util/joblist のキャッシュに反映されないという場合である。

      これを防ぐためには stty 実行時にキャッシュをクリアするか、
      stty 実行直前に明示的に ble/util/joblist.check を呼び出すかする必要がある。
      stty 実行時に確実にジョブの状態変化が bash によって出力されるというのであれば、
      ble/util/joblist.clear してしまって良いだろう。

    3 検知した状態変化を何処かのタイミングで出力する必要がある。

      これは新しくコマンドを実行する直前と、コマンドを実行した直後にしたい。

      コマンドを実行する直前 (もしくはプロンプトの再計算を要求する箇所) を探してみる。
      先ず、コマンドを実行したりする為に newline を呼び出す。
      ここでは _ble_edit_LINENO を increment する。
      _ble_edit_LINENO が変化しているとプロンプトの再計算が実行され、
      次にプロンプトを表示する際に一から表示されることになる。
      さて、よく見ると _ble_edit_LINENO を更新する直前で、
      プロンプト・コマンドライン行の末端で改行を出力している。
      この直後で jobline.flush を実行すれば良いだろう。

      一方でコマンドを実行した直後ではどうだろう。
      これについては、そもそもコマンドを実行している最中に内部関数
      ble/util/joblist を呼び出すことは想定していないので、
      そもそも何らのジョブ変更イベントも記録されない様に思われる。
      従って、わざわざ出力させる必要はないと考える。

      →通常の bash はどの様な動作であったか。試してみる。
        どうやら "外部コマンド" が終了する度に確認を行っている様である。

        一方で、複数のコマンドの間に挟まれてジョブ情報が出力されると見にくいので、
        ble ではコマンド実行の前とコマンド実行の後にまとめて出力するのが良さそうである。

      現状では、コマンド実行を開始する直前の command stty でジョブ情報が出力される。
      (というか実は command stty でジョブ情報が出力されるのも、
      別に stty が呼び出されたからジョブ情報が出力される、というのではなくて、
      単に外部コマンドが呼び出されて終了したからジョブ情報を出力しているという動作に過ぎないのではないか。)
      従って、コマンド終了後にまとめてジョブ情報を出力する仕組みにしているとジョブ情報の順序が前後することになり分かりにくい。
      よって、コマンド実行をする前に joblist.flush はしておきたい。

      一方で、長いコマンドを実行して終了した時に既にジョブ状態が変更されている場合、
      その出力を次のコマンドを入力して実行した時まで遅延するというのはまた分かりにくい。
      それならばいっその事コマンド実行が終了した時にも同様にチェックをしたい所である。
      コマンド実行が終了する箇所というのを探すのは簡単である。
      行末位置調整などを行っている場所で一緒に実行してしまえばよい。

    4 動作確認

      bug: events が二回ずつ登録されている。これはどういう事か。

        →調べてみたら、実行中から終了に変化し、終了から空に変化し、
        という所で両方に引っ掛かってなっていた様である。
        どちらか片方だけで良い。

      bug: それと joblist の表示が一足遅い気がする。何故か。

        →これはプロンプトの再計算が on demand で行われている為で、
        joblist.check, joblist.flush をしてからプロンプトを計算して、
        その時にジョブ状態の変更が検出されるためではないだろうか。
        結果として次のコマンド実行まで検出されたジョブ状態変更が出力されない。

        しかしそれは変だ。それならば何故初めの joblist.check で検出されないのだろうか。

        →理由が分かった。そもそも joblist.check, joblist.flush をしていない。
        現在はコマンドを実行した後に joblist.check, joblist.flush をしているが、
        よく考えてみたら空コマンドで newline した時はそもそもコマンド実行に到らないので、
        joblist.check, joblist.flush には到らないのだ。
        従って、newline をした時でも joblist.check 及び joblist.flush
        を実行する様に変更しなければならない。それも明示的に。
        うーん。でも変だ。newline をした時に flush はしている筈なのに…。
        と、よく考えたら flush しているだけで check をしていなかった。

        うーん。設計を眺めてみるに flush の直前には必ず check をする事になっている。
        考えてみればそれもそうだ。そうでなければならない。
        なので、flush の内部で check を呼び出してしまう事にする。

      現在の所動作良好である。反応も遅くなっていない。

2016-07-04

  * ble-detach して ble-attach すると、BS が効かない。 [#D0329]

    bind -p | less で確認すると以下の項目について unbind できていない。
    "\C-u": self-insert
    "\C-v": self-insert
    "\C-w": self-insert
    "\C-?": self-insert

    しかし不思議だ detach してみると上記のキーは self-insert
    ではない物に bind されている。だとすると、何処かで変な bind をしているのか?

    うーん。変だ。この状態で

    $ builtin bind -x '"\177":ble-decode-byte:bind 127; builtin eval "$_ble_decode_bind_hook"'

    を手動で実行してみる。するとちゃんと BS が効く様になる。
    ということは ble-attach の方の問題なのだろうか。

    ble-attach を少しずつ実行してみることにする。
    ble-decode-attach の source "$_ble_base_cache/ble-decode-bind.$_ble_bash.bind" を実行すれば直る。

    うーｎ。何か、これ、前にも似た様なことをして対策した様な気がする…と思ったら、
    関数 ble-decode-bind/uvw である。ここでは変数 _ble_decode_bind__uvwflag を使って、
    未だ設定が行われていなければ bind をやり直すということをしている。
    そしてこの関数は ble-decode-byte:bind/PROLOGUE で呼び出されている。
    つまり、毎回ちゃんと呼び出されると考えて良いだろう。
    そうすると問題は _ble_decode_bind__uvwflag の値の設定ということになる。
    これを検索してみると、ble-decode-bind/uvw を定義した一箇所しか存在しない。
    つまり、最初の ble-attach でしか uvw に対する特別な bind が動作しないということである。
    これでは駄目だ。という訳で ble-attach の際に _ble_decode_bind__uvwflag= を設定すれば良い。
    →これで解決した。

2016-06-27

  * $_ble_base/cache ユーザの分離ができていない。 [#D0328]

    これも $_ble_base/tmp と同様に chmod a+rwxt
    してその下に $UID でデータを置く様にする必要がある。
    あと UID 変数は信用できるのだろうか→man bash によれば読み取り専用である。OK.

    既に cache というディレクトリを作ってしまっているので、
    g pull 等で更新した時には問題になる。
    cache.d という名前のディレクトリに変更して処理するべきである。
    また、その際に既に存在しているファイル達を移動する仕組みも提供するか。

  * [2016-06-22] sleep の実装方法 → ble/util/sleep として実装した [#D0327]

    $ mkfifo tmp/sleep
    $ exec 3<> tmp/sleep
    $ function sleep { local v; ! read -t 0.1 v <&3; }

    自分で作った fifo なら自分で書き込まない限りはブロックされる事が保証できる。

    # これで cygwin でも高精度な sleep ができる! と思ったらそんな事は無い。
    # "bash: read: 読み込みエラー: 0: Communication error on send"
    # というエラーを出力して終わってしまう。
    #
    # うーん。仕方がない。cygwin では /dev/tcp/0.0.0.0/80 に頼るか…。
    # (少なくとも cygwin では bash /dev/tcp が有効でビルドされている事は知っている。)
    # しかし、/dev/tcp/0.0.0.0/80 が完全に永劫にブロックする物なのかは謎である。
    # これについては長時間放置したテストが必要になる。
    # →と思ったら高々 20 秒で接続を諦めて止まる様子だ。
    # しかし接続を諦めたとしてももう一回実行すればまたブロックされる。
    # さて、この方法の問題点は何かというと普通に外に向かって通信を開始してしまう事である。
    #
    # うーん。また mkfifo に戻ってくる。cygwin はやはり駄目なのか。
    # http://cygwin.1069669.n5.nabble.com/Bug-Named-Pipes-FIFO-Bash-td10925.html
    # と思ったらどうも cygwin では真面目に mkfifo の blocking な振る舞いを実装する気はなさそうだ。
    # 色々な人が文句を言っていると言う事は work around はないという事ではないか。
    #
    # あるいは cygwin ではこうする?
    #
    #   exec 3< <( while :; do sleep 1d; done &> /dev/null )
    #
    # できた! と思ったが…そもそも
    #
    #   time read -t 0.1 <&3
    #
    # がきっかり 0.1 にならずに 0.109 か 0.125 になる…。うーん。何故だ。
    # 因みに /dev/tcp/0.0.0.0/80 は 0.094 か 0.109 になる。こちらはそんなに変ではない。
    # もう一つの問題点は C-c をするとそれが while :; ... に伝達して終了してしまう事。
    # プロセス置換が延々と生きていて欲しいのだが…。
    # <(while do done &) としてみたがすると今度は <&3 で読み取ろうとしても何も読み取れない。
    # うーん、C-c だけならば trap -- '' INT とかすれば良い。
    # しかし今度は C-\ を押した時にやはり消えていなくなる。QUIT を追加した。
    # しかし、うーん、INT と QUIT だけ無視しておけば OK なのかどうかは不明である。

    [cygwin の場合、まとめ]

    cygwin の場合には mkfifo でブロックされない。
    /dev/tcp/ は外部に変なアクセスをするので timer には向かない。
    というか socket を作りまくって接続数の上限に抵触する可能性すらある。
    更に、時々固まるので時間計測にも支障を来す。

      exec 3< <( trap -- '' INT QUIT; while :; do sleep 1d; done &> /dev/null )

    で頑張るしかない。しかしこれによる sleep は多少遅延がある。

    →実際にやってみたら read -t 0.001 <&3 するだけで 12ms の時間を消費することが分かった。
      read -t 0.001 -u 3 でも時間は全く変わらない様だ。
      一方で read -t 0.001 </dev/tcp/0.0.0.0/80 は遅延が 1.5ms 程度と短い。
      どうも繋がっている先によって遅延時間が異なる様である。

      もっと他の繋ぎ方も試してみる事にする。

      $ mkfifo tmp1
      $ (exec 3> tmp1; sleep 65535) &
      $ exec 8< tmp1
      $ read -t 0.001 -u 8
      → やはり同じ時間掛かる。

      うーん。/dev/tcp がごく短い時間しかかからないというのが不思議だ。
      実は通信を始める前に処理を中断しているのだという可能性もある。
      →うーん。実際に while :; do read -t 0.01 </dev/tcp/0.0.0.0/80; done を試してみたが、
        外部に対して通信を行っている気配はない。
        ということはネットワークに対する負荷はないのではないか。
      →今度は実在する IP アドレスに対して同じ事を行ってみた。
        外部に対して通信を大量にしまくっている様だ。これはいけない。
        ということはやはり 0.0.0.0 の場合には通信が内部で閉じているという事である。
        しかしこれは Windows だけの話かも知れないので他の OS では事情が異なるかもしれない。
        やはり mkfifo が期待通りに働かず pipe が遅い Windows ならではの措置である。

    Cygwin 上で系統的に速度の計測を行ってみる

    $ exec 9< <(
    >   [[ $- == *i* ]] && trap -- '' INT QUIT
    >   while :; do command sleep 65535; done
    > )
    $ (exec 3> tmp1; sleep 65535) & exec 8< tmp1
    $ exec 7<> tmp1

    | コマンド                                | 実行時間 (Cygwin)  | 環境2
    |-----------------------------------------|--------------------|--------------------
    | sleep 0.001                             | 1819.10 usec/eval  | 1214.50 usec/eval
    | read -t 0.001 < /dev/tcp/0.0.0.0/80     | 1967.50 usec/eval  | 1410.60 usec/eval
    | read -t 0.001 < /dev/tcp/127.0.0.1/80   | 1967.50 usec/eval  | 1410.60 usec/eval
    | read -t 0.001 < /dev/tcp/███.███.6.2/80 | 23337.50 usec/eval | 14070.60 usec/eval
    | read -t 0.001 < /dev/udp/0.0.0.0/80     | 3067.50 usec/eval  | 1310.60 usec/eval
    | read -t 0.001 <&9                       | 12437.50 usec/eval | 1210.60 usec/eval
    | read -t 0.001 -u 9                      | 12437.50 usec/eval | 1220.60 usec/eval
    | read -t 0.001 -u 8                      | 12437.50 usec/eval | 1210.60 usec/eval
    | read -t 0.001 -u 7                      | ※1                | 1200.60 usec/eval

    ※1 bash: read: read error: 6: Communication error on send

    | コマンド                                | 環境1 Cygwin | 環境2 GNU/Linux |
    |-----------------------------------------|----------|---------|
    | `read -t 0.001 < /dev/tcp/0.0.0.0/80`   | 2.0 ms   | 1.41 ms |
    | `read -t 0.001 < /dev/tcp/127.0.0.1/80` | 2.0 ms   | 1.41 ms |
    | `read -t 0.001 < /dev/tcp/██.██.6.2/80` | 23 ms    | 14.1 ms |
    | `read -t 0.001 < /dev/udp/0.0.0.0/80`   | 3.1 ms   | 1.31 ms |
    | `read -t 0.001 <&9`                     | 12 ms    | 1.21 ms |
    | `read -t 0.001 -u 9`                    | 12 ms    | 1.22 ms |
    | `read -t 0.001 -u 8`                    | 12 ms    | 1.21 ms |
    | `read -t 0.001 -u 7`                    | エラー   | 1.20 ms |

2016-06-20

  * isearch: 検索に時間が掛かっている時に進捗状況を表示する。 [#D0326]

    isearch_suspend で進捗状況を表示しようと考えたが、どうも動かない。
    よく考えてみたら isearch_suspend は次の文字が標準入力に来ている時にだけしか起こらない。
    なので、次の文字が来ているかどうかに拘わらず更新をしなければならない。
    最初は一定の数以上処理を行ったら中断を行う様に変更しようかとも考えたが、
    次の文字が来ていないのに中断を実行してしまうと続きの検索が処理されなくなってしまう。
    従って、中断を行うのではなくてその場で更新を行う必要がある。

    →実装した。検索の進捗状況が表示されている。

  * isearch: history 検索に時間が掛かっている時に次の入力が来たら中断できないか? [#D0325]

    % 単に中断するのだと問題がある。abc と入力したのに b
    % が入力されなかった事になってしまうという事があるからである。
    % 検索に時間が掛かっている状態で次の入力が来た時の振る舞いについて整理する必要がある。
    %
    % a back 等で検索状態を一つ戻すキーが来た場合には処理を中断する。
    %   直前の状態に戻りキーの入力を待つ。
    %
    % b RET やその他のキーで等で確定する場合には、
    %   一旦 RET を受領してから検索の続きを実行し、
    %   当たったら其処で確定を行う。
    %
    %   引き続きその他のキーについて処理を実行する必要がある時には
    %   それを自分で呼び出す必要がある。
    %
    % c 続きの文字を入力した場合は、
    %   やはり一旦キーを受領してから検索の続きを実行し、
    %   それが終わったらまた次のキーを処理し、
    %   という事をしなければならない。
    %
    %   単に検索文字列を更新するだけでは駄目なのは、検索の進行をスタックに記録しなければならないからである。
    %   つまり、abc と入力したら a まで入力した時の一致位置、b まで入力した時の一致位置も記録しておかなければならない。
    %   - そうしないと abc まで打ってから back をして ab に戻した時に適切な位置にまで戻ることができないからである。
    %     勿論、abc が一致しているのだから ab が同じ位置で一致していたということは明かだろうが、
    %     例えば ab までは一致して abc について一致する項目がない場合には、
    %     ab に戻るためには ab の位置がやはり記録されていなければならない。
    %   - 何より、a → ab → abc という様に検索を行っても、abc を一発で検索しても検索のコストが変わらない。
    %     従って、わざわざ検索文字列をすりかえて処理を一回の検索で済ませる様にする利点がない。
    %
    %   検索を再開する場合には前回の検索位置からの続きとして実行をしたい。
    %   初めから検索をやりなおすのではどんどん時間が掛かる様になってしまうからである。
    %   その為には現在の検索位置の変数をグローバル変数にする、
    %   または、検索位置の変数を対応するグローバル変数に保存するようにする必要がある。
    %
    % 結局、現在検索中かどうかと言う情報を保持する様にすればよいように思う。

    結局考察の結果として少し違った実装になったので、上記の当初の案はそのままは採用されなかった。


    さて、検索中に次の文字が来た時にどの様に検索方法を修正するかなどについては
    いきなり考えると訳が分からなくなってしまうので、
    取り敢えずは検索を単に中断して再開する方向で実装を考えてみる。

    取り敢えず ble/widget/isearch/next-history を中断可能に書き換える。
    と思ったけれどももっと全体を見てから書き換えた方がよい様な気もする。
    どの様に実装すれば良いか。取り敢えず現在の方法はすっかり止めて、
    [タスクを登録] → [タスクを実行] という形に変更しなければならない。
    そしてタスクを実行している途中で中断があればタスクを再開する
    というタスクを先頭に挿入する必要がある。
    もしくは先頭に挿入するというよりは完全に新しくタスク列を設定し直すという考え方でも良い。
    もし現在待ち状態になっているタスクがない場合には、その時に限って直接実行を行っても良い?


    中断を実行できる様に設計を変更した。以下の問題点・課題がある。

    - isearch: is-stdin-ready で中断するとき、既に一致したコマンドラインの描画が為されない
      →別項目 2016-06-20
    - isearch: 検索中の accept は実行しない。
      →別項目 2016-06-20
    - isearch: 検索に時間が掛かっている時に進捗状況を表示する。
      →別項目 2016-06-20

  * isearch: is-stdin-ready で中断するとき、既に一致したコマンドラインの描画が為されない [#D0324]

    is-stdin-ready が true になっている限りコマンドラインの描画がされないので、
    全ての検索が終了するまで、途中の一致が表示されない。
    これは恐らく今迄の実装でもそうなっていたのではないかと思われる。

    →これについては is-stdin-ready の時に描画をスキップする様になっている箇所で、
    何らかの変数を参照して描画を実行する必要がある場合はスキップしない様にすれば良い。
    描画を実行するかどうかを決定づけているのは、ble-decode-byte:bind/EPILOGUE である。

    しかし、ここでは is-stdin-ready の際には描画をスキップするだけでなく、
    ユーザによって実行を要求されたコマンドの実行もスキップされる。
    今回の用途の場合にはコマンドの実行もスキップする必要はあるのだろうか。
    そもそも今回の場合 (isearch) には検索中にコマンドの実行が要求される事がない。
    なので、もっと異なる状況で考えなければならない。
    例えば、複雑なキー操作と思い処理によって順次実行するコマンドの内容を決定していく場合を考える。
    この様な場合に確定したコマンドを実行するタイミングはどうであるべきか。
    うーん。現在の処理だと中途半端な状態でコマンドを実行すると、
    編集行の下に表示されているパネルなどの上にコマンドの実行結果が上書きされたりして変な事になる。
    本来は、コマンドを実行する前にその様なパネルなどの表示を消去しておくべきなのである。
    現状の方向性としては、

    a. 描画する時はコマンド実行をスキップしない。パネルなどの表示はコマンド実行時に消去する様にする。
    b. is-stdin-ready の場合には描画をスキップしないとしてもコマンド実行をスキップするか、

    の二通りが考えられる。どちらもそれなりに理に適った実装の様に思われる。
    但し、コマンドをスキップするかスキップしないかに拘わらず、
    コマンドの実行時には一時的に表示しているパネルなどは消去するべきなのは確かである。
    現在の所は実装が楽な b. の様に処理をすることにして後で問題になったら a. にするのが良さそうである。
    パネルの一時消去に関しては新しく項目を作って保留とする。

    → 変数名は _ble_edit_bind_force_draw とする。


    変数に描画が必要である事を設定する箇所の候補は二つ考えられる。

    a. ble-edit/isearch/.goto-match
    b. ble-edit/history/goto

    そもそも描画をスキップしない様にする必要が生じるのは、
    時間の掛かる処理を実行している途中に、入力に応答できる様に中断する時である。
    ということはスキップしない様に値を設定するのは、
    その様な中断を行う枠組の方であるべきである。
    ble-edit/history/goto はその様な時間の掛かる処理以外でも使われる。
    つまり、ble-edit/isearch/.goto-match の側で設定を行うべきである。

  * isearch: 検索中は accept をしないように変更したい。 [#D0323]
    今迄の実装だと現在実行中の検索が終わってから accept をしていた。
    しかし、これだと思いがけず変なコマンドが検索に当たって実行されてしまうかも知れないので。
    また、現在表示されている (現在までに一致した) コマンドを実行するという仕組みにするのも危険である。
    というのも現在実行中の検索がある場合、ユーザが accept をしようとした瞬間に
    表示されているコマンドが切り替わる可能性があるからである。

    しかし accept しないと言っても検索の中断はすぐさま行われる訳ではないので、
    多少の検索が実行されて新しく一致した後にそのコマンドが実行される可能性もある。
    しかし、"基本的に accept しない" 設計にしておけば、
    ユーザからすれば検索中に accept することの意味が殆ど失われるので、
    ユーザがその様な操作を実行する可能性が少なくなる。
    従ってその心配はしなくても良いのではないか。

2016-05-21

  * 出た 2016-04-23 [#D0322]

    [状況]

    | stackdump: 0 <= beg=23 <= end=24 <= len=1; beg=23, end=23, ins(1)=c
    | @ /home/murase/prog/ble/ble.sh:5079 (_ble_edit_str.replace)
    | @ /home/murase/prog/ble/ble.sh:-1789 (ble/widget/self-insert)
    | @ /home/murase/prog/ble/ble.sh:33 (ble-decode-key/.invoke-command)
    | @ /home/murase/prog/ble/ble.sh:22 (ble-decode-key/.invoke-partial-match)
    | @ /home/murase/prog/ble/ble.sh:37 (ble-decode-key)
    | @ /home/murase/prog/ble/ble.sh:92 (ble-decode-char/.send-modified-key)
    | @ /home/murase/prog/ble/ble.sh:50 (ble-decode-char)
    | @ /home/murase/prog/ble/ble.sh:-966 (ble-decode-byte+UTF-8)
    | @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)
    |
    | 改めて探してみるが不整合が出る様な場所は存在しない。
    | _ble_edit_str に値を設定している場所は _ble_edit_str.replace, _ble_edit_str.reset だけである。
    | _ble_edit_str.reset-and-check-dirty は現在の設定では使用していない筈である。
    | _ble_edit_dirty_syntax_{beg,end} に関しても値を設定している箇所は
    | _ble_edit_str/update-dirty-range だけだし、
    | _ble_edit_str/update-dirty-range を呼び出している箇所は、
    | 上記の _ble_edit_str.{replace,reset} だけである。
    |
    | と思ったが…良く考えたら挿入位置が範囲外になっているという事だろうか。
    | self-insert で起こっているという事は、
    | _ble_edit_ind の値が範囲外になっているという事である。
    | そして今迄の経験から言ってこの現象が起こるのは履歴の操作をした後であるから、
    | 履歴の移動を行った際に _ble_edit_ind の更新を忘れている、または、更新に失敗しているというのが怪しい。
    |
    | ble-edit/history/goto を確かめてみたがちゃんと _ble_edit_ind _ble_edit_mark は設定されている。
    | 怪しいのは、ble-edit/history/goto の直後に ble-edit/isearch/.set-region を実行している箇所である。
    | ここで格納されている・或いは関数外から指定されている beg end はちゃんと範囲内になっているのだろうか。
    | 結局また迷宮入りの様な雰囲気がしている。
    | しかし前よりは進歩があった。_ble_edit_ind, _ble_edit_mark の設定が怪しい。

    → _ble_edit_ind, _ble_edit_mark が異常な値 (範囲外) になっている。

    [原因]

    | 怪しい所を発見した。
    | ble/widget/isearch/next-history において、_ble_edit_history における一致箇所を取得している。
    | その次に ble-edit/isearch/.goto-match で一致した箇所に移動を行っている。
    | しかし、ble-edit/isearch/.goto-match から呼び出された ble-edit/history/goto では
    | _ble_edit_history_edit または _ble_edit_history から文字列をロードしている。
    | もし _ble_edit_history_edit が設定されているのに _ble_edit_history の中に一致が見付かった場合、
    | _ble_edit_str には _ble_edit_history_edit からの文字列が設定され、
    | _ble_edit_ind には _ble_edit_history の中の文字列における位置が設定される。
    | _ble_edit_history_edit の文字列が _ble_edit_history の文字列よりも短く、
    | 更に検索で _ble_edit_history の末尾付近 (_ble_edit_history_edit の文字列の長さよりも後尾) で一致が発生した場合、
    | そこで _ble_edit_ind に対する不整合が生じることになる。

    →ble/widget/isearch/next-history において _ble_edit_history の中を検索している。
      しかし、実際に ble-edit/history/goto で設定される文字列は _ble_edit_history_edit から優先して取得される。
      両者の文字列の内容に違いがある場合不整合が生じる。
      更に、長さが異なり _ble_edit_ind が範囲外になった時にエラーが発生する。

    [再現方法]

    | 実際に再現するかどうかを試験する。
    | →カーソルの位置がずれるというバグを発見した。しかしながら、
    |   以前から出ているエラーは再現しない。
    |
    | うーん。_ble_edit_ind が不正な状態の時に self-insert が発生する為には、
    | 或る時点で検索が中断されなければならない。矢印キーで検索を中断しようとすると、
    | カーソルの移動が起こって、その際に正しい位置に _ble_edit_ind が設定され直す様だ。
    | (本当か?) → 確かに関数 .ble-edit.forward-char において範囲外になった時のチェック・補正が行われている。
    | という事は、矢印キー以外で検索を中断する手段があるという事になる。再度キー割り当てを確認する。
    |
    | C-d にすると補正が行われずに検索状態から抜けられそうである。
    | 実際にやってみた。確かに初めの self-insert で変な状態になっている様に見えるが、
    | しかしエラーは発生しない様である。うーん。と思ったが、検索した文字がいけない?
    |
    | 1. "echo hello" RET として入力・実行
    | 2. up back*5 down として hello を削除
    | 3. C-r "h" C-d で検索を行い中断
    |
    | としたが "h" で検索を行ったので "echo " の末尾にカーソルが設置された状態になっていて
    | 何も問題が発生していないという事ではないだろうか。という事で o で検索を行ってみる事にする。
    | 出た! 再現方法が分かった! 以下に再現方法の最小操作を書く

    再現方法 → "aa" RET up C-u down C-r "a" C-d "a"

    [解決方法]

    ad hoc には検索時に _ble_edit_history だけでなく _ble_edit_history_edit も参照する様にすれば良い。
    しかし、やはり実際に履歴を遡った時に表示する内容を _ble_edit_history に格納した方が良いのではないかという気がする。
    つまり、現在は実際の履歴を _ble_edit_history に格納し、履歴の編集仕掛の状態を _ble_edit_history_edit に格納しているが、
    そうではなくて、編集したものも含めて _ble_edit_history に格納しておいて、
    編集前の状態を _ble_edit_history_edit に格納するという様に変更するべきかもしれない。

    しかし、一方で現在の編集状態が _ble_edit_history に入っていると不都合という場合もあるかもしれない。
    _ble_edit_history か _ble_edit_history_edit かどちらの値が入っている方が扱いやすいかについて、
    それぞれの配列が使用されている各箇所で確認を行う必要がある。

    * ble-edit/history/add の erasedups のチェックで使用する _ble_edit_history は編集前の内容であるべきである。
    * ble-edit/history/goto で読み出しているのは編集後の内容であるべきだ。現在は既にその様な実装になっている。
    * ble/widget/isearch/next-history で使用するのはやはり編集後の内容であるべきだ。
      そしてここではループなどで読み取りを実行する為、_ble_edit_history_edit,
      _ble_edit_history の両方をチェックする様な実装にはしたくない。

    両者ともループでチェックする部分を含んでいる事から、編集前の状態と編集後の状態を完全に保持するという手もある。

    * redo undo との関係

      | また、今後 redo undo を実装することも考えて実装を選択する必要もあるだろう。
      | redo undo を前提にするとどの様な実装が良いだろうか。
      |
      | a 一つの方法は現在の編集後の状態を _ble_edit_history に記録しておいて、
      |   編集の履歴は一つの配列に edit[編集番号]="履歴番号 文字列" の形で積み重ねて記録する方法である。
      | b もう一つの方法は、配列の履歴番号に対応する要素に edit[履歴番号]="文字列0 文字列1 ..." と格納する方法である。
      |   この方法だと格納する文字列に適切な escape を施す必要がある。
      |   例えば空白類を別の文字で置き換えるか、或いは、%q で格納しておいて使用する時に eval で取り出す。
      | c 或いは編集前の状態を _ble_edit_history に記録して、編集の履歴を a と同様に格納する方法、
      | d また、編集前の状態を _ble_edit_history に記録して、編集の履歴を b と同様に格納する方法が考えられる。
      |
      | 何れの方法を選ぶとしても erasedup check もしくは next-history で、
      | 編集前の状態、編集後の状態の両方を高速に処理することはできない。
      | という事は結局、やはり、編集前の状態・編集後の状態・編集過程の情報
      | の三種類を独立に管理するという事になる。
      | この内の "編集過程の情報" の管理に関しては redo undo で完全に閉じている話で、
      | 実際に redo undo を実装する段階になってから考察すればよい。
      | そして、編集前の状態・編集後の状態に関しては redo undo の方法に依らずに実装できる。
      | つまり、redo undo と履歴データの保持は直交的である。或いは、直交的な実装にするのが見通しがよい。

      [結論]

      "編集前の状態"・"編集後の状態" は redo undo とは関係なく実装する。
      更に redo undo については "編集過程の情報" を保持する何らかの形式の配列を用いる。

    % 現在は、編集前の状態を _ble_edit_history に格納し、
    % 編集がある場合には編集後の状態を _ble_edit_history_edit に格納している。
    % その儘 _ble_edit_history_edit が完全な情報を持つ様に拡張を行うのが自然に思われる。
    % しかし、その為の管理は大変ではないかどうか確かめる必要がある。
    %
    % 基本的に _ble_edit_history に値を設定している箇所で
    % 同様に _ble_edit_history_edit にも値を設定する様にすればよい。
    % 調べてみた所 _ble_edit_history に値を設定しているのは、
    % ble-edit/history/load と ble-edit/history/add だけである。
    % また _ble_edit_history_edit に値を設定しているのは、
    % ble-edit/history/add で _ble_edit_history_edit の中身をクリアしている所と、
    % ble-edit/history/goto で移動前に値を格納している所だけである。
    % 以外と変更範囲が少ないので拡張の見通しは良い。
    %
    % [実行]
    % _ble_edit_history_edit の拡張を実行する。
    % 更に改名: _ble_edit_history -> _ble_edit_history0,
    % _ble_edit_history_edit -> _ble_edit_history
    %
    % [問題]
    % 変更してみるとバグは発生しなくなった。しかし今度は別の問題点が生じる。
    % コマンドの実行が遅い。コマンドを実行する際に履歴に実行するコマンドを登録する。
    % その時に _ble_edit_history0 の内容を丸ごと _ble_edit_history にコピーする。
    % そのコピーに時間が掛かっている様だ。実際に、
    %
    %   time alpha=("${_ble_edit_history[@]}")
    %
    % を実行してみると、0.374s かかっている。ble-edit/history/add ではこれを2回実行している。
    % つまり、毎回 0.7s 以上の遅延が生じるという事になる。
    %
    % やはり丸ごと同じ物を管理するというのは非現実的なのだろうか。
    % 或いは、_ble_edit_history の内容をクリアするのに丸まるデータをコピーするのではなく、
    % 変更のあった物だけクリアするという方法でも良い。
    % この方針の場合には、変更のあった履歴番号を記録に残しておく必要がある。
    %
    % 或いは、実際に _ble_edit_history を使おうとするまでは
    % _ble_edit_history0 -> _ble_edit_history のコピーは遅延させるか。
    % しかし何れにしても history の検索に無駄な時間が掛かることに違いはない。

    速度が遅いということが判明したので、
    _ble_edit_history_edit にも完全な情報を持たせるという方法は棄却することにした。
    代わりに、(多少検索に時間が掛かる様になるかもしれないが) 編集後の値が必要な箇所では

      ${_ble_edit_history_edit[i]-${_ble_edit_history[i]}}

    の形式でアクセスする様に変更した。

    何れにしても現在の時点で既に検索には時間が掛かる傾向があって、
    その対策として検索中に入力がないかチェックすることを考えていた。
    検索中に入力がないかチェックする機能が完成すれば、
    この形式のアクセスによるオーバーヘッドは気にならなくなるだろう。
    (実測はしていないが元々そんなに重くはないだろうと予想されるので)。

    以下にある過去の報告はこの修正で直った物と思われる。
    もし依然として問題が残っているのだとしても、それはその時に考える事にする。

    | 2016-01-12
    |
    | * 履歴検索を起動しただけで×になった。比較的最新版である。
    |   最近の構文解析のバグは全て潰した後である。
    |
    |   | stackdump: X1 0 <= beg:11 <= end:12 <= iN:1, beg:11 <= end0:11 (shift=1 text=s)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-16 (ble-syntax/parse)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:4 (_ble_edit_str.update-syntax)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-135 (ble-highlight-layer:syntax/update)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:4441 (ble-highlight-layer/update)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:4884 (.ble-line-text/update)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:1 (.ble-edit-draw.update)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:1 (.ble-edit-draw.update-adjusted)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:966 (ble-edit/bind/.tail)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-4230 (ble-decode-byte:bind/EPILOGUE)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:1 (ble-decode-byte:bind)
    |   | -bash: beg: 読み取り専用の変数です
    |   | stackdump: X2 0 <= 0 <= 11 <= 12 <= 1 <= 1
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-16 (ble-syntax/parse)
    |   |   ※以降のエラーは全て ble-syntax/parse 以下で起きている。
    |   |     上記と同じなので詳細な stackdump は以降は省略する。
    |   | stackdump: X1 0 <= beg:12 <= end:13 <= iN:2, beg:12 <= end0:12 (shift=1 text=ss)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-16 (ble-syntax/parse)
    |   | -bash: beg: 読み取り専用の変数です
    |   | stackdump: X2 0 <= 1 <= 12 <= 13 <= 2 <= 2
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-16 (ble-syntax/parse)
    |   | stackdump: X1 0 <= beg:13 <= end:14 <= iN:3, beg:13 <= end0:13 (shift=1 text=ssh)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-16 (ble-syntax/parse)
    |   | -bash: beg: 読み取り専用の変数です
    |   | stackdump: X2 0 <= 2 <= 13 <= 14 <= 3 <= 3
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-16 (ble-syntax/parse)
    |   | stackdump: X1 0 <= beg:14 <= end:15 <= iN:4, beg:14 <= end0:14 (shift=1 text=ssh )
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-16 (ble-syntax/parse)
    |   | -bash: beg: 読み取り専用の変数です
    |   | stackdump: X2 0 <= 3 <= 14 <= 15 <= 4 <= 4
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-16 (ble-syntax/parse)
    |   | stackdump: X1 0 <= beg:15 <= end:16 <= iN:5, beg:15 <= end0:15 (shift=1 text=ssh l)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-16 (ble-syntax/parse)
    |   | -bash: beg: 読み取り専用の変数です
    |   | stackdump: X2 0 <= 4 <= 15 <= 16 <= 5 <= 5
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-16 (ble-syntax/parse)
    |   | stackdump: X1 0 <= beg:16 <= end:17 <= iN:6, beg:16 <= end0:16 (shift=1 text=ssh la)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-16 (ble-syntax/parse)
    |   | -bash: beg: 読み取り専用の変数です
    |   | stackdump: X2 0 <= 5 <= 16 <= 17 <= 6 <= 6
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-16 (ble-syntax/parse)
    |   | assertion failure: ((nofs<${#node[@]}))
    |   | ble-syntax/tree-enumerate/.impl(i=4,iN=6,nofs=0,node=,command=ble-syntax/parse/shift.impl2/.proc1)/FATAL1
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:7612 (ble-assert)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:108 (ble-syntax/tree-enumerate/.impl)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:22 (ble-syntax/tree-enumerate)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:1901 (ble-syntax/parse/shift)
    |   |   @ /home/murase/.mwg/src/ble.sh/out/ble.sh:-16 (ble-syntax/parse)
    |
    |   三つの問題点が生じている。再現性はない (正確には、再現方法は未だ不明)。
    |
    |   1. dirty range がおかしい (文字列の長さの外にある)。
    |     これはここではなく dirty range を更新している部分でチェックを行うべきではないか。
    |   2. dirty range がおかしい時の対策として beg, end を再設定している。
    |     しかしここで "-bash: beg: 読み取り専用の変数です" のエラーが発生している。
    |   3. 以下のエラーが発生している。node が空である。
    |     assertion failure: ((nofs<${#node[@]}))
    |     ble-syntax/tree-enumerate/.impl(i=4,iN=6,nofs=0,node=,command=ble-syntax/parse/shift.impl2/.proc1)/FATAL1
    |
    |   どうも今迄の経験から 1. の範囲の異常は履歴の移動に関係している気がする。
    |   取り敢えず 2. "beg: 読み取り専用の変数です" のエラーメッセージの部分だけは修正する。
    |   3. に関してはこのエラーに関係しているのかどうか分からないが、
    |   一見すると独立なエラーのようにも思われる。
    |   しかし発生したタイミング的には明らかに相関している。
    |   そうだとするとどの様にしてこのエラーが発生するのか確認する必要がある。
    |
    |   先ずは改めて dirty range の計算について調べる。
    |   _ble_edit_str が直接変更されているのは、初期化時を除けば、
    |   function _ble_edit_str.{replace,reset,reset-and-check-dirty} のみである。
    |   現在の所 reset-and-check-dirty は使用されていない。
    |
    |   →トラップをしかけたら直ぐに引っかかった。
    |   _ble_edit_replace である。履歴検索をして中断した後になる。
    |
    | 2015-11-30
    |
    | * 構文解析部分更新の bug
    |
    |   + bug (2015-11-28a)
    |
    |     $ seq2gif -f 0 -b 254 < demo.tty > out/img/demo.gif
    |     カーソルを先頭に移動した時?? 再現しない。
    |
    |   + stackdump: X1 0 <= 48 <= 49 <= 1, 48 <= 48
    |       @ /home/murase/prog/ble/ble.sh:-16 (ble-syntax/parse)
    |       @ /home/murase/prog/ble/ble.sh:4 (_ble_edit_str.update-syntax)
    |       @ /home/murase/prog/ble/ble.sh:-135 (ble-highlight-layer:syntax/update)
    |       @ /home/murase/prog/ble/ble.sh:4327 (ble-highlight-layer/update)
    |       @ /home/murase/prog/ble/ble.sh:4818 (.ble-line-text/update)
    |       @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
    |       @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
    |       @ /home/murase/prog/ble/ble.sh:1001 (.ble-decode-byte:bind/tail)
    |       @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)
    |     stackdump: X2 0 <= 0 <= 48 <= 49 <= 1 <= 1
    |       @ /home/murase/prog/ble/ble.sh:-16 (ble-syntax/parse)
    |       @ /home/murase/prog/ble/ble.sh:4 (_ble_edit_str.update-syntax)
    |       @ /home/murase/prog/ble/ble.sh:-135 (ble-highlight-layer:syntax/update)
    |       @ /home/murase/prog/ble/ble.sh:4327 (ble-highlight-layer/update)
    |       @ /home/murase/prog/ble/ble.sh:4818 (.ble-line-text/update)
    |       @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
    |       @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
    |       @ /home/murase/prog/ble/ble.sh:1001 (.ble-decode-byte:bind/tail)
    |       @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)
    |
    |     また出た。一旦 C-u した後に RET して貼付をしたら出た。2015-12-03
    |     でもまた同じようにしても再現しない??
    |
    |     stackdump: X1 0 <= beg:66 <= end:96 <= iN:30, beg:66 <= end0:66 (shift=30 text=function () () { echo hello; })
    |       @ /home/murase/prog/ble/ble.sh:-16 (ble-syntax/parse)
    |       @ /home/murase/prog/ble/ble.sh:4 (_ble_edit_str.update-syntax)
    |       @ /home/murase/prog/ble/ble.sh:-135 (ble-highlight-layer:syntax/update)
    |       @ /home/murase/prog/ble/ble.sh:4353 (ble-highlight-layer/update)
    |       @ /home/murase/prog/ble/ble.sh:4844 (.ble-line-text/update)
    |       @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
    |       @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
    |       @ /home/murase/prog/ble/ble.sh:1140 (.ble-decode-byte:bind/tail)
    |       @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)
    |     stackdump: X2 0 <= 0 <= 66 <= 96 <= 30 <= 30
    |       @ /home/murase/prog/ble/ble.sh:-16 (ble-syntax/parse)
    |       @ /home/murase/prog/ble/ble.sh:4 (_ble_edit_str.update-syntax)
    |       @ /home/murase/prog/ble/ble.sh:-135 (ble-highlight-layer:syntax/update)
    |       @ /home/murase/prog/ble/ble.sh:4353 (ble-highlight-layer/update)
    |       @ /home/murase/prog/ble/ble.sh:4844 (.ble-line-text/update)
    |       @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
    |       @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
    |       @ /home/murase/prog/ble/ble.sh:1140 (.ble-decode-byte:bind/tail)
    |       @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)
    |
    |   見た感じ dirty-range の更新に失敗している様である。

2016-04-07

  * バグが出た。再現性がある。 [2016-04-05 提起] [#D0321]

    今迄に出ていたバグとはまた種類が異なる様に見える。

    | $ CXXKEY=g454 cxx -I$HOME/opt/libmwg-201509 20160318.idea.sfinae-overload.cpp ← 最後の引数の先頭で C-w C-y C-y する
    | $ CXXKEY=g454 cxx -I$HOME/opt/libmwg-201509  -I$HOME/opt/libmwg-201509 20160318.idea.sfinae-overload.cpp
    | $ CXXKEY=g454 cxx -I$HOME/opt/libmwg-201509 -I$HOME/opt/libmwg-201509 20160318.idea.sfinae-overload.cpp
    | $ CXXKEY=g454 cxx -I$HOME/opt/libmwg-201509 -I$HOME/opt/libmwg-201509/i 20160318.idea.sfinae-overload.cpp
    |
    | assertion failure: ((nofs<${#node[@]}))
    | ble-syntax/tree-enumerate/.impl(i=40,iN=106,nofs=0,node=,command=ble-syntax/parse/shift.impl2/.proc1)/FATAL1
    |   @ /home/murase/prog/ble/ble.sh:7630 (ble-assert)
    |   @ /home/murase/prog/ble/ble.sh:108 (ble-syntax/tree-enumerate/.impl)
    |   @ /home/murase/prog/ble/ble.sh:22 (ble-syntax/tree-enumerate)
    |   @ /home/murase/prog/ble/ble.sh:2127 (ble-syntax/parse/shift)
    |   @ /home/murase/prog/ble/ble.sh:-16 (ble-syntax/parse)
    |   @ /home/murase/prog/ble/ble.sh:4 (_ble_edit_str.update-syntax)
    |   @ /home/murase/prog/ble/ble.sh:-135 (ble-highlight-layer:syntax/update)
    |   @ /home/murase/prog/ble/ble.sh:4388 (ble-highlight-layer/update)
    |   @ /home/murase/prog/ble/ble.sh:4902 (.ble-line-text/update)
    |   @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
    |   @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
    |   @ /home/murase/prog/ble/ble.sh:966 (ble-edit/bind/.tail)
    |   @ /home/murase/prog/ble/ble.sh:-4248 (ble-decode-byte:bind/EPILOGUE)
    |   @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)

    単純化する。何と以下の操作だけでバグが出る。

    $ echo  $B+
    $ echo $B+
    $ echo $B+12

    上から二行目の時点で何か以上になっていると見るべきであろう。
    空白を消したりせずに、先頭から順に入力した時には何もエラーには為らないので、それと比較すればよい。

    +-------------------------------------------------------------+-------------------------------------------------------------+
    | エラーが発生する直前                                        | 正常時 (順に入力した時)                                     |
    +-------------------------------------------------------------+-------------------------------------------------------------+
    | [murase@padparadscha 0 ~]$ echo $B+                         | [murase@padparadscha 0 ~]$ echo $B+                         |
    | A?                                                          | A?                                                          |
    |  2 aw   000 'e' | stat=(1 w=- n=- t=-1:-1)                  |  2*aw   000 'e' | stat=(1 w=- n=- t=-1:-1)                  |
    |  | aw   001 'c' |                                           |  |*aw   001 'c' |                                           |
    |  | aw   002 'h' |                                           |  |*aw   002 'h' |                                           |
    |  | aw   003 'o' + word=2:0-4                                |  |*aw   003 'o' + word=2:0-4                                |
    |  3 a    004 ' '                                             |  3*a    004 ' '                                             |
    | 14 a  s 005 '$' | stat=(3 w=- n=- t=1:-1)                   | 14*a    005 '$' | stat=(3 w=- n=- t=1:-1)                   |
    |  7 a    006 'B' |                                           |  7*a    006 'B' |                                           |
    |  4 a    007 '+' + word=4:@3>5-8 stat=(4 w=4:5- n=- t=-1:4)  |  4*a    007 '+' + word=4:@3>5-8 stat=(4 w=4:5- n=- t=-1:3)  | !
    | \_ 'echo'                                                   | \_ 'echo'                                                   |
    | \_ '$B+'                                                    | \_ '$B+'                                                    |
    +-------------------------------------------------------------+-------------------------------------------------------------+

    早速違いがある。記録されている stat だ。木構造に於ける兄の位置がずれている。
    具体的に表示されているのは t=tclen:tplen の様だ。
    実際には tplen = _ble_syntax_stat[index][5] に記録されている。

    正常値 tplen=3 は 3 文字前の 境界4 で単語が終了している事を表している。
    そして、それは実際には単語情報が セル3 に格納されている事を表す。
    一方で異常値 tplen=4 は境界3 で単語が終了して セル2 にデータが格納されている事を期待する。
    ところが其処には何も格納されていない為にエラーが発生するのである。

    と言う事はスペースを削除する瞬間に _ble_syntax_stat[index][5] の shift に失敗している事になる。
    shift を実行しているのは function ble-syntax/parse/shift.stat である。
    実際に shift の際に呼び出されている所を確認する。j=9 及び j=6 で呼び出されている。
    これは実際に stat が設置されている場合にのみ shift を行うという事なのだろう…?
    しかし良く分からないのが、この時点で設置されているのは j=6 及び j=8 なのではないかという事である。
    うーん呼出元を確認してみる事にする。現在は ble_shift_method は 2 に設定されているので、
    function ble-syntax/parse/shift.impl2/.proc1 が実効的に処理をしている事になる。
    これに実装中という文字が書かれているのが気になるが、よく動作を見てみる事にする。

      ここで気付いたのだが、shift が起こったかどうかは _ble_syntax_shift という配列に記録して、
      それを上記の dump で表示している事に気付いた。s という文字がある場所でだけ実際に shift が起こったという事を表す。
      確かにそれを見ると 境界7 に設定されている stat で shift が起こらなかったという事が見て取れる。
      つまり、このバグの問題点は shift するべき対象の列挙に失敗しているという事である。

      やりにくいので末尾 (iN 番目) に設置されている stat も ble_debug=1 で表示する事にする。

    改めて ble-syntax/parse/shift.impl2/.proc1 に戻る。
    ble-syntax/parse/shift.impl2/.proc1 の呼び出しの時点では j = 9 ... 6 について処理を行う様に呼び出しがある様だ。
    という事は問題は skip にあるという事だろうか。というか i だとか j2 だとか j の値は誰が決めているのだろうか。。

    - 先ず、i については ble-syntax/tree-enumerate/.impl が設定している値の様である。
      現在処理を行っている word (tree node) の終端境界の番号である。
      具体的に word の情報は _ble_syntax_tree[i-1] に格納されている。
      さて、ここでの疑問は shift.impl2 で参照している変数 i が果たして
      本当に tree-enumerate の内部変数を意図しているのかという事である。
      shift.impl2 の呼出元を辿ってみるが意図して i を設定しているという箇所はないようなので、
      これは確かに tree-enumerate の内部変数 i を意図しているのだろうと推測・仮定する。

    - 次に j, j2 に関しては ble-syntax/tree-enumerate/.impl では特に設定を行っていない様である。
      というか寧ろ shift.impl2/.proc の呼出元 (ble-syntax/parse/shift) で意図的に iN 及び j を設定している。
      この変数名は本当は変えるべきである。tree-enumerate の実装を変更して内部で j を使う様に変えてしまうと事故が起こる。
      いや、iN に関しては変更する必要はない、というか、iN は tree-enumerate に対する入力(tree 起点)なので変数名は変えては行けない。

      うーん。変数名を変えようと思ったが tree-enumerate を跨いで共有されている変数が実は他にも沢山ある様だ。
      しかも広範な関数でこれらが共有されている。

      beg,end,end0,shift は勿論の事、ble-syntax/parse のローカル変数である i1,i2,j2,iN も共有されている。
      そして j に関しても、shift.stat, shift.nest, shift.tree, shift.tree/1 等の
      諸々の関数で使用されているので変数名を変える訳には行かない。
      しかし j という変数名は余りに衝突が起きやすそうであり危険である。
      これは後で処理する事にした。

    変数の役割については大体分かったので、実際に .proc1 を呼び出した時の変数の様子について見てみる。

      shift.impl2/.proc1: current word: 6-9, end0=6 tprev=4 tchild=-1
      shift.impl2/.proc1: loop will be j = 9 (_shift2_j) ... 6 (j2)

    という事のようだ。この時 tchild が存在していないので内部に対する探索は行われない。
    そのままその単語についてだけ処理が行われて中に設置されているデータに対する shift は実施されないのである。
    つまり "$B+" という単語については内部構造がないので内部の shift を省略するというのである。
    しかしながら実際には内部に解析再開点が存在している。これらの shift が飛ばされてしまうのである。

    うーん。これはこの shift 対象列挙の strategy 自体に欠陥があるという事になる。
    内部の解析再開点に関しては一つ一つ配列の中身を確認して shift を試みるという手もあるが、
    それだと元々の strategy 1 と違いがない。寧ろ strategy 1 の様に単純に shift を全部試みるのがよい。
    或いは、

    結局何が問題なのかというと内部の解析再開点については単語の内部にしか参照を持っていないと仮定したからではないかという気がする。

    > 一つの方法は tree nest は木構造を反映した方法によって更新を行い、stat はそれとは別に更新を行うという方法である。
    > そして、stat を保持するに当たって直前の stat の位置を一緒に記録する事にするのである。
    > 直前の stat の位置の情報を保持するとなると
    >
    > - ble-syntax/parse の変数が一つ増える。
    > - shift の際にその直前の stat の位置もずらさなければならない。
    > - 直前の stat の位置も一致していないと同一状態になったと判定できないので、中断が起こりにくくなる。
    >
    >   > しかしながら直前の stat の位置というのは実は解析に使用されていないので、
    >   > それが一致していなくても解析中断を実行しても良いという気がする。
    >   > というか、今迄が直前の stat の位置に依存せずに中断を起こしていたのでこれは問題にならない。
    >   > 単純に前回の解析中断位置をその場で更新して終了するだけで済む話である。
    >   > 更に、len (負のoffset) で記録しておけば shift も実は行わなくて良い様な気がする。
    >   > len を shift する必要がある場合というのは、
    >   > 直前の解析中断位置と現在位置の間に dirty range が被っている場合で、
    >   > しかし、その様な場合に関しては何れにしても再解析が実行される事になるのでその時に結局上書きされるのである。
    >
    >   結論: 直前の stat の位置は解析中断判定には使わない。直前の stat の位置は stat 更新時に設定すればよい。
    >
    > しかし、shift だけを実行して、実際の解析を最後までやりきらなかった場合には一体どうなるのだろうか。
    > 現状ではその様な動作はしない事になっているが将来的には解析を途中で中断して、それから
    > 解析を後で再開するというような機能を実装したいと考えている。というか、現在の構造はそれを意図しての構造である。
    > しかし、解析を後で再開しようという時に直前 stat 位置の shift が中途半端な状態になっていると
    > 再度の shift を実行する事が不可能になってしまう。
    >
    > →えーと。でもそれは現在の tree-enumerate による実装でも同様なのではないだろうか。
    >   途中で解析を中断して後で解析を始めよう…という時に tree 構造が中途半端になっていると、
    >   そもそも tree 構造を辿って shift 位置を楽しようと言う事ができなくなる。
    >   つまり、現在の実装だと結局全探索を余儀なくされるという事になるのではないだろうか。
    >
    > ちょっと現在の手法について再度一から考え直した方が良いような気がする。
    >
    > 一応直前 stat 位置を記録する、という方法は何とか manage する事ができる。
    > 解析途中で一時停止をする際に辻褄が合うように直前 stat 位置を更新すればよいのである。
    > しかし tree 構造に関して解析一時停止をする時になんとか辻褄が合うような形にするというのは無理である。
    > できるとしても可成り複雑になりプログラムを書くのが面倒になる事請け合いである。
    >
    > 従って tree, nest に関してもそれぞれに直前の非空白要素の位置を管理する様にすれば良い気がする。
    > そもそもは、既にある tree の仕組みを利用すれば additional な情報を管理せずに
    > 高速に shift 対象を列挙できるのではないかと考えた事にあった。
    > この様に直前の非空白要素の位置を管理するようにしてしまうと管理コストが増えてしまう。
    > しかし、これも将来的にはしょうがないという気もする。

    結論:

    現状の方法では、解析一時中断を行った時に shift 対象の高速な列挙が出来なくなる。
    唯一の現実的な高速化手法は "直前非空白要素の位置" を管理するように変更する事である。
    これは解析自体の動作とは全く関係なく、_ble_syntax_tree/stat/nest の配列としてのデータ構造を拡張するという事である。
    解析自体の実装とは直交して実装する事が可能と思われるが、新規情報の管理コストが増えるという問題点が残る。

    > 解析一時中断を考えない現状での解決方法についても考えてみる。
    > 解析一時中断を考えない事にすれば、現状の方法でも解決する方法があるかもしれない。
    > 何が問題だったかというと、その単語が dirty range に被っていないのであれば、
    > 内部に存在している stat nest の何れも dirty range 及びそれを跨いだ参照は持たないと仮定した事にある。
    > しかし乍らその単語自体が dirty range に被るような参照を持っている場合は、
    > 内部に設置された stat も dirty range に被るような参照を持っているという事を意味する。
    > 何故ならばその単語が dirty range に被るような参照を持つ事が出来るのは、
    > 内部の stat を通じてその参照が継承されたからなのである。
    > 従って *少なくとも* その単語自体が dirty range に被るような参照を持っている場合には、
    > 内部の shift を実行する必要があるという事になる。
    > 問題はその単語自体が dirty range に被るような参照を持たない場合に、
    > 実は内部の stat が dirty range に被るような参照をもっているかもしれないという事である。
    > 外部に対する参照として可能なのは基本的に tprev inest のみである。
    > 単語内部では既に wbegin が設定された状態にあり、それを跨ぐ事が出来るのは tprev (tplen) inest (nlen) だけだからである。
    > tchild (tclen) に関しては wbegin 以降でなければならない。wlen については wbegin その物を参照する。
    > その他の種類の参照は多分存在していない様に思う。

    結論: 単語外部に対する参照として可能なのは tprev inest のみである。
      tplen 及び nlen について dirty-range に被らないという事が保証できる時に
      単語内部の探索のスキップが可能である。

    tprev に関してチェックを追加しようと思ったら既にチェックが入っていた。
    というかコメントに正にその様に書かれている。
    それなのに今回その事が問題になった。では、一体何が悪いのか。
    何か ble-syntax/parse/shift.impl2/.proc1 の構造が変である。
    →結局大幅に直した。バグが出なくなった。skip も適切に行われている。
      結局、問題点については shift.impl2/.proc1 の実装当初認識していたが実装が甘かったという事だ。

    % 後で余裕があれば shift.stat, shift.nest, shift.tree, shift.tree/1 は引数で j を受け取る様に変更する。
    %
    %   shift.stat, shift.nest の呼出元は何れも 3 箇所である。意味的にも j を引数で受け取って変な事はない。
    %   shift.tree の呼出元は二箇所である。しかし実は既に引数として nofs を受け取る仕組みになっている。
    %   j を新しく受け取れるような仕組みにはなっていない…?
    %   然し意味を考えれば nofs というのは _ble_syntax_tree[j]
    %   の要素の中の更に nofs 番目のフィールドという意味であるから、
    %   本来は nofs を受け取るのであればそれが属している所の j も受け取るのが自然である。
    %   なのでこれも書き換えて問題ないと考える。
    %   shift.tree/1 に関しては様々なローカル変数を受け取っている中で j だけ引数で受け取るようにするのは変である。
    %   幸いにして呼び出しているのは shift.tree だけなので、
    %   shift.tree/1 は親の shift.tree のローカル変数を共有していると考えて、
    %   ローカル変数 j を直截さ割って良い事にする。関数名が shift.tree/1 であるのはそういう事である。
    %
    %   もう一つ確認しておくべき事は各関数が j を内部で書き換えていないかという事である。
    %   内部で書き換えた値が外部に伝播する事を意図しているのだとしたら、
    %   単純に引数で受け取るように変更してしまうと問題が生じる。
    %   これに関しては関数内部を観察してみた所 j を書き換えている様子はないし、
    %   関数の役割的にも j を書き換えるのは不自然に思われたので、多分大丈夫だろう。
    %   多分だとアレなので再度確認する。特に別の関数を呼び出しているという事もないようなので、
    %   更に子関数で書き換えられているという危険性もない。
    %   唯一呼び出されている関数が touch-updated-word であるが、この関数も内部で j には触っていない。
    %
    %   よって以下のように変更を行う → OK
    %   - shift.stat, shift.nest, shift.tree は引数を介して j を受け取る様にする。
    %   - 特に shift.tree に関しては第一引数に j を受け取り、第二引数に nofs を optional で受け取る様にする。

    変数名の変更については、そもそもそんなに綺麗な実装でもないのでどうでも良くなった。
    というか j を紛らわしくない変数名にすると言っても余り良い変数名も思い付かないし、
    _shift2_j の様な不自然に長い変数名だと関数を書いていて何か変な感じがする。
    結局 tree-enumerate を跨ぐ部分でだけ _shift2_j という変数に値を待避する事にした。

    tree-enumerate による skip の実装と解析一時中断の不整合に関しては別項目で残す事にする。


2015-12-24

  * (ble-syntax:bash): time -p 対応 [#D0320]

    > [2015-02-16] (ble-syntax:bash): time -p

    parse_suppressNextStat を用いて無理矢理対応した。
    問題があるかもしれないので注視する。

    + parse_suppressNextStat は常に設置する事にする。

      当初条件を満たせば parse_suppressNextStat を設置せずに
      -p を解析済とする様にしていたがそれでも問題が起こる様だった。

      例えば time -p<(echo hello) の様に入力する事を考える。
      time -p< まで入力した時点で time -p で確定し、再開点が < に設置される。
      しかし <( まで入力した時点で、実は '<' はリダイレクトではなくて単語の一部だったという事になり、
      そこで単語が終わるという仮定の下での time -p での確定が誤りだったという事になる。

      他にも似たような罠があるかもしれないので、
      複雑な条件で parse_suppressNextStat 設置を省略するのは止めて、
      常に parse_suppressNextStat は設置する様にする事にする。

    + -p を確定した場合は単語を設置する事にする。

      この様にしないとコマンドとして解釈していた時の単語着色が残ってしまう。
      (これは現在の単語着色の仕組みの問題点に起因する物であるが、
      -p を単語として登録しても別に損する事は無いし寧ろ好ましい)。

  * (ble-syntax:bash): a=([...]=value), a+=([...]+=delta) に対応。 [#D0319]

    > [2015-02-16] (ble-syntax:bash): a=([key]=value) b=([x]=123 [y]=321)

  * bug: extglob の所為で var+= が正しく読み取られない。 [#D0318]

    どうも var+ まで入力した時点で |var|+ の二箇所に解析再開点が設置される様である。
    この状態で var+= を入力しても解析は += から再開されるので、
    正規表現の var+= に引っかかる事がないという事になる。

    これを何とかする為には、+( 以外の + については解析再開点を設置せずに
    前の解析に取り込んで処理する必要がある。

    parse_suppressNextStat という変数を新しく追加してみる事にした。
    この変数に値を設定すると次の stat 記録が保留される。
    これによって不都合が起こるかもしれないので暫く様子を見る。

  * (ble-syntax:bash): \new 文脈 CTX_CASE [#D0317]

    > ;& ;; ;;& の次に来るのは CTX_CMDX ではなくて CTX_CASE? 的な物では?
    > ;& ;; ;;& の場合には CTX_ARGX CTX_CMDXV に加え CTX_CMDX でも ERR ではない。

    case word in 直後、;; ;;& ;& 直後 の状態。
    次に esac が来れば esac をコマンドとして受け入れる。
    次に ( が来ればそれをパターンの開始と解釈する。
    他の場合にはそのままパターンが開始すると解釈する。

    未だ case コマンドの方で対応していないので、
    現状では case a in ...) は正しく解釈されない。

  * ble-syntax.sh: CTX_VAL{X,I} から CTX_COND{X,I} を分離。 [#D0316]

    > 値リストと条件コマンドの文法は、 &<>() 等の文字に対して結構違う。
    > 分離した方が良いのではないか?

  * ble-edit.sh: bug: 履歴展開が効かない [#D0315]

  * ble-syntax:bash extglob 対応 [#D0314]

    > [2015-02-16] (ble-syntax:bash): extglob

    extglob が有効なのはどの箇所か。
    - case pattern 内部
    - パラメータ展開内部
    - [[ == globpat ]]
    - シェル単語
    特に色付けなどをしなくても良くて入れ子状態だけ正しく処理できれば良いのであれば、
    シェル単語の箇所と case pattern 内部だけ処理すれば良い。
    色も付けようとなると面倒である。


    [入れ子構造の解析について]

    パラメータ展開内部に関しては extglob の括弧の中にあるかどうかに拘わらず
    '}' が来ればパラメータ展開は終了する様である。
    extglob としての解釈はパラメータ展開を切り出してからの様である。

    シェル単語などの様に裸で extglob の括弧が登場する場合に関しては
    文法的に特別な扱いをして括弧を考慮に入れなければ正しく構文解析する事ができない。
    (現状では構文解析が滅茶苦茶になるという事は無くて、
    単に括弧の開始部分と内部でエラーが発生するというだけであるが。)

    1 パラメータ展開内部・[[ ]] の == 右辺に関しては特別な扱いを考える必要はない。
    2 シェル単語及び case のパターン部分を解析する際には extglob
      を考えて入れ子構造を追う必要がある。
    3 実は現状でも突如として出て来る () の解釈をコマンド置換としてではなく、
      配列処理と同様のリストとして解釈する様にすれば見た目上の動作として充分かも知れない。
      もっとつめるとすれば !( @( などの組合せを正しく認識して、
      認識できない組合せになっている時にエラーを表示するという事である。

    配列のリストと同じようにしてみたがやはり動作としては異なる様な気がする。
    配列のリスト処理では単語分割まで実行するが、extglob の括弧の場合は、
    内部に単語などの構造はない。スペースがあったとしてもそのままスペースの文字として解釈される。
    更に <, > や ;, & 等のコマンド区切の文字も extglob 内部では通常文字として取り扱われる様だ。
    但し | は "または" の意味を持つ。
    (逆に言えば @() で quote できるという事にもなる?)

  * (ble-syntax:bash): bugfix: redirect 直後に redirect/delimiter があった時に解析データ書き込み違反。 [#D0313]
    具体的には echo <>& と入力した時にエラーになる (そもそも <>& というリダイレクトは存在しない)。
    解析に際し echo <> までは問題なく終了し、その後で & を読もうとした時にエラーになる。
    直前の redirect に対してエラー設置及び nest-pop を実行していた為であった。
    直前の redirect は既に解析が終わっているので、これに対して変更を行う事は出来ない。

    redirect を設置した時点で次に redirect/delimiter がないかチェックする様にしてみた。
    →問題なく動いている。しかし、エラーの設置位置にやはり違和感がある。
      エラーが設置されるべきは echo <>& の <> の方ではなくて、& の方ではないのか。
    →やはり & の方にエラーを設置する様に変更してみる。
      動いている…と思ったら何か変だ。カーソルの位置がジャンプする。
      変数がリークしているか?
      と思ったら単に正規表現テストの左辺を間違えている所為で
      インデックスの計算がおかしくなっていただけだった。
    →OK 動いている。

  * ble-syntax.sh: 正規表現の整理: rex_delimiters [#D0312]
    一回変数に入れてから適用しているがその必要はないのでは?

  整理 (自然解消した項目)

  * [2015-02-18] 履歴展開の微妙な所 [#D0311]

    例えば echo "!a" は !a の部分が履歴展開される。
    しかし echo !a" は !a" の部分が履歴展開される。
    これらの規則は一体どうなっているのだろう。man には大して何も書かれていない。

2015-12-23

  * ble-syntax:bash declare 配列初期化構文対応 [#D0310]

    > * [2015-02-16] ble-syntax.sh: local a=(arr) a+=
    >   これは declare や local typeset readonly 等を文法的に特別扱いしなければ対応できない

    色々試してみた所、以下のコマンドの引数で =() を特別扱いする様である。
      declare readonly typeset local export alias
    alias に関しては他のコマンドと全然性質が違う様な気がするし、
    export に関しては配列の初めの要素しか export されない気がするが、
    文法的には両者とも =() の形式を許容する様である。
    或いは、他にも同様の形式の引数を許容する組コマンドが存在するかもしれない。

    (少なくとも echo などの組み込みコマンドや、外部コマンドに関しては
    引数に =() 等という物が含まれていると失敗する。)

    [書き換え]

    > 取り敢えず、CTX_ARGX, CTX_ARGI という文脈を複製して、
      CTX_ARGVX, CTX_ARGVI という文脈を作成した。

    > [[:alpha:]_][[:alnum:]_]*\+?=() の形式の引数を許容する
      これは CTX_CMDX の辺りを真似すればよい。

    > 補完候補生成の種類を指定

    > その他ちゃんと動いているかのチェック。

  * ble-syntax:bash: assignment a=(1 2 3) 直後の文脈の変更 [#D0309]

    今迄、配列の代入文 a=(1 2 3) において、
    括弧を抜けた直後に次の単語に移る様に構成していた。
    (具体的には "(" を nest-push する直前に一旦単語を抜けてしまって、
    更に、ctx (nest-pop 時の文脈) として CTX_CMDXV を設定していた。)

    しかしながら実際の bash で試してみると、代入文の () の直後は
    やはり未だ代入文の右辺の続きとして取り扱われる様である。
    即ち、a=(1 2)b=123 と記述すると、
    a=(1 2) b=123 と解釈されるのではなくて、
    a='(1 2)b=123' と解釈される様である。

    bash の動作に合わせて "(" を nest-push する際は、
    単語をキャンセルしないし、また、nest-pop 時の文脈も敢えて変更はしない、
    という様に動作を変更する。

2015-12-21

  * ble-syntax:bash [#D0308]
    > a[算術式] の終了条件 (() pairs ではなくて [] pairs を数える)
    >   $((...)) ((...)) は () pairs で終了判定する。
    >   ${a[...]} a[...]= $[...] は [] pairs で終了判定する。
    >   ${v:...:...} は } が来たら無条件で終了する。

  * bash-3.0 で C-d が効かなくなっている。 [#D0307]

  * /dev/null に色が着いていない → つけた [#D0306]

  整理 (自然解消した項目)

  * [2015-02-16] ble-syntax:bash: 関数定義 function ... [#D0305]

  * [2015-02-16] ble-syntax:bash: Here string [#D0304]

  * [2015-02-16] ble-syntax:bash: aaa=(hoge), 他に aaa+=(hoge) というパターンもある。 [#D0303]

  * [2015-11-23] ble-detach 後の stty sane [#D0302]
    現在はユーザに stty sane を実行して貰っている。もっと綺麗な方法はないか?
    →保留する。これは今のままでも余り気にならないのでそのままで良い。

2015-12-20

  * ble-synta.sh: bug: 配列添字の書き換え時に syntax error [#D0301]

    以下の編集でエラーになる。
    $ a['']=
    $ a['a']=

    | assertion failure: ((nofs<${#node[@]}))
    | ble-syntax/tree-enumerate/.impl(i=5,iN=7,nofs=0,node=,command=ble-highlight-layer:syntax/word/.proc-childnode)/FATAL1
    |   @ /home/murase/prog/ble/ble.sh:10 (ble-assert)
    |   @ /home/murase/prog/ble/ble.sh:4 (ble-syntax/tree-enumerate/.impl)
    |   @ /home/murase/prog/ble/ble.sh:164 (ble-syntax/tree-enumerate-children)
    |   @ /home/murase/prog/ble/ble.sh:472 (ble-highlight-layer:syntax/update-word-table)
    |   @ /home/murase/prog/ble/ble.sh:-135 (ble-highlight-layer:syntax/update)
    |   @ /home/murase/prog/ble/ble.sh:4380 (ble-highlight-layer/update)
    |   @ /home/murase/prog/ble/ble.sh:4884 (.ble-line-text/update)
    |   @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
    |   @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
    |   @ /home/murase/prog/ble/ble.sh:966 (ble-edit/bind/.tail)
    |   @ /home/murase/prog/ble/ble.sh:-4230 (ble-decode-byte:bind/EPILOGUE)
    |   @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)
    | assertion failure: ((nofs<${#node[@]}))te_mode_buff='()'$
    | ble-syntax/tree-enumerate/.impl(i=5,iN=7,nofs=0,node=,command=ble-syntax/print-status/.dump-tree/proc1)/FATAL1
    |   @ /home/murase/prog/ble/ble.sh:10 (ble-assert)
    |   @ /home/murase/prog/ble/ble.sh:4 (ble-syntax/tree-enumerate/.impl)
    |   @ /home/murase/prog/ble/ble.sh:2 (ble-syntax/tree-enumerate-children)
    |   @ /home/murase/prog/ble/ble.sh:7614 (ble-syntax/print-status/.dump-tree/proc1)
    |   @ /home/murase/prog/ble/ble.sh:108 (ble-syntax/tree-enumerate/.impl)
    |   @ /home/murase/prog/ble/ble.sh:5 (ble-syntax/tree-enumerate)
    |   @ /home/murase/prog/ble/ble.sh:8005 (ble-syntax/print-status/.dump-tree)
    |   @ /home/murase/prog/ble/ble.sh:-24 (ble-syntax/print-status)
    |   @ /home/murase/prog/ble/ble.sh:-135 (ble-highlight-layer:syntax/update)
    |   @ /home/murase/prog/ble/ble.sh:4380 (ble-highlight-layer/update)
    |   @ /home/murase/prog/ble/ble.sh:4884 (.ble-line-text/update)
    |   @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
    |   @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
    |   @ /home/murase/prog/ble/ble.sh:966 (ble-edit/bind/.tail)
    |   @ /home/murase/prog/ble/ble.sh:-4230 (ble-decode-byte:bind/EPILOGUE)
    |   @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)
    |
    | 異常
    | A?
    |  7 a    000 'a' | stat=(1 w=- n=- t=-1:-1)
    |  8 a    001 '[' | nest=(11 w=7:0- n=- t=-1:-1)
    |  9*a    002 ''' | stat=(8 w=- n=@1 t=-1:-1)
    |  5*a    003 'a' |
    |  9*a    004 ''' |
    |  8 a  s 005 ']' | stat=(8 w=- n=@1 t=-1:-1)
    |  | a  s 006 '=' + word=7:0-7>@4
    | \_ 'a['a']='
    |
    | 正常
    | A?
    |  7*a    000 'a' |  stat=(1 w=- n=- t=-1:-1)
    |  8*a    001 '[' || nest=(11 w=7:0- n=- t=-1:-1)
    |  9*a    002 ''' || stat=(8 w=- n=@1 t=-1:-1)
    |  5*a    003 'a' ||
    |  9*a    004 ''' |+ word=na[:1-5
    |  8*a    005 ']' |  stat=(8 w=- n=@1 t=-1:-1)
    |  |*a    006 '=' +  word=7:0-7>@4
    | \_ 'a['a']='
    |     \_ '['a''


    設置されている筈の単語が存在しないという所にある。
    というかそもそも単語の設置位置が変な気もする。
    単語は終了が判明した時点でその前の点に設置する物だったろうか?
    良く分からなくなってきた。配列の添字の終了点での処理について再度確認する。

    どうやら nest-pop をする時に i を進めた後に nest-pop するか、
    i を進める前に nest-pop するかの違いのようだ。
    調べてみると、a[...]= の時以外の nest-pop に関しては全て i を増加させた後に nest-pop を指定している。
    nest-pop は更に tree-append を呼び出している。tree-append は [i-1] に情報を格納している。
    つまり、tree-append 自体 i を進めた後にしか呼び出してはいけない物になっている。
    この辺りの注意書きは何処にも書かれていない。

    [tree-append/nest-pop/word-pop 呼出条件確認]

    実際に _ble_syntax_tree 等の使用時の条件と、tree-append の内部動作を見るに、
    tree-append/nest-pop/word-pop の呼出条件は以下のようになる:

      解析開始点を p1 とする。現在の位置を i とする。tree-append/nest-pop は i >= p1+1 の時にだけ呼び出して良い。

    この注意点を _ble_syntax_tree の制限の部分に書き加える。
    また、tree-append/nest-pop/word-pop のそれぞれの関数の注意書き (要件) にも記す。
    更に tree-append 内部にチェック用のコードを導入する事にした。

    [既存コードの check]
    さて似たような誤りを他の箇所でも犯していないか確認する必要がある。

    基本的には check-word-end の中では必ず i が進んでいる筈なので tree-append を呼び出しても nest-pop を呼び出しても問題ない。
    一方で、実際の解析部分では tree-append もしくは nest-pop は注意して呼び出す必要がある。
    nest-pop に関しては類似の呼出箇所で問題がないか確認した。
    tree-append を確認した所 word-pop と nest-pop だけからしか呼び出されていない。
    word-pop に関しても調べてみたが全ての箇所で i を進めてからの呼出になっていた。

  * ble-edit: [[ ! -o history ]] の時は履歴に登録しない。 [#D0300]

  * ble-syntax.sh: rex_redirect を何処かに共有する。 [#D0299]

    rex_redirect -> _ble_syntax_bash_rex_redirect.

  * ble-syntax.sh (ble-syntax:bash): < check [#D0298]

  * ble-syntax.sh (ble-syntax:bash): <>| や &>| はどうなっているのか? [#D0297]
    →試してみたが <>| や &>| は存在しない様だ。
      set -C の時に上書きできるのは >| だけという事になる。

    一方で <> は set -C でも普通に実行できている様な気がする。何故だ。
    多分 < として開かれるという事で書き込みはできないが読み取りはできるという事なのだろう。

  * [2015-06-28] complete: HOGE= の直後の編集でファイル名などを補完候補として出して欲しい [#D0296]

    →これが出てこない理由は二つあった。
    1 一つは HOGE= 直後の状態 CTX_VRHS について check-here でのチェックを行っていなかった事。
    2 もう一つの理由は check-prefix で候補が存在した場合には check-here を行っていない事。
      HOGE= の直後にカーソルがある時、候補生成として HOGE= を用いたコマンド補完も試みられる。
      その為に既に check-prefix で候補生成が設定されているという事になりその場での補完が有効にならないのだ。

      もともとこの仕組みは単語中で単語開始の補完が実行されない様にする為の物であった。
      例えば CTX_CMDI の場合には既にコマンドや単語の中にいるという事が分かっているので
      必ず check-prefix で実行しなければならないという事が分かるが、
      CTX_CMDX CTX_ARGX 等の場合には、その場で単語を開始するべきか一旦スペースを挟むべきか分からない。
      →本当か? 直後に単語を構成する文字が存在するかどうかで判定できるのではないか?
      a 例えば単語を構成する文字がない場合にはそので直前の単語が終了して次の単語を希望する状態であるから、
        そこからいきなり次の単語を挿入するというのはおかしい。直前の単語の続きとするべきである。
      b 一方で、直後に単語を構成する文字が存在するのであれば…そこで丁度単語が開始しているという事なので、
        新しい単語を其処に挿入するのは問題ないだろう。
      c もし直後に文字が何も存在しない場合は、そこに何か空白などを追加するべきなのか、
        それとも新しい単語をその箇所で初めて良いのか分からない。

      結局の所、その箇所から新しい単語が始まるかどうかを判定するには prefix を調べて、
      その続きとして挿入できそうならばそうするし、そうでなければ新しい単語の開始として処理するしかない。
      まさに現在の構造はそうなっている。
      そして単語の途中で節がある場合には、そこから新しい補完候補の生成が必要になるが、
      現在の実装ではそういう状況は check-prefix の中で処理されている。
      例えば単語中に = があった場合などにその続きから候補生成が実行されている。
      やはりそれがどういう節なのかという事は prefix を見ているから分かるのである。

    →check-prefix に書き加える事で VAR= の続きの候補生成を実装する事にした。
      丁度 VA から変数名 VAR に補完する部分があったので其処に追加・修正する形にする。

    また同時に RDRF や RDRS の時にも候補が生成できる様にする。

  * [2015-08-11] complete: コマンドの補完で現在のディレクトリにあるサブディレクトリも候補に入れる。 [#D0295]

  * [2015-11-25] complete: bug 単語と単語の間で補完が効かない。 [#D0294]

    →単語と単語の間の空白の位置で TAB を押しても補完候補が生成されなかった。
      これは前の単語の終端位置から次の単語が始まっていると認識されて、
      空白で始まるファイル名を検索していたからであった。

2015-12-19

  * [2015-12-12] complete FIGNORE に対応 [#D0293]

  * ble-syntax.sh: 現在の実装ではリダイレクトの直後に改行が来る事を許している。 [#D0292]

  * ble-syntax.sh: リダイレクト先 ディレクトリチェック・上書きチェック [#D0291]

    →この着色は単語の着色時に行うのが良い。それより前に着色を行ったとしても、
    工夫をしないと単語の着色時に上書きされてしまうからである。
    しかし単語の着色時にはリダイレクトに使用した演算子の情報が消失している。

    リダイレクトに使用した演算子を取得する為には、
    木情報を辿るか、或いは、自分で直前部分を読み取って抽出するかである。
    自分で直前部分を読み取る方法は ad hoc には良いが、
    実際に構築された木と独立な解析なので齟齬が生じるかも知れないし、
    またデバグという観点からも独立な解析が二つ存在するのは好ましくない。
    なので、取り敢えずは木情報を辿る方針で考えてみる事にする。

    木情報がどうなっているかは改めて ble_debug=1 等で確認する。
    →確認してみると親 word の wtype に "n..." という形で格納されている。
      現在着色は tree-enumerate-in-range を用いて行われている。
      子ノードから親ノードの情報を取得するのは面倒そうである。
      そもそも _ble_syntax_word のデータ構造からして子には親の情報が含まれていない。
      tree-enumerate-in-range は木を辿って列挙している訳ではないので、
      呼出の過程で適当に情報を記録して、という方法も使えない。

    しかし乍ら、リダイレクトの場合にはファイル名の終端と同じ位置に
    親ノードが設置されている (同じ位置でリダイレクトのネストが閉じる) と期待できる。
    リダイレクトのファイル名とリダイレクトが同じ位置で終了するという
    仮定の下に実装してしまって良いのではないだろうか。

  * ble-edit.sh (ble/widget/command-help): less は POSIX ではないが、チェックを行っていない。 [#D0290]

    →less がない場合は more または cat を使う様に変更。

  * [2015-12-19] ble-syntax.sh: <<< を順に入力すると文法エラーになる。 [#D0289]

    これは見てみた所 << と入力した時点で駄目になっている。
    << に対応する文法要素がない (ヒアドキュメントは未実装) 為に、
    < + < と解釈されて解析再開点が二箇所設定されている為である。
    しかしながら <<< に対応する以上、
    << が二回来た段階では一つ目の < で解析結果を確定させては成らない。

    << も受け付ける様にして、単語を受け取ることができる様にする。

  * POSIX コマンドについて全て必ず用意されている物かどうか確認する。 [#D0288]
    POSIX の utilities に載っていたとしても optional だったり deprecated だったりするかもしれないので。
    →tput は UP option だった。しかし ble.sh の動作に必ず必要という訳でもないのでチェックから外す。

  * date の使い方が POSIX じゃない。 [#D0287]

    %N に対応しているとは限らない。
    -r filename に対応しているとは限らない。
    特に -r filename に関しては問題である。
    調べてみると date ではなく stat を用いた方法が紹介されている。

    →stat を使った date に対応する。
    →%N に関しては対応していない場合は単に '%N' がそのまま出力されるだけなので気にしない。

  * [2015-12-16] パラメータ展開の中で '' single quote が効かない。 [#D0286]

    パラメータ展開の中で '' や $'', $"" 等の quote をどの様に解釈するかは
    そのパラメータ展開自体がどの様な環境にあるかに依存している。
    パラメータ展開の親が何かの情報を取得してそれを元にして動作を変更する必要がある。

    [動作確定]

    動作に関して:
      '' に関してはパラメータ展開の親が "" の中であればそのまま "''" という文字列として解釈される。
      パラメータ展開の親がコマンドの文脈である時は qoute として扱われ、除去の対象となる。

    extquote -s の時 (既定) は、
      パラメータ展開の親が "" の中にあったとしても、
      $'' や $"" を qoute として解釈し qoute 除去が行われる。

    "" に関しては extquote に関係なく、また、
    パラメータ展開が "" の中にあるか外にあるかに拘わらず
    常に quote として取り扱われる様です。

    何か良く分からなくなってきたので表にする。

          "" の外   "" の中(-s extqoute)  "" の中(-u extqoute)
    ----  --------  --------------------  --------------------
    ''    有効      無効                  無効
    ""    有効      有効                  有効
    $''   有効      有効                  無効
    $""   有効      有効                  無効 (空白になる?)


    [実装方法]

    a 先ずはパラメータ展開の文脈の際に親の文脈を取得する所から始まる。
      ネスト構造を辿れば現在のパラメータ展開がどの様な文脈の下にあるのかという情報を取得できる筈である。
      但し、毎回ネスト構造を遡るというのも効率などの観点からどうだろうという事もある。
      とはいいつつも、' や $' $" に当たった時にだけネスト構造を辿れば良いのだからそんなに重くもならないだろう。

    b 或いはパラメータ展開が開始する時点で異なる文脈として扱うという方法でも良い。
      現在文脈は CTX_PARAM, CTX_PWORD である。動作が異なるのは CTX_PWORD の方である。
      パラメータ展開が開始する時点で文脈を指定しようと思ったら
      CTX_PARAM2, CTX_PWORD2 の二種類を用意する必要があり、管理が面倒である。

    c もう一つの方法はパラメータ展開のネストを開始する時の、<ネストの種類の文字列> を使って区別する方法である。
      現在は '${' を用いているが、例えばそれに加えて '"${' を用いるなど。
      ネストの種類の文字列は ble-syntax/parse/nest-type -v type でいつでも取得できる。
      またパラメータ展開の開始は ble-syntax:bash/check-dollar の中で以下の様にして実行される。
      ble-syntax/parse/nest-push "$CTX_PARAM" '${'
      従って (1) この部分の '${' を現在いる文脈に応じて変更する様に書き換えて、
      (2) check-qoutes において ble-syntax/parse/nest-type を用いてこの文字列を取得して
      quote が有効かどうかを判定するという形になるだろう。

    ここでは c の方法を採用する事にする。

  * [2015-12-12] ble-syntax.sh: extquote off に対応 [#D0285]

  整理 (過去の修正によって解決済の物)

  * [2015-06-28] complete: <bug> HOGE=aa| の状態で TAB を押すと滅茶苦茶沢山のコマンドが表示される [#D0284]

  * [2013-06-06] complete: 空白文字や " や ' などをエスケープしている時も正しく単語分割する [#D0283]

2015-12-12

  * 起動チェック: bash の現在の設定を取得する方法に関して [#D0282]

    起動チェック: set -o posix を確かめる方法?
    → POSIXLY_CORRECT=y か空欄かで判定する事ができる。
    → [[ -o posix ]] で OK. ただ、POSIX の時に [[ -o optname ]] が有効なのかは不明。
      試すと動くから POSIX でも bash 固有の機能は相変わらず使えるのだろう。

    a 既存の物については速度測定をして速い方法に移行する。

      [[ $- == *H* ]] は [[ -o histexpand ]] の方が早いようだ。しかも分かり易い。

      % shopt -q は $BASHOPTS を用いた物の方が早い方である。
      % しかし読みにくいのは問題だ。$BASHOPTS を使用して判定する為の関数を定義してしまっても良い気がする。
      shopt は >/dev/null にリダイレクトする必要はない。リダイレクトしなければ速い。

    b set -o に関しては?

      % set -o posix    -> [[ $POSIXLY_CORRECT ]]
      %   Note: set -o posix の時は POSIXLY_CORRECT=y になっている。
      %   set +o posix の時は POSIXLY_CORRECT は unset になっている。
      %
      % set -o ignoreeof -> [[ $IGNOREEOF == 10 ]]
      %   これは実行すると実際に IGNOREEOF=10 が設定されるので問題ない。
      %
      % set -o pipefail -> false | :
      %   これは false | : で判断できるが fork が入るので遅いかも。
      %
      % set -o emacs
      % set -o vi
      % bash --noediting
      % EMACS=t bash
      %   → EMACS=t に関しては環境変数を介して判定できるが、
      %   それ以外の方法による行編集機能の有効・無効・デフォルトキーマップは判断不能?
      %
      %
      %   候補 bind
      %     一応行編集機能が有効になっているかどうかは bind がエラーメッセージを出すかどうかで判断できる?
      %     しかし bind の返却値は常に 0 の様だ (エラーメッセージを出力するだけ)。
      %
      %   候補 set +o emacs && set -o emacs
      %   候補 set +o vi && set -o vi
      %     これら (set +o emacs, vi) は訳に立たない。
      %     既にその設定になっているかどうかに拘わらず常に成功する様だ。
      %
      % set -o history
      %   これの判定方法は全く不明だ。
      %
      %   候補 history
      %     常に成功する。動作も変わらない様だ。

      と思ったら set に関しては全て [[ -o option-name ]] で判定できるのであった。

      起動オプション → [[ -o name ]] または [[ $- == *X* ]]
      set → [[ -o option-name ]]
      shopt → shopt -q optname

  * LANG だけでいいのか? LC_ALL は? [#D0281]

    LANG=... を使っているのは read -t 0 のチェック部分と、
    初期化の command awk の呼出の部分だけである。

    結局以下の bash-4.0 未満のコードは使われていない上に、
    仮に動いてしまったとしても問題点もある(?)ので削除する事にする。
    何れにしても bash-4.0 未満ではこの方法では、
    入力が溜まっている事を検知することはできないので削除するのが良い。

    | # x 以下は bind '"\e[":"\xC0\x9B["' による
    | #   byte の受信順序が乱れるので使えない。
    | # x bash-4.0 未満では結局以下では何も起こらない。
    | #   read -t 0 としても必ず失敗する様である。
    | local byte=0
    | while IFS= LC_ALL=C read -t 0 -s -r -d '' -n 1 byte; do
    |   LC_ALL=C ble-text.s2c -v byte "$byte" 0
    |   "ble-decode-byte+$bleopt_input_encoding" "$byte"
    | done

  [過去の ToDo の整理]

  * ble-bind の説明を追加 [#D0280]

  * cat 置き換え [#D0279]

  * [2015-11-06] isearch-forward/backward で現在の一致範囲をハイライトする。 [#D0278]

  * [2015-03-06] complete の古いコード [#D0277]

    →これは誰からも使われていない古い関数達を削除した。please, see commit log.

  * [2015-03-06] binder-source 周辺 [#D0276]

  * [2015-02-27] complete: 既存の bash complete に対応する。 [#D0275]

  * [2015-02-25] isearch-forward/backward の動作 [#D0274]

    気付いたのだが bash では isearch-forward/backward は各ヒストリ項目に対して一致しているのではなく、
    ヒストリ項目の中にある文字列に対して一致している様だ。
    つまり、複数の一致が一つのコマンドラインの中にあれば、
    その中を C-r C-s で移動していく事になる。
    そればかりか現在編集している文字列の中で一致する物についてもちゃんと移動できる。。

  * [2013-06-06] complete: complete -F に対する対応 [#D0273]

  * [2013-06-06] complete: コマンド先頭位置の検出 (複合文の途中からコマンドが始まっている場合など) [#D0272]

  * [2013-06-05] ^U ^V ^W ^? bind 関連 [#D0271]
    + 説明書にその事を書いておく。
    + ^U ^V ^W ^? を bind するより良い方法があれば考える
    + bashrc の中でも同様に問題が起こるのか?

    + 一旦 bind '"":"hogehoge"' 等として変換したら受信できる可能性?

    2015-12-12 →これは現在何も問題が起こっていない気がするので完了済と解釈する。

  * [2013-06-04] vbell .time の置き場所を変更? [#D0270]

    2015-12-12 →一時ファイルは現在は $_ble_base_tmp を介して統一的に取り扱う事になっている。
      もし置き場所を整理するとすれば $_ble_base_tmp 自体を変更する事になるが、
      現在の実装で満足しているので、現在の所変更の予定はない。

  * [2013-06-01 以前] 編集文字列の表示 [#D0269]
    + スタイル指定文字列
    + color fall backs
    + forward-char
    + goto-char
    + insert-string
    + insert-char

    2015-12-12 → これらの ToDo 項目が元々何を意図していたのか良く分からないが、
      スタイル指定文字列は gspec として実装してあるし、
      編集関数 goto-char, forward-char, insert-string, insert-char は実装済である。
      編集関数と編集文字列の「表示」にどの様な関係があるのかは不明。

2015-12-05

  * ble-bind -L, ble-bind --list-edit-functions [#D0268]
    declare -f | sed -n -r 's/^ble-edit\+([[:alpha:]][^[:space:]();&|]+) \(\)[[:space:]]*$/\1/p'

  * v0.1-master: release=1 で更新、release 登録する [#D0267]

  * download/git clone 順序入れ替え [#D0266]

  * 日本語 README.md [#D0265]

2015-12-03

  * また遅くなってきたので初期化の速度について再確認する? [#D0264]

                    時間      行数  最適化後  以前の記録
    ble-core.sh     0m0.023s   605  0m0.013s  0.002s
    ble-decode.sh   0m0.010s  1632  0m0.010s  0.008s
    ble-color.sh    0m0.006s  1034  0m0.002s  0.003s
    ble-edit.sh     0m0.009s  4204  0m0.009s  0.007s
    ble-syntax.sh   0m0.031s  2944  0m0.006s  0.019s
    ble-initialize  0m0.015s        0m0.014s
    合計            0m0.094s        0m0.054s

    ble.sh parse                    0m0.105s
    ble-attach                      0m0.088s

    行数から考えるに ble-syntax.sh は ble-edit.sh に較べて load に時間が掛かりすぎる。
    ble-core.sh についても意外に時間が掛かっている。

    ble-core.sh については _ble_base_tmp.wipe を弄ると 3ms になるので、
    悪いのは各ファイルについてプロセス生死判定を行っている事にある。
    → kill -0 を消しても 25ms のままだった。
    より詳細に _ble_base_tmp.wipe の中を調べる。

    - ファイル列挙        = 4ms (7ms)
    - ファイル名存在確認  = 0ms (7ms)
    - ファイル名形式検査  = 15ms (22ms)
    - プロセス生死判定    = 3ms (25ms)

    どうも正規表現の判定に結構時間が掛かっている様子だった。
    正規表現はそんなに重くないのだと思っていたがやはり重いのか。
    (最初のコンパイルに時間が掛かるが、それ以降は内部で再利用される?)
    何れにしても正規表現を止めてパラメータ展開を用いて pid を抽出する様に変更したら
    全体で 23ms かかっていたのが 12ms 程度まで減少した。
    ble-core.sh の他の箇所は 3ms 程度しか掛かっていないので気にしても仕方がない。

    ble-syntax.sh についても見る事にする。
    殆ど関数定義と変数・配列への代入しかないのにと思ってみると
    関数 _ble_syntax_attr2iface.define, ble-color-defface を大量に呼び出している箇所がある。
    この部分を削除してみると 5ms にまで縮まる。
    特に ble-color-defface で 25ms 程度使っている様で、
    _ble_syntax_attr2iface.define に関しては 2ms しか使っていない様子である。

    どのタイミングで色が必要とされるかに依るかも知れないが、
    例えば色の初期化について遅延を行うとどうだろうか。
    調べてみると幸いに _ble_faces 系統の変数を直接操作しているはごくごく一部である。
    →遅延初期化にしてみた…が、結局最後にプロンプトを表示する時に初期化が必要??
    →調べてみた所 ble-highlight-layer:syntax/update-error-table において
      中身がなくても g (syntax_error) の初期化を行っていた。これを省略すれば良い。

    と思ったら一番時間が掛かっているのは ble-attach だった。
    しかしながら ble とは関係ない部分でもっと時間が掛かっている様にも見える。
    .bashrc の方を調べた。全体で 0.513 かかっている。内訳は:
    - ble.sh        160ms
    - ble-attach     88ms
    - .mwg/bashrc    95ms
    - /etc/bashrc   155ms
    - 残り           15ms

    あれ。変だ。ble.sh が結局 160+88 = 248ms も使っている。
    ble.sh 自身の計測だと 54+88ms しか使わないはずなのに。
    →どうやら parse に時間が掛かっている様だ。
      bash は先にファイル全体を parse して、その後で実行をしているのではないか。
      短いファイルの場合は 100ms も待たされないのでファイルを開くだけでそんなに時間が掛かるとは考えがたい。
      また、ble.sh の先頭で非自明な return を実行する場合でも 100ms 待たされるので、
      実際に実行しようが実行しまいがファイルの長さに依存した解析を実行するという事になる。
      (return の位置で 100ms 待たされなかったりする。
        もしかすると {} で囲まれた単位で parse を実行しているという事だろうか。
        そうだとするとスクリプト実行中にファイルを書き換えた時に変な事になるのも合点が行く。)
      そう考えると ({} が登場する毎に散発的に為される) parse に合計で 105ms かかっている。
      つまり 100 行あたり 1ms つかっている計算になる。

    うーん。これは仕様がない。
    遅延ロードするばかりでなく遅延部分を外部に分離すれば parse 時間も短くなるかもしれないが、
    そもそも遅延部分でそんなに行数を食っている物は少ない。
    あるとすれば ble-edit の編集関数を遅延ロードにするぐらいだろうか。
    と思ったが ble-edit のプロンプト構築や座標計算部分は省略できないし、
    やはり頑張ってもそんなに初期化時間を稼ぐ事は出来ない気がする。
    調べてみるとやはり編集関数は2000行程度である。その他の部分は基本的な部分である。
    これでは 20ms 程度しか稼げない。

    後、コメントが 2000 行程度あった。しかしコメント 2000 行程度にそんなに解析時間が掛かるとも思えない。
    →と思って計測したら 25ms もかかる。そもそもコメントには日本語も多くデータ量が元から多い。その事が原因か?
    しかしながら 25ms でも全体 250ms の 10% に過ぎない。そんなに体感は変わらないだろう。

    まあ、取り敢えずこれはこれで良しとする。

  * ble-syntax/parse/nest-equals bug [#D0263]

    + bug (2015-12-03) まただ

      C-d で以下の様に書き換えを行おうとしたらなる。
      $ function () () { echo hello; }
      $ function () { echo hello; }

      stackdump: invalid nest
        @ /home/murase/prog/ble/ble.sh:1480 (ble-syntax/parse/nest-equals)
        @ /home/murase/prog/ble/ble.sh:-16 (ble-syntax/parse)
        @ /home/murase/prog/ble/ble.sh:4 (_ble_edit_str.update-syntax)
        @ /home/murase/prog/ble/ble.sh:2583 (ble-highlight-layer:syntax/update)
        @ /home/murase/prog/ble/ble.sh:4292 (ble-highlight-layer/update)
        @ /home/murase/prog/ble/ble.sh:4844 (.ble-line-text/update)
        @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
        @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
        @ /home/murase/prog/ble/ble.sh:1140 (.ble-decode-byte:bind/tail)
        @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)

    これは今丁度直した所の直し方が甘かった所為で余計に変な事になっていただけだった。
    すぐに直した。そんなに問題はない。

  * 構文解析部分更新の bug [#D0262]

    + bug (2015-12-02)

      また出た。今度は

      $ echo a "$(echo b "$(echo c "$(echo d "$(echo e "$(echo f)")")")")"

      を

      $ echo "a $(echo "b $(echo c "$(echo d "$(echo e "$(echo f)")")")")"

      に書き換える過程で起きた。これは 11-28 のケースと状況が似ている。


    + bug (2015-11-28b)

      ble-assert

        "$f" --date="$(date +'%F %T %Z' -r "$f")"
        "${f}" --date="$(date +'%F %T %Z' -r "$f")"

      の過程でエラー。最小化:

        echo "$f" "$(B 'D' "$f")"
        echo "${f" "$(B 'D' "$f")" <- この時点でエラーになっている。(ble_debug= だと次の入力で明らかになるが。)
        echo "${f}" "$(B 'D' "$f")"

    先ず第一に ble_debug=1 が設定されているかされていないかでエラーが表示されるタイミングが異なる。
    しかしこれは単にチェックのタイミングの問題である事は以前のバグ取りの時に分かっている。
    ble_debug=1 が設定されていると現在の状態を表示する為に、その場で構文木の構造を辿る。
    その際にエラーが存在している事が即座に検知されるという訳である。
    一方で ble_debug= になっている場合にはその場で構文木を辿らないので後になってエラーが発生している事が分かる。
    従って ble_debug=1 の時のエラーを先ず見るのが自然である。

    エラーメッセージ

    | ble-syntax/tree-enumerate/.impl(i=10,iN=26,nofs=0,node=,command=ble-syntax/print-status/.dump-tree/proc1)/FATAL1
    |   @ /home/murase/prog/ble/ble.sh:7685 (ble-assert)
    |   @ /home/murase/prog/ble/ble.sh:108 (ble-syntax/tree-enumerate/.impl)
    |   @ /home/murase/prog/ble/ble.sh:5 (ble-syntax/tree-enumerate)
    |   @ /home/murase/prog/ble/ble.sh:8034 (ble-syntax/print-status/.dump-tree)
    |   @ /home/murase/prog/ble/ble.sh:8264 (ble-syntax/print-status)
    |   @ /home/murase/prog/ble/ble.sh:-135 (ble-highlight-layer:syntax/update)
    |   @ /home/murase/prog/ble/ble.sh:4290 (ble-highlight-layer/update)
    |   @ /home/murase/prog/ble/ble.sh:4842 (.ble-line-text/update)
    |   @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)=(5 w=- n=@5 t=-1:-1)
    |   @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
    |   @ /home/murase/prog/ble/ble.sh:1130 (.ble-decode-byte:bind/tail)t=1:-1)
    |   @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)t=(5 w=- n=@10 t=-1:-1)

    +-------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------+
    | エラー状態                                                                                | 正常状態                                                                               |
    +-------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------+
    | A?                                                                                        | A?                                                                                     |
    |  2 aw   000 'e' |     stat=(1 w=- n=- t=-1:-1)                                            |  2 aw   000 'e' |   stat=(1 w=- n=- t=-1:-1)                                           |
    |  | aw   001 'c' |                                                                         |  | aw   001 'c' |                                                                      |
    |  | aw   002 'h' |                                                                         |  | aw   002 'h' |                                                                      |
    |  | aw   003 'o' +     word=2:0-4                                                          |  | aw   003 'o' +   word=2:0-4                                                         |
    |  3 a    004 ' '                                                                           |  3 a    004 ' '                                                                        |
    |  9 a    005 '"'       nest=(4 w=4:5- n=- t=-1:1) stat=(3 w=- n=- t=1:-1)                  |  9 a e  005 '"'     nest=(4 w=4:5- n=- t=-1:1) stat=(3 w=- n=- t=1:-1)                 |
    | 14*a    006 '$'       nest=(5 w=- n='${':5- t=-1:-1) stat=(5 w=- n=@5 t=-1:-1)            | 14 a e  006 '$'     nest=(5 w=- n='${':5- t=-1:-1) stat=(5 w=- n=@5 t=-1:-1)           |
    |  |*a    007 '{'                                                                           |  | a e  007 '{'                                                                        |
    |  7*a    008 'f'                                                                           |  7 a    008 'f'                                                                        |
    |  9*a    009 '"'       stat=(14 w=- n=@6 t=-1:-1)                                          |  9 a    009 '"'     stat=(14 w=- n=@6 t=-1:-1)                                         |
    |  5*a  s 010 ' '                                                                           |  5 a    010 ' '                                                                        |
    |  9*a  s 011 '"' ||                                                                        |  9 a    011 '"'                                                                        |
    | 14*a    012 '$' |||   nest=(15 w=- n='$(':6- t=-1:-1) stat=(15 w=- n=@6 t=-1:-1)          | 14 a    012 '$' |   nest=(15 w=- n='$(':6- t=-1:-1) stat=(15 w=- n=@6 t=-1:-1)         |
    |  |*a    013 '(' |||                                                                       |  | a    013 '(' |                                                                      |
    |  2*aw   014 'B' |||+  word=2:14-15 stat=(1 w=- n=@12 t=-1:-1)                             |  2 aw   014 'B' |+  word=2:14-15 stat=(1 w=- n=@12 t=-1:-1)                            |
    |  3*a    015 ' ' |||                                                                       |  3 a    015 ' ' |                                                                      |
    |  9*a    016 ''' ||||  stat=(3 w=- n=@12 t=1:-1)                                           |  9 a    016 ''' ||  stat=(3 w=- n=@12 t=1:-1)                                          |
    |  5*a    017 'D' ||||                                                                      |  5 a    017 'D' ||                                                                     |
    |  9*a    018 ''' |||+  word=4:@14>16-19                                                    |  9 a    018 ''' |+  word=4:@14>16-19                                                   |
    |  3*a    019 ' ' |||   stat=(3 w=- n=@12 t=0:-1)                                           |  3 a    019 ' ' |   stat=(3 w=- n=@12 t=0:-1)                                          |
    |  9*a    020 '"' ||||| nest=(4 w=4:20- n='none':12- t=-1:1) stat=(3 w=- n=@12 t=1:-1)      |  9 a    020 '"' ||| nest=(4 w=4:20- n='none':12- t=-1:1) stat=(3 w=- n=@12 t=1:-1)     |
    | 14 a    021 '$' ||||| stat=(5 w=- n=@20 t=-1:-1)                                          | 14 a    021 '$' ||| stat=(5 w=- n=@20 t=-1:-1)                                         |
    |  7 a    022 'f' |||||                                                                     |  7 a    022 'f' |||                                                                    |
    |  9 a    023 '"' |||++ word=4:@18>20-24>@23 word=nnone:20-24 stat=(5 w=- n=@20 t=-1:-1)    |  9 a    023 '"' |++ word=4:@18>20-24>@23 word=nnone:20-24 stat=(5 w=- n=@20 t=-1:-1)   |
    | 14 a    024 ')' ||+   word=n$(:12-25>@23 stat=(3 w=- n=@12 t=0:-1)                        | 14 a    024 ')' +   word=n$(:12-25>@23 stat=(3 w=- n=@12 t=0:-1)                       |
    |  9 a    025 '"' ++    word=4:@9>11-26>@25 word=nnone:11-26>@24 stat=(5 w=- n=@11 t=0:-1)  |  6 a e  025 '"'     nest=(15 w=- n='none':6- t=0:-1) stat=(15 w=- n=@6 t=0:-1)         |
    | \_ '"$(B 'D' "$f")"'                                                                      | \_ 'echo'                                                                              |
    |     \_ '"$(B 'D' "$f")"'                                                                  | \_ '"${f" "$(B 'D' "$f")"'                                                             |
    |         \_ '$(B 'D' "$f")'                                                                |     \_ '"${f" "$(B 'D' "$f")"'                                                         |
    |             \_ 'B'                                                                        |         \_ '${f" "$(B 'D' "$f")"'                                                      |
    |             \_ ''D''                                                                      |             \_ '$(B 'D' "$f")'                                                         |
    |             \_ '"$f"'                                                                     |             |   \_ 'B'                                                                 |
    |                 \_ '"$f"'                                                                 |             |   \_ ''D''                                                               |
    |                                                                                           |             |   \_ '"$f"'                                                              |
    |                                                                                           |             |       \_ '"$f"'                                                          |
    |                                                                                           |             \_ '"'                                                                     |
    +-------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------+

    状態の差分

    | --- a.txt       2015-12-03 05:12:49.627927314 +0900
    | +++ b.txt       2015-12-03 05:12:55.499708773 +0900
    | @@ -1,4 +1,4 @@
    | -正常状態
    | +エラー状態
    |  000 'e' stat=(1 w=- n=- t=-1:-1)
    |  001 'c'
    |  002 'h'
    | @@ -24,4 +24,4 @@
    |  022 'f'
    |  023 '"' word=4:@18>20-24>@23 word=nnone:20-24 stat=(5 w=- n=@20 t=-1:-1)
    |  024 ')' word=n$(:12-25>@23 stat=(3 w=- n=@12 t=0:-1)
    | -025 '"' nest=(15 w=- n='none':6- t=0:-1) stat=(15 w=- n=@6 t=0:-1)
    | +025 '"' word=4:@9>11-26>@25 word=nnone:11-26>@24 stat=(5 w=- n=@11 t=0:-1)

    これを見ると最後の状態が異なるだけの様である。
    解析中断点は 020 にあるが 020 までの状態は完全に同じである。
    %%という事は解析の状態は完全に一致している筈なのでその後の解析も同じでなければならない?%%
    と思ったが、解析状態の際に比較するのは (現在の状態 vs 正しいと想定される状態) ではなくて、
    (現在の状態 vs 前回までに解析した状態) であるのでここでは関係ないはずである。
    この結果から言える事は、

    a shift に失敗している
    b 解析の中断の判定に失敗している
    c または解析途中状態が同じで以降の文字列が同じだったとしても最終的な解析結果に違いが出る可能性がある

    のどちらかという事になる。今迄の経験から行くと初めに a, b を疑った方が良い。
    その為に前回までの解析状態を確認しておく必要がある。

    +-------------------------------------------------------------------------------------------+
    | 直前の状態                                                                                |
    +-------------------------------------------------------------------------------------------+
    | A?                                                                                        |
    |  2*aw   000 'e' |     stat=(1 w=- n=- t=-1:-1)                                            |
    |  |*aw   001 'c' |                                                                         |
    |  |*aw   002 'h' |                                                                         |
    |  |*aw   003 'o' +     word=2:0-4                                                          |
    |  3*a    004 ' '                                                                           |
    |  9*a    005 '"' ||    nest=(4 w=4:5- n=- t=-1:1) stat=(3 w=- n=- t=1:-1)                  |
    | 14*a    006 '$' ||    stat=(5 w=- n=@5 t=-1:-1)                                           |
    |  7*a    007 'f' ||                                                                        |
    |  9*a    008 '"' ++    word=4:@3>5-9>@8 word=nnone:5-9 stat=(5 w=- n=@5 t=-1:-1)           |
    |  3*a    009 ' '       stat=(3 w=- n=- t=0:-1)                                             |
    |  9*a    010 '"' ||    nest=(4 w=4:10- n=- t=-1:1) stat=(3 w=- n=- t=1:-1)                 |
    | 14*a    011 '$' |||   nest=(5 w=- n='$(':10- t=-1:-1) stat=(5 w=- n=@10 t=-1:-1)          |
    |  |*a    012 '(' |||                                                                       |
    |  2*aw   013 'B' |||+  word=2:13-14 stat=(1 w=- n=@11 t=-1:-1)                             |
    |  3*a    014 ' ' |||                                                                       |
    |  9*a    015 ''' ||||  stat=(3 w=- n=@11 t=1:-1)                                           |
    |  5*a    016 'D' ||||                                                                      |
    |  9*a    017 ''' |||+  word=4:@13>15-18                                                    |
    |  3*a    018 ' ' |||   stat=(3 w=- n=@11 t=0:-1)                                           |
    |  9*a    019 '"' ||||| nest=(4 w=4:19- n='none':11- t=-1:1) stat=(3 w=- n=@11 t=1:-1)      |
    | 14*a    020 '$' ||||| stat=(5 w=- n=@19 t=-1:-1)                                          |
    |  7*a    021 'f' |||||                                                                     |
    |  9*a    022 '"' |||++ word=4:@17>19-23>@22 word=nnone:19-23 stat=(5 w=- n=@19 t=-1:-1)    |
    | 14*a    023 ')' ||+   word=n$(:11-24>@22 stat=(3 w=- n=@11 t=0:-1)                        |
    |  9*a    024 '"' ++    word=4:@8>10-25>@24 word=nnone:10-25>@23 stat=(5 w=- n=@10 t=0:-1)  |
    | \_ 'echo'                                                                                 |
    | \_ '"$f"'                                                                                 |
    | |   \_ '"$f"'                                                                             |
    | \_ '"$(B 'D' "$f")"'                                                                      |
    |     \_ '"$(B 'D' "$f")"'                                                                  |
    |         \_ '$(B 'D' "$f")'                                                                |
    |             \_ 'B'                                                                        |
    |             \_ ''D''                                                                      |
    |             \_ '"$f"'                                                                     |
    |                 \_ '"$f"'                                                                 |
    +-------------------------------------------------------------------------------------------+

    やはりどうも腑に落ちない。shift に失敗しているのだとしても文法的な入れ子構造が全く違うのだから、
    解析の中断が起こるはずがないのである。という事は、少なくとも解析の中断の判定部分に問題があるのであり、
    先にそちらを解決する方が先になるであろう。という訳で例によって ble-syntax/parse/nest-equals を確認する。
    以下が最後の ble-syntax/parse/nest-equals 呼出時の動作の流れである。

    | ble-syntax/parse/nest-equals
    | declare -- parent_inest="20" i1="6" i2="8"
    | A0
    | declare -- _onest="4 0 4 8 -1 1 none" _nnest="4 0 4 8 -1 1 none"
    | A1
    | A2
    | A3
    | declare -- parent_inest="8" i1="6" i2="8"
    | A0
    | declare -- _onest="" _nnest=""
    | A1
    | A2
    | A3
    | declare -- parent_inest="" i1="6" i2="8"
    | A0

    おかしい、途中で _onest _nnest が空白になっている。そんな事があるだろうか。
    直前の状態ではエラーが生じていなかったはずなので直前の状態で nest を辿って空白になるという事は考えにくい。
    それなのに _onest についてすら空白になっている。_onest を格納している配列の中身の構築に失敗している?

    と思ったが…あれ parent_inest=8 とはどういう事だろう。8 には勿論何もない。
    parent_inest の更新部分を見てみると onest[3] の中身を直接読み取っている。
    確かにこれでは動作しない onest[3] の中に入っているのは現在位置からみた時の parent_inest の相対位置なので、
    直接代入するのではなくて現在の位置からのずれとして計算しなければならない。
    つまり、正しくは parent_inest=$((parent_inest-onest[3]))=20-8 として計算するべきなのだ。
    しかしそうだとしても変である。20-8 = 12 にはやはり何も nest は設置されていないからである。
    →と思ってよく見てみたら設置されている。なので相対位置で計算する様に修正した。
    →修正した。エラーは出なくなった。OK
      2015-12-02 のエラーも出なくなった。OK。

    しかしこれは 2015-11-28 のエラーとは関係ないようである。取り敢えず一旦整理する。

  * alias 対策 [#D0261]

  * fgrep に依存している [#D0260]

  * bash-3 で C-d を捕獲する為のメッセージについて [#D0259]

    これは各言語・各 version で異なるので統一的に取り扱える様にしたい。

    これらのメッセージは

    [u@h bash-4.3/po]$ sed -nr '/msgid "Use \\"%s\\" to leave the shell\.\\n"/{n;p;}' *.po

    とすれば各言語版でどの様なメッセージが使用されているか調べられる。更に、

    % [u@h bash-4.3/po]$ sed -nr '/msgid "Use \\"%s\\" to leave the shell\.\\n"/{n;s/^msgstr/printf/;s/$/ exit/;p;}' *.po | bash
    %
    % とすれば具体的なメッセージを出力する事ができる。
    % と思ったがエスケープしなければならない文字が shell と po では違うので駄目だ。
    % 例えば "" 中の ` をエスケープしないとシェルではコマンド置換と勘違いされる。
    % なのでもう少し慎重になる必要がある。

    % [u@h bash-4.3/po]$ sed -nr '/msgid "Use \\"%s\\" to leave the shell\.\\n"/{n;s/^msgstr/printf/;s/$/ exit/;p;}' *.po | bash

    この結果を何処かにファイルに放り込んでおいて readarray なり何なりで読み込むようにすれば良いのでは?

    → generate.sh に生成用のスクリプトを書いて、生成結果を ignoreeof-messages.txt に出力することにした。
      C-d の検出時にはこの ignoreeof-messages.txt を使用する事にした。

2015-12-01

  * bugfix: 引数に対する補完で complete -D が登録されていない場合に何も起こらなかった。 [#D0258]

    以下のバグはこれに関連する物である:

    > * bug: tab 補完が効かない @ laguerre
    > * bug cygwin 環境で補完が効かない

  * bug: isearch/forward incremental にできない。 [#D0257]

2015-11-30

  * release の登録 on GitHub [#D0256]

2015-11-29

  * input_encoding=C full support as 'UTF-8' [#D0255]

  * bug [#D0254]

    選択している状態で history を移動すると座標がずれる。
    特に長いコマンドの一部を選択している時にずれる。
    ずれの量は選択範囲の長さや位置に依存しない。

    どうやら ble-syntax-layer:region が悪い様だ。
    _ble_highlight_layer__list から region を外したら直った。

  * ライセンスファイルの追加 [#D0253]

  * ble-bind -xf [#D0252]
    ble-bind -x 未実装状態になっている
    →これは単純に ble-edit+... を実装してそれを ble-bind -c で登録すれば良いだけなのでは?

2015-11-25

  * 公開までに特に必要な物 [2015-03-01] [#D0251]

    > 1 背景が暗い環境での色の設定
    >   これは確認してみたがそんなに問題にならないのではないかという気がした。
    >   何れにしても自由に配色を設定できるようにする仕組みは提供する必要がある。
    >   →解説を加えれば良い。
    > 2 complete の設定の取り込み
    3 bind 等の設定の取り込み
      readline 関数の完全対応
      bind -x は対応しなくて良い
      inputrc は対応しない。簡単に翻訳できるから。
    > 4 正しい PS1 の解釈

    取り敢えず大体の所は終わった。
    readline 関数の完全対応には時間が掛かると思われるので、一旦保留として別項目にする。

2015-11-23

  * magic-space [#D0250]

    特定の文字列がある時にカーソルが末端に移動する。

  * プログラム補完: ディレクトリ名の直後の "/" 挿入 [#D0249]

    プログラム補完でディレクトリ名を列挙されると、
    それがディレクトリ名であるにも関わらず直後に " " が挿入されて中のファイルを列挙できなくなる。
    仕方がないのでプログラム補完で生成される候補については action/file で登録する事にする。
    つまり、ディレクトリ名に一致すれば "/" を末尾に挿入するしそれ以外ならば " " を挿入する。

  * complete/compopt -o の対応 [#D0248]

    + compopt -o nospace 等の情報を取り出す事ができない?
      これは complete -p の解析時に先ず抽出し、
      更に、プログラム補完時に compopt 関数を上書きすればよい。
      →実装した。動いている様に見える。

    + compopt -o filenames/dirnames/default/bashdefault
      現状だとこれらは全く使われない様だ。
      これは compgen に失敗した時にどの様に動作するかを指定する物であって、
      compgen 自体の動作には影響を与えない様である。

    + compopt -o plusdirs については compgen の方で処理してくれる様なので気にする必要はない。

  * bug: ble-detach による stty 破壊 [#D0247]

    ble-detach した後に rm file RET yes RET とすると反応がなくなる。
    改行が正しく伝わっていない? stty で調べてみる。

    ble$ bash-4.0 --norc
    ble$ stty -a
    speed 38400 baud; rows 73; columns 210; line = 0;
    intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = M-^?; eol2 = M-^?; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;
    -parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
    -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl -ixon -ixoff -iuclc -ixany -imaxbel -iutf8
    opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
    isig -icanon iexten echo -echoe -echok -echonl -noflsh -xcase -tostop -echoprt -echoctl -echoke

    ble$ stty -a
    speed 38400 baud; rows 73; columns 210; line = 0;
    intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = M-^?; eol2 = M-^?; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;
    -parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
    -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl -ixon -ixoff -iuclc -ixany -imaxbel -iutf8
    opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
    isig -icanon iexten echo -echoe -echok -echonl -noflsh -xcase -tostop -echoprt -echoctl -echoke

    ble$ ble-detach
    ble$ stty -a
    speed 38400 baud; rows 73; columns 210; line = 0;
    intr = <undef>; quit = <undef>; erase = <undef>; kill = <undef>; eof = ^D; eol = M-^?; eol2 = M-^?; swtch = <undef>; start = ^Q; stop = ^S; susp = <undef>; rprnt = ^R; werase = <undef>; lnext = <undef>;
    flush = ^O; min = 1; time = 0;
    -parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
    -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr -icrnl -ixon -ixoff -iuclc -ixany -imaxbel -iutf8
    opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
    isig -icanon iexten echo -echoe -echok -echonl -noflsh -xcase -tostop -echoprt -echoctl -echoke

    どうも色々な設定が消滅している様子である。
    状態の復元は ble-decode-detach -> .ble-stty.finalize -> stty で実行している筈である。
    やはり bind -x の中で実行した stty の反映には制限が伴うという事か。
    一応最後に stty sane を実行すれば直る。

    取り敢えずの暫定処置として stty sane を ble-detach 後にユーザに実行して貰う事にする。

  * complete -p による補完を動作する様に修正。 [#D0246]

    下らないバグだった。extract-command 内で、出力変数の筈の
    comp_words comp_line comp_point comp_cword に対して local を指定したままだった。
    (実装中にテスト用として local 宣言していたのが残っていた。)

  * complete -F 対応 [#D0245]

    if complete -p コマンド名 &>/dev/null; then
      IFS=$'\n'
      local arr=$(
        1 ble-getopt $(complete -p コマンド名) で解析
        2 -F, -C オプションに指定されたコマンドを ble の用意した物に置き換え
          ble の関数で COMP_ 変数を用意し、
          その後で -F -C オプションに指定されていたコマンドを呼び出す。
          呼出方などは -F -C の仕様に準じる。
        3 compgen 解析したオプション -- "$COMPV" を呼び出し候補を列挙する
      )
    fi

    既存のシェル関数による補完候補生成 (complete -F) の仕様について確認する。

    | complete -F による補完を実行する際にどの様な変数を設定する事になっていたか、
    | どの様にして補完単語及び補完単語を指定する事になっていたかについても確認する必要がある。
    | それらの仕様によってどの様にコマンドラインの情報を構築するかが変わってくるからである。
    |
    | 基本的に complete -F 呼出元では COMP_ シェル変数を設定すれば良いと考えられる。
    | COMP_* シェル変数には以下のような物がある。
    | - COMP_LINE   コマンドライン全体
    | - COMP_POINT  コマンドライン全体の内の位置
    | - COMP_WORDS  コマンドラインを構成する単語たち
    | - COMP_CWORD  COMP_WORDS 内のどの単語に現在カーソルがあるか
    | - COMP_KEY
    | - COMP_TYPE
    | - COMP_WORDBREAKS ← これはユーザ側が comp の動作を制御する為に使用する変数であって、comp 側で設定する変数ではない。
    |
    | 疑問: 補完関数はどの様にして COMP_WORDS[COMP_CWORD] 内におけるカーソルの位置を知るのか?
    | a 例えばカーソル位置で必ず単語が切断されるのか、
    | b 或いは、COMP_WORDS[COMP_CWORD] にはカーソルよりも前の部分しか格納されないのか、
    | c COMP_WORDS 自体がカーソルよりも前の部分だけしか含まないのか、
    | d それともカーソル位置を知る方法はないのか。
    |
    | →d の様である。COMP_WORDS COMP_CWORD は素直に生成される。
    |   従って単語の途中で TAB を押している可能性もあるので、
    |   シェル関数側では「COMP_WORDS[COMP_CWORD] から始まる単語だけを生成する」
    |   という訳には行かないようである。ちゃんと COMP_LINE, COMP_POINT を用いて、
    |   現在のカーソルの位置が何処にあるのかを確認して候補を列挙する必要がある。
    |
    | 疑問: COMP_POINT の説明が気になる。コマンドの先頭からの offset というのは、
    |   コマンドラインの先頭からの位置とは違うのだろうか。例えば複数のコマンドがコマンドラインに含まれている場合にどうなるか。
    |   特に、複数のコマンドが含まれている場合には、他のシェル変数 COMP_CWORD, COMP_WORDS, COMP_LINE 等もどうなるか気になる。
    |
    | →何と! ちゃんとコマンドライン中の、現在のコマンドに対応する部分を切り出して
    |   COMP_LINE, COMP_WORDS, COMP_CWORD を設定してくれる様だ。
    |   COMP_LINE が現在のコマンドラインだという説明が誤っていたという事になる。
    |
    |   所で $(echo $(echo $(...)) 等としてみたが、... の場所に書かれているコマンドについては
    |   complete で設定された補完は実行されないようである。
    |   一番外側のコマンドについて complete が呼び出されるだけである。
    |   一番外側のコマンドについての補完では $(...) はちゃんとひとまとまりとして
    |   (途中の空白で単語分割されたりせずに) 扱われる様である。
    |
    | 疑問: compgen は COMP_* に対して透過的か?
    |   つまり、先ず compgen -F でシェル関数は呼び出されるのか? という事と、更に、
    |   COMP_* だけ自分で適当に設定すれば compgen -F を介して呼び出される関数は期待通りに動くのか?
    |
    | →試してみた所、透過的ではなかった。関数内で見ると COMP_LINE= COMP_POINT=0 COMP_CWORD=-1 の状態になる。
    |   そればかりか、関数呼出元の変数の内容も変更されてしまう様である。
    |   もし compgen を利用するとなると -F の内容は一旦関数でくるんで実行する事になるだろう。
    |
    | 従来の bash 向けの補完関数の能力を最大限に引き出す為には ble 側で、
    | 現在のコマンドの部分を切り出して仮想的に再現した COMP_LINE, COMP_POINT を用意する必要がある。

    結論 (origiinal complete の仕様)

    (1) COMP_LINE, COMP_POINT, COMP_WORDS, COMP_CWORD は現在のカーソル位置にあるコマンドから作られる。
    (2) COMP_WORDS, COMP_CWORD はカーソルが現在の単語の中のどの位置にあるかは教えてくれない。
    (3) compgen -F を実行すると COMP_* の内容がクリアされてしまう。

    結論 (方針)

    (1) 基本的には complete -p の結果を元に compgen を用いて候補の生成を行う。
    (2) complete -F のシェル関数は COMP_* を設定する関数を一旦挟んでから呼び出す様に介入する。
    (3) 補完対象は現在カーソルがある位置のコマンド全体を特定して決める。
      そこから仮想 COMP_LINE COMP_POINT を構築する。

    先ずはコマンド全体を抽出する所から始まる。

    | [コマンド全体を抽出する手法の選択]
    |
    | というよりそもそも現在の実装で単語のどの様に抽出していたか?
    | →ble-edit+complete 関数から ble-syntax/completion-context 関数を呼び出している。
    |   更にそこから ble-syntax/completion-context/check-prefix 関数を呼び出している。
    |   この中で現在位置が属している単語の切り出しを行っている筈である。
    |   実際に見てみると現在位置から先頭に向かって順に _ble_syntax_stat を見ていって、
    |   現在位置より前にある最後の解析再開点の情報を読む。
    |   解析再開点には現在の解析における単語開始位置などの情報が格納されている。
    |   この情報を利用すれば確かに現在位置にある単語の情報を抽出する事ができる。
    |
    | では更に現在位置の属している単語だけではなくコマンドまで抽出するにはどうしたら良いか。
    | 取り敢えず現在の単語とそれより前にある単語を順に辿って行って、
    | 初めにコマンド単語に当たったら其処で停止するという方法を取れば現在のコマンドを抽出できる。
    | その過程でコマンド・最初の引数から現在の引数までを取得する事は可能である。
    | しかし、以降の単語を抽出するにはどの様にしたら良いのだろうか。
    | 一文字ずつ進んで確かめていく方法だとそのコマンドがとても長いコマンドであった場合に時間が掛かる。
    | すると木構造を辿るしかないのだろうか。現在の実装だと中身から木構造を根本に辿る方法は提供されない。
    | ここで二つの選択肢がある。
    |
    | a tree-enumerate を利用して根本から順に辿っていく方法
    |
    |   現状 ble_debug=1 としてデバグ用情報を表示している時でもそんなに重くは無いようだから、
    |   根本から情報を辿る方式でもそんなに問題は無いように思われる。
    |
    | b tree-enumerate の情報をキャッシュして葉から根本の方向へ辿る事のできるデータ構造を構築する方法
    |
    |   % しかしながら、今後色付けなどの更新の方の需要から、
    |   % 葉から根本の方向へ辿る事のできるデータ構造を構築するかもしれない。
    |   % もしその様な仕組みが整うのだとしたら初めからその事を意識した実装にする必要がある。
    |   % 或いはもうこの complete の実装の為にその仕組みの大枠を作ってしまう方が良いかも知れない。
    |   %
    |   % 例えば葉から根本の方向へ辿る事のできるデータ構造を取り敢えず作り、
    |   % その更新は愚直に全体に対して行う事にする。
    |   % 部分更新などの細かい最適化の可能性については後で考える事にする。
    |   %
    |   % しかし、昔の考察だと部分更新は(整合性を保つようにするのが)かなり難しいと思われる。
    |   % そうすると結局最終的にも完全に全体を毎回再構築する事になるかもしれない。
    |   % それだと結局キャッシュする事の意味も余りないという事になる。
    |   % 色付けの更新の際にもその様な調子であれば結局この仕組みは遺棄される事になる。
    |   % それならば無駄なデータ構造を作らない方が良いとも考えられる。
    |   %
    |   % 結局の所具体的な需要がはっきりしないうちに仕組みを中途半端に揃えても、
    |   % 結局想定していた需要に対しては利用できない・実現不可能という事になって、
    |   % 無駄になるかもしれない。それならば今の段階では余り具体的な行動は動かさない方が良い様に思われる。
    |
    |   色付け更新の方から来る需要にも対応して入れ子構造のデータを構築するのは後回しにする。
    |
    |   そもそもその様な入れ子構造のデータを管理して色付けを効率化できるか不明である事、
    |   "complete で必要としているのは現在のコマンドに於ける最後の引数の位置" という単純な物であるから、
    |   その様な入れ子構造のデータを実装してからでも対応は難しくない事からである。
    |
    | 結局、「最後の引数の位置を特定する」機能を実装して、更に其処からコマンドを抽出するという事にする。
    | この最後の引数の位置は a/b のどちらでも実装できるが取り敢えずの所は a による実装で進める。
    |
    | 現在の単語抽出の枠組を流用しようかと思ったが、どうも現在の実装は不完全の様な気がする。
    | 現在の位置が "～" で囲まれた場所だったりした時に補完が働かない。
    | 一方で現在の位置が ${～} で囲まれた場所だった場合は補完が働かなくて正解なので
    | やはり現状の実装の様にする必要もあるかも知れない。
    | どの様な時にコマンド単語としての補完を実行して、どの様な時にしないのかをはっきりとさせておく必要がある。
    |
    | もう少し体系的な取り扱いをしたいが、これは現状の実装でも同じ様に体系的な扱いをしたいので、
    | 別に新しく作るという事はせずに、現在の枠組の延長としてコマンド抽出を実装し、
    | もし体系的な取り扱いをしたければ現状の実装の部分を拡張する方針で行く。

    結論
    (1) コマンドの抽出部分はモジュール性が高く簡単に再実装できるので、
      現状の枠組 (tree-enumerate) による抽出コードを取り敢えず書いて使う。
    (2) もし今後最適化の機会があれば再度書き直す。

    先に補完対象 (file, command, argument, etc.) を列挙し、
    その後で argument による補完候補列挙が必要になった時にコマンドの抽出を行う。

    | [コマンド部分の抽出の実装]
    |
    | コマンドの抽出はまた別の関数として実装する事にする。
    | 取り敢えず入れ子構造を走るプログラムを書いてみる事にする。
    |
    | そのノードが現在地を含む一番小さな word である条件は?
    |
    | 1.そのノードが word であるという事。
    |
    |   nest による構造ではなくて word であるという意味である。
    |   これは wtype が整数 (CTX_*) か文字列化で判定できる筈。
    |
    |   →本当か? nest で整数を使っている箇所はないのか?
    |     各場所の nest-push 調べてみた所、
    |     数字をしている箇所は存在しないようである。
    |     一箇所だけ何も指定していない場所があるが、
    |     nest-push 関数の中を見ると何も指定しない場合は type は "none" になる様である。
    |   →或いは、nest による node 登録は別の方法で区別できるようになっていたかも知れないのでそれも確認する。
    |     調べてみたが ntype をそのまま tree-append に渡しているので、
    |     区別する為にはやはり ntype, wtype を使用する必要がある。
    |     現在は ntype の値は使用していない様に思われるので、
    |     実は tree-append 時に type を "n$ntype" にしてしまえば良いのではないだろうか?
    |   →また既に ${node[0]} =~ ^[0-9]+$ で判定を行っている箇所を発見した。
    |
    |   保険の為 nest の場合は tree-append 時に n$ntype とする事にした。
    |
    | 2. 内側に word を含まない事
    |
    |   これは先に tree-enumerate-children して内部の構造を調べてから自分の処理を実行するという風にすれば良い。
    |   自分が word で内部に word を含まないと判定できれば isword=1 を設定する事にすれば良い。
    |   内部に word を含まないという事は isword= である事によって確認できる。
    |
    | > 現在のカーソル位置に未だ単語が出来ていない場合はどうするのか?
    | > つまり単語を其処に入力しようとしているが未だ 1 文字も入力していない状態の場合である。
    | > この様な場合を検出する為には単語ではなくて寧ろコマンドの context で検出するべきなのではという気がする。
    | >
    | > 或いは、現在地を含む単語によって検出するのではなくて、現在地より前にある単語を用いて検出するか?
    | > 現在地より前にある単語でかつ親ノードの内側に現在地を含む物が見付かれば良い。
    | > これについては後で対策する。-> Done.
    |
    | コマンドに属する単語の抽出は大体完了した様子である。
    | 更に comp_line や comp_point comp_cword にも対応する必要がある。
    | →対応した。

    取り敢えず実装したので commit する事にする。
    何故か動いていないが後でデバグする。

2015-11-19

  * bleopt コマンド [#D0244]

  * PROMPT_COMMAND [#D0243]

    普通の bash (ble のない bash) では、
    bind -x によって設定したコマンドを実行後に prompt を再描画するが、
    その時には PROMPT_COMMAND の中身は実行されない様だ。
    あくまで通常コマンドを実行した後にプロンプトの内容を
    再計算する時にコマンドが実行される様である。

    つまり PROMPT_COMMAND はプロンプトを計算する際に実行すれば良い。
    プロンプトの計算は .ble-line-prompt/update の中で、
    _ble_edit_LINENO と _ble_line_prompt[0] (前回のプロンプトの計算をした時の LINENO) が
    不一致だった時に実行される。

    PROMPT_COMMAND の内容を何処で実行するかは問題になる。
    関数の内側で実行すると declare した変数が見えないし、
    また関数の内側で定義された変数に干渉する事ができてしまう。

    一番外側で実行しようと思うと色々面倒なことになる気がするので
    取り敢えずは .ble-line-prompt/update の中で
    eval "$PROMPT_COMMAND" を実行する事にする。

    2017-10-26 変更を眺めていて思ったが、これは直しきれていない。改めて修正した。

  * histexpand: "～" 中の histexpand, extglob の際の histexpand 開始 [#D0242]

    > - 文字列 "～" 中の history-expansion は " を含まない。
    > - '!(' not histexpansion when shopt -s extglob 対応

  * histexpand: histchars 対応 [#D0241]

    histchars が設定されている時の正規表現の修正。
    > - _ble_syntax_bashc (旧 _BLE_SYNTAX_CSPECIAL)
    > - _ble_syntax_rex_simple_word
    > - _ble_syntax_rex_simple_word_element

2015-11-16

  * bug: 解析エラー [#D0240]

    解析のバグがようやく直ったと思っていたらまたエラーになった。
    今度は以下の様な状況でエラーが起こる:

    1. echo "${a[*]}" と入力する。
    2. echo ""${a[*]}"
    3. echo ""${a[*]}"" ←これでエラーになる。更に続けて何回かエラーが出る。

    しかもエラー状態のまま色々操作しているとついに CPU 100% でハングする。

    | [murase@padparadscha 0 ~]$ ""${a[*]}"
    | A?
    |  9*a    000 '"'      stat=(1 w=- n=- t=-1:-1)
    |  9*a    001 '"' ||
    | 14*a    002 '$' |||  nest=(2 w=2:0- n=- t=-1:-1) stat=(2 w=2:0- n=- t=-1:-1)
    |  |*a    003 '{' |||
    |  7*a    004 'a' |||
    |  8*a    005 '[' |||| nest=(14 w=- n='v[':2- t=-1:-1)
    |  8 a    006 '*' |||| stat=(8 w=- n=@5 t=-1:-1)
    |  8 a    007 ']' |||+ word=v[:5-8 stat=(8 w=- n=@5 t=-1:-1)
    | 14 a  s 008 '}' ||+  word=${:2-9>@7 stat=(14 w=- n=@2 t=0:-1)
    |  9 a  s 009 '"' ++   word=2:1-10>@9 word=none:1-10>@8 stat=(5 w=- n=@1 t=0:-1)

    何が起こっているかはすぐに分かった。一つ目の " を挿入した時に、
    解析が ${a[ までで中断している。本来は入れ子の構造が異なるので中断してはならない筈である。
    さて最近の修正の所為で中断されなくなったのか、それとも昔からあったバグなのか。

    先ず初めの可能性は更新された領域が誤った解析結果になっていないかという事である。
    上の状態で言えば 000, 002, 005 に設置されている情報に当たる。
    これはなさそうであるが念のため確認しておく。
    →挿入をせずに初めから順番に入力していった場合 (エラーは起こらない) と比較する。
      000, 002, 005 は完全に一致している。
      更にいうならば 006 に設置されている stat も一致している。

    000, 002, 005 が一致しているのは正しく解析が行われているという事なのでOKである。
    ところが 006 も一致しているというのは何かおかしい。
    これだけの情報だと確かにこの場所で解析が中断されてしまう。

    何故前回の解析で全く同じ stat が再現されているのだろうか??
    →いや局所的に見れば stat が一致するのは不思議な事ではない。
    たとえ全く同じ stat になったとしてもその参照先の nest が異なるのでここで中断はないはずなのだ。
    念のため直前の nest の状態についても調べておく:

    | [murase@padparadscha 0 ~]$ "${a[*]}"
    | A?
    |  9 a    000 '"' ||   nest=(2 w=2:0- n=- t=-1:-1) stat=(1 w=- n=- t=-1:-1)
    | 14 a    001 '$' |||  nest=(5 w=- n='${':0- t=-1:-1) stat=(5 w=- n=@0 t=-1:-1)
    |  | a    002 '{' |||
    |  7 a    003 'a' |||
    |  8 a    004 '[' |||| nest=(14 w=- n='v[':1- t=-1:-1)
    |  8 a    005 '*' |||| stat=(8 w=- n=@4 t=-1:-1)
    |  8 a    006 ']' |||+ word=v[:4-7 stat=(8 w=- n=@4 t=-1:-1)
    | 14*a    007 '}' ||+  word=${:1-8>@6 stat=(14 w=- n=@1 t=0:-1)
    |  9*a    008 '"' ++   word=2:0-9>@8 word=none:0-9>@7 stat=(5 w=- n=@0 t=0:-1)

    やはり "nest" が違うようだ。一つ上の nest @ 004/005 は一致している。
    更にもう一つ上の nest @ 001/002 は内容が異なる。
    '"' 挿入前は更にもう一つ上の nest @ 000 を参照しているのに対して、
    '"' 挿入後はもう一つ上の nest は - となっていて無効になっている。

    原因として考えられるのは:

    a. nest を遡った比較に失敗している?
    c. nest を遡って比較する為のデータを誤って参照している?
      またはデータを移動する時に失敗して新しいデータが混入している?
    b. shift に失敗している? (shift の際にデータが化けている?)

    一つずつ確かめていくしかない。確認の簡単そうな物&怪しそうな物から順に。
    先ずは a を疑う。function ble-syntax/parse/nest-equals の制御パスを調べる。
    →おかしい。ループが終わるはずのない場所で終わっている…。
      変だ…と思ったらこれはデバグ用コードの return が悪さをしている??
    →ああ、これだ。bash の && と || の優先順位は同じで左結合である。

    試してみた所、
    * [[ ～ ]] の && と || は期待通りの優先順位である。
      [[ a || '' && '' ]]         -> 0
      [[ ( a || '' ) && '' ]]     -> 1
    * (( ～ )) の && と || の優先順位も期待通りである。
      ((1||0&&0))                 -> 0
      (((1||0)&&0))               -> 1
    * command || command && command の優先順位は注意しなければならない。
      true || false && false      -> 1
      true || { false && false; } -> 0

    一応他にも同じ間違いをしている箇所がないか以下のコマンドで調べる:

    $ grc '\&\&' | grep -E '\|\|' | grep --color -E '\&\&|\|\|'

    他には同じ間違いをおかしている箇所は無いようである。
    元々コマンドを三つ以上 && や || で繋ぐ場合が少ない上に、
    使っている場合でも先に && があってその後に || があるパターンばかりの様である。
    左結合なので、この場合は期待通りに && が内側にあると解釈してくれる。

    (以前同じ様な事で嵌って修正を行ったような気がするが、
    その時に && と || を入れ替えたのだったか…。余り覚えていないが… 恐らく、
    A || B && C となっているのを ! A && B && C にしたのだろう。)

    何れにしても今後は && と || の優先順位に騙されないように注意深く実装を行う。

2015-11-08

  * 補完候補列挙に時間がかかっている時に入力があった場合、中止する? [#D0239]

    そもそも補完候補列挙のどの部分に時間がかかっているのか調べる必要がある。
    列挙・フィルタ部分なのか、それとも描画レイアウト決定部分なのか、描画部分なのか。

    特に時間が掛かるのは何も入力されていない状態で TAB を押した時である。
    complete がどの様な手順で処理されているかについて初めに調べる。
    ble-edit+complete (ble-edit.sh ble-autoload)
    -> ble-edit+complete (complete.sh)
        この関数内で殆ど分岐の処理をしている。
        先ず初めに候補を列挙して (ble-complete/source/command)、
        候補をスキャンして共通部分を計算する。
        候補が複数あったら描画を実行する。
    一番時間が掛かっているのは候補の列挙であり、
    そして次に時間が掛かっているのは共通部分の絞り込みである。
    今迄描画に時間が掛かっているのかと思っていたが、
    描画は本当に一瞬で終わっている。

    もっと ble-complete/source/command を詳しく見てみると、
    どうやら各候補についての情報を生成する所 ble-complete/yield-candidate で時間が掛かっている様だ。
    うーんこれを最適化するのは難しい…と思ったが、
    この部分はシェルによるループになっているので read -t 0 をチェックして中断するのは容易である。

    read -t 0 の performance をチェックする:

    > | $ time for ((i=0;i<100000;i++)); do read -t 0 && echo "$i"; done
    > |
    > | real    0m2.139s
    > | user    0m1.998s
    > | sys     0m0.139s
    > | [ble: exit 1]
    > | $ time for ((i=0;i<100000;i++)); do ((i%10==0)) && read -t 0 && echo "$i"; done
    > |
    > | real    0m1.673s
    > | user    0m1.664s
    > | sys     0m0.009s
    >
    > read -t 0 の呼出回数を 1/10 にしても対して変わらない様だ。
    > つまりループのコストか、或いは算術式による i%10==0 の実行の方も同じ位の実行コストがあるという事である。
    > これならば下手に read -t 0 の判定を間引く必要もないだろう。
    >
    > | $ function ble-util/check-input { IFS= read -t 0 -n 1; }
    > | $ time for ((i=0;i<100000;i++)); do ble-util/check-input && echo "$i"; done
    > |
    > | real    0m9.482s
    > | user    0m9.260s
    > | sys     0m0.213s
    > |
    > | $ function ble-util/check-input { IFS= LANG=C read -t 0 -s -r -d '' -n 1; }
    > | $ time for ((i=0;i<100000;i++)); do ble-util/check-input && echo "$i"; done
    > |
    > | real    0m16.039s
    > | user    0m15.809s
    > | sys     0m0.215s
    > |
    > | $ function ble-util/check-input { IFS= LANG=C read -t 0; }
    > | $ time for ((i=0;i<100000;i++)); do ble-util/check-input && echo "$i" && break; done
    > |
    > | real    0m11.199s
    > | user    0m10.965s
    > | sys     0m0.226s
    > |
    > | $ function ble-util/check-input { read -t 0; }
    > | $ time for ((i=0;i<100000;i++)); do ble-util/check-input && echo "$i"; done
    > |
    > | real    0m3.687s
    > | user    0m3.518s
    > | sys     0m0.166s
    > |
    > |
    > | $ IFS= LANG=C; time !!
    > |
    > | real    0m3.219s
    > | user    0m3.048s
    > | sys     0m0.168s
    >
    > 分かった事は read -t 0 の引数を増やすとそれだけ処理時間が増えるという事、
    > それ以上に IFS= LANG=C によって変数を書き換えるのに時間が掛かるという事。
    > 所で read -t 0 の引数を削除しても振る舞いには影響がないように見える。
    > 唯単に速度が遅くなるだけなのでループ中断の判定の歳には引数は無駄に指定しない事にする。
    >
    > | $ time for ((i=0;i<100000;i++)); do ((_ble_bash>=40000)) && read -t 0 && echo "$i"; done
    > |
    > | real    0m2.909s
    > | user    0m2.775s
    > | sys     0m0.131s
    > |
    > | $ time for ((i=0;i<100000;i++)); do ((check)) && read -t 0 && echo "$i"; done
    > |
    > | real    0m2.712s
    > | user    0m2.646s
    > | sys     0m0.064s
    > |
    > | $ check=1
    > | $ time for ((i=0;i<100000;i++)); do [[ $check ]] && read -t 0 && echo "$i"; done
    > |
    > | real    0m2.614s
    > | user    0m2.419s
    > | sys     0m0.193s
    >
    > 更に、関数呼出はそれほどには重くはないが多少時間は掛かるという事。
    > それでも算術式展開と殆ど同じである。一番早いのは [[ ]] による長さ判定である。
    > 関数呼出が絡むのであれば算術式 ((i%100==0)) でも挟んだ方が結局の所は有効なのかも知れない。
    >
    > | $ time for ((i=0;i<100000;i++)); do ((i%100==0)) && IFS= LANG=C ble-util/check-input && echo "$i"; done
    > |
    > | real    0m1.681s
    > | user    0m1.679s
    > | sys     0m0.001s
    > |
    > | $ time for ((i=0;i<100000;i++)); do ((i%10==0)) && IFS= LANG=C ble-util/check-input && echo "$i"; done
    > |
    > | real    0m2.475s
    > | user    0m2.458s
    > | sys     0m0.014s
    > |
    > | $ time for ((i=0;i<100000;i++)); do false && IFS= LANG=C ble-util/check-input && echo "$i"; done
    > |
    > | real    0m1.586s
    > | user    0m1.585s
    > | sys     0m0.000s
    > |
    > | $ time for ((i=0;i<100000;i++)); do :; done
    > |
    > | real    0m1.399s
    > | user    0m1.398s
    > | sys     0m0.000s
    >
    > そもそもループのコストが一番大きくて、算術式や [[ ]] による判定は殆どノーコストな様だ。
    > read -t 0 による判定は 10 に 1 でも良いかも知れない。

    read -t 0 の performance は大体分かったので適当に complete.sh に中断を実装した。
    関数 ble/util/is-stdin-ready (ble-core.sh) に実装して、それをループ内で間引きつつ呼び出す事にする。

    今の所は使い勝手はそんなに問題ない。誤って TAB を押しても固まるという事は無い。

    ただし、初めのコマンドを compgen で列挙する phase は環境によって滅茶苦茶時間が掛かるかも知れない。
    以下に速度を計測してみる事にする。

    | @gauge Cygwin (Intel(R) Core(TM)2 CPU 6300 @ 1.86GHz)
    |
    | $ time compgen -A command '' > /dev/null
    |
    | real    0m24.248s
    | user    0m0.953s
    | sys     0m5.875s
    |
    | $ time compgen -A command '' > /dev/null
    |
    | real    0m6.578s
    | user    0m1.063s
    | sys     0m5.375s
    |
    | $ time compgen -A command '' | wc
    |    6472    6494   65984
    |
    | real    0m6.734s
    | user    0m1.296s
    | sys     0m5.420s
    |
    | @padparadscha GNU/Linux (Intel(R) Core(TM) Duo CPU T2300 @ 1.66GHz)
    |
    | $ time compgen -A command '' | wc
    |    5274    5274   68019
    |
    | real    0m0.119s
    | user    0m0.038s
    | sys     0m0.092s
    |
    | @hankel GNU/Linux (Intel(R) Core(TM) i7-2600 CPU @ 3.40GHz)
    |
    | $ time compgen -A command '' | wc
    |    4112    4112   57267
    |
    | real    0m0.051s
    | user    0m0.019s
    | sys     0m0.038s
    |
    | @laguerre GNU/Linux (Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz)
    |
    | $ time compgen -A command '' | wc
    |    7639    7639   87603
    |
    | real    0m0.094s
    | user    0m0.021s
    | sys     0m0.079s

    やはり cygwin では桁違いの遅さである。
    cygwin では command prefix が空の時は何も列挙しないなどの対策が必要かも知れない。
    →しかしながらこれは ble.sh を使っていなくても同じ事である。
      遅いのが嫌であれば shopt -s no_empty_cmd_completion を設定している筈なのだから、
      この設定を参照して補完の有効・無効を切り替えるべきである。

2015-11-07

  * M-\ delete-horizontal-space [#D0238]

2015-11-06

  * <bug> 編集中に偶にエラーが起こる。起こる条件は不明 [提起: 2015-09-24] [#D0237]

    [状況確認]

    起こった時のメッセージを記録する。
    "${i}" → "${i" → "${i))" → "$((i))" とする過程で起きた。
    詳細: &kbd{'echo "${i}"' left left DEL "))" left left left DEL}: これで起こる。
    入れ子の境界を backspace で消した時に起きた?
    或いは別の入れ子の終了を挿入した時?

    assertion failure: [[ ${_ble_syntax_nest[inest]} ]]
    ble-syntax/tree-enumerate/.initialize/FATAL1
      @ /home/murase/prog/ble/ble.sh:7397 (ble-assert)
      @ /home/murase/prog/ble/ble.sh:2 (ble-syntax/tree-enumerate/.initialize)
      @ /home/murase/prog/ble/ble.sh:22 (ble-syntax/tree-enumerate)
      @ /home/murase/prog/ble/ble.sh:236 (ble-syntax/parse/shift)
      @ /home/murase/prog/ble/ble.sh:-16 (ble-syntax/parse)
      @ /home/murase/prog/ble/ble.sh:4 (_ble_edit_str.update-syntax)
      @ /home/murase/prog/ble/ble.sh:2479 (ble-highlight-layer:syntax/update)
      @ /home/murase/prog/ble/ble.sh:4223 (ble-highlight-layer/update)
      @ /home/murase/prog/ble/ble.sh:4762 (.ble-line-text/update)
      @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
      @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
      @ /home/murase/prog/ble/ble.sh:975 (.ble-decode-byte:bind/tail)
      @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)

    異常状態
    [murase@padparadscha 0 ~]$ echo "${i))"
    A?
     2 aw   000 'e' | stat=(1 w=- n=- t=-1:-1)
     | aw   001 'c' |
     | aw   002 'h' |
     | aw   003 'o' + word=2:0-4
     3 a    004 ' '
     9 a e  005 '"'   nest=(4 w=4:5- n=- t=-1:1) stat=(3 w=- n=- t=1:-1)
    14 a e  006 '$'   nest=(5 w=- n='${':5- t=-1:-1) stat=(5 w=- n=@5 t=-1:-1)
     | a e  007 '{'
     7 a    008 'i'
    15 a    009 ')'   stat=(14 w=- n=@6 t=-1:-1)
     | a    010 ')'
     6 a es 011 '"'   nest=(15 w=- n='none':7- t=-1:-1) stat=(15 w=- n=@6 t=-1:-1)
    \_ '"' (← ※エラーの結果としてこうなっている。原因ではない。)

    正常状態
    [murase@padparadscha 0 ~]$ echo "${i))"
    A?
     2 aw   000 'e' | stat=(1 w=- n=- t=-1:-1)
     | aw   001 'c' |
     | aw   002 'h' |
     | aw   003 'o' + word=2:0-4
     3 a    004 ' '
     9 a e  005 '"'   nest=(4 w=4:5- n=- t=-1:1) stat=(3 w=- n=- t=1:-1)
    14 a e  006 '$'   nest=(5 w=- n='${':5- t=-1:-1) stat=(5 w=- n=@5 t=-1:-1)
     | a e  007 '{'
     7 a    008 'i'
    15*a    009 ')'   stat=(14 w=- n=@6 t=-1:-1)
     |*a    010 ')'
     6*a e  011 '"'   nest=(15 w=- n='none':6- t=-1:-1) stat=(15 w=- n=@6 t=-1:-1)
    \_ 'echo'
    \_ '"${i))"'
        \_ '"${i))"'
            \_ '${i))"'
                \_ '"'

    011 文字目の nest の値に誤りがある。正しく shift されていない?
    どうやら "${i)" から "${i))" にした時にずれる様だ。
    更に色々調べていると "${i " から "${i a" にしても問題になる。
    "${i" を "${iaa" としても問題は起こらない。

    [原因特定]

    違いを見てみると最後の " の部分についても再更新を行っているかどうかに依存している様である。
    何も問題が生じない時には最後の " についても再更新が行われている。
    しかし問題が起こる場合には最後の " についての再更新が行われず、
    そこで状態が一致したと解釈されて解析が終了してしまう。

    最後の " について shift が実行されていないという事から見ると、
    本来は最後の " に関しては必ず再更新を行うという想定なのだろう。
    それが何かの具合で " の位置で状態 (stat) が一致すればそこで中断可能という事になっている。
    (或いは、逆で、状態が一致すればそこで中断可能の筈なのに、shift が省略されているのかもしれない。)

    最後の " (つまり、挿入部分の直後の文字) について状態が一致した時に
    そこで中断可能とするべきなのかどうなのかについて再度考察する必要がある。
    以前に、再開を可能とする為の条件についてまとめた様な気がするのでそれを参照する。
    →"[memo] の解析の際の原則" に書いたものだったはず。
      ここには解析データ配列に対する操作の原則を書いている。
      この原則から中断が可能かどうかについて導出ができるはず。
    →この原則が厳密に守られているのであれば解析は中断可能な気がする。
      % いや。解析データに関しては問題はないが、編集文字列本体に関してはどうだろうか。
      % 解析の際にどこに解析再開点を設置するかを決定するために、解析点よりも先の文字を使用している。
      % →でも一旦解析状態 stat (及び nest 構造) が同じになって、その点以降の文字列が同じであれば
      % 解析の結果は完全に同じになるほかはない。従ってその場所で解析の中断が可能なはずである。
      やはり解析は挿入範囲の直後で中断可能である。

    % もう一つの疑問点は "${i" を "${iaa" とする過程で、何故解析の中断が行われないのかという点である。
    % stat は一致する筈のように思われるし、解析中断可能範囲は "${i a" とする時と同じはずである。
    % % →本当に stat は一致するのだろうか。もしその位置の stat も shift をしないのだとすれば
    % % 解析状態 stat は一致しないのでそこで解析が中断する事は無い。
    % % でも、そうすると今度は "${i a" の時に何故解析状態が一致してしまうのかという話になる。
    % % うーん。謎だ。というか確認してみた所 stat はちゃんと shift されている様である。
    % stat はやはり shift されている。従って一致しても良いように思われる。
    %
    % とすると残るのは解析中断範囲の計算方法の問題だろうか。。
    % (つまり、挿入範囲直後の文字を含んだり含まなかったりまちまちになっている可能性?)
    % →実際に調べてみると解析中断範囲 (-i1 i2-)は問題が出ている時も出ていない時も、
    % 挿入範囲直後の文字の位置に i2 がある。つまり、解析中断範囲の指定によると解析中断可能の筈である。
    % それが中断不可能と判定される理由は何であろうか…。
    % % 唯一の違いは '${' から解析を再開しているかその中身から解析を再開しているかに依存すると思われた。
    % % しかし、中身から解析を再開した場合でも問題が起きない場合には起きない様だ。
    % % →気のせい??→どうやら ble_debug を入れている時と入れていない時でエラーが出るタイミングが違うようだ。
    % %   ble_debug を入れている時の方が即座にエラーを検知していると思われる。今後その仮定の下で調べる。
    % やはり '${' から解析を再開しているかどうかである。
    % '${' から解析を再開する場合、それに対応する nest
    % への参照を含む stat が全て削除されてしまうのが中断が起こらない原因と思われる。
    % さて、ここで改めて考えるに '${' から再解析をして再び全く同じ状態になった場合、
    % 新しく作成される nest は元々あった nest とは違うインスタンスではあるが、
    % やはりそれより後の解析状態は同じになるのではないだろうか。
    % そうだとすると nest が新しく作成された物であったとしても、
    % そこで中断して良いはずなのではないだろうか。
    % →取り敢えずは挿入範囲で削除された要素に対する参照が復元された場合でも中断可能として考える事にする★
    %
    % もし「新しい nest インスタンスであっても同じ状態になれば中断可能」とするならば
    % shift の部分を弄ってその nest に対する参照がある stat/nest etc. を削除しない様に修正する。
    % (削除する代わりに適当なshiftを実行する。特に、内容が変わらないという仮定の下での shift で良かろう。)
    %
    % % - 挿入範囲にあって削除される単語・ネストを参照する解析要素でも削除せず
    % %   適当な shift を実行する事にする。
    % →確認してみた所初めからその様になっている様である。おかしい
    →解析の中断が終わらないのは nest の shift 自体にバグがあって nest が変な状態になっていたからであった?
      でも変である。解析の中断の判定は stat 及び stat の参照している nest だけしか参照しない。
      現在の位置に設定されている nest は解析を続行する事によって設定されるはずの物だから、
      解析の中断の判定には使わないはずだし実際に確認してみた所そうなっている様に見える。

    未だ残っている問題というか、確認していない事項は shift 対象の範囲である。
    なぜ nest の情報が shift の対象になっていないのだろうか。
    nest の格納方法について再度確認を行う。別に特別な格納の方法はしていない様だ。
    原則に則った格納方法になっている。

    各項目の shift 方法の判定についても確認してみたが問題ないようである。
    と思ったらバグを発見した。klen = nest[k] の値を見て nest[k] の shift 方法を判定するべき所を、
    nest[1] を見て nest[k] の shift 方法を判定していたようだ。
    →修正した。これで当初のエラーは発生しなくなった。

    ToDo: 残る事はこの修正によって解析の中断がちゃんと起こる事を確認する事である。
    →おかしい。やはり解析の中断は起こっていない。
      確認してみたが stat の状態は同じ様である。という事は nest か。
      やはりそうだった nest の判定で棄却されている。ではどの様に?
    原因が分かったこれは別項目として独立させる (2015-11-06)。

2015-08-25

  * ble-edit.sh (function .ble-edit/history/generate-source-to-load-history): bash-3.0, [#D0236]
    history が load されているか確認する時 history '!1' でエラーメッセージが表示される。

  * ble-edit.sh: PS1 の中に含まれる ! が \! に化ける。 [#D0235]

    → eval 'a="!m"' となっていても特に履歴展開は起こらない様だ。
    また、PS1 中の ` は特別な意味を持つのでエスケープしない。

  * ble-edit.sh: PS1 の \w の $HOME を ~ に置換する部分で、 [#D0234]
    或るユーザ名が自分のユーザ名を先頭に含んでいる場合、
    そのユーザのホームディレクトリが部分的に ~ に置換されてしまう。

2015-08-19

  * <bug> bash-3.0 で上 (prev-history) をすると今迄に実行したコマンドの履歴が消える。 [#D0233]

    bash-3.0 で消える。bash-3.1 ではちゃんと期待通りの動作になっている。

    そもそも history に登録されていないという可能性もある??
    →しかし一回履歴を見てから実行したコマンドについてはちゃんと履歴に残っている様である。
      でも、それは history コマンドから拾った事に依る物ではなくて、
      自前で記録しているからに過ぎないのでは?

    実際に history コマンドでどの様な物が登録されているかを確認してみればよい。
    と思って確認してみた所最近拾ったコマンドですら登録されていない。
    というか、history に項目を登録するたびに実際には
    history の末端の項目が削除されて行っている様である。
    これは history コマンドの呼出周辺に問題がありそうである。

    少し触ってみて分かった事。
    bash-3.0 では history -s -- で登録したコマンドは末尾に追加されるのではなくて、
    一番最近のコマンドを置き換える形で実行される様である。この動作は bash-3.1 の時と異なる。
    history -s 'echo hello' としても同じであった。
    しかしこれだけならば何故コマンドを実行する度に数が減るのかを説明できない。

    もう少し試してみる。bind -x に history ... を指定したらどうなるだろうか。

      bind -x '"\C-t":history -s echo "$RANDOM"; echo ok'

    として C-t を何回か押してみたが history が寧ろ減少するという状況は再現しない。

    他に history に対して操作をしている箇所と言えば history -p ... のみである。
    それとも history -p を実行する度に history の中身が減少するのだろうか。。。

      bind -x '"\C-t":history -p "echo $RANDOM"; echo ok'

    →何とこれだった! bash-3.0 では history -p する度に history の中身が減少するのだ。
    しかも一回 history -p する度に 2 個ずつ項目が削除される様だ。

    a history -sp としてやってみると何も問題は起こらないようだ。
      しかしこれだと評価結果が出力されないので history から読み出す必要がある。
      更に問題なのは history -sp を用いるとそれまでに history の一番上にあった項目が置換されてしまうという事である。
      これに対応する為には一番上にあった項目を一旦別の変数に覚えておいて、
      history -sp ...; history 1; の後に再度覚えて置いた項目を history -s で設定する必要がある。
      しかも history 1 で出力される内容は行番号 (と変更があれば * も) なので、自分で解析して正しい履歴内容にする必要がある。
    b 上の方法は大変に面倒である。面倒な事をするぐらいならば、
      実は (history -p ...) の様に subshell の中で history -p を実行してしまうのが一番楽である。
      subshell 内での履歴リストに対する変更は親シェルには影響がないので。
      fork のコストはあるものの、どうせ古い bash の対応であるのでこれで良いだろう。

    しかし、history -p で履歴が削除されるのを防ぐ事が出来たとしても問題は依然として残る。
    実際にコマンドを履歴に登録する history -s が使えない事である。
    history -s を用いても最近の項目が置換されるばかりで新しい項目としての登録が出来ない。
    これは、複数回のコマンドを実行しても一番最近の一つのコマンドの履歴しか保持できないという事を意味する。
    これに対処する為には、bash の history に頼らずに初めから全て ble.sh の側で処理してしまうしかない?

    →結局 history -s には頼らずに全部 ble 内で処理することにした。
    起動時に既に .bash_history を読み込んでしまい、
    そして、history -s には頼らずに直接 .bash_history に append を行う。

2015-08-18

  * <bug> bash-3.0 で less <<< と入力した時点で assertion failure が出る [#D0232]

    更に echo $(echo) と入力しただけでも assertion failure になる。

    - FATAL1 が出て無限ループになる → 無限ループになっていたのは
      ble-assert || break による停止が働いていなかった為。
      ble-assert の実装を新しくして上記の使い方が出来る様にしたつもりで居たが、
      実際には古い ble-assert が使われていた為。

    - さて assertion-failure になるのは children で参照した先が空欄である為。
      print-status で構築されている木の形を見てみようとしたが何か出力が変である。
      と思ったら local arr=() の形を使っていた為に bash-3.0 で arr='(...)' が代入されていた。
      これを local -a arr; arr=() の形に修正したらすぐに print-status は直った。

    さて漸く print-status による出力を確認してみる。しかし assertion failure になる直前の形に問題はない。
    (正しく動いている bash-4.3 の出力と全く同じ物が出力されている。)
    逆に assertion-failure 直後の print-status の状態を確認してみると一箇所だけ間違っている。

    | --- a.txt       2015-08-18 23:27:44.399485443 +0900
    | +++ b.txt       2015-08-18 23:28:20.860151961 +0900
    | @@ -11,7 +11,7 @@
    |   | aw   008 'c' |||
    |   | aw   009 'h' |||
    |   | aw   010 'o' ||+ word=2:7-11
    | -14 a    011 ')' ++  word=4:@3>5-12>@11 word=$(:5-12>@10 stat=(3 w=- n=@5 t=0:-1)
    | +14 a    011 ')' ++  word=4:@3>5-12>@11 word=$(:@4>5-12>@10 stat=(3 w=- n=@5 t=0:6)
    |  \_ 'echo'
    |  \_ '$(echo)'
    |      \_ '$(echo)'

    何故か存在しない単語を親単語としている様である ("@4>" の部分)。
    しかしこれは寧ろ ble-assert による中断で shift に失敗しているという事の様な気もする。
    しかしそもそも ble-assert が発生するのは存在しないノードへの参照がある為であり、これがその原因とも解釈できる。
    もう少し動作を見て判断する必要がある。

    全体を探す前に念のため local arr=() の形式の誤りをしていないか確認を行っておく。
    他に2箇所その様な問題のある記述をしている箇所が見付かった。それを修正する。
    それを修正したら今迄出ていた assertion failure も出なくなった。
    echo $(echo) をしても何も起こらないし、また、cat <<< hello 等としても何も起こらない。良かった。

2015-08-16

  * [2015-02-21] <bug> [#D0231]

    word の属性が解除されてもそれが表示に反映されない。
    これはレイヤーの機能を使って実装した方が良いだろう。

    付記: 以下の問題もこの問題によるものだった。

    % * color: <bug> \ arg → \rm arg という編集をすると間の空白が構文再計算の対象から抜ける??
    %   →問題点は構文解析部分ではなくて単語に対する着色を削除する部分にある。
    %     構文解析や属性・単語の更新範囲の計算には問題がない事が分かった。
    %

    % echo file とした後 echo を C-d で消すとその直後の空白がエラー状態になる。
    % そのまま新しいコマンドを入力してもエラーの儘?
    % →再現しない?

    そればかりか…。前に存在していた word が消えた時 (word 以外の意味になった時)
    にそれを検知する術がない…。前回の word 配列を覚えておいてそれと比較する必要がある?
    二つの方向性がある。

    a parse で消えた word についての情報も提供する

      実は消滅した単語というのは、(1) DMIN DMAX0 の間にあったものと
      (2) _tail_syntax_word で使われなかった部分の2種類しかないのでは?
      代入する事によって上書きして消している word は存在しない。
      常にまっさらな所を i が走り、その i の箇所で word に代入しているから。

      (1) はどうせ削除されるから関係なさそうとも思ったが、
      DMIN DMAX0 の間にあった単語に関しても蔑ろにはできない。
      というのも DMIN DMAX0 の間に終端があって開始点は
      それよりも前にあるかも知れず、これらの単語が消える可能性もあるから。

      さて、parse の側でこれらの消滅について通知する事も出来るが、
      これは parse のするべき事なのかというと疑問である。
      もう少し別の方法…補足的情報を外部で取得する事によって、
      外部で消滅した単語の情報を取得する方法はないだろうか。

      (1) に関しては外部で既に計算する事が可能である。
      (2) に関しては…外部で計算前の _word のコピーを持っていれば、
      最後に処理した i さえ分かれば分かる。
      そして (将来的に変わるかも知れないが) _ble_syntax_attr_uend がそれに対応する。

    |
    | b 或いは、呼出側で前回の _word の内容を覚えて置いて消えた物がないか確認する。
    |
    |   これだと比較する為には呼出側で覚えて置いた物について shift したりしなければならない。
    |   というか覚えて置いたとしても同一性を確認するのは骨である。
    |   範囲と種類が同じであったとしても内容が同じとは限らないし、
    |   内容までも覚えておくのは面倒である。
    |   それに内容が完全に一致したとしても本当に同一と言えるのか??? (同一として良い気がするが)
    |
    | c 更に別の方法としては呼出側で単語と描画属性の組を覚えておくというのもある。
    |   (これは独立したレイヤーとして扱うという事に近い)。
    |
    |   これを用いて毎回全ての単語に対して属性の適用を行う。
    |   但し、単語の描画属性が何になるかだとか引数の解析だとかは省略する。
    |
    |   然し乍らこれは結構なコストである。属性の適用についてキャッシュしていないから。
    |   それに消滅する単語に対する処理は結局考えなければならないので変わりない。


    改めて考え直す。parse 呼出元で呼出前の _ble_syntax_tree を保持しておいて、
    消滅した単語を検知するというのは面倒である。もっと良い方法がないか。

    呼出元で呼出前の状態を保持する場合にしなければならないのは以下の事である。
    1. 先ず初めに、parse による更新範囲を取得する。
    2. 1 で得た更新範囲に登録されている単語を列挙し、
      その単語が存在していた範囲を特定する。更新による shift に注意する事。
    3. 2 で得た範囲に含まれる文字について着色を再計算する。

    実際には消滅した単語の更新範囲 (上記 2.) さえ分かればよいのだから、
    それを parse の中で計算してしまうと言う手もない事はない。

    また、3. を実行するという事は、任意に与えられた範囲に対して
    入れ子構造を考慮に入れた着色を実行するという事になる。

    これは何れ対応しなければならなかったので難点とはならない。

    ∵現状では新規生成された単語の範囲内のみで入れ子構造を考えていたが、
      実はこの実装は不十分である。新規生成された単語に着色が為されない場合、
      本来その親節の着色を適用するべきであるが、現在の入れ子構造の処理方法だと、
      任意に与えられた単語の親を取得する事が困難である。
      仕様がないので現状では着色無し、という事にしている。
      更に、単語と単語の間の空隙に関しても親節の着色を適用すべき所であるが、
      % これについては現在の実装では何もしていない (前回の状態が残る)。
      これについては着色の更新範囲内に入った場合には属性を完全に削除する様に変更した。

    つまり、色々な小細工を考えても仕方がない。現状で既に問題があるのだから、
    入れ子構造を用いた再着色の実装は必須である。

    「任意に与えられた範囲に対して入れ子構造を考慮に入れた着色を実行する」のは結構骨である。
    後ろから入れ子構造を辿っていかなければ完全な木を構築する事が出来ないからである。
    実は、似た操作を shift の時にも行っている。一回木の構造 (というか親節へのポインタ) を生成してしまえば
    後はそれを使い回せばよいので、木の構造を何処かにキャッシュする仕組みがあると良いだろう。

    % 1 取り敢えず消滅単語の範囲を計算するコードを書く。
    % 1.1 更新によって消滅する部分については、parse 呼出前に確認する。
    % 1.2 再解析によって捨てられる部分に関しては、何とか parse から結果を借りる方法を考える。
    %   適当なフラグに従って tail_* に対して local を宣言しないようにすれば良いだけでは?

    parse をできるだけ弄らないように実装しようとしていたがどうも困難な様なので
    結局 parse 内に消滅単語呼出の追跡の為の関数呼出を書き込む事にした。
    取り敢えず実装した。以下の変数に範囲を記録する:
      _ble_syntax_vanishing_word_umin _ble_syntax_vanishing_word_umax

    2 入れ子構造に対して計算を実行するコードを書く

    現状で十分動いているので、一旦切る事にする。
    効率が悪くなったら再度考え直す。

  * color: <bug> echo hello world と入力してから echo を消去すると、 [#D0230]
    hello に適用されるはずの色が "hello world" 全体に適用されてしまう。
    内部の _ble_highlight_layer_syntax?_table 系統の配列の内容は正しい物になっているが、
    _ble_highlight_layer_syntax_buff の内容はずれている。

    ble-syntax.sh (ble-highlight-layer:syntax/update-attribute-table) の実装で、
    _ble_syntax_attr_uend とするべき所 _ble_syntax_attr_umax としている部分を見つけた。
    取り敢えずこれを修正する→直った。。。原因を探索することなく、案外呆気なく直った。

  * <BUG> 表示されている文字列と内容の文字列がずれている。 [#D0229]

    まとめ: これは ble-edit/dirty-range/update 実装中の2種のタイプミスによる物だった。
      今迄影響が出ていなかった(影響に気付かなかった)のが不思議な位に致命的なバグであった。

    C-d を連続で入力した時などに発生している。
    どうも描画用の配列に対する shift が正しく処理されていない様に見える。
    _ble_highlight_layer_syntax_buff の内容を見てみたが変な事はないようだ。
    →異常がないように見えた物のよく見たらちゃんと shift できていない様だ。
      実際の文字数よりも長い配列になってしまっている。

    もう少し詳しく見てみる事にする。これらの *_buff 配列は、
      function ble-highlight-layer/update/shift
    を呼び出す事によって shift している。そしてこの関数では DMIN, DMAX, DMAX0
    を用いて shift を実行している。一方で、ble-syntax/parse ではどの様に
    shift を行っていただろうか (もしかするとこれ自体も間違いを含んでいるかもしれない)。
      ble-syntax/parse text beg end end0
    の引数を参照している様だ。そしてこの関数は ble-edit.sh (_ble_edit_str.update-syntax)
    から参照されている。ここでは _ble_edit_dirty_syntax_* に格納されている情報を渡している様だ。

    一方で *_buff の shift に用いている DMIN, DMAX, DMAX0 の出所は何処だろうか。
      ble-highlight-layer/update
    において DMIN, DMAX, DMAX0 が設定されている。この関数では配列 BLELINE_RANGE_UPDATE に
    格納された情報をそのままコピーしている。配列 BLELINE_RANGE_UPDATE は、
      ble-edit.sh (.ble-edit-draw.update)
    関数で、_ble_edit_dirty_draw_* から読み出している。これらの、
    _ble_edit_dirty_draw_*, 及び _ble_edit_dirty_syntax_* の更新は、
      ble-edit.sh (_ble_edit_str/update-dirty-range)
    にて実行されている。同時に実行されているので両者の内容に変化が生じるとは思えない。

    という事は syntax の方も不当な shift/解析になっている可能性もある。
    但し、元の文字列を参照して解析を行っているので目立った問題が見えていないと言うだけと思われる。
    これについてもチェックする。ble-assert を試しに埋め込んで見る。
    やはり _ble_edit_dirty_draw_*, 及び _ble_edit_dirty_syntax_* の内容は常に同じになっている。

    すると問題点は dirty 領域の合成自体にあると思われる。試しに、

      $ ble-edit/dirty-range/clear --prefix=hello
      $ echo $hellobeg:$helloend:$helloend0
      -1:-1:-1
      $ ble-edit/dirty-range/update --prefix=hello 2 2 3
      $ echo $hellobeg:$helloend:$helloend0
      2:2:3
      $ ble-edit/dirty-range/update --prefix=hello 2 2 3
      $ echo $hellobeg:$helloend:$helloend0
      2:2:2

    もうこれだけで間違った合成になっている。全然駄目だ。ble-edit/dirty-range/update の実装を見直す。
    ちょっと見ても分からないので過去のログを見る事にする。ble-edit/dirty-range/update の実装の詳細については、
    2015-02-16 の実装ログに記録が残っていた。論理についてよく見てみたが誤りは内容に思われる。
    結局、結果の式に値を代入しても正しい結果になると言う事を確認した。
    再度、コードの方を見てみると…何と変数名を間違えている。delta とするべき所が del になっていた。

    直した。然し良く分からないのは、このミスだけだったら最終的な結果は 2:2:2 ではなくて、
    2:2:3 という謝り方をしていた筈なのではないかという事である。
    2:2:2 になるという事は未だ別の箇所で何かミスをしているという事ではないだろうか。。
    取り敢えず再度実行してみる…。

      -1:-1:-1
      2:2:3
      2:2:3

    今度は 2:2:3 がもう一度表示されるという結果になった。本当は 2:2:4 になるべきだ。
    手で計算しても 2:2:4 になる気がする。再度数式を追って何で 2:2:4 にならないのか確認する。
    と思ったら…endA0 読み出しの時点で beg を読み出していた…。

      -1:-1:-1
      2:2:3
      2:2:4

    今度は正しい合成になっている。

  * eval は builtin eval に書き換え。test は [[ ]] に書き換え。 [#D0228]
    builtin の上書きを阻止。他にも複数のコマンドの上書きを阻止する。

  * <bug> コマンドを編集中にカーソルの位置がずれて表示されている文字列と内部の文字列に齟齬が生じる。 [#D0227]

    これはどうやら read -t 0 で読み取ったキーシーケンスが不当に解釈されて、
    結果として不正な文字が編集文字列に挿入されるためのようである。
    どの様な文字が挿入されているかを調べてから対策を考える事にする。

    1 本来は不正な文字が挿入されたとしても正しく表示されるべきである。
      →不正な文字 (というか 0x80-0x9F) が挿入された時に M-^? と表示される様に変更を行った。
      (元の bash readline ではこれに対する対策は行っていない。従って表示がずれる。)

    2 また、不正な文字が挿入される過程についても調べる。

      挿入されている文字を確認した所 "M-^[" であった。
      つまりこれは ESC [ を受け取る為にこれを CSI の utf-8 表現に変換しているのが原因である。
      変換の際に bind '"\e[":"\xC0\x9B["' としているが、この "\xC0\x9B[" という列は
      bind を通じてしか読み取る事ができず read で読み取れる文字とは別である。
      bind で 1 byte 目を受け取った時点で read を実行すると 2 byte 目ではなく、
      "\e[" の更に次に来た文字を読み取ってしまう。
      "\e[" の 2/3 byte 目は全ての read が実行された後にようやく処理される事になる。
      つまり受信される文字の順序が変化してしまうのである。

      (実際に確かめてみた所、その通りだった。しかし、この場合だけでなく複数の文字に対して
      bind -x または bind している物の場合に同様の問題が発生しうる?
      →複数文字から1コマンドへのmappingの際には問題にならない。複数文字が来て初めて
      コマンドが実行される為、複数文字の順序が交換されたりする事はない。)

      解決方法は色々考え得る。

      | a read -t 0 を使う以外の方法を考える。
      |
      |   bind -s と相性の良い読み取り手段が有れば良い。
      |   例えば、bind -s で待機されている文字をコマンドから取り出す方法が有れば良い…
      |   がそのような方法があるとは思えない。
      |   或いは、bind を用いて次の文字を直ぐに受信できるかどうかを判定する方法さえあればよい?
      |
      | a' read -t 0 で次の文字が来ていれば再描画を行わずに bind を抜ける
      |
      |   実は read -t 0 を用いて次の文字がすぐに来る事が確認できれば、
      |   表示を省略して bind を抜けても良いのではないだろうか。
      |   再描画は次の文字を処理する為の bind で実行されるであろう。
      |
      |   問題は accept-line の処理中に、
      |   再描画が完全に終わっている事を前提として処理が行われているかも知れないという事である。
      |   (exec:exec の場合にはそうではなかったのでちゃんと再描画していたはずだが、
      |   exec:gexec の場合にどうなっているかは調べないと分からない。)
      |   →どうも exec:gexec の場合には
      |
      |     ".ble-edit+accept-line/process+$bleopt_exec_type" && return 0
      |
      |   によって bind を取り敢えず抜けてから exec:gexec の設定した trap の内部で
      |   再描画処理を実行するので、再描画を省略しても問題はない。というか、
      |   元々 bind 内部では再描画されない。
      |
      |
      | b "ESC [" を受け取る別の方法を考える。
      |
      |   bind '"\e[":"\C0\9B["' が悪い、という事ならば別の方法で受け取る方法を考えればよい。
      |   しかしこれは可成り苦しんだ事なので他に解決方法を見つけるのは難しい。
      |
      | c utf-8 decoder の内部状態を見て bind-s の処理中かどうかを確認し、
      |   bind-s の処理中であれば read -t 0 で次の文字を読み取るのを抑制する。
      |
      |   例えば現状だと "\e[":"\xC0\x9B[" としているが、代わりに
      |   "\e":"\xC0\9B" という事にすれば、最後の文字として \xC0 が来た場合には、
      |   次の read -t 0 を抑制するという風にするだけで問題は発生しなくなる。
      |
      |   実は内部状態を見なくても、その :bind の中で最後に処理された byte が
      |   C0 かどうかだけ見れば良いのではないかという気がする。
      |   但し "\e[" の代わりに "\e" に対して bind を行った場合。
      |
      |   % x しかし \xC0 で始まる文字は結構ある (u80-u7FF) ので、
      |   %   それらの文字の read -t 0 ができなくなるという問題点がある。
      |   % と思ったが、\xC0 は u80-u7FF では決して使われないのでこれは気にする事は無い。
      |   % \xC0 はいわば非正規化表現でしか使われないのでそれ程気にしなくても良い。
      |
      |   x この方法だと実際に次の文字が来ているのに、
      |     \e[ の回数 (bind-s を介した読み取りの回数) だけ
      |     再描画処理が実行されてしまうという問題もある。
      |
      |     というか、実は "\e[" の組合せだと utf-8 の内部状態を見ても bind -s の処理途中なのか
      |     どうなのかという事を判定できない (utf-8 decoder を弄れば出来ない事もないが) ので、
      |     "\e" に bind -s するのが現実的となる。しかし、そうすると "\e" を含むシーケンスは全て
      |     read -t 0 の抑制の対象になってしまい、入力の高速化には繋がらない。
      |
      |     とも思ったが "\e" の読み取り過程では実際のキー入力は発生せず、
      |     ble-decode-key または ble-decode-byte の内部状態を変更するだけで、
      |     再描画も何も処理されないので、read -t 0 で急いで読み取らなくても問題ないのでは?
      |     という気もする。とも思ったが、確かに byte 毎の処理は実行されないが、
      |     例えば矢印キーによる移動などを考えると key 毎の矢印キーの移動・更新は実行される事になる。
      |     その過程で syntax も更新されるだろう。key 毎に syntax を更新するという事なので、
      |     やはり入力には従来通りの時間が掛かってしまうと言う事と思って良い。
      |
      | c' utf-8 で来るはずのない byte \xFF を用いるという手もある。
      |
      |   % c において、多くの文字で read -t 0 ができないのを防ぐ為に、
      |   % →この問題は気にしなくても良いという事が分かった。
      |   % つまり、この方法は c と比べて何らの利点もない。
      |
      |   "\e":"\xFF\9B" 等としておいて byte \xFF が来たら次の文字では read -t 0 をしないという具合に。
      |   x この方法を用いる場合 utf-8 decoder に手を加える必要がある。
      |     或いは、ble-decode-byte:bind 側で \xFF のみを特別扱いして
      |     ble-decode-byte に実際には文字が渡らない様にするなどの対処が必要である。
      |   x この方法は utf-8 以外の文字符号化方式では使えない。
      |     或いは文字符号化方式毎に調整が必要である。
      |   x 更に、c でもう一つ問題だった \e[ の入力の際に処理を抑制できない
      |     という問題も解決されていない。
      |
      |   この方法は可成り実装が面倒なのと場当たり的なので、余り考えたくない。

      → a' の方針で行く事にした。簡単な実装だがちゃんと動いている様だ。

  * read -t 0 を用いて貼付などの際に入力をまとめて処理するという事。 [#D0226]

    実は read の timeout を 0 にして呼び出せば、これまでに入力されたバイトを全て読み出せるのでは?
    →意外と簡単に実装できた? と思ったが色々と問題がある様だ。

    1. bash-4.0 未満では文字を既に入力していても何故か read -t 0 に失敗する。

      (何も入力がない時には単に失敗するだけなので、bash-4.0 未満では単に動作しないだけである。)

      bind -x 内部で実行している為に環境が違って read -t 0 が動作しないのかとも思ったが、
      実際に通常のスクリプト (test/readbyte.sh) として実行してみてもやはり動作しない。

      改めてマニュアルを見てみると read -t 0 について言及があるのは bash-4.0 以降の様だ。


    2. 日本語の文字を入力した時に変な事になる。

      bind -x で受信しているのはバイトである。一方で read で受信できるのは、
      bash-4.0 以降では文字である。日本語を入力すると、日本語の 1 byte 目は bind で受信され、
      2 byte 目以降は read で読み取る事になる。この時に、

      - read で読み取られた不完全なバイトをどの様に処理するか
      - byte 単位で読み取られた文字と文字単位で読み取られた文字をどの様に区別するか
      - 現状不完全な byte の内容取り出しに失敗している (printf %d '文字 は常に 0 を返す様だ)。
        →否、負の数を返してる様だ?

      が問題になる、解決の方法としては、

      a byte/char を区別する方法を考える。

        byte の場合、read の結果に不完全な文字が入っているという事なので、
        原理的に区別はできる筈だが…。また、区別できたとして、
        不完全な byte の内容を取得できる必要がある。

      b read でバイト単位で読み取る方法を考える。

        試しに LANG=C を read につけて読み取るなどしてみたが効果は無かった。

        →どうやら LANG=C をつければちゃんと byte 単位で読み取られる様だ。
        しかし、その直後の s2c で LANG=C を付けていなかった為に
        変な結果になっていたという事の様だ。

2015-08-15

  * ble-syntax.sh: `function ...' 対応 [#D0225]

    先ず関数名に使用する事の出来る文字について確認しておく必要がある。

    使える物: [][:%=~^{}@+-*:,.?/_]
    使えない物: [	 "$&'();<>\`|]
    条件付き:
      !    shopt -H して置かないと履歴展開されてしまう。
      #    単語の先頭には使えない (コメントになる)
      \001 使えるが実際に定義される関数名は何故か \001\001 になる。
      \177 使えるが実際に定義される関数名は何故か \001\177 になる。

    $'[^#\t\n "$&\'();<>\\`|][^\t\n "$&\'();<>\\`|]*'

  * ble-syntax.sh: `hoge ()', `function hoge ()' 直後のコマンドに制限をかける。 [#D0224]


2015-08-14

  * ble-syntax/parse/shift.impl2: <bug>: echo $(echo hello) hello で1つ目のhelloをBSで削除すると無限ループになる。 [#D0223]

    取り敢えず今は、古い実装を使う事にする。

    ble-syntax/tree-enumerate ble-syntax/parse/shift.impl2/.proc1

    の内部で無限ループになっている様である。
    どうやら一箇所に複数の節が登録されている時に
    一番外側の節に出会った時に一気に shift を実行してから、
    内側の節に対する処理を続けるという形にしていた為に不整合を生じていたようだ。
    一気に shift をするのではなく自分に対応している所だけ shift をする様に変更したら問題は発生しなくなった。
    取り敢えず、これで一旦解決とする。


  * [2015-03-08] <bug> $() を閉じると中身に色が着かない。 [#D0222]

    $( だけ書いて中身を記述している時は正しく着色されている。
    $( の中の引数も、コマンド名についても同様に着色の対象になっていない様だ。
    ( ) の中については正しく処理されている様に見える。

    原因は分かった。$() 全体が一つの単語となっている為に
    $() 全体としての着色が施され、内部にある個々の単語の着色が消されているという事だ。
    これをどの様に処理するのが良いかは考える必要がある。
    例えば zdepth 的な物を使って被覆されない様にするとか?
    しかし、それだと単語が消滅した時に困る。
    より上の階層にある単語の色を使いたいが
    その情報は失われているので単語の色を再計算しなければならない。

    一応適用順序を範囲の広い物が先に行われる様に修正したが、
    それでも部分更新に際しては完全ではない。
    やはり部分更新と単語毎の着色は親和性が低いのだろうか。

    これに完全に対応する為には現在存在している全ての単語について
    どの様に着色をしているかの情報を保持する必要がある。
    その為には必然的に単語の生死を完全に追跡する必要がある。

    実は単語の生死を追跡するのは簡単なのではないか?
    単語の生成に関してはわざわざ述べる迄もない。
    単語の消滅に関しても beg-end0 に存在していた単語と、
    shift 後に j2-i に存在していた単語が消滅する単語と分かっている。

    ただし、問題は単語が消滅した事が分かったとしてどの様に着色を修正するのかという事である。
    親単語が変更された時に全ての子単語について再度着色をするのは大変であるが、
    各単語の着色については _ble_syntax_tree に記録してしまうという手もある。

    入れ子構造が変化した時の着色の変化をどの様に適用するかについて二通りの方法を考え得る。

    a 着色の変化を考慮に入れるべき範囲を先に計算し、その範囲内の各点について色を計算する。
      この方法を用いるとどの部分を再度着色し直さなければならないのかという事を計算しやすい。
      一方で、各点がどの色になるのかという計算が難しい。
      愚直にやると各点についてその点に存在する word を列挙しなければならず現実的でない。

      実は末端から順番に着色を進めていけばそんなに複雑な操作をしなくても着色ができるのでは?

    b 生成・変更のあった各単語について着色を実行する。

      単語に overlap がある場合に複数回着色されて非効率に思われるかもしれないが、
      親単語から順に着色を実行する様にすれば他の単語の事は考えずに自然に着色が出来る。
      問題点は親単語の一部でも変更があると、その親単語に含まれる全ての子要素について再度着色を実行する必要が生じることである。

      特にこの問題はトップレベルの単語が消滅した場合にも拡張される。
      トップレベルの単語が消滅した場合、その部分の着色は解除されて既定の色になるべきである。
      しかし、単語に対して着色を実行するだけで、既定の色を適用するという操作をしなければそこに色が残ってしまう。
      結局トップレベルの文脈で既定の色を適用するという操作が必要になるのである。
      しかし、トップレベルで既定の色を適用すると全ての単語について再度着色を実行しなければならなくなる。

    c もっと効率的な実装はないだろうか?

      例えば CG で複数の物体が重なり合っている場合にどの様に処理を行うか?
      CG の場合には毎回全てのオブジェクトを描画し直すという事をする気がする。
      その場合には z-depth を用いてどのオブジェクトが前に来るかの判断を行う。

      今回の場合には単語の入れ子構造の情報を持っているので z-depth を考える必要はなくて、
      単純に親のノードから順に着色を実行していけばよいだけの事である。
      従って z-depth だとかの手法は今回の場合には訳に立たない。

      今回特に考えたいのは "部分更新" である。
      部分更新の対象は、生成された単語に対する着色、消滅した単語についての着色解除を含む。
      更に、コマンドに応じた着色を行っている際には、単語自体に変化が無くても着色が変化する事もあるだろう。
      これらを効率的に処理するにはどうしたら良いだろうか。
      特に最終的に "その点の配色" を格納した配列を更新・取得できればそれで良い。

      % 例えば単語の depth 毎に配列を用意してそこに値を記録するという方式は?
      % →単語のレベルがまとめて上がったり下がったりする時に大移動が起こる。非効率である。
      %   更に、depth が深くなれば成る程より遅くなる。

      % 各点についてそこに存在する単語へのリスト構造を保持する方式は?
      % この様にすれば或る単語が削除された時に、その位置に次に存在する色を直ぐに取り出す事ができる。
      % →リストを管理するのが大変である。
      %   単語の生成・消滅に際してリストへの登録・解除を行う必要がある。
      %   単語自体はその範囲情報を伴っているので、どの範囲に登録・解除をするべきかという情報を追加で持つ必要はない。
      %   逆にリストの各項目がどの単語に対応しているかという情報が必要である。
      %   shift が起こった場合などには更に面倒な事になる。
      %   余り考えたくない方法である。単語が削除された時にその下にある色を取得する方法としては大袈裟すぎる。

    色々考えたが a の方法が現実的な気がする。もう少し案を具体化する。

    先ず、単語自体の着色と結果の着色は独立に扱う。

    単語自体の着色情報は _ble_syntax_tree に補足情報として追加する事にする。

    > 1 _ble_syntax_tree に色情報を記録できる様にする。
    > 1.1 4と即値で指定している所を修正する。
    > 1.2 _ble_syntax_tree の幅を5に増やす。未設定の状態では - を置く。
    >   終端していない単語の場合には - の代わりに -- を置く事にした。
    > 1.3 長さや内容の変化した node についての色も - に戻す。
    >   _ble_syntax_word_umin 等に登録を行う。
    >
    > 2 更新された単語について色情報を再計算する。
    >   同時に色情報の変化のあった範囲を記録する。
    >
    > 3 色の変化のあった範囲に関して色配列を更新する。

    取り敢えず実装した。$() の中も期待通りに着色されている。
    一旦此処でこの項目は解決とする。

    削除して消滅した単語について着色が除去されない、
    速度について検証していない、等の問題点はあるが、
    これらは後で問題になってから考えればよい。

  * leak variables [#D0221]

    > cs ps1out                             # local 宣言忘れ
    > rex=$'^([ \t]*)(\\([ \t]*(\\))?)?'    # local rex 宣言忘れ
    > rmax=-1 rmin=-1                       # local rmax rmin 宣言忘れ
    > type='$('                             # parse/nest-type -v type 前に local type 忘れ
    > tchild=11 tprev=-1 wbegin=-1 wtype=-1 # parse/nest-pop を parse の外側で呼び出していたのが原因

    現在 g が leak している事が分かっているが、使用箇所が分散している為に見つけるのが面倒。
    → g も処理した。

  * ble-syntax/parse: shift チェックのループが遅い。 [#D0220]

    [現状]

    % これはどんなに後ろの方であっても挿入位置に wbegin や inest の参照があるかもしれない
    % という可能性が否定できない所に問題点がある。取り敢えず、この可能性があるかないか
    % 判定する簡便な方法について考えてみる。
    %
    % 1 削除領域内に word 開始点や nest 開始点がなければこのチェックは免れられる。
    % 2 word 終了点や nest 終了点は一つの開始点に対して一つまでしかない

    と思ったが、stat の有効性のチェックは上記の様に工夫すれば省略を考えられるが、
    shift に関しては結局全てチェックしなければならないので意味がない様に思う。
    ただ、stat や word を相対位置で覚えておくようにすれば、
    編集領域に跨る word や nest 以外についての shift をしなくても済む様になる。

    % どの様にすればスキップを行う事ができるだろうか。
    % 先ずは stat から考えてみる事にする。
    % inest の可能性について。
    %
    % 1 編集領域の終了点でトップレベルならば中で始まった inest が外で閉じる事は無い
    %
    %   編集領域の前と後で nest level が同じ場合、新しい inest が中で始まっている可能性はあるだろうか。
    %   と思ったが、ある。xxxx の中で一旦括弧が閉じて再び括弧が始まる可能性などを考えなければならない。
    %   但し、xxxx が top の nest level にある場合には中で括弧が閉じる事は出来ないので inest が中にあるとは考えにくい。
    %   (ただ、inest の境界などで何が起こるかは慎重に考えなければならない。)
    %
    %   まとめ: 編集領域の開始点と終了点でトップレベルならば中で始まった inest が外で閉じる事はない
    %   と思ったが、別に開始点はトップレベルでなくても関係ない。終了点でトップレベルならば関係ないのだ。
    %
    % 2 編集領域の終了点での inest が編集領域の開始点よりも前を指しているのならば、
    %   中で始まった nest が外で閉じる事はない。
    %
    %   というかつまり編集領域の終了点で inest が編集領域の内部を指していなければ OK という事である。
    %
    % 3 編集領域の終了点から順に見ていって、一度でも inest が編集領域よりも前を指したならば、
    %   それ以降に編集領域の内部を指す inest が現れる事はない。
    %
    % 3 は 1,2 の一般化になっているので 3 だけチェックすれば OK である。
    % もっと条件を課す事が出来ないかとも考えたが、長いネスト領域の開始点を編集した時に
    % 多少処理に時間が掛かるという事は不自然な事ではない。
    % 長さ(相対位置)を補正するのに時間が掛かっているのだなという事は想像できるだろう。
    %
    % 次に stat に格納されている wbegin について。基本的に wbegin についても同じである。
    % wbegin は通常 inest よりも更に下の構造である。つまり inest < wbegin の筈である。
    % この事が使えるかは分からない。
    % 少なくとも言える事は wbegin も inest と同じ様な判定方法ができるという事である。
    % ここで更に考えたいのは inest と wbegin を組み合わせてより効率的に中断をできないかという事。
    % もう少し考える inest < wbegin であるのならば、
    % wbegin < dbeg になった時には inest も wbegin も更新を中断して良い。
    % しかし inest < dbeg となった段階では未だ wbegin が dbeg より手前にあるかもしれない。
    % でも少なくとも word は同じネストレベルの中で構造は作らないはずだから、
    % 一旦 dend0 < wbegin となったならばそのネストレベルでは二度と wbegin が編集領域内に現れる事は無いだろう。
    % 但し、一つネストレベルを抜けた時にまた wbegin が編集領域内に現れる可能性はある。
    % 一つネストレベルを抜けた時にまた wbegin が現れない為の条件は何か?
    % これは何とも言えない。抜けたネストレベルの inest が編集領域内にある限りは
    % 常に wbegin が編集領域内に新しく現れる可能性を排除できない。
    % 逆に inest < dbeg なネストを抜けたら OK という事になる。
    %
    % wbegin も考慮に入れた時の中断の条件を更新する:
    %
    % 4 編集領域の終了点から順に見ていって始めに以下の条件を満たした時に中断できる
    %   inest < dbeg かつ ( wbeg < dbeg または dend0 < wbeg )
    %   この時に inest が再び編集領域内部に現れる事は無いし、
    %   また wbeg も編集領域内部に現れる事は無い
    %
    %   仮定: word は或るネストレベルの中で構造を作る事はない
    %     (これは現在の解析の仕組み上保証されている様に思うので特別に意識する必要はない)

    此処まで書いて気付いたが、上は編集領域内に inest や wbegin がない事の条件であって、
    inest や wbegin の相対位置を補正しなくても良い条件ではない。
    相対位置で記録した場合に inest や wbegin の補正が必要になるのは、
    編集領域の長さが変化し、かつ、inest や wbegin が編集領域よりも前を参照している場合である。

    一方で編集領域の長さが変化しなかった場合でも、
    word の invalidate が必要になるのでループを回す必要は残る。
    いっその事 word の invalidate は別のループで処理した方が良いのかも知れない。
    word の invalidate に関しては上記の方法でループを回すのを中断して問題ない。

    思うに、尻からで良いからネストの構造を掘り出す事ができる様なデータを記録するべきだという気がする。
    特に、直前のネスト構造ノードへの nest の offset を保持する様な。
    全ての点について一々ネストノードだとか stat だとかが設定されているかどうかをチェックするのは大変である。
    考えなければならないのはその様なデータ構造自身も shift の対象としなければならない事、
    それから文脈値 (stat) が同じになった時に解析の中断をしてデータ構造が壊れないかどうか考える事。

    少し考えてみる。その様な掘り出すのに必要なデータは何かというと…。
    先ず、途中から解析を再開できる様にする為にはその点よりも後の情報を含んでいる様なデータは保持できない。
    従って、必然的にノードはデータ構造の末尾に置く事になる。
    1 兄(末尾)のoffset 2 親(先頭)のoffset 3 末子(末尾)のoffset である。
    親の offset に関しては兄を辿っていけば早晩に辿り着くので記録しなくても良い。
    というか、親の offset は stat の inest に記録されているのでわざわざ此処で記録する必要はないし、
    そもそも親の末尾の offset さえ知っていれば問題なく、
    これは掘り出す過程で知っているはずなので各ノードのデータに含める事は考えない。

    更に良く考えてみたら自身の情報についても格納しなければならない。自身の先頭の offset も含める。
    データの内容について改める。
      data="${自身の先頭のoffset} ${兄(末尾)のoffset} ${末子(末尾)のoffset(子がなければ -1)}"

    [2015-08-11] 取り敢えず _ble_syntax_* に含まれるポインタを offset (長さ) で表現する様に書き換えた。

    [2015-08-13] _ble_syntax_tree (旧 _ble_syntax_word): 入れ子構造を記録する様に変更

    入れ子構造の情報を利用して shift を実行するコードを書いてみた。
    しかしそれ程高速化はしていないようである。もっと積極的に shift の skip を行うべきか?
    しかし、取り敢えずはこれで良いという事にする。

  * [2015-08-13] _ble_syntax_tree (旧 _ble_syntax_word): 入れ子構造を記録する様に変更 [#D0219]

    shift の際に入れ子構造を考慮に入れたスキップをする為に、
    入れ子構造を記録・構築する様に改良を行う。

    % 整理2015-08-12
    %
    % 改めて _ble_syntax_* の形式についてまとめる:
    %
    % | _ble_syntax_text    解析結果の対象の文字列を記録
    % | _ble_syntax_stat[]  文字 #i を解釈する直前の解析状態
    % |   ctx     現在の解析の文脈
    % |   wlen    現在のシェル単語の継続長さ
    % |   wtype   現在のシェル単語の種類
    % |   nlen    現在の入れ子段階の継続長さ
    % | _ble_syntax_nest[]  入れ子の情報
    % |   ctx     入れ子を抜けた時の復帰状態
    % |   wlen    同上
    % |   wtype   同上
    % |   nlen    同上
    % |   type    入れ子の種類を表す文字列
    % | _ble_syntax_word[]  境界 #(i+1) で終わる単語の情報を記録
    % |                     (つまり単語の最後の文字の位置に記録されると思えば良い)
    % |   wtype   シェル単語の種類
    % |   wlen    シェル単語の長さ
    % |
    % |   ※境界#(i+1) (または境界#i が word[i-1] に対応する) の様に1つずらして格納しているのは、
    % |     部分更新の際の配列の切り貼りを他の配列と同様に行える様にする為である。
    % |     基本的に配列の切り貼りは、添字 data[i] に対応している情報はその境界の右にある文字に附属していると見做して実施される。
    % |     従って単語の情報は単語を構成する最後の文字、つまり添字 i-1、に附属しなければならない。

    [計画]

    - 入れ子構造を利用して効率的に shift を実行するためには、
      入れ子構造の情報を残して置かなければならない。
      現状の実装では入れ子構造の情報の一部は _ble_syntax_nest 等に残存しているが、
      解析終了後に再び構造を調べるのに十分な情報は記録されていない。

    - 入れ子構造を構築するに当って、word に関する入れ子構造の管理は不要である。
      というのも、word が入れ子になっている場合には
      必ず nest を通して入れ子になっているはずだからである。

      ただし、word を効率的に列挙して処理を実行するためには
      "前のword" に対するポインタを word 情報に含めておくのが良い。
      →しかしそうすると prev_word ポインタについても
        shift を考えなければならないという面倒な事に…。

      nest に関しては自分の親、自分の兄、自分の末子に対するポインタを保持する。

    - どこにどの様な形式で情報を格納しておくかというのも考える必要がある。
      既存の _ble_syntax_* のどこかに入れ子構造を記録するという形にするという手と、
      新しく _ble_syntax_tree などの配列を作成してそこに記録するという二種類の方法がある。

      既存の _ble_syntax_* のどこかに記録するとしたら _ble_syntax_word が適切であろう。
      ちょうど _ble_syntax_word は解析の動作自体に影響は与えず「出力」としての効果を持つ。
      また、word と nest の入れ子構造を統合して統一的に記述できる可能性がある。
      この変更にあたって _ble_syntax_word の中身の形式を大幅に変更してしまっても良い。

      新しく _ble_syntax_tree などの配列を作成して管理する事にすると、
      x 切り貼りをしなければならない配列が増える。
        元々 sparse な配列なので無駄に切り貼りの作業を増やしても損した気分になる。
      x word/nest の両方について入れ子構造を辿るのも面倒かも。

      _ble_syntax_word を改造して形式を一新する方向で考える。
      まず、現在 _ble_syntax_word が使用されている箇所について確認を行う。
      - 単語の登録・shift
      - 色付け (syntax/update-word-table)
      - debug 用コード (print-status など)
      現在の形式は "wtype wlen" である。此処にどの様な情報を付加するべきか?
      - word と nest は同じ箇所で終了する可能性がある。
        したがって両方登録できる様にするべきである。
        同じ箇所で終了する場合、word の内部に nest があるという構造になっている。
      - word の親と nest の親は必然的に同じである。
      - word の親はなしまたは nest である。nest の親はなしまたは word である。
        word が word の親になっていたり nest が nest の親になっている事はない。

      a 案 "wtype wlen parent prev child ..." というのはどうだろうか。
        [[ $wtype == ^[0-9]+$ ]] の時に word でありそれ以外の時に nest である。
        child > 0 の時は末子はその offset の位置に存在する。
        child == 0 の時は末子は同じ位置で終了し ... に末子の情報が記録される。
        既に登録されている場合には "wtype wlen parent prev 0 既存内容" などとすれば良い。

        % ? 疑問点: 前回の解析までに存在していた内容を消去しなくても良いのか?
        %   前回の内容はいつ消去されるのだろうか。
        %   何処かで削除を実施しないと、前回の解析の結果が混ざってしまう。
        % - これは今迄の実装でも注意しなければならなかったはずだ。
        %   前回の解析で単語の終端だった部分が新しい解析で単語の途中になった場合、
        %   前回の解析で生成された単語が消去される機会が失われてしまう。
        % →前回の解析で存在していた内容を気にする必要はない。
        %   これらは配列の切り貼りの時点で削除され _tail_syntax_word に移動される。
        %   途中で解析状態が同一になった時にのみ _tail_syntax_word から再度コピーされる。
        %   つまり、解析する時には _ble_syntax_word は空文字列になっているので
        %   前回の内容の残存については気にしなくて良い。

        この方法ならば同じ位置で複数のレベルの word が終端する場合にも対応できる。
        今現在ではそのような単語の区切り方は存在し得ないが、柔軟な構造にしておいた方が見通しが良いだろう。

        ? nest-push の type として [0-9]+ の様な物が存在していると word と区別が付かない。
          そのような物が存在していないことを確認する必要がある。
          → grc --exclude=out nest-push で確認した。その様なものは今のところない。OK

    [実装]

    上記 a 案で行くことにする。

    1 先ず初めに word に登録する関数を準備する。これで word を登録する様に変更する。動作を確認する。
    2 word に別の情報も登録できる様に word 読み取り部分の変更を行う
    3 nest 情報も pop 時に登録する様に変更する。print-status の改良

    4 兄情報・子情報も登録する。入れ子になっている部分も shift する

    > (a) 兄情報・子情報をその場で計算して登録するという可能性?
    >
    >   兄情報・子情報も登録するためには stat に兄情報・子情報を記録する必要がある?
    >   もし兄情報・子情報をその場で計算して求めることができるのであれば、
    >   わざわざ現在の解析状態に含める必要はないのではないかということ。
    >
    >   ? stat に記録を行わなくても _ble_syntax_word, _ble_syntax_nest 等を用いて
    >     兄情報・子情報を構築することは可能だろうか?
    >
    >     兄は max { 終端 | 親の開始位置 < 終端 <= 自身の開始位置 } の筈である。
    >     また、子は max { 終端 | 自身の開始位置 <= 終端 <= 自身の終端位置 } の筈である。
    >     親の開始位置は、
    >       wbegin が設定されている場合は wbegin が、
    >       inest が設定されている場合は inest が、
    >       それ以外ならば初期位置 0 が該当する。
    >     自身の開始位置・終端位置は知っている。
    >
    >     これらの情報を用いれば兄情報・子情報を必要になった時に構築する事は可能である。
    >
    >   ? 解析時は兄情報・子情報はローカル変数に保持しながら解析して、
    >     ただし、stat から復元する時には兄情報・子情報を再構築するという方法はどうか?
    >     nest-pop の際にも同様に構築する必要が生じるのでは?
    >     これだとコストがかかってしまうので、nest-push の際にまとめて兄情報・子情報も push して良い。
    >     しかし、その様にするのであれば stat にも同様に保存してしまえば良いのではという事になる。
    >     但し面倒なのは、兄情報・子情報を stat/nest に記録する様にしてしまうと、
    >     兄情報・子情報に対する shift も実装しなければならないという事である。
    >
    >   取り敢えずの方針としては、shift の実装が面倒なので兄情報・子情報は stat/nest には含めない。
    >   代わりに word に登録する際に毎回自分で兄情報・子情報を計算する、という事にする。
    >
    >   問題点
    >
    >   ? 兄情報・子情報は shift だけで良いのか?
    >     stat に登録していない為に兄情報・子情報がずれていても
    >     解析状態が同じになったと判定されてしまう可能性がある。
    >
    >     →削除された領域にあるノードを参照している stat は削除すればよい。
    >       stat で現在参照しているのは wbegin, inest である。
    >
    >     % 但しチェックする範囲が広がるのが難点かも知れない。
    >     % →stat に兄情報・子情報を記録する場合でも stat の更新範囲が広くなるので
    >     %   結局どのようにしても同程度チェックする範囲が広がる。気にしなくて良い。
    >
    >     →削除された領域にあるノードを参照している弟ノードはどうするのか?
    >       それも削除すると更にその弟も再構築の対象になり…を繰り返して結局すべて解析し直す事になる?
    >       更に、削除された領域にあるノードでなくても、
    >       解析状態が一致しないことによって再解析が行われて失われる word も存在している。
    >       それらを兄情報・子情報として参照しているノードはどの様に取り扱うべきか。
    >
    >     結局 _ble_syntax_* に記録された昔の情報を参照して構築する方式だと、
    >     部分更新した際に不整合が生じてしまう。
    >     昔の情報を参照して構築した部分をすべて再計算しなければならなくなるが、
    >     どの部分がどの部分の昔の情報まで使って構築したかの情報がないので、
    >     すべて再計算しなければならなくなる。
    >     (一応各ノードを調べれば再計算が必要かどうかを得ることができるが、
    >     いずれにしてもすべてのノードについてそのチェックを実行しなければならない。)
    >
    >     因みに _ble_syntax_nest に関しては過去の情報を使用して解析が実行されるが、
    >     解析状態一致の確認の際にはちゃんと _ble_syntax_nest の一致まで確認されている。
    >
    > (b) 兄情報・子情報に対応する情報も stat に含めて計算を実行する
    >
    >   word/nest が混合しているのでどの様に取り扱うかが微妙である。
    >   兄にしろ子にしろ (ある条件を満たすノードで) 最後に登録したノードへのポインタになる。
    >
    >   何れにしても wbegin/inest 設置の瞬間に兄・子の情報も更新する必要があるような気がする。
    >   inest 設置の瞬間の処理については nest-push で行えば良い。
    >   wbegin 設置については新しく wbegin 設置用の関数を置くことにするか?
    >   先ず初めに wbegin 設置位置について確認を行う。
    >   →主に3箇所の wbegin 設置箇所があったので新しく関数を用意してそれに置き換えた。
    >
    >   更に解析状態を表す tprev, tchild という変数を追加した。
    >   tchild は現在の level で一番最後に設置された節の位置を表す。
    >   tprev は一つ上の level で一番最後に設置された節の位置を表す。
    >   child/prev というのは現在の節からの視点であって、
    >   現在の位置に新しく設置する節からの視点ではないことに注意する。
    >
    >   ? stat に tprev/tchild を記録する必要は実はないのではないか?
    >     というのも解析再開時に状態を復元する際は、
    >     過去のデータ配列の内容を参照して良いはずだから、
    >     わざわざ記録しなくても計算で tprev/tchild を再構築できるからである。
    >
    >     →やはり記録する必要はある。stat には2つの役割がある。
    >       一つは解析再開時に解析途中の状態を復元する役割であり、
    >       もう一つは解析状態が一致したかどうかを判定して、
    >       解析を中断するための参照状態となる役割である。
    >
    >     前者の役割を果たす為には tprev/tchild は再構築できるので不要であるが、
    >     後者の役割を果たす為には参照用の tprev/tchild を保持している必要がある。
    >     (後者の場合でも、一応 "古いデータ配列を全て覚えておいて、かつ解析状態の比較の際に
    >     毎回古いデータ配列から tprev/tchild を再構築して一致するか確かめる" という力技もあるが、
    >     それはさすがに遅くなるのでやはり記録をする。)
    >
    >     結論: stat に tprev/tchild も記録する。
    >
    >   ? nest に tchild を記録する必要は実はないのでは?
    >     nest は pop した時に状態を復元するためにある。
    >     ところで pop した時に新しい節が作成されて tchild は上書きされて消える。
    >     どうせ直後に上書きされて消えるのであれば記録する意味は無いのでは?
    >
    >     解析状態の一致の際にもチェックする必要はないように思われる。
    >     というのも結局使われない情報であるため、
    >     もしチェックをせずに違いを看過したとしても最終的な結果には何の違いも出ないからである。
    >
    >     % また記録するとその分また shift のコストが上がるという事を意味する。
    >     % 取り敢えず nest には tchild を記録しない方針で行くことにする。
    >
    >     実は nest の tchild は必要のようだ。
    >     nest の下に word を構築する際、word に入って word から抜けた時に tprev を復元しなければならない。
    >     それが実は nest-push した時の tchild に対応している。
    >
    >   ? word-pop 後の tprev について現在のデータ形式で自然に再構築できるか?
    >
    >     word-pop 後は nest の level (または top level) に必ずいる。
    >     というのも word の下に word は直接来ないからである。
    >     word-pop 後の tprev は何を意味するかというと、現在の nest-level の前の nest-level である。
    >     これは nest-push する直前の tchild を意味する。
    >
    > 取り敢えず (a) で実装したが (b) に方針転換する事にする。

    4.1 word-pop の際の tprev の再構築?
    4.2 ble_syntax_stat の形式変更
    4.3 check
    4.4 新しく追加した項目の shift

    > shift は再度整理して書き直す事にする。
    >
    >   不可解な実装になっている部分についても再考察を行う。
    >
    >   ? stat 無効化に於いて wbegin/inest の判定範囲が
    >     更新領域 beg-end0 ではなく再計算領域 i1-j2 になっているが、
    >     無効化は更新領域に被る時にだけ行えば問題ないのでは?
    >
    >     或いは実は原則を破っている箇所があった為にこの様になっていた?
    >     例えば var[]= の部分に関しては、元々原則を破った実装になっていた。
    >     (現在は、この部分に関しては保留中である。
    >     最終的には word 着色で var[] としての着色を上書きしてしまうなどすれば良い。)
    >
    >   ? stat の shift に於ける無効化チェックは必要なのだろうか?
    >
    >     原則さえ守っていれば stat/nest の解析状態チェックだけでOKなのでは?
    >
    >     元々この様にした理由は、無効化がないと不正確な stat が残ってしまうという事である。
    >     % この不正確な stat の状態で解析を続行しても続きのデータを再現できない可能性がある。
    >     % つまり、この事により予期しない解析中断が生じる可能性がある。従って無効化は必要である。
    >
    >     →本当だろうか? 不正確な stat (その様な stat が生成される機会はなかった) としても
    >     stat が一致している以上は後続のデータも全く同様の物が生成されるのではないだろうか?
    >     つまり、stat を無効化するかどうかの判定は「前回の解析の shift だけで同じ stat が生成されるかどうか」
    >     ではなく、もっと許容的な「後続のデータを再現することができる stat」という条件にするべきという事である。
    >
    >     逆に stat が壊れた状態になったとしても、
    >     後続のデータと整合する様に修正する事ができれば無効化する必要はないという事になる。
    >     stat の wbegin/inest が指し示している部分が消滅した時の wbegin の変更の仕方を一つ決めればよい。

    5 check: チェックの為に print-status に構文木の結果を表示する。

    5.1 未だ終端していない入れ子構造についても正しく処理する必要がある。

    > 例えば shift を計算する範囲を決定する際に愁嘆していない入れ子構造の部分を跳ばす事はできない。
    > 終端していない入れ子構造についてどの様に処理を実行するべきかは、print-status の実装で試せばよい。
    > 他の shift 等に対しても同様の処理を実行する際には print-status の実装を真似すれば良い。
    >
    > 一つの方法は無理矢理終端させた時のデータ配列を作成して、
    > その配列に対して処理を実行する方法である。
    > この様にすればデータ配列の形式に従ってそのまま処理を実行する事が出来る。
    > 終端していない節と終端した節 (データ配列に格納された節) が混合したままだと、
    > それに対する処理を上手に書くのが面倒なように思われる。
    >
    > 何れにしても print-status の実装を終端していない節に対応する過程で再考察を行う。
    >
    > 何だか良く分からなくなったので、結局終端していない入れ子構造についての情報を変数 tree に集計した後で、
    > ("${_ble_syntax_tree[@]}" "$tree") に対して処理を実行するという形にする事にした。
    > 関数 ble-syntax/tree-enumerate proc, ble-syntax/tree-enumerate-children proc を使う。
    > proc には各節を処理する関数名を指定する。
    > これを用いて print-status も実装した。多分動作している。

2015-08-11

  * _ble_syntax_* の単語・入れ子開始位置の記録方法を変更 (絶対位置 wbegin → 相対位置 wlen) [#D0218]
    記録点からの負のoffset(単語長・入れ子継続長)で指定する事にした。

    % 整理2015-08-11
    %
    % 何やらよく分からなくなってきたので改めて現在の状況についてまとめることにする。
    % まず、現在の _ble_syntax_* のデータは以下のような形式になっている。
    %
    % _ble_syntax_text    解析結果の対象の文字列を記録
    % _ble_syntax_stat[]  文字 #i を解釈する直前の解析状態
    %   ctx     現在の解析の文脈
    %   wbegin* 現在のシェル単語の開始位置
    %   wtype   現在のシェル単語の種類
    %   inest*  現在の入れ子の開始点
    % _ble_syntax_nest[]  入れ子の情報
    %   ctx     入れ子を抜けた時の復帰状態
    %   wbegin* 同上
    %   wtype   同上
    %   inest*  同上
    %   type    入れ子の種類を表す文字列
    % _ble_syntax_word[]  境界 #(i+1) で終わる単語の情報を記録
    %                     (つまり単語の最後の文字の位置に記録されると思えば良い)
    %   wtype   シェル単語の種類
    %   wbegin* シェル単語の開始位置
    %
    %   ※境界#(i+1) (または境界#i が word[i-1] に対応する) の様に1つずらして格納しているのは、
    %     部分更新の際の配列の切り貼りを他の配列と同様に行える様にする為である。
    %     基本的に配列の切り貼りは、添字 data[i] に対応している情報はその境界の右にある文字に附属していると見做して実施される。
    %     従って単語の情報は単語を構成する最後の文字、つまり添字 i-1、に附属しなければならない。
    %
    % shift の対象となるのは * で示した項目である。
    % 現在、内部構造を表現する情報に nest と word の2種類がある。
    %
    % A word&nest を統合する可能性について:
    %
    %   word と nest を別々に管理していることによって、
    %   shift 対象の管理がより面倒になっている様に思われる。
    %   nest は解析のために必要な入れ子の情報であり、
    %   word は解析には必要がないが解析の結果として呼び出し元に提供する情報である。
    %   どちらも似た様な入れ子構造を構築することには変わりないが使い方が多少異なる。
    %
    %   x どちらも同じ位置で二段階の入れ子を作ったり抜けたりする事はない、
    %     という前提で実装されている気がする。
    %     統合するとしたらこの前提が成立しなくなるので注意する必要がある。
    %     例えば echo $(command),$(command) となっている場合、
    %     echo の第一引数の単語は、開始点で2段階の入れ子を作成し、
    %     また、最終点で2段階の入れ子を抜ける事になっている。
    %     (ところで、単語と解析の入れ子が交錯する様な事態は起こらないので、
    %     多段階の入れ子作成・解除にさえ対応すればそれで問題はなくなる。)
    %
    %   x word/nest は微妙に異なる構造の構築になっている気がする。
    %     word は word の終了時にその性質が決定され、末端に情報を格納する。
    %     word が開始した時点では word 情報は確定していないので、
    %     配列には記録せずにむしろ解析状態 stat に現在の word を直接記録している。
    %     一方で nest は入れ子が開始した時点で、
    %     それがどの様な入れ子なのかが確定するので、開始点に全ての情報を格納できる。
    %
    %   x 何より完全に解析部分を再実装することになりそうなので統合したくない。
    %     現在の実装では、解析の制御に最低限必要な部分を nest に格納している形になっていて、
    %     解析の制御に関係のない word の部分は分離している、という体である。
    %     Shift 時の複雑さには目を瞑ってこのままで良い気がする。
    %
    %   →上記の色々な理由から word&nest の統合は取りあえず断念する
    %
    % shift 時は単純に該当する項目の補正を行うだけではなく、
    % 無効になった word, nest を参照している stat を削除するという事もする。
    %
    % B 単語の開始位置を offset で管理している場合:
    %
    %   単語が完全に更新領域の外側にある時は書き換えの必要性はない。
    %   単語の開始点が更新領域に含まれている場合、
    %     単語は消滅する。この単語を参照している stat (解析状態) も同時に削除しなければならない。
    %     削除しておかないと、再解析の結果として偶々同じ stat になった時に解析が停止してしまう。
    %     # 或いは、解析が停止するのならばそれで良いのではないだろうか?
    %     # 全く同じ状態になったのであれば以後の計算をしても同じ結果になるはず。
    %     # もし同じ結果にならないのであれば shift/状態復元 に失敗しているという事だから、
    %     # そちらを修正するべきということである。
    %     # これは shift を正しく実行できないのだとしたら削除するべきということでもある。
    %     # 今、単語の開始位置の表現を変更した為に、前と状況が変わっているかもしれない。
    %     # この辺りの stat を削除するかしないかについては再度慎重に検討するべきである。
    %     この単語を参照している nest は、使用されることがないので放置で良い。
    %     何故ならば解析再開点は nest が記録された位置よりも前になり、
    %     また…(本当か???)
    %   単語の内部に更新領域が含まれている場合
    %     その単語の長さの修正を行う。
    %   単語の終端だけが更新領域に含まれている場合
    %     単語は word には記録されていない。
    %     stat にある相対位置だけ修正を行えば問題ない。
    %
    %   →考えるのが面倒になったので実際に実装してしまう事にした。意外と簡単に済んだ。
    %     _ble_syntax_{stat,word,nest} に対して内容の形式を変更した。
    %     先ず単語の終端が更新領域よりも後にある場合にしか単語の shift は必要ない。
    %     (というのも、単語の終端が更新領域よりも前にある場合は勿論 shift は不要だし、
    %     単語の終端が更新領域の内部にある場合は単語自体が無効になるからである。)
    %     そして更に単語の長さが変更になるのは単語の開始が更新領域よりも前にある場合である。
    %     (というのも、単語の開始が更新領域の内部にある場合には単語自体が消滅するからである。)

  * <bug> 履歴が正しく初期化されない [#D0217]

    何かコマンドを実行した後に history-prev を実行すると、
    直前に実行されたコマンドが表示されず、少し昔のコマンドが表示される。
    幾つか遡っていくと直前に実行されたコマンドが表示される。

    history で表示されるコマンドは正しいコマンド順になっている。
    また、遡っていって直前に実行されたコマンドに行き着けば、
    それより前は正しいコマンド順になっている様である。
    余分コマンド (直前に実行したコマンドと履歴リストの末端の間にあるコマンド)
    に対応した抜けがある訳でもなく、余分コマンドと同じコマンドが幾つか繰り返している。
    どうやらコマンド順が変になっているのではなくて、
    履歴のリストの末端に余分にコマンドが追加されているという事のようだ。

    どうやら .bash_history に空行があると駄目な様だ。
    .bash_history の空行は初期化の際に読み取られないので行番号がずれる。
    行番号がずれていると history -n で追加読み取りした部分がずれる。
    →.bash_history の空行を削除したら問題は発生しなくなった。

    と思ったが、それでも ble.sh を起動してからコマンドが追加されたりして、
    その後で初めて履歴を使う、という事をするとまた履歴が末尾に追加されて分かりにくい。

    % 無条件で履歴を読み取るのではなくて、履歴エントリが空の時にだけ読み取る様に変更するべきでは?
    % →履歴エントリが空の時にだけ読み取る様にすると、
    %   一回でもコマンドを実行すると過去の履歴が辿れなくなる。
    %   履歴の初期化をせずにコマンドを実行したときの履歴の処理はどうしているのか。

    再度履歴情報の取り扱いについて整理する:

      履歴情報は2段階ある。shell が持っている history 情報と、
      ble で取り扱えるようにシェル変数に格納した履歴情報である。
      ble の履歴情報の初期化には時間がかかるのでできるだけ遅延したい。
      bashrc 処理時には shell の history にまだ履歴が読み込まれていない。
      bashrc の処理が終了して対話状態になった時には shell の history は初期化されている。
      しかし、ble の履歴情報はまだ初期化されていない状態である。
      ble でコマンドを実行したときには shell の history に情報を追加する。
      ble の history 情報が既に初期化されていればそちらの更新も行う。

    結局、shell の history が空の時にだけ読み取る様に変更することにした。

2015-08-09

  * complete: <bug> リダイレクトのファイル名でファイル名補完が効かない。 [#D0216]
    →対応した。
  * complete: <bug> .# で始まるファイルを扱うために .\# などとして tab をしても補完が効かない。 [#D0215]
    →再現しない。再度改めて試してみたが、補完は問題なく動いている様である。

  * complete に関連する過去の修正 [#D0214]
    - 変数= の補間でファイル名を取り扱える様にする
    - > の直後のファイル名の補間が働かないのを修正
    - (command) ディレクトリ名の直後に / を挿入する

2015-04-25
  * complete: 補間挿入: 既に直後に '/' または ' ' がある場合にはこれらの文字を挿入せずに次に文字を進める。 [#D0213]
  * complete: option hoge=, hoge: の続きにファイル名を指定できる様にする [#D0212]

2015-03-22

  * ble-decode.sh: bugfix, bash-4.1 でも ESC * に登録しないと駄目 [#D0211]

    一回でも ESC z 等を bind -x で登録して解除すれば OK になる。
    しかし、一回も bind -x をしていない状態だと
    ESC 単体で登録しても何も起こらない。
    どの bash の version でも ESC * に対して張る事にする。

    今度は ESC [ を捕まえられなくなった。
    bash_execute_unix_command: cannot find keymap for command のエラーになる。
    bash-4.3 と同じ症状である。結局 bash-4.3 と同様に ESC [ を変換する事にする。

2015-03-11

  * ble-syntax.sh: <bug> 単語の先頭に空白を挿入すると空白が単語の一部とされる [#D0210]

    % 単語の先頭に文字列を挿入した時に単語情報 _ble_syntax_word が更新されない。
    % 結果として単語の先頭位置が更新されず、空白も単語の一部と解釈される。
    %
    % 本来であれば wbegin の位置が変化しているのだから _ble_syntax_stat が一致せず、
    % 単語の終端まで行って漸く _ble_syntax_stat が一致する筈である。
    % 単語の終端まで行くのであるから word の情報も再設定されるはずという算段である。

    これは単に単語の shift が実行されていない事が原因であった。
    元々は、単語の登録は必ず stat の設定を行った箇所でしか起こらないと決めていた。
    従って shift 判定の時は stat に値が設定されている時にだけ単語の shift の確認を行っていた。
    所が、shift の判定を stat に値が設定されているかどうかに拘わらず実行する様にしたら、問題が発生しなくなった。
    これはつまり stat の設定が行われた箇所とは異なる場所で word が設定されているという事を意味する。

    - よく考えてみれば for の直後などでも空白を飛ばしているので for に対する word の箇所では stat が起きない。
      つまり、この場合にも stat が設定されている事を前提とした word の shift は動かない事になる。
      と思ったが改めてみてみると for の直後には stat が設定されている。
      改めて考えてみれば for の直後の状態は CTX_CMDXF で表現する様に変更したのであった。

    - 問題の発生していた例 "echo hello" の場合には word の位置に必ず stat が設定される様に思ったが、
      これで問題が起きていたという事は echo の終端位置に stat が設定されていないという事を意味する。
      実際に echo hello を解析した後に stat の内容を吐き出してみたが、stat が設定されているのは、
      (echo の直前、hello の直前、終端) の三箇所だけになっている。
      改めて ctx-command/check-wrod-end を見てみると、
      関数定義に対応した時にコマンドの後の空白を読みとばす様に変更したのであった。

  * <bug> i-word[1]: substring expression < 0 [#D0209]

    time : $(echo | echo | echo) を time : $(: | : | :) に書き換えている最中に
    bash-4.0: i-word[1]: substring expression < 0 というエラーが出た。
    bash-4.0 と bash-4.1 で再現したが、再度起こそうとしても起きない。
    起きる条件が良く分からない。

    エラーメッセージに現れる式は ble-syntax.sh の
    ble-highlight-layer:syntax/update-word-table
    にしか現れない式である。wbegin の shift に失敗しているのだろうか。

    再び起こった。今度はもう少し違ったパターンだが共通点はある。
    $() の中で | の直後の単語の一部を削除している時に起こったというのが共通点である。
    しかし似たような編集を再度実行しても問題が再現しないようである点も同様である。

    多少 shift の部分に手を加えた。これで解決したかは分からない。

    追記:

    "単語の先頭に空白を挿入した時に空白が単語の一部になる" バグの修正の際に、
    word は必ずしも stat の設定された場所だけに設定される訳ではない、
    という事が判明しそれに対する修正を行った。
    この修正の前は shift するべきなのに shift されていない単語があった事になる。
    この substring expression < 0 の問題もこれに関連していた可能性が高い。
    再度 $() 等を入力して色々してみても問題は再現しないようなので、
    取り敢えずこの bug に関しても解決したと解釈する事にする。
    実際には解決されていないとしても、再び問題が発生した時に考える事にする。

2015-03-08

  * cygwin 上で prompt の色がついていない。 [#D0208]

    _ble_line_prompt の内容を覗いてみると、
    何と ps1out に CSI 99s や CSI 99u が残っている。
    また、\e[32m も本来ならば \e[0;32m 等に翻訳されている筈なのにそれがない。
    要するに ps1esc がそのまま出力されている様に見える。
    出力幅が22桁余分である事から CSI sequence を認識していない様に思われる。
    先頭の CSI の部分だけ無視して残りを普通に出力している。

    試しに以下を cygwin 上で実行してみた所、失敗する。(linux の上では成功する。)
    rex_csi=$'^\e\\[[ -?]*[@-~]' && [[ $'\e[99s' =~ $rex_csi ]] && echo hello
    何故だろう。locale の問題かも知れない。と思って LANG=C としたら成功した…。
    更にプロンプトにも色が着くようになった…。

    然し、LANG=C にしていると今度は日本語があった場合の動作が怪しいのではという気がする。
    →実際に日本語を入力してみると大変な事になる。なので一時的にだけ LANG=C にしたい。
    実装した。テストは未だしていない。→テストした動くようになった。

  * <bug> bash-4.1 以下でカーソルの表示位置がずれている。 [#D0207]
    現在のカーソル位置の追跡自体は誤っていない様に思われる。
    という事は、移動先の cx cy の算出を誤っているという事か?

    bash-4.1, 4.0, 3.2 で起きる。bash-3.0, 3.1, 4.2, 4.3 では起きない。
    調べてみると getxy.cur の返す値が変である。
    変な値を返している時に _ble_line_text_cache_pos の中身を確認したが問題ない。
    と思ったら ((_eoc[2]&&(_pos[0]=0,_pos[1]++))) が駄目であった。
    bash のバグで条件分岐内で配列要素を参照できないのであった
    (参照するとその branch が必ず実行される)。

  * <bug> bash-4.2, 4.0, 3.2, 不完全な編集内容に対してエラーが出る。 [#D0206]

    i=${ で駄目。
    bash-4.3 では起きない。bash-4.1 でも何故か起きない?

    どうも正規表現が正しく動いていない様な気がする。
    →これは正規表現中の "'" を無駄に多く escape していたのが原因であった。
    '[^']*' で済む所を \'[^\']*\' としていた事による。
    然し \' になっていた時の解釈が謎である。例えば以下が一致する。

    rex="^([^\$]|\\'[^\\']*\\')+\$" && [[ 'i$' =~ $rex ]] && echo hello

    上で 'i$' を '$' にすると一致しない(正常)。
    上をこれ以上単純化する事は出来なかった。

    何だか良く分からないが \' を ' に修正したら問題は起きなくなったのでこれで解決とする。

  * <bug> bash-4.0, 4.1 でプロンプトが表示されない [#D0205]
    これは declare DRAW_BUFF としただけの時に、
    ${#DRAW_BUFF[*]} が 1 になっている事が原因であった。

  * <bug> bash-4.1 以下でプロンプトの色が着かない。。 [#D0204]
    何と、_ret="${specs[++i]%%:*}" を実行すると i が 2 増える…。
    つまり配列の添字を複数回評価しているという事になる。

    色々試してみた。
    i=1; _ret="${a[++i]%%:*}"
    - a が配列でない場合には起こらない。
    - %%:* がない場合には起こらない。
    - %%:* の代わりに #a 等でも起こる。${a{++i]#a} では起こらない。

2015-03-07

  * ble-decode.sh: CSI Function Key Sequence を特別扱いする? (2015-02-28) [#D0203]

    現在の登録作業は些か無駄な事をしている様な気がする。
    ble-bind の出力も exaustive になっているし、
    テーブルも巨大な物になっていて declare や set の時に見苦しい。

    - .ble-decode-char 再実装した。
    - それに伴って .ble-decode-char/csi/* も追加し、
      CSI シーケンスを特別に読み取る様に変更した。
    - また、cmap/default.sh も大幅に変更した。
    - 修飾の機能は sendkey の方で一括で行う様に変更する。
      C-x @ S 等に対して ESC と同様の修飾の機能を与える。

2015-03-06

  * ToDoの整理 [#D0202]

    > 2015-02-17
    > * for 等の末端が赤くならない
    >   →コマンドとしての着色によってエラー色が上書きされていた。
    >   着色の "レイヤー" に対応できる様にしたい。その後で再度考える。

    これは改めて確認してみた所、赤くなっている。
    単語の色付けよりも後にエラーの着色を行っている為であろう。
    エラーに関しては又後で仕組みを整えるつもりであるが、
    特にこの問題に関しては解決済という事にする。

    > 2013-06-10
    > * <lbug> complete: ~ で始まるパス名の場合、
    >   ディレクトリ名の末端に / を追加したり、
    >   ファイル名の末端に SP を追加したりする機能が機能しない。
    >   これは test -e "$hoge" としてファイル名がどうかを判定している時に、
    >   hoge の中に含まれている ~ が展開されない為である。
    >   同様に ~user で始まる形式のパスについても期待通りに働かない。

    これは新しい complete の仕組みの元では問題なく動作している。
    単語を eval で評価してから候補を生成している事により見た目の表現には関係なく動作する。

  * overwrite-mode に対応 [#D0201]

    | 2013-06-06
    | * overwrite mode
    |   + 開始時は insert
    |   + self-insert, delete-backward-char で対応するだけで OK
    |   + 現在のカーソル位置を反転して表示する

    ble-edit+overwrite-mode 実装、self-insert, delete-backward-char の対応。テスト。
    test (overwrite-mode): OK, accept-line 後のリセットOK
    test (self-insert): 半角を半角で上書き、全角を半角で上書き、半角を全角で上書き、全角で全角を上書き。
    test (self-insert): 行末での半角挿入、行末での全角挿入、改行の挿入
    test (delete-backward-char): 編集文字列終端での削除、文字列中途での削除、行末での削除、行頭での削除

    TAB や改行が関係する場合の emacs の動作について調べる。
    - 改行とタブを挿入する場合は次にある文字を削除する事はしない様だ
    - 改行を上書きする事は無い。タブを上書きする時はタブの終端に達する場合にはタブを削除する。
      終端に達しない場合にはタブをそのまま保持する。
      面倒なので ble では取り敢えずはタブを常に保持する事にする。

    →xterm の場合は元からカーソル位置を反転して表示する様になっている。
      この状態でカーソル位置の属性を反転させると二重に反転して、カーソルが見えなくなってしまう。
      カーソル位置の別の表現方法を考える必要がある。
      或いはカーソルの大きさを制御するシーケンスを出す? カーソルを隠すシーケンスを出しても良い。
      $'\e[?25l' $'\e[?25h' を発射してカーソルを隠す。

    カーソルの反転は layer で行うか、それとも描画部分に対して完全にハードコードするか。
    ハードコードする前回書き込んだカーソル位置の情報を再び回復しなければならない。
    別に layer として実装した時と比べて実装が楽になる訳でも無い様に思われる。
    layer として実装した。無駄に複雑になったように思うが取り敢えずテスト。
    - insert を toggle しても即座に反映されてない
      →これは .ble-line-draw.update の更新判定に登録するのを忘れていただけ。
    - 前の文字の反転が解除されない
      前回の buffer の内容を流用しているのが行けないのかと思ったが、
      どうやら PREV_UMIN PREV_UMAX の方の問題の様である。
      とも思ったがそうでもない。どうも変な動きをすると思ったら、
      そもそも上のレイヤーでの更新に失敗している様だ。/update/getg を弄った事が原因だろうか。
      確認してみると ble-highlight-layer:syntax/update で
      ble-highlight-layer/update/getg を呼び出すべき所で、
      ble-highlight-layer/getg を呼び出していた。つまり layer:syntax 側でのバグであった。

      ble-highlight-layer/update/getg を呼び出す様に変更してみた物の、それでも何か変だ。
      良く考えたら /update/getg でも駄目だ。自分自身を含めないと行けない。
      ble-highlight-layer:syntax/getg を呼び出して空だったら ble-highlight-layer/update/getg を呼び出す様に変更した。
    - bugfix: PREV_UMAX の計算
      insert mode の時に途中を編集するとカーソルの位置が狂う。
      C-u を押した時のカーソルの位置が変。
      C-u 等、overwrite と関係なく見える物でも起こっているので、別の箇所のバグかと思いきや、
      layer:overwrite_mode を外すと上記の現象は起こらなくなる。
      色々試した結果 oindex の shift を間違っている所為で PREV_UMAX が変に大きな値になり、
      その所為で座標位置が 0 0 にあると勘違いされてずれるという事が分かった。

2015-03-05

  * ble-edit.sh (ble-edit/draw/trace): 描画属性も詳しく。 [#D0200]

    描画属性の追跡も実装した。
    これに伴って、プロンプトの最後の文字の属性も(限定的ではあるが)取得できる様になった。

    | 2015-02-23
    | * bleopt_suppress_bash_output 制限
    |   - プロンプト最後の文字の SGR が消える。これに対応するにはプロンプト中の SGR を解析しなければならず大変。

    完璧な対応という訳ではないが、これで上の問題は解決された。

2015-03-04

  * 修正: 環境での行末での動作 [#D0199]

    編集の行が減った時に削除される行が間違っている気がする。
    長い行を編集してその行が短くなった時の動作に問題がある。
    というか行が減った後のカーソルの表示位置が変だ。
    内部的なカーソルの位置(挿入位置)は正しいようだ。

    どうも丁度ぴったり columns に収まる時の座標計算の問題?
    →カーソルを動かしてみると座標計算自体は問題ないようだ。
    やはり前の行の最後の位置にいるにも拘わらず次の行の先頭にいると勘違いしている様に見える。
    問題は何故前の行の最後の位置に移動してしまうのかという事である。

    % 分かったような気がする。座標計算と部分更新に問題がある。問題点は結構複雑な気がする。
    % 現在、update-positions で計算されるのは「次の文字が表示される位置」という事になっている。
    % これは指定した位置へカーソルを移動させるのに使う。カーソルの移動先は、
    % そこに存在する文字の先頭にあるべきである。
    %
    % 一方で、部分更新をした後にカーソルが存在している位置、というのは xenl cap のある端末では
    % 実は次の文字が表示される位置とは異なっている。
    % 行末の文字を出力した時にカーソルはその行の末端に留まっている。
    % 所が、update-position に格納されているのは、次の文字の開始位置である次の行の先頭である。
    % この時に勘違いが起こる。これを解決するには update-positions に格納されている情報の意味を考え直すか、
    % 或いは、update-position とは独立に文字を出力し終わった後の位置の情報も管理するという事である。
    % 後者は余り考えたくない。殆どの場合で文字出力後の位置と次の文字の開始位置は同じである。
    %
    % どの様な場合にずれが生じるかというと、
    % 1 行末=次の行頭
    % 2 行末近くに wide 文字が存在して入りきらずに次の行へ送られている場合
    %   現在の計算だと次の表へ送られる場合は先頭に行末を埋める padding をつける事になっている。
    %   例えば " あ" 等としている。この時カーソルの位置は "あ" の位置ではなく行末の空白の位置になっている。
    %   これはどちらに表示するべきか改めて考えた方が良いかも知れない。この状態で例えば "a" 等と入力すると
    %   行末に文字が挿入される事になる。カーソルは依然として "あ" の位置ではなくて行末にあるべきなのかもしれない。
    %   しかしながら、例えば↑キーで更に次の行の行頭から移動してきた時に、カーソルが二つ上の行の行末に来るのは変である。
    %   そういう意味から言うとあの先頭にやはり文字を置くべきなのかも知れない。
    %
    % 少なくとも三種類の位置が存在する
    % - 部分更新出力後の位置:
    %   これは部分更新をした後の座標計算に必要である。
    % - 部分更新開始の位置:
    %   これはカーソルの表示位置とは異なる。例えば行末の " あ" の場合には、
    %   カーソルの表示位置は "あ" の直前に来るが、
    %   部分更新の開始位置は " " の直前になければならない。
    %   しかし出力後の位置とも限らない。例えば出力後に行末にカーソルがある場合、
    %   そこから部分更新の出力を開始しようと思っても、そもそも其処にカーソルを移動させる手段がない。
    %   (xenl の厄介な所は文字を出力した時にだけ行末にカーソルが来る可能性があるという所である。)
    %   そこ場合は移動先を次の行頭に変更しなければならない。
    % - カーソルの表示位置:
    %   これは次に来る文字が何かに依存する。
    %   positions の部分更新なども考えるとこれは記録せず、出力後の位置から計算する方が良い。
    %   例えば次に改行が来るのであれば行末だし(でも行末にカーソルを移動させる方法はない■)、
    %   それ以外の文字が来るのであれば次の行頭である。
    %
    % どの箇所で getxy が呼ばれているかについて確認する
    % 意外と呼び出している場所は少ない様である。
    % (改めて考えてみればそんな物だろう、というのは
    % 元々は update-positions は x y endx endy cx cy 等のシェル変数を通して
    % 直接計算した値を返していたからである。つまり、結果は呼出元の関数でしか使っていなかったという事である。)
    %
    % - 先ず、カーソル位置へ移動する時の cx cy と、
    %   bleopt_suppress_bash_output= の時にその左の文字 lc を取得する時。
    % - 後、描画領域を確保する為の begx begy endx endy
    % - それから部分更新の為の umin umax → uminx uminy umaxx umaxy
    % - また、矢印キーによる移動の際の移動先の計算
    %
    % 取り敢えず、_ble_line_text_cache_pos に格納するのは
    % その文字の開始位置ではなくて、前の文字の終了位置という事にする。
    % その文字の開始位置は前の文字の終了位置から計算する事が出来る。

    + bugfix: ascii printable characters の行末で \n を付加した時 ichg に登録していなかった。
      と思って update/postion を変更しようとしたら新しい事実が発覚した…。
      そもそも xenl の場合、行末に来た文字の末尾には \n を付けて、
      文字を出力した際に必ず次の行頭に進むように調整をしていた。
      しかしながら、ASCII 文字が連なっている場合の最適化として
      位置を設定しているループの部分で、「変更文字」ichg のマークをつけていなかった。
      これの所為で実際の出力には \n が反映されておらず期待した位置とは異なる位置に
      文字が出力されるという事態になっていた。

      取り敢えずこれで問題点の一つは解決される事になる。
      そしてまた、上の考察で区別しなければならないとしていた部分更新後のカーソル位置と、
      部分更新開始時のカーソルの位置の違いがなくなった。
      更に、行末にカーソルが来ない事を保証しているので、
      部分更新開始時の位置として行末が来た場合に其処にカーソルを移動できないという問題にも引っかからない。
      (結局、\n を末尾に追加するというのは特に重い処理でもなく、
      また実装も面倒ではなく、そもそも実装されていたというのが考察の上での穴であった。)

    上記の部分を修正してテストしてみた所、表示がずれるという問題は解消された。
    しかし問題(といえるかどうかは分からないが)は未だ残っている。
    行末に入りきらなかった wide character の先頭に移動した時のカーソルの表示位置である。

    + bugfix: _ble_util_string_prototype の長さ指定に 0 を指定していた
      試してみたらかなり微妙な事になっている…。空白が挿入されていない! と思ったら
      x=cols を設定した後に空白を挿入していた。修正した。このバグはこの前全く同じ物を潰したような気がするが…。
      →検索してみたら結構色々な所に似たようなコードがある様だ。(余り良い事とは言えない…)

      また、これに伴って意図的に terminal の幅を縮めた時の折返しの処理も正しくされる様に、
      xenl の時に (本当の端末の端にいる時には敢えて付加しなくても良かった) \n を付加する様に変更した。

      更に、^? や ^A 等の特殊な制御文字の場合についても追い出しを実行する事にする。
      (bash の readline ではこれらの特殊文字の表現に関してはわざわざ追い出しはしないようだが。)

      また、行末付近での tab の取り扱いについても変更を行った。
      特に一番右端にいる場合には " " + 改行を入れる。
      (所で ble-edit/draw/trace の方の tab の取り扱いも同様の問題があるのでは、
      と思って確認してみた所こちらについてはちゃんと実装されていた…。)

    先ず _ble_line_text_cache_pos の形式を変更した。今迄は "x y" だったが、
    更に、入りきらない文字が追い出しされたかどうかを判定する為に "x y wrapping" とした。
    wrapping=0 が通常の文字 (出力開始位置とカーソルの位置が同じ) で、
    wrapping=1 が行頭に押し出された文字 (出力開始位置は前の行の最後、
    カーソルの表示位置は行頭) を表す物とする。
    カーソルの位置を取得する場合には wrapping を見て、((x=0,y++)) 等とする。

    更に、出力位置の制御に用いる getxy とは別に
    カーソルの表示位置を制御する getxy.cur を用意した。
    カーソル移動などの際に参照するのは専ら getxy.cur である。
    また get-index-at 関数も getxy.cur を参照する様に変更した。

    テスト: と、実装してからテストしてみたがずれている…。
    % 改めてみてみると wrapping の格納位置がずれている。
    その文字が wrapping の対象となるかどうかは、その文字を処理してからでないと分からない。
    従って、その文字の終端の境界に wrapping の情報を格納する現在の実装は正しい物である。
    寧ろ、参照する時に「現在の文字の位置」ではなく「次の文字の位置」の wrapping を参照するべきである。
    →この修正で自然な動作をする様になった。

  * ble-edit.sh: プロンプト内の job count 等の情報が更新されない。 [#D0198]
    →新実装で取得したデータのキャッシュを local に設定するのを忘れていた。

  * ble-decode.sh (stty): -icanon の設定。 [#D0197]

    何故か bless を起動してその儘抜けると入力しても反応しなくなる
    →無限ループに陥っているのかと思ったらそうではない様だ。
    →どうも入力が buffering されている様で C-d を押した時に初めて入力が読み取られ、
      それまでに入力した内容が一気に書き込まれていく。
    →stty で bless 前後を比較してみると stty -icanon が stty icanon に変わっている。
      stty -icanon を設定し直したら正常に表示される様になった。
      stty.enter で -icanon も設定する事にする。

2015-03-03

  * ble-edit.sh: prompt 再実装 [#D0196]

    | 2013-06-06
    | * <bug> PS1 に $() などが含まれているとプロンプト位置を正確に計算する事が出来ない。
    |   _ps1txt の方を eval してから再度位置の計算をする?
    |   →それだと _ps1txt, _ps1esc の両方について $() の展開をしなければならない。
    |     つまり、$() が2回実行される。これは意図しない動作になるかもしれない。
    |
    |   例えば \[ ... \] を [ - ] などに変換して出力し、
    |   その後で [ ... ] を除いた物を用いて位置の計算をする?

    この問題が未だ解決されていなかったので。
    bash の PS1 に対する振る舞いも確認して再実装した。
    bash 内部では先に \? の部分だけ展開して、
    その後で "" に全体を入れて eval している様な振る舞いをする様だった。
    それに従って再実装を行った。幅の計算は eval の後に行う事にした。
    \? の解決と幅の計算を独立させた事により、実装は却ってすっきりとした物になった。

    | 2015-02-23
    |
    | * <最適化> プロンプト構築
    |
    |   改行を押し続けた時の反応が遅い
    |   プロンプトの更新を停止すると動きが速くなる。
    |   これはプロンプトの生成に時間が掛かっているという事。
    |   見てみるに高速化できる余地はそんなに無い様な気がする。
    |   jobcount を実行するのに subshell 実行が必要なのは気にはなるが。

    新実装に移行した後に再度確認してみたが、それ程気にならないのでこの問題は破棄する。
    新実装になった事で速くなったのかも知れないし、
    あるいは変わっていないが気分の問題で気にならなくなっただけかも知れないが。


  * ble-edit.sh, ble-edit.color: discard-line の際に着色 [#D0195]

    | 2013-06-02
    | * ble-edit+discard-line: 灰色にする

  * ble-edit.sh: bugfix, 複数行で上に行けない [#D0194]
    →_ble_line_begx _ble_line_begy に編集内容の開始点を格納する様に変更。

  * ble-edit.sh: bugfix, 複数行なのに空行の accept-line でのずれ量が1行になっている [#D0193]
    →行を更新した後に _ble_line_x=0 _ble_line_y=0 を設定する必要。

2015-02-28

  * <bug> 履歴項目を移動中色が更新されない例を発見 [#D0192]

    "[[ ; == \; ]]" から "arr=(a b<a c)" に移動した時、初めの 2 文字の色がそのままだ。
    これは良く考えたら word による着色を消していない事と関係がある。
    特に上の二つの文字列は長さが一致しているので、shift を呼び出しても
    shift の実行が省略される為に中身がクリアされない。
    これは word 着色のバグ解決の時に解決されるはず。

    長さが一致していても shift を実行する事にする。
    shift によって途中の編集部分がクリアされる方が動作として自然だからである。
    或いは、途中の編集部分に何が入っているか未定義、という事にしていると、
    一々使う側でクリアしなければならないからである。
    編集部分で前の属性などを保持するのは不自然であるし、
    使う側でクリアするよりは shift の内部で行っている様な繋ぎ替えの方がコストが小さい。

    →結局 shift 長さが変わらない場合でも shift を実行するように変更した。

  * 初期化最適化: ble-bind が遅い [#D0191]

    どうも ble-bind の遅さが、後続の bashrc をも遅くしている様である。
    手軽に ble-bind を呼び出す事ができないのは致命的なので performance の悪さについて調べる。
    どうも調べてみると ble-getopt が遅い様に思われる。
    手で解析を書いて試してみる…(面倒だ。似たようなコードを何度も書かなければならない。
    確かに ble-getopt の様な仕組みを作りたくなる物である。)

    ble-bind を ble-getopt なしで書き直してみる。
    今回は ~/.mwg/bashrc にある 7 つの binding について試してみる。
    1 ble-bind (old, using ble-getopt) 122ms - 100ms = 22ms
    2 ble-bind (new) 87ms - 78ms = 9ms
    新実装の方が半分以下の時間で実行できる様になった。
    これで現在 87ms で bashrc がロードされる様になった。

    所で ble-bind が全体でどれぐらいの割合を占めているかについても概算しておく。
    ble-bind が 9/22 の速さで実行できる事によって全体で 122 - 87 = 35ms 短縮している。
    (ble-bind old 時間) * 13/22 = 35ms なのだから、(ble-bind old 時間) = 59ms という事になる。
    実に半分を ble-bind が占めていた事になる。残りの 63ms が他の処理である。
    現在は全体で 87ms に迄減った。63ms (他) + 24ms (ble-bind) という形である。

    また、新しい実装についてより分かり易く実装できないかと、各オプションを関数に分けてみた。
    結果、94ms - 83ms = 11ms であった。それ程遅くはなっていない。
    他のコマンドのオプションを作る時にはこれを参考にしても良いだろう。

    さてこれで ble-bind の速度は割合改善したがそれでも定数倍である。
    本当はもっと速くなって欲しい。改めて現在時間の掛かっている部分の特定をする。
    引数の解析部分を飛ばして直接呼び出して速度を確認すると、
    83ms - 76ms = 7ms であった。という事は引数の解析は 2ms しか費やしていない。
    今度は実際の登録部分について最適化を試みるべきであろう。

    特に気になっているのは ble-decode-kbd の部分である。
    試しに ble-decode-kbd を再実装してみたがそんなに時間は変わらない。
    全体で 83ms である。元々 85ms であったから 2ms しか変わっていない。
    特にテストに使っている部分 (7ms) に限って言えば大体 2/3ms 程度しか速くなっていないという事。
    別の部分で時間が掛かっているという事だろうか。
    試しに ble-decode-kbd 単体の速度を測ってみる事にする。
    | time for ((i=0;i<1000;i++)); do ble-decode-kbd C-,; done → 292ms
    | time for ((i=0;i<1000;i++)); do ble-decode-kbd M-down; done → 295ms
    | 7 * 0.294ms = 2ms なので、全体の内 2/7 がこの ble-decode-kbd であると分かる。
    バグがあった。修正したらかなり変わった。
    | time for ((i=0;i<1000;i++)); do ble-decode-kbd C-,; done → 230ms
    | time for ((i=0;i<1000;i++)); do ble-decode-kbd M-down; done → 375ms
    正規表現によるマッチは結構重い??
    →正規表現ではなく ${key//[...]/} を用いて試したら 375 → 257ms 迄速くなった。
      所で、長さが 1 である事を確かめるならば、
      算術式で長さを求めてから比較するよりは glob の pattern で一致させた方が速い様だ。
    所で、旧実装を削除する前に改めて速度を測っておく。
    →C-, に対しては 346ms,  M-down に対しては 670ms である。
      全体の内 3.070ms / 7ms である。またこの事からこれ以外の部分に 4ms かかるという事が分かる。
    | time for ((i=0;i<1000;i++)); do ble-decode-kbd C-,; done → 231ms
    | time for ((i=0;i<1000;i++)); do ble-decode-kbd M-down; done → 257ms
    | → bashrc の 7 bindings に対し大体 1.667ms / (4+1.6)ms。大体 5/17 を占める。

    その他の部分で怪しいのは .ble-decode-key.bind である。
    押されるキーの数×2 の eval を実行している。
    しかしこれはどうしようもないので取り敢えず諦める。

  * ble-edit.sh: bugfix, .ble-line-info.clear で位置がずれる [#D0190]

    描画後の座標値の設定時に存在しない変数 x y を参照していた。これらは 0 であるべき。

  * 初期化の最適化 [#D0189]

    現在の初期化のボトルネックは圧倒的に history である (2015-02-09)
    →.ble-edit.history-load を多少最適化した。読み取り時間が約半分になった。
      それでも未だ全体の半分が history 読み取りである
      (しかし history を 16k も溜めている場合は少ないから、実際は無視できるかも)。

    | 改めて初期化の時間を調べる:
    | 多少なりとも時間が掛かっているのは以下の phase
    | - ble-core.sh                     58ms
    | - ble-edit.sh                    629ms (554ms が history, 75ms が他)
    | - ble-decode-bind.cmap            52ms
    | - ble-decode-bind                105ms
    | - .ble-edit.default-key-bindings 229ms
    | - .ble-edit-draw.redraw           35ms
    |
    | default-key-bindings を見るに ble-bind に平均 229/75 ms かかっている様だ。
    | これを考えると ble-edit.sh の中の 33ms も ble-bind の遅さに起因する。

    改めて初期化の時間を計る (2015-02-28)
    前回から、初期化と attach の分離、history 遅延ロードの実装など、
    初期化の順序・構成が変化した。

    1 ファイルの読込                 |  39ms
    2 ble-initialize
      ble-decode-initialize          |  53ms
      .ble-edit.default-key-bindings | 309ms -> 4ms
      ble-edit-initialize            |   4ms
    3 ble-attach
      ble-decode-attach              | 201ms -> 55ms
      ble-edit-attach                |   0ms
      .ble-edit-draw.redraw          |  36ms

    ble-decode-initialize は ble-decode-bind.cmap の現在の名前と思って良い。
    これのロード時間は大して変わっていない。
    この部分は基本的にファイルにキャッシュした配列を読み取っているだけである。
    しかしその容量が大きい為にこれだけの時間が掛かっている。
    CSI Funtion Key が大半を占めているので、これらを特別扱いする様にすれば多少は解消するかも。

    .ble-edit.default-key-bindings は前回よりも大幅に増えている。
    これは多少の bindings の追加を行った事もあるが、
    keymap isearch などの初期化を .default-key-bindings に統合した事もある。
    →これもファイルに dump を出力する様にした。これは 4ms と嘘のように軽くなった。
      ble-bind 自体に問題があるのかもしれない…。

    ble-decode-attach は前回に比べて大幅に増えている。
    これは bash-4.3 で ESC [ ... に bind する為に、
    全ての可能性に対して bind を実行している為であろう。
    (しかしそれでも元々 100ms 程度かかっていたのでここを直しても劇的に速くなるという事はない)。
    更に詳しく調べる。既存の bind の保存と削除は 31ms で済んでいる。
    全組合せに対する bind は 77ms 掛かっている。メインの bind に 91ms かかっている。
    実はこの部分をこそ最適化するべきなのかも知れない。
    →既存の bind の保存と削除の部分は awk の呼出が2回に渡っているのを1回にくっつけた。
      この部分は時間を計測してみたが 31ms の儘で変化しなかった。
    →結局全組合せに対する bind はしないで代わりに ESC [ を utf-8 で翻訳する方向にした。
    →また、メインの bind はコマンドを生成するのに時間が掛かっている様に思われたので、
      先にコマンドを生成してファイルにキャッシュする様に変更した。
      その為に新しく bind のコマンドを生成する為のファイル ble/bind.sh を作成した。
    結果として元々の 201ms から 55ms に迄ロード時間を減らす事ができた。

    これで一通り重い場所は解決したように思うので解決とする。

  * ble-decode.sh (.ble-decode-bind/generate-source-to-unbind-default): awk 呼出を一回に統合。 [#D0188]

    | * 既に bind -x してある物を削除するという事?
    |   bash-4.3 では bind -X が実装されたので bind -x した物を列挙できる。
    |   (但し、bind -r しても bind -X のリストには残ってしまう様だ @bash-4.3.33
    |   リストには残っているが実際には削除されている。)

    同時に上記の項目 (2015-02-09) も実装した。

  * ble-core.sh, ble-color.sh: .ble-shopt-extglob-push/pop/pop-all 廃止 [#D0187]

    ble-color.sh で、extglob を使った部分のコードの管理が
    好い加減面倒なので正規表現による実装に切り替えた。
    (そもそもこの部分は現在は使われていない部分ではあるが。)

    さて、.ble-shopt-extglob-push/pop/pop-all 関数は
    この部分でしか使われていなかったので削除してしまう事にする。
    別にそう大した実装でもないので。

  * history 遅延ロードについて [#D0186]

    これから本格的に常用する為にはできるだけ速くロードできる様にしたい。
    特にボトルネックになっているのは history である。
    history の遅延ロードの可能性について考える。

    現在の実装では history がロードされている事を前提にして書かれているので、
    できるだけ history の項目に触る前に history がロードされる事を
    保証する様に書き換えなければならない。
    特に history の interface を絞る事によって移行しやすくする事を考える。

    現在の所どの様な場所で history が参照されているかを確認する。
    先ず現在の history 項目の数を幾つかの場所で参照している。
    実はこれは HISTCMD 変数を用いて参照する事ができるのではないか?

    HISTCMD は代入してもその効果がなくずっと history に登録されている項目の数を指している様に見える。
    と思って実際に ble.sh を起動して確認してみると常に 1 という値になっている。これは困った。
    しかし何故明示的に unset している訳でもないのに HISTCMD=1 なのだろうか。
    これは rcfile で読み取っている事にも関係しているのだろうか。。
    →判明した bind -x の内部で HISTCMD を参照すると 0 になっていると言う事の様だ。

    という事は HISTCMD を参照する事によって history 項目の数を取得するというのはできないという事だ。
    別の方法を考える…。どうやら count=($(history 1)) で取得した値が、
    実際に history からロードした時のエントリの個数と一致する様である。
    という事は count=($(history 1)) を必要になった時に一回呼び出して、
    後はそれを maintain (increment するなど) すれば問題ないという事になる。

    更に history-add の時にもロードを遅延させる事は出来ないかと考える。
    その為に history -s の動作について確認しておく。
    - history -s を使っても HISTCONTROL は考慮に入れられる様だ
      従って、ble.sh の側で HISTCONTROL の処理をしなくても済む。
      逆に現在の history 項目の数は分からなくなる。
      history が追加されたのかされていないのか分からないから。
      返却値も確かめてみたが、重複によって登録されなかった場合でも 0 (正常終了) する様である。

    対応できそうなので遅延ロードに対応する事にした。実際の修正は意外と小規模で済んだ。
    未だ、何処かに取りこぼしがあるかも知れないがそれは問題になってから対処する事にする。

2015-02-27

  * <bug> bash-3.0, bash-3.1 [#D0185]

    何故かパス名展開がされない: echo * としても * がそのまま表示される。
    echo $- としても f はついていない。
    何故か分からないが unset GLOBIGNORE したら直った。
    (GLOBIGNORE には何も設定されていない様に見えるのに)

    →ble-decode-kbd の local GLOBIGNORE を削除したら直った。

  * bash-3.0 対応 [#D0184]

    bash-3.0 では += 演算子が使えない。また、${#param} が文字数ではない。

    これらの事から対応を諦めていたが、
    += 演算子については調べてみたらそんなに使っていない様だ。

    grc '\+=[("'\'']' --exclude=test --exclude=out --exclude=ble.sh

    term.sh (varnames),
    ble-syntax.sh (completion-context context, _ble_highlight_layer_syntax3_list),
    ble-core.sh (ble-stackdump message),
    ble-decode.sh (.ble-decode/keymap/push, ble-decode-kbd keymods)
    ble-edit.sh (_ble_edit_accept_line, _ble_line_text_cache_ichg, _ble_edit_isearch_arr)

    面倒になったので ble/util/array-push という関数を作って、
    速度に関係なさそうな所ではそれに置き換えた。
    (注意しなければいけないのは、array-push を使う時は、
    配列要素が 0 から順に割り振られている必要があるという事。
    専ら push のみを用いて要素を追加する場合には問題はない。)

    さて bash-4.3 で問題なく動いているか確かめてみると、TAB を打った時に表示がずれる。
    →これはまた別のバグであった。別項目として独立して解決。

    今度は bash-3.0 で起動してみる。すると、沢山のエラーが発生している。
    何より unknown ble edit function と表示されてそもそも関数が登録されていない様だ。
    ble/util/isfunction が悪いのかと思って調べたがちゃんと動いている。
    改めてエラーメッセージと ble-bind を照らし合わせると…そもそも ble-getopt が駄目なのかも。

    →何と…。
      local a=($command)
      上の実行結果が a="($command)" というのと同じになっていた。以下の様に -a を指定する必要がある:
      local -a a=($command)

    さてこの様な使い方をしている所は正直沢山ある。以下で列挙できる。
      grc '(local|declare) [a-zA-Z_][a-zA-Z_0-9]*=\(' --exclude=out --exclude=test --exclude=ble.sh
    特に ble-decode.sh の中にあるのは致命的なので、取り敢えずそれだけは直しておく。
    また ble-core.sh や ble-getopt.sh に関しても起動に致命的な影響を与えるので修正する。

    さてそれでも ble-decode が動いていない様に見える。
    noattach の状態でもエラーが出ているのでそれを手がかりに原因を探る。
    どうも .ble-edit.default-key-bindings の中でエラーになっている。
    しかも其処で死んでいて、続きの初期化が実行されていない??
    この中でやっているのは ble-bind の呼出だけである。
    という事は ble-bind に未だ問題点があるという事だろう。
    何と初回の ble-bind で既に死んでいる。。
    →ble-decode-kbd の中の同様の配列の初期化が悪かった様だ。先程 grep した正規表現では不十分だった。
      grc '(local|declare|readonly|typeset)[^-]* [a-zA-Z_][a-zA-Z_0-9]*=\(' --exclude=out --exclude=test --exclude=ble.sh

    この修正で取り敢えず起動はする様になった。
    しかし、少し弄るだけで簡単に無限ループになる。やはり上記の配列の初期化を全部修正しないと駄目なのだろうか。
    →仕様がないので配列の初期化を全部修正してみたら意外とすんなりと起動した。
      普通に色も着いているし問題は起こっていない様に見える。
      但し、.ble-line-info.draw の表示が少し狂っている様に見える。

      後ファイル名の補完候補を列挙できていない。

    何と…初期化内容に括弧があると local/declare -a に失敗する。
      a="1(2"
      declare -a b=("$a") → エラー
      b=("$a") → これはOK
    local/declare は文法的に特別な処置を受けて折らず唯単に文字列の引数を受け取っているという事だろうか。
    再び大幅な書き換えが必要になりそう…。→結局全部書き換えた。

    改めて bash-4.3 で起動してみると補完候補の表示が狂っている。
    今迄の書き換えで何処かミスしたという事だろう。。
    .ble-line-info.draw を潰すと何も問題はない様なので、
    .ble-line-info.draw の中か関連した所が怪しい。
    そもそも .ble-line-info.draw が表示されている箇所がおかしい。
    .ble-line-info.draw が表示されている箇所に対する相対位置としては最終的なカーソルの位置は正しい。
    という事は何処かで座標計算がずれているという事。

    多分分かった…bash-3.0 の declare で吐き出した term.sh のキャッシュが間違っている。
    →当たりだった…。bash-3.0 は _ble_term_ind (内容は $'\n') について、
    | _ble_term_ind="\
    | "
    という風に出力していて、成る程そういう扱い方もあるのか、等と思っていたが、
    上記のコードは "" となる(改行は消える)。試しにやってみると…やはりそうだ。
    | $ echo "a\
    | $ b"
    | ab
    つまり bash-3.0 の declare -p は信用できないという事である。修正した。

  * <bug> TAB 等の変更文字があった場合に文字列が表示されなくなる [#D0183]

    bash-3.0 対応の時に _ble_line_text_cache_ichg 関係を書き換えテストした時に発見したバグ。
    色々試してみるとこれは今回の変更とは関係ない様に見える。今迄のコードに直しても再現する。
    また、_ble_line_text_cache_ichg の登録を止めるとまた異なるずれ方になるので、
    これは _ble_line_text_cache_ichg の登録に失敗しているのではなく、
    _ble_line_text_cache_ichg を使用している側で失敗しているのではないかと思う。
    →確認してみたが、置き換えに失敗しているという事は無い様だ。
      という事は、座標計算を間違っている可能性の方が高い。
      改めて ichg を設定している側に戻って座標について確認してみる。
      良く分からないので、やはり適用している側に行きそこで _ble_line_text_cache_pos を出力する。
      この部分についても何も問題はない様に見える。
    →もしかして出力している物が間違っている?
      と思ったら空文字列を出力していた…。
      元々 .ble-line-text/update で HIGHLIGHT_BUFF に指定された物を使って出力していて、
      .ble-line-text/update の後で slice によって出力内容を取得する様に変更したのが原因だった。
      変更文字があった場合には HIGHLIGHT_BUFF の示す先をローカル変数 buff に置き換えて
      その場で出力させていた。当然ローカル変数は他の関数 /slice を呼び出した時には
      残っていないので空文字列 (或いは、呼出元で buff が定義されていればその内容) が出力される事になる。
      変更文字があった場合にローカル変数に書き込むのは止めて、グローバルに変数を用意して其処に書き込む事にした。

  * <bug> bash-3.1 日本語の色付け・描画が変だ [#D0182]

    何と日本語が含まれている時の BASH_REMATCH が変だ…。
    一致を試みる際には文字数でカウントして、しかし結果は
    バイトオフセットで切り出しているという具合に見える。

    と思って色々試したらどうも自分で指定している SGR 指定ですら変な事になっている。
    もしかして BASH_REMATCH 等の問題ではなく、単に自分の新しいコードの問題か?
    と思ったが 4.0 4.3 では問題は起きていない。3.2 でも問題は起きていない。
    これはやはり 3.1 固有の問題である様だ。

    よく考えたら SGR 指定で変な事になっているのは、SGR の出力に問題があるというよりは
    その前後に変な文字 (UTF-8 の不完全なシーケンス) がある所為で、
    SGR の先頭の ESC 等が食われてしまっている事による物と推察される。
    さて、描画に用いている文字は基本的に _ble_line_text_cache_cs から来ている。
    そして、_ble_line_text_cache_cs に格納されている文字は
    ${text:i:1} によって取り出した物である。問題があるとすればこの辺りだろうか。

    試しに a='ああ' として見て色々試したが問題がある様には見えない。${a:ofs:len} は勿論の事、
    ${#a} も正しい値を返している。取り敢えずは保留という事にする。
    念のため、最後に新しく実装した.ble-line-text.construct が悪さをしている訳ではない
    事を確かめる為に古い関数に戻して試してみる。やはり古い関数でも同様に変な風になっている。
    従って、新しい実装が悪さをしているという訳ではない。

    →何と ${#BASH_REMATCH[n]} がバイト数になる様だ…。
      以下を実行すると、通常時は正しく日本語の文字数で数えているが、
      BASH_REMATCH の中ではバイト数になっている。

      local text='あいう'
      [[ $text =~ ^.+$ ]]
      echo "#${text} = ${#text}, #${BASH_REMATCH[0]} = ${#BASH_REMATCH[0]}"

      | ${BASH_REMATCH[0]:ofs:len} 等は問題なく動いている様なので謎だ。
      | 別の変数に再代入しても問題は続く。
      | 一旦 ${BASH_REMATCH[0]:0} 等として別の変数に移せば問題ない様だ。
      と思ったら関係ない様だ。

      % if ((_ble_bash>=30200)); then
      %   function ble/util/modify-bash31-rematch {
      %     :
      %   }
      % else
      %   # In bash-3.1, BASH_REMATCH returns corrupted string
      %   # when multibyte characters are matched.
      %   function ble/util/modify-bash31-rematch {
      %     local i iN="${#BASH_REMATCH[*]}"
      %     for((i=0;i<iN;i++)); do
      %       BASH_REMATCH[i]="${BASH_REMATCH[i]:0}"
      %     done
      %   }
      % fi

    →色々試して、漸く問題点が分かった。これは BASH_REMATCH だけの問題ではなく、
      ${#配列[n]} 全般で起こる問題である。この形式で要素の長さを取得すると
      文字数ではなくバイト数が取得される。
      ${#配列} の様にして第一要素の長さを取得する場合は問題にはならない。
      (結構重大な問題だと思うが bash の ChangeLog には fixed された等とは書いていない様だ。
      一応 3.0 → 3.1 で ${#param} の場合にバイト数ではなく文字数を返すように修正された様ではある。)

      取り敢えず以下で問題のありそうな部分を列挙する
      grc '#[a-zA-Z_][a-zA-Z_0-9]*\[[^@*]' --exclude=test --exclude=out --exclude=ble.sh

      一番多いのは ${#BASH_REMATCH[0]} なのでこれは単に ${#BASH_REMATCH} と書き換えれば良い。
      次に多いのは、その場所に一致したかしていないかの判定 ((${#BASH_REMATCH[n]})) である。
      これは [[ ${BASH_REMATCH[n]} ]] 等に書き換えてしまえば問題ない。
      こういった物を除いていったら本当に ${#BASH_REMATCH[n]} を使っている場所は 11 箇所のみであった。
      これならば何とか対応できる。対応した。

      これで着色の問題に関しては解決した。しかし、今度はカーソルの移動の度に C だとか D だとかの、
      カーソルの移動方向に対応した文字が出力される。term.sh のキャッシュの読み取りに失敗しているという事だろうか。
      →分かったような気がする %d の置換に失敗しているのではないか?
      →やはりそうだった
        $ aa=123%d4
        $ echo "${aa//%d/@}"
        $ echo "${aa//'%d'/@}"
        123%d4
        123@4

        下のように %d を '' で括っておけば問題ない様なのでこれで行く事にする。
        しかしそうすると、visible-message も壊れているのでは…。
        以下で問題の有りそうな所を列挙して修正する。修正した。

        grc '//%' --exclude=test --exclude=out --exclude=ble.sh

  * 文脈に応じた complete [#D0181]

    syntax の update はいつ行うか

    | これに対応する為には描画時以外にも syntax の update を実行できる様にしなければならない。
    | その為には
    | 1. ble-syntax/parse を独立に実行できる様にする
    | 2. update-positions や描画なども含めて文脈補完時に実行する
    | 3. 実は ble-syntax/parse は up to date になっている筈?
    |
    | もし 2. の描画が無駄にならないのであれば実装でしても良いが、
    | 補完時には確定部分を挿入するので再度後で解析し直しが必要になる。
    | 3. は補完関数を直接 bind している時には正しいが、
    | 実際には内容を変更してから補完を呼び出すという使い方をシェル関数でするかもしれない。
    |
    | 更新の必要がなければ更新しないだけなので、余分に更新を試みるのは悪い事ではない。

    やはり当初の考え通り 1 の方向性で行く事にする。

    次に補完を行う文脈をどの様に判断するかについて

    文脈に応じた補完と言っても、どの様に文脈を判断するのかが問題になる。
    できるだけ補完点の後の情報に依存しないようにするのが望ましい。
    例えば arr=hoge となっている時に ar の点で補完を開始しようとしたとする。
    もし現在居る単語の種類を元にして補完を行おうとすると、
    現在の単語は変数の代入であるから変数の代入に出てきそうな単語しか補完候補に現れない。
    もし ar で始まるコマンド名に補完したいと考えている場合にはこれは不便である。

    実際に挿入をしながら補完を行う場合については、
    普通カーソルより後の部分は現在入力している物と関係ないと考えるのが自然である。
    というのも挿入を続ける事によって、挿入点以降の文字列の文法的意味は次々に変わっていくからである
    現在の入力状態で挿入点の次にある文字列が補完対象と同じ単語の中に含まれている様に見えても、
    挿入が其処で終わるとは限らないのでどんどんと挿入を続けていけば軈て別の単語になるなど。
    何れにしても、挿入点より後の情報を用いて補完するのは直観的でないという事である。
    なのでルールとして以下を設ける
    @ 挿入点より後の文字列は補完内容の決定に使用してはならない。

    次に現在の attr を使用して補完方法を決める事について。
    結論から言うとこれは使えないのではないかと思う。
    先ず、エラーがある場合には attr にはエラーが設定される。
    エラーが発生した時には別の配列にエラー情報を記録するように設計を変更したとしても、
    attr は未だ0文字も入力していない場合 (例えば ${ の直後) などでは文脈の判断に使えない。
    ${ の直後には変数名が来る事は明らかであるので、例え何も入力していなくても補完候補が出せた方が良い。
    @ attr は補完の文脈の決定を行うのには使わない。

    とすれば残るのはやはり直近の stat の状態である。
    stat は解析の再開に用いられる物であるから、
    次にどの様な文法的要素が来るのかを規定するのに充分な情報を持つ。
    但し、問題点は stat は解析結果ではなく解析を行う為の情報に過ぎない事である。
    この事から、stat を用いて補完を実行する為には、
    解析に極めて近い所まで処理する必要が出て来るという事である。

    complete 側でこれを処理するのは面倒だし、
    また、ble-syntax/parse で用いている stat の形式に大きく依存するので、
    これは ble-syntax 側で実装する方が適当である。
    つまり ble-syntax 側で指定した位置が文法的にどの様な物を期待する物なのかを決める。
    実際の補完候補の決定などは ble-edit 側で行えばよい。


    実装1 取り敢えず実装してみる

      取り敢えず簡単の実装の為に、プログラム補完は考えない事にする。
      補完をする為に必要な情報は何か。。
      補完の際に行う事が何かを考えそれを元に必要最低限の情報について考える。

      - 補完候補を表示する → 表示される文字列
        この為には補完候補の一覧が取得できれば良い。
        但し注意しなければならないのは、
        表示される補完候補と実際に補完される単語が一致しているとは限らないという事である。
        例えば、 a/b/c/ ディレクトリの下にあるファイルを保管しようとしている時、
        全ての補完候補に a/b/c/... とディレクトリ名が付いているのは煩い。
        普通は a/b/c/ 以下のファイル名の部分しか表示しない物である。

      - 一意確定部分を求める → 追加挿入される文字列
        共通一致部分。これの為にはこれから挿入しようとしている内容が必要。

        文脈によっては何らかの方法で共通一致以外の確定方法があるかもしれない。
        この時にはこれから挿入しようとしている物の内容は不明である…。
        というか様々な種類の確定方法が混在していた時に、それらをまとめて
        一つの答えを出すという操作は慎重に考える必要がある。
        どんな候補の場合にも確定できる方法と言えば
        やはりこれから挿入しようとする文字列を各候補に生成させる事である。

        特に意識したいのは曖昧一致による確定である。この場合には決定した時に
        既に入力した部分も含めて置き換えが行われる。
        これに対応するには、挿入される文字列などではなくて、
        既に出力されている部分も含めての置き換えを提出させるのでも良いかも知れない。
        その様にすればより自由度は向上する。しかし、問題は、
        異なる補完開始点を持つ候補が混在している場合である。
        その様な場合に共通一致部分を計算したり曖昧一致を計算したりするのは可能か?

        所で、曖昧一致と先頭一致では区別して、先頭一致の方を優先させる等の処理をしたい。
        例えば、先頭一致だけを見ると確定しているが、曖昧一致の候補まで含めると色々ある、
        という場合には先頭一致で確定させてしまって良い。
        (一方で、先頭一致の共通一致部分に関しては確定しない方が良い?
        或いは曖昧一致探索と先頭一致探索はそもそも混ざり合わない様に異なるキーに
        割り当てるべきなのかも知れない。)
        それぞれの候補についてそれが曖昧一致なのか先頭一致なのかで形式を変えても良いかも。
        しかしそれぞれの候補をどう取り扱うかは受け取った側で設定できるようにしたくもある。
        それに候補生成の方法を複雑にすると言うのもなんである。
        そう考えるとやはり候補の生成の際には両者を区別しない形で列挙して、
        それを使う側で先頭一致とそれ以外に分けるという方法の方が良いようにも思う。

      - 挿入する → 挿入関数名
        ただ挿入するだけではなく、様々な追加操作を行う可能性がある。
        例えば、一意確定の際にスペースまたは / を挿入するという事。
        或いはお節介な機能として確定した単語について
        様々な装飾・エスケープなどを施したいという需要があるかもしれない。
        これは色々と自由度が高い様な気がするので関数で実装する事にする。
        各候補についてどの関数を用いて挿入を行うかを取得できる様にする。

      他に問題になるのは、上記に示した情報をどの段階で生成するのかという事である。
      必要最低限と言えば、補完候補の文字列とその取り扱いを定義する関数さえ持っていれば、
      後は関数を呼び出す事によって、補完候補の表示文字列も生成できるし、
      追加挿入される部分について生成する事もできるし、候補表示の時の着色やら、
      メニュー表示にした時の説明文まで何でもできる。
      ただ、候補生成の時にしか分からない情報もあるかもしれないから、
      後でそれらの関数が利用できる様に各項目に data 等というフィールドが使える様にする。
      (これらはそれらの補完関数に形式・使用方法を任せる。)

      取り敢えずその形式で行く事にする。
      候補生成関数が用意するのは、
      1 補完候補
      2 補完関数群 (これは名前の形式を定めておき prefix 等を呈示する)
      3 2 で使用する内部データ (あれば)
      という事にする。
      補完の表示文字列については高確率で必要になるので、これも生成時に用意させる。
      4 表示文字列
      また、候補毎に挿入位置や元にしている文字列が異なるかもしれないので、
      これについても用意した方が良い様に思う。
      5 補完開始点・補完終了点・対象の単語
      補完対象の単語、というのはクォート除去・パラメータ展開などを行った後の値である。

      補完候補、表示文字列、対象の単語に関しては内部に任意の文字列を含みうるので、
      独立した変数に入れる様にした方が管理しやすい。
      一応、固定形式の末端に入れれば何とか抽出できない事もないが面倒なので止める。
      補完関数群の prefix 補完開始点・補完終了点などの情報は空白を含まないので、
      これらは一つに纏める事ができる。
      補完関数群で使用できる内部データは補完関数群の内部で簡単に使える様にする為に、
      やはり一つの独立したデータであるべきである。
      従って候補のデータは以下の様な物に改める:

      cand_word 単語
      cand_show 表示文字列
      cand_head 対象の単語
      cand_prop 関数群接頭辞 開始点 終了点
      cand_data 自由データ

      特に簡単な候補生成の為に cand_word さえ渡せば他を fill できる様にするべきである。

    実装2:

      実装1の方針で実装してみたが問題がある。
      上記の方針では異なる補完開始点や関数群に従った候補を混在させる事ができる様になっている。
      しかし、候補を一意に絞れない時の動作はどの関数群に従ったらよいか判断できない。

      但し、以下に挙げる様な特定の候補に関する操作に関しては、候補語との関数の指定で問題ない
      - 一意確定時の動作 (挿入した時に後に " " や "/" を追加するなど)
      - 各候補に対する説明の取得や色つきの表示文字列の取得など

      問題になるのは以下の動作である。
      - 共通部分確定時の挿入

        単純に挿入するだけであれば共通の動作であるので別に関数群に頼る事は無い。
        しかし、文脈によっては挿入によって文法構造が壊れてしまう事もある。
        その様な場合には色々な修飾が必要になってくる。

        例えば myfile-$ind の末端の様に変数名補完と
        ファイル名補完が混在している時を考える。
        変数名補完としては myfile-$index になる事を考え、
        ファイル名補完としては myfile-${ind}ex になる事を考えている場合、
        両者の補完は共に ex となるので共通一致で ex を挿入しようと言う事になるが、
        実際に挿入する場合にはどちらか一方のやり方で挿入する訳には行かない。
        結局の所、共通一致しそうに見えて一致しないというのが答えである。

        この判断をどの様にすれば良いのかについて慎重に考えなければならない。
        というかそもそも両者は異なる補完結果を与えるのだから、
        異なる候補として区別すればよいだけの事かも知れない。

        つまり、挿入の仕方は挿入関数を定義する事によって実現するのではなくて、
        そもそも候補列挙の時点で挿入文字列・挿入方法を完全に確定してしまって、
        その後で共通部分一致などを試す必要があるのではないかという事。
        逆に挿入時には共通の処理しか挟まない様にする。

      今後他にも共通操作に関して問題になる事があるかもしれないが、
      取り敢えず今回の共通部分確定時の挿入に関しては、
      事前に何が挿入されるか迄候補として生成して、
      共通部分探索時にそれを考慮に入れて絞る。

      今度の実装では候補生成を以下の様に行う:
      1 補完範囲の開始点と終了点を得る。
        更にその間にある部分の評価結果を文字列として取得する。
        (これは補完の種類によっては不要であるかもしれない)
        COMP1 = 補完範囲の開始点
        COMP2 = 補完範囲の終了点
        COMPS = 補完範囲の文字列
        COMPV = 補完範囲評価結果

        この次に具体的な候補を複数列挙する事になるが、
        ここまでの処理はそれらの候補の間で共通である。

      2 候補を生成する

        CAND = 候補の文字列
        ACTION = 関数群接頭辞
        DATA = 何か追加情報があれば。ACTION への引数的な物。

        此処までは候補に依存して完全に異なる物である
        エスケープなどの共通の修飾などについては後段に任せる。

      3 各候補に対する処理

        これ以降は既に指定した ACTION による関数で処理を行う。
        候補の違いは全て ACTION の違いで処理する。

        $ACTION/init で処理を行う

        SHOW = 表示文字列
        INSERT = 挿入文字列 ← CAND から生成する
        DATA に対する加工も。

      4 候補の情報の格納

        cand_word+=("INSERT")
        cand_show+=("SHOW")
        cand_prop+=("ACTION COMP1 COMP2")
        cand_data+=("DATA")

        その他の情報については後で使う事は無いと思う。
        何か特別に必要な物があれば DATA に入れる。
        一般的に使う機会が多そうな物があれば配列を増やす。

    新しく共通部分の探索も加えて取り敢えず実装を行った。
    今の所は仕組みとしては問題なく動いている。
    後はこの仕組みに従って少しずつ拡張していけば良い。


    | * <bug> complete
    |   引用符に囲まれた場合などに挿入位置がずれる。

    この問題は新しく実装し直した事によって解消した。

2015-02-25

  * <bug> accept-single-line-or-newline が二回目以降常に accept [#D0180]
  * <bug> 複数行の編集時に履歴移動をすると表示が乱れる [#D0179]

    他にも編集してから実行をすると実行後にずれるとか、
    複数行の場合には accept-line ではなくて newline の筈なのに accept されるとか。

    これには二つの別の問題が関係していた
    1. 表示を消す時の座標の間違い
    2. stty -nl で icrnl が設定される事により CR が LF に変更されていた

    accept の件は、本来は、行末が次の行に移動しているかどうかではなく
    $'\n' がコマンドラインに含まれているかどうかで判断するのが良い。
    唯単に端末が狭くて折り返しているだけで単一行の時もあるから。
    しかしそうだとしても accept されるのは不思議である。
    accept-single-line する前に一旦表示している筈だから _ble_line_endy
    は更新されている筈であるのに。

    % やはり _ble_line_endy の更新に失敗しているという事であろう。
    % と思ったらいつの間にかに accept が正しく動くようになっている。謎だ。

    それでも表示が乱れるのは変わっていない。
    色々試した結果、_ble_line_endx _ble_line_endy は正しい値になっている。
    よく見てみると、単純に表示を削除する時の座標を間違えていただけであった。
    これで問題なく動くようになった。

    accept の方の問題に関しては再現する条件がある様だ。
    良く分からないが echo hello の様に単純なコマンドを一回実行してからだと
    常に accept される様に変わってしまう。
    表示の部分で _ble_line_x 等の動作を確認してみたが問題は内容に見える。

    と思って ble-edit+accept-single-line-or-newline の内部で
    出力を行う様にしてみた所、何故か初めの一回だけしか呼び出されていない。。
    ble-bind で確認してみても何か別の物に置き換わっているという様子もないようだ。
    すると何が起きているのだろうか…。
    実行されているという事は accept-line は呼び出されていると思われる。
    →実際に accept-line で stackdump すると ble-decode-key/invoke-command
    から直接 accept-line が呼び出される様になる様だ。
    もう少し詳しく調べる事にする。
    →どうやら ble-decode-char の時点で 13 ではなく 10 を受信しているようだ。
      もっと遡ると ble-decode-byte でも 10 を受け取っているし、
      そもそも ble-decode-byte:bind でも 10 を受け取っている。
      (何故始めの1回だけ正しい物を受け取っているのか謎である。)

    - bind -X で確認してみたが異常はない。
    - 因みにコマンドを一回も実行しない限りはずっと 13 が受信できる。
      何か stty の設定と関係があるのだろうか。
    - M-c で ble-bind -cf のコマンドを実行した場合も同様である。

    判明した function .ble-stty.enter の中の stty -nl が駄目だった。
    stty nl としてみたら動くようになった。然しそうすると表示が滅茶苦茶になる。
    今迄の描画ルーチンでは全然駄目という事になる。

    | 解決方法は二つある。
    | stty のモードをもう一つ付け加えて、入力を受け付ける時にだけ stty nl にする。
    | 或いは、 stty nl でも正しく描画できる様に描画ルーチンを変更する。
    |
    | a 何とかして stty を使わずに端末の設定を切り替える方法はあるか?
    |
    |   現在の所 stty のモードの変更はコマンドを実行する瞬間だけで済んでいる。
    |   もし描画する時と表示する時で毎回 stty を呼び出して切り替えなければならないのだとすると、
    |   かなりコストが高い。
    |
    |   - できるならば stty を呼び出さずに端末を制御する方法が有れば良いのだが…。
    |   - 或いは、stty を裏で起動しっぱなしにしてリアルタイムで変更させるなんて言う事ができたら…。
    |     しかしそんな機能はない。
    |   - それとも新しく仮想端末を作ってしまって設定に応じて出力先を変更する、
    |     等という事も出来たりするのだろうか。。
    |
    |   mknod とか?? 試しに
    |   $ mknod testtty c 4 100
    |   等としてみる…。許可されていない操作ですと怒られて終わる。これでは駄目だ。
    |   $ mknod a c 136 10
    |   としても駄目だ。今度は
    |   $ mknod /dev/pts/10 c 136 10
    |   等としてみる。エラーメッセージが変わった。"許可がありません" になった。
    |   良く考えてみればこれは "許可されていない操作です" 以前の問題なので、
    |   寧ろ遠ざかったのではないかと思う。
    |   さて、システムが落ちても嫌なので無理矢理 sudo で作るのは止めておこう。
    |   使い方も良く分からない事であるし。
    |
    |   関係有りそうな質問が出ている:
    |     [[Create new /dev/pts/&lt;n&gt; device using bash script?>https://forums.opensuse.org/showthread.php/494468-Create-new-dev-pts-lt-n-gt-device-using-bash-script]]
    |   しかし解決法は呈示されていない。
    |
    |   [[screenの”Cannot open your terminal ‘/dev/pts/0′”対策 | Siguniang's Blog>https://siguniang.wordpress.com/2012/08/11/screen-and-pseudo-terminal/]]
    |   によると script コマンドを起動すると新しい pts が開かれる様である。
    |   例えば、script コマンドを無理矢理開いて、その後でその script コマンドが作成した端末に書き込んだりするとどうなるのだろう。
    |   script を & で開いて新しく作成された pts に何か書き込んでみたが何も起きない。
    |   プロセスを見てみたが script コマンドが新しく pts/8 な bash を中で開いている様だ。
    |   要するに bash が何か出力したら script がそれを読み出す、という事なのだろう。
    |   bash は -i で起動し入力待ち状態になる。この時に pts/8 に書き込んでも何も起きない。
    |   うーん。良く分からない。もう少し試してみる。
    |
    |   $ script $(tty) &
    |
    |   何とも微妙な事になる。先ず & で起動しても script は停止してしまう。
    |   仕様がないので fg に持ってくると今度は出力が二重化されている。
    |   うーん。
    |
    |   $ script $(tty) -c cat &
    |   としてみる。cat は起動されていない様だ。
    |   この状態で /dev/pts/8 に書き込んでも何も起こらない。
    |   といって fg で中にはいると C-z 等で抜ける事ができない。どうした物か。
    |   % どうも /dev/pts/8 に書き込むというのは cat に書き込むという事のようである?
    |   とも思ったがそういう訳ではないようだ。やはりちゃんと $(tty) の方に書き込まれている。
    |
    | b もし -nl で描画を設計しなければならないとすると結構骨である。
    |   echo 等で適当に出力する事ができないという事になる訳だから。
    |   何を出力するにしても .ble-line-* を通して描画するか、
    |   或いは stty を自分で設定して出力するかをしなければならない。
    |
    |   例えばログアウトや戻り値が 0 以外の時に [ble: hoge] 等と表示しているが、
    |   これらも全て適当な出力としてではなく "描画" として取り扱う様に注意をしなければならなくなる。
    |
    | c 実は stty をもっと細かく設定できるのではないか?
    |   というか入力と出力で別々に設定が出来た様な気がする。と思って stty --help を見てみたら、
    |
    |   入力設定:
    |      [-]icrnl      復帰 (CR) を改行 (LF) に翻訳
    |      [-]igncr      復帰 (CR) を無視
    |      [-]inlcr      改行 (LF) を復帰 (CR) に翻訳
    |
    |   出力設定:
    |    * [-]ocrnl      復帰 (CR) を改行 (LF) に翻訳
    |    * [-]ofdel      ヌル文字の代わりに埋める文字として削除文字を使用
    |    * [-]ofill      遅延のタイミングの代わりに埋める文字を使用
    |    * [-]olcuc      小文字を大文字に翻訳
    |    * [-]onlcr      改行 (LF) を復帰改行 (CR-LF) に翻訳
    |    * [-]onlret     改行 (LF) が復帰 (CR) として振舞う
    |    * [-]onocr      1桁目の復帰 (CR) を表示しない
    |
    |    nl            -icrnl -onlcr と同じ
    |    -nl           icrnl -inlcr -igncr onlcr -ocrnl -onlret と同じ
    |
    |   と書かれていた…。基本的に -nl で、問題のありそうな物を nl と同じ設定にする、
    |   という事にすれば良いのではないだろうか。
    |
    |   -nl: icrnl  → cr を nl に変換する (これが駄目)
    |   -nl: -inlcr → nl を cr に変換する (これはその儘でないと駄目)
    |   -nl: -igncr → cr を無視しない (これもその儘でないと駄目)
    |   -nl: onlcr  → 出力の nl を cr nl に変換する (これもその儘)
    |   -nl: -ocrnl → cr は nl にしない (その儘)
    |   -nl: -onlret → nl は cr として振る舞わない (謎)
    |
    |   結局 -nl -icrnl とかすれば良いのでは??

    stty -nl -icrnl とするだけで済んだ。呆気ない事だった。
    また無事に問題が解決したので、
    accept-single-line-or-newline の判定の修正を行う。
    表示上の行数ではなくてコマンド内に \n があるかどうかで判定する。

  * ble-syntax.sh: 条件式 [[ ... ]] と配列初期化子内の文脈に対応、コメントにも対応 [#D0178]

    以下の問題はこの実装の後に確認したら直っていた。
    (そもそも何故この問題が起こっていたのかよく分かっていなかったが。)

    | 2015-02-17
    |
    | * [[ ]] の括弧が異なる色になる。
    |   "]]" は "[[" の色に合わせる様にしているのに…と思ったら、
    |   これに関してもコマンドとしての着色によって "[[" の色が後で
    |   上書きされている様だ。
    |
    |   取り敢えずコマンドとして解釈されない様に、
    |   ATTR_DEL を rword[0] に代入してみたが…。
    |   これだと [[ に対する引数を complete の規則で取り扱えない。
    |
    |   結局、正しくキーワードと解釈される事を期待して、
    |   "]]" に先に ATTR_CMD_KEYWORD を適用してしまう事にする。
    |   [[ ～ ]] の取り扱いは後で又考え直す事になると思う。
    |
    |   と思ったら今度は急に動かなくなった。
    |   先ず [[ まで入力した時点で初めの単語の長さが 0 になっている。
    |   更に ]] を用いて閉じると正しい長さにはなるが
    |   単語の種類がコマンドから引数に切り替わってしまう。
    |   また "[[ text " と入力すると最後の空白が単語として認識されている。

  * <bug> invalid nest " $()" の先頭に for を挿入した時 [#D0177]
    →これは寧ろチェックのコードの方が誤っていた。nest の形式の変更に追随していなかった。

  * 複数行コマンドの履歴 [#D0176]

    複数行のコマンドの履歴について何とかする…。eval -- ''... に置き換える等。
    読み取り時に負荷になる?

    →複数行のコマンドを履歴に登録する時には eval -- $'' の形式にする事にした。
      これは printf %q を用いて出力する事ができる。
      読み取りの際には history-load の awk で ^eval -- ... に対して一致させる。

    保存する時には printf %q を用いる。bash-3.0 でも bash-4.3 でも $'' の形式になる様だ。

    意外と問題もなく直ぐに実装できた。
    これで複数行のコマンドも心おきなく編集・実行できる。

  * <bug> 表示の属性の更新がうまく行かない事がある。 [#D0175]

    例1: for ((abc)) の a を消すと bc が (( と同じ属性になる。
    例2: for (()) の (()) の中にカーソルを移動して中身を書くと )) の属性が中身と同じになる。

    挿入や削除のあった箇所で sgr の再設定がされていない様子。
    これは見たら直ぐに分かって修正できた。

  * カーソル移動 [#D0174]

    複数行に渡っている場合には up down で中を移動できる様にする。
    カーソルが一番上にある時に up を押した時に前の履歴項目に移動する。

    →一通り対応した。

    従来の kill-forward-line, kill-backward-line, beginning-of-line, end-of-line は
    kill-forward-text, kill-backward-text, beginning-of-text, end-of-text に移動。
    新しく kill-forward-line, kill-backward-line, beginning-of-line, end-of-line,
    forward-line, backward-line, forward-line-or-history-next, backward-line-or-history-prev を実装。
    newline, accept-single-line-or-newline の実装。

  * ble-syntax.sh: $[...] の形式に対応 (何故か bash の説明には一切載っていないが使える)。 [#D0173]

  * ble-edit.sh: printf %()T を用いた実装の導入、PS1 \D{...} に対応 [#D0172]

    | 2013-06-12
    | * <bug> ps1, \D{format} に対応していない。

  * <bug> 編集文字列の行数が変わった時に info.draw の内容がずれる [#D0171]

    これは info.draw の問題というよりは寧ろ
    .ble-edit-draw.update の方の問題の様に見える。
    → .ble-edit-draw.update の側で正しく描画領域を確保して描画する様にしたら直った。

2015-02-24

  * 描画ちらつき [#D0170]

    未だちらつく。全体を再描画するのではなく変更部分だけ更新したい
    先ず、開始時に bash に編集文字列を消されるのに対抗して再描画するのは
    bleopt_suppress_bash_output=1 である今必要はないと思って省略しようとしたら…
    元からちゃんと bleopt_suppress_bash_output を見て省略していた。

    とするとちらつくのは専ら再描画の為に一旦全体を消してから
    全体を再度出力し直している事による。
    現在は実装を一新したので変更のあった部分だけ出力する様に変更を図る。

    現在の実装について確認する。
    特に文字列の座標計算と表示内容の構築を行っているのは以下の関数である。
    .ble-line-text.update-positions
    .ble-line-text.construct
    もう少し関数に細分化・分散していると思っていたが意外とコンパクトに纏まっている。
    現在、update-positions は construct から呼び出されるので直接外部から呼び出す事は無い。
    (むしろ外部から呼び出すと update の回数がずれて
    二重に shift を実行してしまって全体を計算し直すことになったりして良い事は無い。)
    つまり、実質的に interface は .ble-line-text.construct だけという事になる。

    計算結果は現在は専ら .ble-line-text.construct の戻り値を介して取得している。
    しかし、外部からもっと簡単に様々な情報にアクセスする事ができるようにしても良いと考える。
    幸いにしても .ble-line-text.construct の呼出元は一箇所しかないので、
    簡単に interface を変更する事が出来る。


    取り敢えず更新の必要な範囲についてだけ更新を行う様に変更する事を考える。
    実際には文字列の挿入や削除などの場合でも文字列は移動するだけだから ICH や DCH でもっと
    賢く再描画する事も可能かも知れない。
    しかし、取り敢えずの所は移動する文字についても完全に再描画する事にする。
    また、実際に必要とされる文字列についてはの /update で計算するのではなくて、
    使う側が必要になったら構築を呼び出す様に変更する。

  * <重い> 改行を挟んでいれば編集は軽くなると思っていたが軽くない [#D0169]

    update-positions は途中で終わると考えていたが、違うという事なのか?
    実際に調べてみた所 update-positions や highlight はちゃんと更新の必要がある範囲で終わっている様だ。
    試すと明らかに挿入が遅い。末端に文字列を書き込んでいる時にはそんなに重くないのに、
    改行を挟んでいる所に文字列を書き込むと遅い。
    再度試してみたが、そもそも内容が長くなってくると重いのは仕方がないとして、
    やはり途中に挿入するのが特に重い。

    試しに syntax を止めてみたら途端に滅茶苦茶軽くなった。
    syntax が full に走ってしまっている可能性がある…。
    また syntax を入れてみて試してみる。
    やはり死ぬ程遅いが、ble-syntax-highlight+syntax が返す更新範囲はそんなに大きくない。
    次に ble-syntax-highlight+syntax の中身を覗いてみる。
    何と解析が最後まで走っている事が判明した…。

    と思ってよく見てみると _ble_syntax_stat の shift に失敗していた。
    これを直して再度試してみる事にする。未だ最後まで走っている…。
    もっと調べてみるとそもそも dirty-range 拡大が最後まで走っている様だ。
    どうも word による dirty 拡大が連鎖で起こっている様子だ。

    そもそも dirty 拡大の時の拡大領域の値が +1 されているのは何故だったか良く分からなくなった。
    もともとは、その当該要素も確実に再解析の対象になる様にという事だったとは思うが、
    その時点での stat の値が一致していれば直前までの解析で良いのではないか? それでは不十分なのか?
    という事になる。というかそもそも dirty 拡大が必要なのは何故だったか?

    もしかすると word の古い取り扱いに関連していたのかも知れない。
    でもそうだとすると今回新しく word による dirty 拡大をした理由も何だか良く分からなくなる。
    もう少し落ち着いて考える。参照先が消滅している場合にはその stat は無効になる、と考えるのは自然である。
    例え解析の結果によって stat が全く同じ値になったとしてもこれは前の stat と同一か? と言えば異なるとした方が良い。
    とするならば解析範囲の拡大を行う事によってこれに対応するのではなくて、無効になった stat を削除すると言うのが正しい対処法ではないのか?
    word に対する dirty 拡大はもう少し異なる状況である。
    word については解析中断の条件に入っていないので word の情報を消したとしても無意味である。x
    抑も word の先頭が消滅・或いは無効化した時に word が更新された事を検知したいというのが目的だった。
    もし dirty 拡大をしていないと word の先頭が消滅・無効化した時でも再解析によって word の途中で
    一致した文脈状態になった時に其処で解析が終了してしまう。
    その時に _ble_syntax_word_umin _ble_syntax_word_umax に登録されないという問題が生じる。

    でも _ble_syntax_word_umin, _ble_syntax_word_umax に登録するという目的であれば、
    dirty-range 拡大によって無理矢理に解析をやり直させるよりは良い方法がある様に思う。
    無理矢理解析を行わせるように成っている為に必要のない所まで再解析・単語更新を強いる事になる。
    例えば、"$(echo hello world)" において先頭に a を挿入した場合、dirty 拡大を行っている場合、
    echo や hello, world 等までも再解析の対象になり、また _ble_syntax_word_umin の対象になる。
    実際に考慮に入れるべきなのは a"$(echo hello world)" という全体に対してのみの筈だ。
    (もし挿入によって文脈構造が変化する場合については echo hello world も自然に再解釈の対象になるので問題ない)。

    単語内部で更新が起こったかどうかによる判定は別に行うべきではないかと考える。
    と思って確認してみたが、既に単語内部で更新が起こった場合については _ble_syntax_word_umin に登録する様になっていた。
    これについては、念のため不等式を変更して word 先頭で編集が起こった場合にも対応する事にした。

    さて今回の変更で dirty 拡大を完全に廃止した事になるが、
    これによって従来動いていた物が動かなくなってはいないか確認するべきである。
    取り敢えず、編集のあった単語について正しく再解析が行われているかどうかについて確認を行う。

    - 色々試すと、単語の先頭に文字列を挿入しても _ble_syntax_word_umin に登録されなくなった。
      謎だ。と思ったら j を登録すべき所 i を登録していた。
      更に、一番最後の点 (index iN) を更新していなかった。
      文字列の末端でも状態を記録する為、一番最後の点まで確認しなければならないのだ。
      これは取り敢えず解決された。

    これに関しては dirty 拡大の取り扱いを止める事によって解決した。
    これで途中の編集に対して末端まで解析を実行する事は防げた。
    今迄 dirty 拡大を行った元でテストしてきたが、これがないと解析を行うべき所で解析されないなどの問題が
    今後発生するかもしれない。しかし、それはまたその時に対応する事にする。

    しかしながら、多少解消はした物のやはり途中に対する挿入は遅い。
    これは結局 shift をする為にループを回しているのがいけない様に思う。
    末端に挿入する場合には shift を確認する範囲は小さくなる。
    しかし初めの方に挿入する時には文字数と同じ数だけの shift のチェックを行わなければならない。
    何か簡単に shift が実行できてしまう様なデータ形式を思い付けば良いが、
    そうでなければこれは仕方がない。shift が遅いという新しい項目として残してここで終わりにする。

  * <bug> 文字削除時 invalid nest の assertion に引っかかる。 [#D0168]
    invalid nest に引っかかる。
    再現: history で l "$(echo hello)" を出して "$ の直前に文字を挿入。その後文字を削除。
    別に history でなくても起こる様だ。

    dirty 拡大に代わり stat を削除する様に変更と言いつつ、
    stat の該当項目に -1 を代入していただけなのが災いしている?
    良く考えたら -1 既に "より上位の nest が存在しない" だとか "今は word の中ではない" という意味だから、
    本当は良くない。でもそうだとしても nest のチェックに引っかかるのかどうかというと疑問な気はする。
    取り敢えず本当に削除する様に変更して様子を見てみる事にする。
    →出なくなった。考えるのが面倒なのでもし今度出たらその時に考える事にして此処で終わりにする。

  * <bug> 編集内容が零文字になった瞬間に改行が起こって表示が消える。 [#D0167]

    調べてみると編集文字列が "" になった瞬間に
    _ble_line_x _ble_line_y が 53 1 という変な値になっている。
    と思ったらこれは .ble-line-info.draw による表示の位置である。
    しかし、何故編集文字列が空になった時にだけ .ble-line-info.draw の
    位置が _ble_line_x に代入されているのだろうか。
    % と思ったがそれは当然である。
    % 変更点があって文字が描画された時には umin<umax なのでその前に描画が為されている。
    しかしそれでも変だ。では何故 "" になるまでは _ble_line_x に別の値が代入されているのだろう。

    別に文字が "" にならなくても末端から削除をしている時は
    新しい文字を描画する必要はないので umin==umax になっているはずである。

    何だか良く分からないのでまた別の方向でも調べてみる。
    部分更新ではなく、常に全体を更新する様にしてみる。
    →全体更新であっても勝手に改行が入ってしまう様である。
      もしかして何処かにデバグ用に埋め込んだ echo があるのか?
    →どうやら bash がエラーを出力していた様だ。
      何と echo 11.8 "$_ble_syntax_word_umin $_ble_syntax_word_umax" で 0 0 が出力される。
      _ble_syntax_word_umin の代入箇所を探しても 0 になる様な箇所はないのだが…。
      と思ったが分かった。削除した時に _ble_syntax_word_umin の shift によって
      有限の値だった物が 0 になっている。

      これが起こるのは仕方のない事なので、これに対して特別に対策を取る事にした。
      更新しようと考えていた単語が消滅した時には _ble_syntax_word_umin を ++ する。
      それによって対象の単語が一つもなくなった場合には -1 を代入する。

    これで直った。しかし、描画の際にエラーメッセージが消されてしまうというのは厄介な事である。

  * <bug> 改行しても先頭がコマンドになっていない [#D0166]

    何と [[ ${#BASH_REMATCH[0]} =~ $'\n' ]] としていた。当然 # は不要である。
    これは直ぐに直った。

  * <bug> _ble_region_highlight_table で空欄になっている箇所がある。 [#D0165]
    echo " と入力した時の空白に対応する部分。

    これは function ble-syntax/highlight/set-attribute の中で
    既に設定されている物と同じ値かどうかの確認の際に、
    数値として比較していた為に空欄と 0 が同一視されている事による物であった。
    修正した。これは無事に 0 が代入される様になった事を確認した。

    それと共に _ble_syntax_attr_umin における色の既定値を正しく計算する様にした。
    (実際には問題にならなかったかも知れない。
    つまり _ble_syntax_attr_umin は必ず attr の設定されている点が設定される様な気がする。)

  * <bug> 単語の属性適用が後ろに続く単語にも続いている。 [#D0164]
    単語の分割はちゃんとできているのに不思議だ。
    これは属性適用の側のバグだと思われる。

    再現:
    1 以下を先頭から順に入力する
      echo "$(less hello world)"
    2 "$( の直前に文字を挿入する
      echo a"$(less hello world)"
      この時 less の属性が less hello world 全体に適用される。
      その他の部分の着色については問題はない様に見える。

    取り敢えず属性適用の部分で何が起こっているか調べようとすると…。
    属性適用が起こっていない様だ。やはり再度試しても呼び出されていない。
    (よく考えてみれば _ble_syntax_word_umin はこの範囲を含んでいないので当たり前である。
    また、これは期待した動作でもある。この部分は変更していないのだから。)
    さて、この時に何故表示内容が崩れてしまうのか。。

    また、不思議なのは先頭にあるコマンドの着色がそのまま後ろに適用されてしまう点である。
    つまり、一旦 word による属性が全て解除された後に word による属性が適用されない、という訳ではない様だ。
    _ble_syntax_attr が削除されているという事だろうか。
    shift の際に属性が飛んでしまうという事なのか? shift ではちゃんと削除された場所以外は保持している筈なのだが。
    試しに _ble_syntax_attr の中を確認してみる。_ble_syntax_attr の中は正しい値になっている。
    という事は adapter での繋ぎ替えに失敗している? 念のため _ble_region_highlight_table を確認する。
    これも正しい値になっている。という事はやはり adapter が怪し。

    今度 _ble_highlight_layer_adapter_buff の中を出力させてみたらどうやら、
    問題は a を挿入前の時点で既に発生していた様だ。
    $( とした状態で順次入力を行っていくと常に最後にエラーの赤い印が付いた状態で入力していく。
    そうするとどうやら属性 0 が全てはぎ取られていく様だ。
    また遡って調べてみようと思ったが、_ble_region_highlight_table の時点で正しい状態だったから、

    やはり adapter の中での更新が問題な様に思われる。
    と思ったら見つけた。gprev に常に 0 が入っていた。
    これは全体に対して _ble_region_highlight_table を読み出していた時のままになっていたという事だろう。
    i1>0 の時には i1 直前の gprev を読み出す様にした。
    これで a を " 直前に挿入した時の色付けは正しくなった。

    しかし、今度は何故か入力していった時の色がおかしくなった。
    と思ったがこれは当然の事である。部分更新なので途中から出力している。
    それなのに前からの続きとして出力してしまっているので SGR が出力されていない。
    これは ble-edit-draw.update 側を修正する。
    これで正しく動作する様になった。

    意外と修正に手間取った。

  * <bug> _ble_syntax_attr の中に "BLE_ATTR_ERR" の文字列が混入している。 [#D0163]
    一応算術式評価では BLE_ATTR_ERR の中を読みに行くので問題はないとはいえ、その様に設計したつもりはないので修正するべき。
    →これは parse の末端で起こっていた。修正した。

2015-02-23

  * 過去の ToDo について改めて整理を行う [#D0162]

    既に自然に実装された物、解決した物、或いは実装する事に意味が無くなった物などを整理する。

    | 2013-06-12
    |
    | * ble-decode-byte:bind の先頭でプロンプトを再描画する必要がある version の境を調べる。
    |   →これは bleopt_suppress_bash_output の実装で余り意味がなくなった。
    |     bleopt_suppress_bash_output=1 で問題が起きていないので、
    |     今後は bleopt_suppress_bash_output= について積極的な最適化をする事はない。
    |
    | * <bug> ウィンドウサイズを変更するとプロンプトが bash の表示する物になる
    |   これはウィンドウサイズを変更した時に bash が自動的にプロンプトを再描画する為。
    |   SIGWINCH を trap して自前で描画し直せばよい?
    |
    |   2015-02-09 bash-4.3 で試したが問題が再現しない。
    |
    |   2015-02-24 これも bleopt_suppress_bash_output=1 を実装したので
    |   今後はこの問題が発生する事は無いのではないかと考えている。

    これらは出力関連の問題であったが、bleopt_suppress_bash_output の実装により余り意味が無くなったので削除する。

    [Done]

    | 2013-06-10, X7 解析器
    |
    | # bash script の解析器を作る。
    | # これは syntax-highlight, complete 等から用いる。
    |
    | 先ず、シェルスクリプトの文法について整理する。
    |
    | !   履歴展開
    |     ! に非空白の文字列が続いている時
    | "   二重引用符の開始
    | '   単引用符の開始
    | `   コマンド
    | $'  引用符の開始
    | ${  パラメータ展開 {} の開始
    | $(  コマンド置換
    | $(( 算術式置換
    | $他 パラメータ展開
    |
    | コマンド修飾 (コマンドよりも前に来る事ができる物)
    |   [0-9]*(>|>>|&>|&>>|<|<>)(&[0-9]+|arg)
    |   [<>]( プロセス置換開始
    |
    | コマンド
    |   ((  算術式の開始
    |   [[  条件式の開始
    |   {   重文開始
    |   (   サブシェル開始
    |   aaa=hoge
    |   aaa[]=hoge
    |   aaa=(hoge)
    |     コマンドが続く
    |   time
    |   time -p
    |     コマンドが続く
    |
    | ; & | && || |&
    |   コマンドが続く
    |
    | ;; ;& ;;&
    |   case パターンが続く
    |
    | ※incremental に解析できる様に再帰呼び出しなどは避けたい。

    この中で実装されていないのは
    - time -p
    - aaa=(hoge), 他に aaa+=(hoge) というパターンもある。
    - ;; ;& ;;& の後に case のパターンを受ける
    - [[ 条件式の文法に正確に対応していない
    等である。その他については (多少の問題点は残るが) 実装してある。
    上記の物に関しては、より最近の文法対応リストに追加しておく事にする。

    | 2013-06-09
    |
    | * split, 書きかけたけれど結局使っていない関数
    |   function .ble-text.split {
    |     local GLOBIGNORE='*'
    |     test -n "${3+set}" && local IFS="$3"
    |     eval "$1=(\$2)"
    |   }

    これはどうでも良い。最近では手で書いている。というか手で書いた方が楽だ。

    | * ble-decode-char: cmap+default.sh を統合する?
    |
    |   改めてコードを見てみたが、それ程サイズが大きい訳でもないので、
    |   ble.sh の中に埋め込んでしまっても良いかも知れない。
    |   しかし、ユーザにカスタマイズの余地を残す、という意味では別のファイルになっていた方が親切である。
    |
    | * ble-decode-char:
    |
    |   これをユーザの側で生成するのには時間が掛かるので、
    |   予め作成しておいた dump ファイルも一緒に配布するのが良い。
    |
    |   連想配列を使う版と使わない版の二種類だけで良い。
    |   と思ったが、連想配列を使うか使わないかが影響を受けるのは、
    |   cmap の側と言うよりは keyname の方なので、元々巨大ではない。
    |   keyname の部分だけは ble.sh に統合してしまうと言う手もある。
    |
    |   *.dump についても統合してしまうという手もあるが、
    |   これについては中身が巨大なので余り統合する気にはなれない。
    |   (でも、最終的には統合した方が綺麗かも知れない。)
    |
    |   もしも統合しないのだとしたら、何れにしても複数ファイルになってしまう訳だから、
    |   cmap+default.sh を ble.sh 内部に統合する意味も余り無い…。
    |   というか、dump を一緒に配布する場合、
    |   そもそも cmap+default.sh を実行する事はない筈である。
    |

    ble.sh は益々肥大化しているのと、これからも様々な設定ファイルが増えていくだろうと予想されるので、
    single file で提供する事はもう考えない。

    | * <bug> キャレットが編集文字列の先頭にある場合、prompt の最後の文字の SGR が反映されない。
    |
    |   これに対応する為には prompt の指定から SGR を抽出するしかない。
    |   普通は prompt の最後の文字は空白にする (本当か?) ので気にしなくても良い気もするが。
    |
    |   これを真面目に実装するには二通りの方向性が考えられる。
    |
    |   一つは zsh の様に PS1 の色・スタイルの指定を %[] の中でやって貰うという方法である。
    |   これならば TERM に依存せずに解析できるので良い。但し、これは bash に非互換なので、
    |   bash から何も設定を変えずに移る、という事ができなくなる。また、% の指定に対応し始めると、
    |   その他の zsh の指定についても対応しないと収まりが悪い。全て実装しようと重うと大変である。
    |
    |   もう一つは PS1 を頑張って解析して、ESC [ ... m から SGR の指定を取り出す方法である。
    |   現実的には ESC [ m 以外で SGR を解釈する端末が存在するとは思えないから、
    |   これでも良い気がする。

    これも bleopt_suppress_bash_output=1 の実装により重要性が低下した。
    一応 bleopt_suppress_bash_output= の問題点として残して置くが、簡単な一行の説明に収める。

    | 2013-06-08
    |
    | * <bug> source を実行している間に C-c をして中断しようとするとその儘動きが止まる。
    |   通常のループなどで時間が掛かっている場合に C-c で止まる様にするには
    |   trap return INT 等とすれば良かったが、source の内部で時間が掛かっている場合には、
    |   C-c で止めようとするとそのまま全体の動きが止まってしまう様である。
    |
    |   序でに関数内のループで時間が掛かっている場合に関しても調べてみたが、
    |   こちらは C-c で正常に中断する事が出来るようである。
    |
    |   + 2013-06-11 12:29:07
    |     改めて試してみたら、ちゃんと停止はする様である。
    |     accept-line.exec でループ構文を使わずに再帰に書き換えたがその事が影響を与えたかも知れない?
    |     或いは、これは前に試した時の勘違い?
    |
    |     しかしながらまた例によって .ble-stty.enter が実行されていない様である。
    |     何故か分からないが処理の流れ的には正しくできている気がする。
    |     しかし、処理の順番が入れ替わっている気がする。
    |     exec.recursive から先に出力されるべき物が、プロンプトの表示よりも後になっている。
    |     後で再度調べ直す必要がある?

    これは gexec の実装の際に色々試して trap - DEBUG の方向性で解決する事にした。
    これによってどんな場合でも確実に停止できるのではないかと考えている。
    具体的に source を使って検証した訳ではないが、関数では充分にテストしたので大丈夫だと考えている。
    もし問題があったら改めてその時に考える事にして、この項目も削除する事にする。

  * <bug> info.draw で特殊文字が改行に跨っている時の座標計算 [#D0161]

    例えば CR などの特殊文字を ^M と表示しているが、これが改行に跨って表示される。
    その時の座標がずれる。(そもそも改行に跨って表示されるのが誤り?)

    →空白を挿入する様にしていたのだが、挿入する空白の長さを空白を挿入した後の値で計算していた。
    つまり空白を挿入する必要がないという解釈になっていた。式の評価の順序を正しい物に変更した。

  * <bug> update-positions で dend-dbeg が負になると警告が出る [#D0160]
    →プロンプトの内容に変更があった際に初期位置 x y が変わる。
    その時の dbeg=0 の設定の際に dend や dend0 を正しく設定していなかった。

2015-02-22

  * <bug> word の内容変化を検知する事のバグ [#D0159]

    - transpose-chars 等を用いた場合 word の内容が変化しても word の着色が更新されないのではないか?
      →コードを見た所、単語内部で変更が起こった場合にはちゃんと ble-syntax/parse/touch-updated-word している。
      単語の終端点を巻き込んだ変項の場合には、否応なく parse で変更される筈なのでここで touch する必要はない。
      つまり、現状のコードでも問題が起こる事はないように思われる。

      と思ったが正しくできていない。
      echo 'd'is't' で真ん中の is を tranpose して見たが、どうも期待通りに動いていない様だ。
      と思って調べたら、そもそも transpose した時には単語の切り出し自体に失敗している様だ。
      長さ 0 になっている。途中で解析が終わっている為であろう。

    - 解析が単語の途中で終わった時に word が壊れない様にする為には?

      これは真面目に考えなければ対応方法が分からないので後で考える。
      (そもそも単語が終了した所で前の位置 word[wbegin] に書き込むというのが混乱の元なのかも。
      データ形式から考え直した方が良いのかもしれない。)

      眺めていたら簡単に書き換えられそうだったので書き換えた。
      _ble_syntax_word[]は単語の先頭ではなくて単語の終端に置く事にした。動いている。
      _ble_syntax_word を用いた dirty 拡大にも対応した。
      後 dirty 拡大の部分に問題を見つけたのでその部分も修正した。

  * <bug> .ble-line-info.draw を使った時行がずれる [#D0158]

    これは新しい描画関数で出力する様にした時に出力の順序を変えた所為だった。
    出力をバッファリングしている時には、その最中で別の複雑な関数を呼んではいけない。
    内部で独自に出力を行うかも知れず出力の順序
    (と _ble_edit_x, _ble_edit_y の参照順序) が変わるからである。

  * <bug> for や do に色が着かない? [#D0157]

    _ble_syntax_word_umin, _ble_syntax_word_umax の問題の様だ
    → ctx-redirect/check-word-end で wbegin=-1 を設定した後に touch していた所為で、
    _ble_syntax_word_umin=-1 になってしまい、範囲が無効化されていた様だ。
    ble-syntax/parse/touch-updated-word に assertion を追加した。

  * 描画の高速化2: 現在の不具合と layer に対する対応 [#D0156]

    | x 現在 update-positions で位置が変化しただけの部分に対しても表示用の SGR 付き文字列を更新している。
    |   これは省略できる筈。改行やタブなどで出力内容に変化のある部分については別に記録して後で合成して表示する。
    |
    | x transpose-chars 等を用いた場合 word の内容が変化しても word の着色が更新されないのではないか?
    |
    | x word の属性が解除されてもそれが表示に反映されない。

    先ず、word の属性が解除された時の動作について考える事にする。これは layer の実装方法にも関わってくる。
    word の属性が解除された時、元々其処にあった属性を復元したい。
    これは _ble_syntax_attr を参照して再度値を書き込めば簡単に実現はできる。
    しかし、今後 ble-syntax とは独立した形で様々な着色を行う事になると思われる。
    その際に _ble_syntax_attr やら更にその後に付加される word の着色に対して毎回参照したり計算したりするのは現実的ではない。
    様々な着色を分離した形で実装する為にはちゃんとした仕組みが必要になる。

    改めて考えるにこの問題は、「word の着色をしても、概念的にはその下には syntax による着色が残っている」のに、
    それが word の着色によって失われてしまっているという事である。つまり、syntax による着色は依然として
    有効であり、word の着色が戻った時にまた有効になる物であるのに、それを上書きして消してしまっているという事である。
    本来は、word の着色やら syntax の着色やらを全て内部的に保持しておいて、表示の時に有効な物を選択して着色するという事が必要である。
    つまり、簡単に言うと layer 機能が必要になるという事である。

    しかし、layer 機能を実装するに当たって考えるべき事がある。効率である。
    現状で何とかぎりぎりで現実的な速度で表示できるようになっているが、
    layer の機能を愚直に実装した場合、現在の高速化に使っている方法がそのままでは使えないのでかなり重くなる。
    現在の方法を何とか適用しようとしても結構面倒な操作が必要であり、どれぐらい遅くなるかは未知数である。

    ここでは複数の方法について考え、また、layer としてどの程度の機能が必要に成るであろうかを整理する。
    もしかすると完全に layer の様なおおがかりな仕組みは実装しなくても良いかも知れない。

    a 始めに考えた方法は、各 layer で着色された文字列を保持しておき、
      表示の際に有効な layer の部分をぱちぱちつなぎ合わせて実装するという物である。
      しかし、これは同じ layer に属する部分は連続している筈だ、という仮定に基づいている。
      様々な layer が滅茶苦茶に混ざり合っている場合には却って遅くなる。
      また、表示の際につなぎ合わせを実行するので部分更新であっても
      文字列の長さ (というか正確には上位 layer の着色範囲の数) に比例する時間が必要になる。

      そもそも当初は「選択範囲の着色」や「括弧の対応」の着色が念頭にあった。
      これらは精々1つか2つの着色範囲しか持たないので、
      どんなに文字列が長くなったとしても繋ぎ替えの操作の階数は一定数に保たれる。
      しかし今後「各コマンドに対応した引数の着色」などに対応するとなると、
      これらも新しい layer として実装する必要があるし、かつ、
      文字列の長さに比例してつなぎ目も増えていく。

      部分更新やカーソル移動だけでも一定の繋ぎ替えの操作が必要になるのは問題である。
      この方法は全く現実的ではない。しかし、この方法を改良すれば何とかなる可能性はある。

    b 次に考えた方法は各 layer について色の配列を保持し、
      それを用いて表示する側で最終的な文字列を一つ構築するという方法である。
      そして部分更新の際には、各 layer の変更範囲を集計して最終的な文字列自体を書き換える。

      これが一番自然な実装に思われるが多少問題点が存在する。
      「括弧の対応」の場合には離れた2点で局所的な更新が実行される為、
      単純な変更最小点と変更最大点の間を全て更新するという方法にしていると、
      変更範囲が無駄に大きくなってしまう。特に編集文字列全体を囲むような括弧の場合に
      毎回全体を更新するのと同じ事になり非現実的である。

      この場合の対策は二つ考えられる。
      1 一つは変更範囲の管理方法を単純な最小点・最大点のペアではなくもっと詳細な物に変更するという方法。
      2 もう一つは、「括弧の対応」や「選択範囲」などの広い領域を cover する layer の場合には、
        自身の更新の特性を知っている筈で、そちらに編集文字列の update を任せるという方法。

      普通は 1 の方向に進みそうな物だが、これだと実装が複雑になる。
      というかどの様なデータ形式にするのが良いのかも良く考えなければならない。
      単純に (begin,end)* の様な構造にすると例えばしましまに更新した時に更新範囲が複雑になる。
      しましまに近い時は複数の範囲ペアをくっつけて一つの変更範囲ペアにしてしまう方が効率が良い。
      しかし、この様にすると変更範囲の合成も無駄に複雑になる。却って合成操作に計算時間が掛かるかもしれない。
      というか 1 と 2 を組み合わせて、(1) 複雑な着色をする物に関しては (begin,end) を一組だけ報告させて、
      (2) 離れた点での着色になる物に関しては (begin,end) を分割して報告させるなど、
      変更範囲の報告を各 layer に任せてしまえば良いのかも知れない。
      変更範囲ペアがそれ程沢山にならないのであれば
      変更範囲の合成についても複雑な事を考えずに素直に実装して良い。

      それでも未だ微妙な点がある。
      b.1 変更範囲が分かったとしても、どの layer が有効なのかの情報がないので、
        描画文字列を更新する際に上の layer から順番に描画属性が適用されているかを確認しなければならない。
        それも各文字についてこれを実行する必要がある。

        しかし、これは別の方法を用いたとしてもループの順序が異なっているだけで等価な事をする
        必要があるのかも知れない?? でもこの方法だと b.2 に挙げる様な layer の最適化が適用できない。

        変更範囲 pair に layer 情報を付加して対策するとしても、
        layer から着色が削除された場合については、
        結局着色が削除された部分についてどの仮想の layer が有効になるのかを計算しなければならない。
        特に下層の layer が複雑になっているかもしれないし、
        隣の変更範囲 pair と地続きになっている可能性を考えてくっつける事もできるかもしれないし#1、
        …など色々と再計算が複雑になってしまう。layer 情報を付加しても効果は限定的であろう。
        # #1 はこういう事である。層3 の属性を削除した時。更に層2、層1についても変更がある。
        # 更新範囲 <22><1><111> (更新の際に参照する範囲)
        # 変更操作 <33333><111>
        # 層3      .......
        # 層2      <-->
        # 層1        <-------->
        # 変更操作としては二つの範囲であるが、
        # 実際に更新の際に参照する属性が載っている部分はより下層で分裂している。
        # 結果として三つの変更範囲が得られる事になるが、よく見ると<1> と隣の <111> の
        # 範囲は同じ layer を参照しているので無駄に範囲が分裂している事になる。
        # これらの無駄に分裂した物をくっつける事ができるか、或いはくっつけた方が良いのかという事である。
        # この様な分裂は大した問題ではない様にも思えるが本当にそうだろうか。考えてみると、
        # 最大で全 layer での削除範囲の合計x2 個の無駄な分裂が起こる…やはり大した問題ではない気がする。
        # n^(layer 数) 等の様なスケールだったら考え物だった、編集箇所の数に比例する程度なら問題ない。

      b.2 region (選択範囲) だとか括弧の対応だとかはその着色を保持するのに配列を用意するまでの事は無い。
        region に関しては現在の mark と point だけで完全に記述できるし、括弧の対応に関しては
        配列の中は殆どの時に空である。というか、選択範囲の方も選択しない限り空である。

        これらの sparse な配列に対しても全て描画属性が設定されていないか確認するのは無駄だ。

      b.3 選択範囲が解除された時など、以前の状態に戻したくなった時に、
        また全て描画文字列を構築し直す必要がある。

        しかしながら、以前に計算したのと同じ物を計算するのは気にくわないという事を除けば、
        これについては大した問題点ではない様にも思う。というのも以前の状態に戻したくなるという状況は
        頻繁には生じないからである。

        これについてはおまけ的に解決できたら良いという指標で良いだろう。
        (これについて簡単な解決ができる方法の方が、
        将来的に別の問題が起こった時にも解決しやすい・汎用的だろうという程度の目安とする。)

    c 以上を踏まえて (もしかしたら却って非効率かも知れないが) もう一つの方法についても挙げる

      各 layer で「その layer 以下の描画属性を適用した状態の文字列」を管理する方法である。
      変更があった場合には、下の layer から順に変更範囲を上の layer に伝達し、
      下の layer は該当部分の変更を自分の持っている描画文字列に対して適用する。

      しかしこの方法は既に挙げた問題を解決できていない。多少実装が楽になるだろうというだけである。

      c.x1 複数の離れた変更範囲がある場合についての解決策にはなっていないので、
        結局複数の変更範囲 pair を扱う事になる。
      c.x2 次に、下層の layer の描画文字列の切り貼りをする為には、
        index 情報が必要 (各文字の表示にエスケープシーケンスを含めて何文字使っているか) であり、
        これらも独立した配列として管理しなければならない。
        例え選択範囲などの様な単純な描画属性に対してであっても、だ。
      c.o1 被覆されて実際には表示状態に変化を与えない下層の layer の更新が上部に伝達されない、
        というのは一つの利点ではある。しかし、その様な変化がある場合は稀であるし、
        結局内部的には下層の layer の保持する文字列に対する更新が行われている。

      少しこの方法に改良を入れて考えてみる。
      「その layer 以下の描画属性を適用した文字の配列」と考える。
      一番上の layer でなければ繋げた文字列をそのまま使うとは限らない。
      それならばそもそも繋げなくても良いのではないか。
      この様にしておけば index 情報を別に覚えておく必要はなくなる。
      パラメータ展開に index を指定するだけで任意の部分列を取り出す事ができる。
      これで c.x2 の問題はなくなる。

      | 但しカーソル移動をする時の為に index 情報は覚えておく必要がある?
      | とも思ったが、これも IFS= a="${cs[*]:i}" b=${#a} 等としてしまえば良い気がする。
      | そもそもカーソル移動は一回のキー入力に対して 1 回しか実行しないのだから、
      | 常に全ての位置についてのカーソル位置の為の index を保持している必要は全くない。
      | そればかりか、そもそも出力文字列に SCOSC SCORC を埋め込む形でカーソル位置を
      | 表現する必要性があるのかすら疑問である (一応この様にしておけば、何処か別の場所から
      | 出力があった場合 (や ble.sh の座標計算のバグがあった場合に)、
      | ずれても大丈夫というのはあるが。)
      |   という事なので毎回 ${cs[*]::i} 等として文字列を連結して長さを数えれば良い。と
      | 思ったが、連結までするぐらいであれば ${cs[*]::i}$SCOSC${cs[*]:i} とすれば良いだけの気が。
      | 所で、この方法に頼っている時に、文字列が長くなると効率二度の程度の影響があるかは
      | 気になる所である。一般に編集はそれ程の速度で行われる事は無いが、カーソル移動は、
      | キーボードの押しっぱなし等によって相当の速度で入力される可能性がある。従って、
      | 編集の際には効率的に問題にならなくても、カーソル移動の際の効率に影響を与える可能性は残る。
      |
      | 追記: 現状の実装で index 情報を記録しているのは元々は別にカーソル位置を任意に
      | 取り出す為ではなかった。これは、キャッシュした文字列を任意に切り貼りできる様に
      | する為の物であった。後で、これがカーソル移動の際に SCOSC を挿入する位置として
      | 活用できる事に気付いた為に使っているだけの事である (とは言っても他に "効率的" に
      | SCOSC の挿入位置を決める方法、または、カーソル位置の確実な復元方法は分からないが。)
      |
      | また、連結した文字列は一番最後の layer だけで保持する事にすればよい。
      | →そう思ったが、連結した文字列を後で再利用しようと思ったら結局 index 情報が必要になる。
      | index 情報を一緒に管理しながら既存の文字列を切り貼りするのと、
      | 最後のレイヤーが出してきた配列全体を連結するのとどちらの方が効率的かという話になる。
      | 配列全体の連結でもそんなに問題はないかも知れない?
      |
      | 少し時間を計測してみる事にする:
      |
      | a=({1..100000})
      | time IFS= eval 'b="${a[*]}"'
      | real    0m0.077s
      | bash の割に驚異的な速度である。
      |
      | time c="${a[*]::10000}""$ins""${a[*]:10000}"
      | real    0m0.200s
      | 多少時間が掛かる。でも 10 万の要素を連結している事を考えれば充分な速度だ。
      | コマンドラインに 100k も文字を書き込む事などない。10k でも多すぎる。
      |
      | index 情報によって文字列 b の中に於ける index が分かっている場合:
      | time c="${b::40000}""$ins""${b:40000}"
      | real    0m0.053s
      | 文字列にすれば滅茶苦茶速い、という訳でもない様だ。
      | (というかマルチバイトで記憶しているから文字数を数え上げなければならない、
      | という事なのだろうか?)
      |
      | 更に index 情報を用いているので、index 情報の更新も行わなければならない。
      | これだけ巨大な配列になってくると index 情報の shift にも相当の時間が掛かるだろう。
      | (何しろスクリプトで for でループを回さなければならない。)
      |
      | 色々考えるに index 情報を管理するのは効率的に駄目だ。
      | SCOSC でカーソル位置を管理したいと思う場合、
      | カーソル移動の際にも文字列を連結しなければならないのは惜しいが、
      | この辺りはカーソル移動を実際にやってみて遅ければ SCOSC は使うのを止めて、
      | ble.sh による座標計算を信用して update-positions のデータを元にカーソルの位置を動かす事にする。

      結論
      - 各 layer 毎に「その layer 以下で計算される描画属性を適用した文字の配列」を管理・更新する
      - 実装の為に描画属性を持たない文字の配列も用意する。
      - 連結済文字列をキャッシュするのはやめる
      - index 情報の管理も行わない
      - カーソル移動の際は以下の 2 通りが考えられる
        - 配列の連結を用いて SCOSC を埋め込む (毎回全文字列を出力する)
        - update-positions を信用してカーソルを計算した位置に動かす

      | 更に、もう一つ考えるべき事として各文字の一つ一つについて描画属性を付加するか、
      | 同じ属性の文字が続いている限りは描画属性の付加を省略するか、という事である。
      | 各文字一つ一つに対して描画属性を適用すると出力が無駄に長くなってしまう。
      | しかし、同じ属性の文字が続いている限りは付加を省略する、という形だと
      | 切り貼りをする際に切った点に新しく描画属性を追加しなければならないので、
      | 各点に於ける描画属性を別に管理する必要があるという事が問題になる。
      |
      | ユーザから見えなくても、余り汚い出力はしたくないので、
      | 各点に於ける描画属性を管理する方向性を考えたい。
      | さて、これはどの様に管理するのがよいかという事になる。
      |
      | A 一番簡単な方法は各点に於ける描画属性を配列に格納しておくという方法である。
      |   下層 layer から上層 layer まで、各層でその層以下の集約結果を配列として保持するという事である。
      |   しかし、これは update がある度に各 layer で描画属性の配列をコピー・書き換えしなければならず、大変だ。
      |   特に、選択範囲や括弧対応の場合にはこの様な配列を管理し、一々書き換えを行うのは非効率に思われる。
      |
      | B そうではなく、各 layer について "描画属性を返す関数" を実装してその中で最も適した方法で
      |   属性値を計算し返すようにするというのも一つの手である。
      |   複雑な色付けを行っている場合には、単に内部で描画属性の配列を管理する様にすればよい。
      |   さて、各 layer で独立に描画属性を管理する場合 (つまり、より下の layer の値について関知しない時)、
      |   下層 layer への問い合わせを順次行う必要がある (勿論、これは関数の呼出側で行う)。
      |   これの overhead についても多少気になるが、
      |   そもそも更新時の切り貼り自体そんなに沢山の箇所で行うとは思わないので、気にしない。
      |
      |   (寧ろ全ての点について描画属性を即座に返せる様に配列で管理するという A の方が無駄である。)

      結局、描画属性を後で必要とする頻度は小さいとして B を採用する事にする。
      つまり、各 layer について指定した位置での描画属性値を返す関数を用意させる。
      描画属性値が設定されず下位の layer に任せる場合には空文字列もしくは -1 を返させる。

      さて、この様な実装を行うと決めたからには、再度描画用出力の生成関数を実装し直さなければならない…。
      後、既に書いたコードも利用できる様に、既に書いたコードを利用する layer も作った方が良い。
      或いは先にそれを書いてから実装を始める。

      各 layer に関する関数名は ble-highlight-layer:*/* の形式にする。
      ble-edit.sh は複雑化して来たので、これらのコードは ble-color.sh の方に実装する事にする。
      ble-color.sh は当初 highlighter の類を記述する目的で作ったが、
      新しく ble-syntax.sh を作成した事で使われなくなった機能などが沢山ある。
      これらを整理・統合する目的もある。

      実装した。動いている様なので差し替えた。

    取り敢えず今回の実装で以下の項目は解決した。

    | x 現在 update-positions で位置が変化しただけの部分に対しても表示用の SGR 付き文字列を更新している。
    |   これは省略できる筈。改行やタブなどで出力内容に変化のある部分については別に記録して後で合成して表示する。

    元々の目的である

    | x word の属性が解除されてもそれが表示に反映されない。

    に関しては未だ実装していない。レイヤーの仕組みを整えたは良いが、各レイヤーを実装する必要はある。
    word の属性を設定しているレイヤーをどの様に実装するのが良いかはまた別の問題である。
    これについては項目を改めて後で考える事にする。

2015-02-21

  * 描画用のシーケンス構築を高速化する [#D0155]

    色々考えた結果、最終的に (a) 描画用のシーケンスと
    (b) TAB 等の位置を制御しながら出力する update-positions を合成しなければならないので、
    a, b の両方を高速に合成可能な形に改良する必要があるという結論に到る。

    update positions の側に関しては、
    出力の文字が事前に予測不可能な物は TAB 等限られているので、
    予測不可能な物に関してだけ合成時に特別な処理を行うという方向で行く。
    つまり、描画用の側で予測可能な文字についてのシーケンスを生成してしまう
    (予測不可能な物に関しては適当な可能性の高そうな文字列を入れておく)。
    update positions 側では出力する文字に関しては、
    特別な処理を行った物についてだけ記録を行う事にする。

    現状の update-positions の実装について

    | さて update positions では複雑な事を行っていて lc だとか lg だとかの計算も行っている。
    | これらの動作について今一度確認してからでないと update positions を弄れない。
    | 確認事項については以下の通り。
    | - lc lg の詳細な動作について。
    |   例えば行頭や行末での処理、複数文字で構成される文字の場合は?
    | - lc lg で計算した結果を使っている箇所は何処か?
    |   それらの場所に影響が出ない様に書き換える必要がある。
    |
    | 取り敢えず何処で使っているかについて調べる事にする。
    | 先ず update-positions の中で出力している物は lc lk lj g である。
    |
    | | - _ble_line_text_cache_lc については、update-positions 及びその中から呼び出される
    | |   save-cursor で設定されている。そして、.ble-line-text.construct で参照されて
    | |   変数 lc の戻り値を設定するのに使われている。lc は .ble-line-text.construct の戻り値か、
    | |   或いは編集文字列が空の場合にはプロンプトの構築によって計算された値になる可能性もある。
    | |   lc はそのまま _ble_line_cur 配列の第2要素(base0)に格納される。
    | |   _ble_line_cur[2] は .ble-edit-draw.update-adjusted の中で取り出されて、
    | |   .ble-text.c2s を通してから READLINE_LINE に設定される。
    | |
    | | - _ble_line_text_cache_lk は update-positions 及び save-cursor で設定される。
    | |   .ble-line-text.construct の中の初期の方に lk に代入されている。
    | |   lk は .ble-line-text.construct の中のループで参照されているが変更はされていない。
    | |   %%どうやら _ble_line_text_cache は lk の計算のキャッシュとして働いている様子である。%%
    | |   更に export する様なコードの残骸も残っている様だが関連するコードが見当たらないので、
    | |   これに関しては廃止されてから久しい、或いは、何か書きかけて取りやめたという可能性が高い。
    | |   さて、改めてよく見てみると lk は lg を抽出する為に使われている。つまり、
    | |   カーソルの一つ前の文字を出力する時に使う lg が何かを計算する為には、
    | |   カーソルの一つ前の文字の文字 index が必要になりそれが lk になっているという事である。
    | |   lk はその他の用途では使われていない。
    | |
    | | - _ble_line_text_cache_lj はコメントの説明を見てもこれまた何の用途の為にあるのか分からない変数である。
    | |   実際に使われている所を見ると、多分これは以前に高速化を行おうとして実装し書けて終わった機能である。
    | |   改めてもう少し解釈を書いておく事にする。現在の実装では全ての文字について一々計算を行っている。
    | |   しかし ASCII の印字可能文字が続いている場合には毎回計算しなくても位置や文字の計算は唯単に
    | |   increment して行って設定するだけである。なので、その様な場合には最後の ASCII 文字まで
    | |   計算を抑えておいて、最後の ASCII 文字までいった時にそれまで溜めていた計算を一気に行う事ができる。
    | |   lj は連続する印字可能文字の最初の位置を保持していると考えれば良い。
    | |   或いは、もっと実際的な機能としては次に本来の計算を実行するべき index という事になる。
    | |   これがコメントに書かれていた説明である。
    | |
    | |   しかしながら、一気に計算を行うと言っても、カーソル位置計算は簡単にはできないので
    | |   結局毎回計算をする事になっているという具合である。今は常に lj=i-1 の状態でループが回っている。
    | |   カーソル位置計算についても一気に行うコードを書いたら (或いは、単純な increment を続けられる
    | |   という事が分かる範囲を計算して、その範囲内だけで一気に行う様にしたら) lj を実際に遅延させるコードに
    | |   移行する予定であったのだろうと予想される。
    | |
    | |   何れにしてもこの変数は実装の詳細というか、最適化の為に用意した物であるので、
    | |   今回位置から実装し直すにあたってこの機能を継承する必要性はない。
    | |   この変数について実装は未だ不完全であるし、似たような機能が必要になればまた新しく考え直した方が良さそうである。
    | |
    | | - _ble_line_text_cache_g _ble_line_text_cache_ei
    | |   何とこの配列は現在は使用されていない。現在の実装では .ble-text-line.construct の中で
    | |   _ble_region_highlight_table から直接 g を読み取って使っている。
    | |   元々は任意のカーソル位置にある g を取得する為に使っていたという事だろうか。
    | |   しかしそれは _ble_region_highlight_table から読み取れば良い事だし、
    | |   そればかりか _ble_region_highlight_table からの lg の読み出しですら、
    | |   描画SGRと update-positions の合成のループを毎回するので、その中でおまけ的に処理している。
    | |
    | |   と思ったが、もしかするとこれは最適化によって消えた変数ではなくて、
    | |   最適化の為に導入しようとして結局導入には到らなかった変数なのではないだろうか。
    | |   _ble_line_text_cache_ei という似た様な位置で定義されていて使われていない変数があるので、
    | |   多分そう言う事だろう。これらの変数は未だ使われていない変数である。
    | |
    | | - _ble_line_text_cache_cs の意味は明確である。表示の為に出力される文字である。
    | |   使い方も単純で .ble-line-text.update-positions で値を fill して、
    | |   .ble-line-text.construct の合成のループで中身を読み出すという物だ。
    | |   上記の2行以外では参照も代入もされていない。
    | |
    | | - _ble_line_text_cache_x, _ble_line_text_cache_y は _ble_line_text_cache_lc
    | |   と全く同じ経路を辿って、別の関数で使われている。
    | |   つまり、cx cy という変数に一旦入って _ble_edit_cur に格納され、
    | |   その後其処から読み出されて使われている。
    |
    | まとめると、
    | - _ble_line_text_cache_x, _ble_line_text_cache_y, _ble_line_text_cache_cs
    |   が主な計算の目的である。
    | - _ble_line_text_cache_lc, _ble_line_text_cache_lk
    |   は左側にある文字の文字コードと sgr を求めるのに使う。
    |   文字幅などの情報は出力しない。
    | - _ble_line_text_cache_lj _ble_line_text_cache_g _ble_line_text_cache_ei
    |   は実装しかけて中断している機能の為の変数の様に思われる。気にしなくてよさそう。
    |
    | さて、次にしらべるべきなのは lc と lk の処理方法の詳細についてである。
    | - 左側に複数文字からなる文字があった場合や、
    |   改行があった場合の取り扱いはどうなっているのか
    |   →複数文字からなる文字があった場合にはその最後の文字を READLINE_LINE に設定している。
    |
    |
    | - 左側の文字の開始位置 (x y) の管理はどうなっているのか
    |   →これは単に文字コード lc から計算される幅を使ってカーソル位置を ESC [ D
    |   で後退させるだけという実装になっている。なので lc さえあれば良いという考えだ。
    | - 出力する sgr は本当に常に左側の文字の物で良いのか。
    |   もしそうならば何故 i-1 等ではなく lk という変数が存在するのか。
    |   →行頭の場合には右側の文字 (なければ空白) を READLINE_LINE に設定して
    |     READLINE_POINT=0 を設定する様になっている。
    |
    | * lc が "文字列" ではなくて単一の "文字" である理由
    |   READLINE_POINT に設定する値を計算する必要があるから。
    |   文字列であっても各文字についてバイト長を計算すれば READLINE_POINT を計算できるが面倒だ。
    |   単一の文字だけというルールにしておけば一回 c2bc を呼び出すだけで済む。
    |
    | * lj で計算を遅延している理由
    |
    |   これは行頭の文字が来た段階では右側に来る文字を予測できないからである。
    |   右側の文字が確定してから lc を計算する。
    |
    |   > 改めて見てみると lj 周りの実装が少し複雑になっている。
    |   > カーソル位置が行頭にあるのが何回か続くと lj が更新されずに続く事になる。
    |   > これは一体何の為の物だろうか???
    |   > 行頭が何回か続くとその後で一気に更新が実行される。
    |   >
    |   > lj が何の為にあるのか漸くわかった。これは「カーソルが行頭にある場合には
    |   > 左側にある文字ではなくて右側にある文字の情報を返す」という仕様に関係している。
    |   > 行頭に文字がある時には未だ次に文字が来るのか別の改行文字が来るのか分かっていない。
    |   > 右側に通常文字が来た場合にはそれで良いが、改行文字が来た場合には改行を出力する訳にも行かないから、
    |   > 代わりに空白文字を出力する事にするのである。そしてそれど同時に READLINE_POINT を 0 にする。

    現状の実装がどうなっているかについては大体分かった。一番処理を複雑にしているのは lc lk の計算である。
    然し、ここで思ったのだが何故 lc lk を毎回計算してキャッシュしているのかという事である。
    x や y に関しては初めから順に計算して累積していかなければ計算する事ができない。
    なのでカーソルを移動するたびに計算するよりは前に計算した物を再利用した方が速い。
    しかし lc lk に関しては x y cs のキャッシュさえ残っていればどの様な物になるかはその場で計算できる。
    ループの中で累積的に計算し、その時の状態をキャッシュする仕組みにしていると先読みができないのでアルゴリズム的に苦しくなるが、
    x y cs を全て update した後に必要な所だけ計算するという事にすれば先読みも何もあった物ではなく簡単に計算できる。
    それに分離した方が bleopt_suppress_bash_stdout に応じて計算するかしないかの選択もできる。

    取り敢えず x y cs だけを計算してその後でカーソル位置の lc lk だけを計算する様に簡単化した version の
    .ble-line-text.construct を作成してみる事にする。
    →様々なバグや bash の不具合が途中で見付かった為に随分と中断してしまったが、
      .ble-line-text.construct の単純 version は直ぐに実装できた。

    さて使ってみるとバグが出てきた。C-u 等をした時に表示内容が変になる。
    保持している文字列は正常の様だから、shift に失敗しているのではないかという気がする。
    と思ったが、そもそも送られてくる BLELINE_RANGE_UPDATE の時点で変だ。
    10 文字ある文字列の 5 文字目で C-u を実行した場合 (0 0 5) 等となる筈だが、
    (9 10 9) という値が入っている。というか、これは最後に追加した文字の分である。

    何処で変な事になっているのか調べる。
    先ず ble-edit/dirty-range/update の呼出を調べる。
    ble-edit/dirty-range/update 0 0 5 等となって正しい値が設定されている様に見える。
    では結果の _ble_edit_str_dbeg の類はどうなっているか? →これも問題ない。

    分かった。やはり .ble-line-text.construct が悪かった。
    dirty<=0 の時に shift が行われていなかった。
    (9 10 9) という物が表示されている様に見えていたのは、前回の shift の時に出力した物を見ていただけであった。
    dirty<=0 の時には shift がそもそも行われていないので、その前後に設置した出力にも引っかかっていなかったという事である。
    これを修正したらすぐに動くようになった。

    次に、.ble-line-text/update-highlight-layer を実装した。
    これは更新の必要のある部分だけ出力データを更新する物である。
    特に、色付けの変わった文字の部分について再計算を行う。
    現在は update-positions によって位置が変更された部分についても再計算を行っているが、
    これは将来的に削除して、update-positions による更新は別の所で処理する予定である。

    さて、新しく実装したはいいが動きが変だ。
    特定の状態にある時にカーソルを移動するだけでも位置がどんどんずれていく。
    と思ったら、これは dbeg<0 なのにこれを変更開始点としてしまっている所があった為だった。
    単に dbeg>=0 を付け忘れていただけですぐに直った。

    未だカーソルの移動が遅いと思って色々試していたら、
    どうやら ble-syntax-hightlight+syntax の中が重い。
    parse は更新された範囲だけに対して処理をしているので遅い筈はない。
    というかカーソルの移動の時には呼び出されない。という事は、
    その後の属性値の適用が重いという事になる。
    取り敢えず umin, uend を用いてその範囲だけ属性値を更新する様にした。
    それでも遅い。どうも word に対しての処理が重い様である。
    良く考えたら毎回各 word に対してファイルかどうかの判定を行っている。
    これは確かに重かろう。修正した。

    さて。次の問題。属性値の適用を _ble_syntax_attr_umin ～ uend
    の間に限った事によって問題が生じている。
    "word による着色" がなくなった時に再び属性値を _ble_syntax_attr から
    復元しなければならないが、 "word による着色" は _ble_syntax_attr_umin
    等の管理の範囲外である。これを正しく実装する為にはやはり layer の様な仕組みが必要となる。
    しかし layer の仕組みを実装するに当たってどの様にすれば良いかについては申し越し考える必要がある。

    ここでは、以下の問題点を挙げて一旦閉じる事にする。
    - "word による着色" がなくなった時にその部分の着色がなくなるべき

2015-02-20

  * bash-3.1 ESC [ の受信について [#D0154]

    bash-3.1 での ESC [ を受信する為に、以前の修正で ESC [ を CSI に変換していた。
    然し、今回 bash-4.3 で C-@ を受信する為に C-@ (0) を UTF-8 の 2-byte 符号で受信し直す様にした。
    この方法を用いれば ESC [ も "ESC の 2-byte 符号" + "[" として受信し直す事ができる筈だ。
    この様にすれば ble-decode-char に特別なコードを書き込んで
    CSI を無理矢理 ESC [ に戻す等という事をしなくても済みコードも綺麗になる。

    変更した。正しく動作している。

  * <bug> C-x a 等に対して x が読み取られる。 [#D0153]

    ble-decode-byte を見てみた所ちゃんと 24 97 が受信されているのでこれは bind の問題ではない。
    その後の文字の処理の問題か、キーの処理の問題である。

    今度は .ble-decode-char の方で何が受信されているかを確認する。
    UTF-8 decode に問題があるとは思われないので、ここでも 24 97 になっている筈である。
    →果たして 24 97 になっている。OK

    今度は .ble-decode-key の方で受信されている物を確認する。
    67108984 97 が受信されている。67108984 は 16 進数に直すと、0x4000078 である。
    これは Ctrl フラグと 78 = 'X' の組合せになっている。この時点でも問題点は内容に思われる。
    とすると問題があるのは .ble-decode-key の中で行われている処理だろうか。

    と思ったら今迄の処理にかなり問題があるという事が分かった。
    というか段々思い出してきた。色々書き換えようと思って弄っている途中で中断していたような気がする。
    (或いは、訳が分からなくなったが取り敢えず動いているから良いという事にしたのだったか。)

    - 先ず、.ble-decode-key.invoke の KEYS に代入される値について。
      ${var//_/ } ではなく ${var//_/} になっているので key 分割に失敗する。

    - .invoke-default で最後に入力された文字だけを見て既定の関数を呼び出している。これは変だ。
      というかそもそも invoke-default はこのタイミングで呼び出すべき物なのかも謎である。

    - また、.ble-decode-key.invoke に失敗した時に _ble_decode_key__seq をクリアしているので、
      .ble-decode-key.invoke && return
      fallback
      とした時に fallback に辿り着く時には _ble_decode_key__seq の情報が消えて無くなっている。
      _ble_decode_key__seq= は呼出側で処理する事にする。

    - 一致に失敗したというエラーを出力してから途中一致する物がないかを探索している。
      失敗したと表示したのに何かを実行するのは変ではないか?
      でも複数のキーからなるシーケンスで失敗した場合にはその複数のキーについてエラーメッセージが表示されて欲しい。

      例えば、一致に失敗した時に
      1 遡って適用できるシーケンスがないか探す。見付かればそれを処理して終わり
      2 もし任意のキーに対する既定の動作が設定されていれば、それを処理して終わり
      3 何も設定されていなければ全体のキーについてのエラーメッセージを表示する
      と言う処理にすれば良いのではないかと思う。x

      さて、これを実装する為には…遡って適用できるシーケンスが見付かって実行した時点で制御を呼出元に戻したい。
      が、現在の emit の再帰呼び出しの方法だとそれができない。emit 関数を再実装する必要がある様に思う。

    また良く分からなくなった。何が望ましい動作なのだろうか。
    ble_opt_error_kseq_discard の意味を変えた方が良い様な気がしてきた。
    現在の実装を見ると ble_opt_error_kseq_discard になっている場合は部分一致がある場合でも捨てる事になっている。
    しかしそうではなくて、部分一致すら見付からなかった時に残っている
    キーの列をどの様に処理するかというのを制御したいのではないか。
    部分一致について処理しないようにしたいのであれば、そもそも keymap にそういう物を登録しない様にすれば良いだけの話である。
    keymap に色々設定しておいてから、ble_opt_error_kseq_discard で部分一致なバインドを
    on/off にするという使い方も可能ではあるが直観的ではないし、何が便利であるのかも分からない。

    ここで、ble_opt_error_kseq_discard は部分一致も見付からなかった場合に残っている出力を捨てる為の設定とする事にする。

    再実装した。すっきりした。

  * <bug> C-@ を受信できていない @ bash-4.3 [2015-02-11] [#D0152]

    > * bash-4.3 C-@ について
    >
    >   bash-4.3 になって bind -x が三文字以上に対して使える様に bugfix されたが、
    >   同時に C-@ を含むような系列に対して bind が正しく処理されなくなった。
    >   現在 bash-4.3 において C-@ を捕捉する事は出来ていない。

    bind -X を見ると確かに
      "\C-@": "ble-decode-byte:bind 0"
    が登録されているのだが受信できない様だ。

    $ bash
    $ bind '"\C-@":"test"
    $ bind -s | less
    $ bind -x '"\C-@":"echo test"'
    $ bind -X | less

    とここまで来て C-@ を押したら
    bash_execute_unix_command のエラーが発生するという事に気付いた。
    (ちらつきを抑える為に bash の出力を殺したのは良くなかったかも知れない)
    →bash の出力をファイルに書き出して、それをチェックする事にした。
      エラーを吐き出していればそれを visible-bell で表示する。

    仕様がないので "C-@ *" に関しても全て登録する事にした。
    →"C-@ *" に割り当てても駄目なようだ。
      というか C-@ を何度も押しても C-@ を続けている限りはエラーも起きない。
      つまり C-@ に関連して bash は何か特別な処理をしている? 気がする。

    % 2015-02-19
    %
    % 現在の所 bash-4.3 において keymap が見付かりませんでしたと表示されるのは
    % C-@ だけなので、keymap が見付かりませんでしたエラーを受信したら C-@
    % を受信したという事にしてしまうというのも一つの手である。
    % これは既に bash-3 で C-d を受け取るのに使用している方法を使えば良い。

    念のため他の version ではどうなっているかも調べておく。
    bash-4.2 は C-@ は普通に受信できる。bash-4.0 でも普通に受信できる。
    bash-3.2 OK。bash-3.1 OK。やはり bash-4.3 だけで C-@ が受信できない。

    bind -x ではなく単に bind '"\C-@":"hello"' 等とすると正しく受信できると分かった。
    ならば bind '"\C-@":"\xC0\x80"' 等としてしまえば問題ない。
    "\xC0\x80" は UTF-8 の表現方式で 0 を表す。
    (但し、UTF-8 は或る code point を表すのに最小の長さの符号化を要求するので、
    上記は正しくない、或いは、正規化されていない表現、という事になる。
    何れにしても、これは直後に .ble-decode-char+UTF-8 で 0 に翻訳される一時的な物なので問題はない。)
    →これで呆気なく動くようになった。

2015-02-19

  * <bug> 4.3, 3.1 いつの間にかに日本語が入力できなくなっている。いつから? [#D0151]

    3.1 は別の問題であった。独立した項目にする。

    4.3 では無効なシーケンスですという(自分で書いた)エラーメッセージが出る
    3.1, 3.2 では謎の文字が入力される。というか ^# と表示される。
    4.0 では何故か入力できる。"あ" とすれば 227 129 130 が UTF-8 で受信されている。
    4.2 でも入力できる。

    あ E3 81 82

    と思っていたらいよいよ全ての version で読み取れなくなった。
    今迄読み取れていたのは何だったのか…。良く分からない。
    .ble-text.c2s と .ble-text.s2c を弄っただけの筈だが何故だろう。
    スクリプトが行けないのかと思って色々試したがよく分からない。

    と思っていたらそもそも受信している byte が 129 130 だけになっていた。227 が何処かに消えている。
    というか ESC にも bind できていない。色々とおかしい。

    何でか分かった。bind に使う文字をどの様に生成するかが関係していた。
    bind に使う文字は utf-8 でエンコードして渡しては行けない。
    直接バイトを指定するか、そうでなければエスケープシーケンスを用いて渡す必要がある。
    直接バイトを指定すると別の文字とくっついたりして変な事になりそうなので専らエスケープシーケンスを用いる事にする。


    2015-02-20
      と思ったら今度は \C-_ \C-[ \C-] \C-^ 等が動作しなくなった。
      \C-@ も今迄エラーメッセージが表示されていたのに、今は bell が鳴る。
      と調べてみたら、この部分の変更が原因になっていた。
      通常文字までもエスケープシーケンスを用いて表現してしまった為に、
      \C-_ \C-[ \C-] \C-^ が \C-\135, etc になってしまっていた。
      エスケープシーケンスにするのは 127 以上の文字 (8bit 文字 + DEL) だけにして解決した。

  * <bug> bash-3.1, .ble-text.s2c が日本語に対して正しく働いていなかった。 [#D0150]

    先ず 3.1, 3.2 で化けている事について。
    内部的には正しく入力できている様なのでこれは簡単に解決できるだろう。

    ^# 等という文字はないよ?? と思ったが、恐らく C-# とデコードされているのだろう。
    と思ったがやはり変だ。info.draw でも ^# と表示されているこの文字は一体何か?
    info.draw では特別なデコードは行っていない筈である。
    改めてみてみると文字コードについて 0 以上であるという仮定に基づいた処理になっている。
    負の文字コードになっているのであろう。
    そしてそれは文字デコードのエラーフラグが立っている事を示す?
    と思って ble_decode_Erro を確認したが別に符号ビットではなかった。
    というか符号ビットを立てるような富豪はないように見える。^# とは一体何なのか…。

    うーん。そして実際に出力してみると正しく "あ" と入力されている様子である。
    表示だけが変になっているという事の様である。これは一体どういう事なのか…。
    改めて見てみると .ble-text.s2c が怪しい。
    実際に試してみたら果たして -29 という値を吐き出している。

    そしてこれがどの様に実装されているかというと結局
      printf '%d' "'あ"
    の様な事をしている。これを実行してみると確かに -29 と表示される。
    これは utf-8 で "あ" を構成する初めのバイト 227 を signed char で解釈した時の値である。
    さて、とすれば bash-3 で unicode の文字コードを取得する正しい方法を考える必要がある。
    試しに
      /usr/bin/printf '%d' "'あ"
    等としてみたら、227 と表示されて、変な文字が余っているというエラーを出力した。使えない。

    bash-3.1, 3.2 では "${a:b:c}" の形式ではバイト単位ではなく文字単位の操作しかできないし困った…。
    decode してしまったのが問題だったという事なのか。でも、補間の場合など ble-decode-byte
    以外を通して入力される文字列もあり、これらも正しく表示する為には ble-decode-byte+UTF-8
    で逐次キャッシュを作成するという方法は使えない。やはりちゃんと計算する方法が必要である。

    うーん。どうやら
    while read -n 1 a; do printf '%d' "'$a"; done <<<"${text:i:1}"
    とすれば何とかできる様ではある。fork するよりは速いだろうか。

    或いは、c2s があるならば二分法で攻めるという手もあるかもしれない。幸い utf-8 は順序を保存する。
    と思ったが c2s 自体が bash-3 では絶望的に遅いので二分法はしたくない。

  * <bug> bash-4.2 が segfault する。算術式中の配列要素に関係して。 [#D0149]

    | 何処で落ちるのかと調べてみたら .ble-edit-draw.redraw の中である。
    | 更に調べてみると以下の様な何の変哲もない部分である。
    |
    | local dbeg dend dend0
    | ((dbeg=BLELINE_RANGE_UPDATE[0],
    |   dend=BLELINE_RANGE_UPDATE[1],
    |   dend0=BLELINE_RANGE_UPDATE[2]))
    |
    | と、ここで思い出したのだが何かの bash の version が、
    | 一つの算術式の中で複数の配列参照を行うと落ちるという問題があった様な…。
    | 少し試してみた: ((x=arr[1],y=arr[2])) これで落ちる。
    | これは面倒臭い。かなり大幅な書き換えをしなければならない。
    | というか patch を当てるんだったらこの動作についても patch を当てて欲しい。

    算術式の中で配列を使うと segfault する問題について。

    | 算術式の中で配列要素を参照すると、次の token に添字が適用されている様だ。
    |
    | 算術式の中で配列要素を参照して代入すると segmentation fault する。
    | 算術式の中で2回以上配列要素の値を参照すると segmentation fault する。
    | 例えば ((x=arr[1],y=arr[2])) で落ちる。
    | 代入するのは平気な様である。また、参照すると必ず落ちる訳でも無い様だ。
    |
    | 配列でない変数に対しても同様に落ちる。
    | 評価時というよりは構文解析時に落ちているのかも知れない。
    | 括弧で括っても駄目だし、カンマ以外で区切っても駄目。let でも駄目。'' で囲んでも駄目。
    | 結局、安全に評価する為には、複数の参照がない様にするべきなのか?
    |
    | 調べたら http://osdir.com/ml/bug-bash-gnu/2013-01/msg00042.html に報告が上がっている。
    | http://osdir.com/ml/bug-bash-gnu/2013-01/msg00043.html で解決したという事になっているが。。
    | 4.2.39 で少なくともエラーが発生していた様だ。手許の bash-4.2 は 4.2.53 なのだが。。
    | もしかして 4.3 には適用されたけれども 4.2 には結局適用されなかったという事か?
    |
    | 所で上記ページで報告されている ((a=b[1],b=1)) という式を試してみたが、これでも落ちる。
    | つまり、配列に対する参照を複数回行った事が問題ではないという事。。うーん。
    | どの様な時に落ちてどの様な時に落ちないのか。。
    |
    | うーん。gdb で見ると配列添字が来るはずの所に次の tok が来ている。
    | 例えば ((a=b[1],b,c=1)) とすると問題なく動く。
    | ((a=b[1],c,d=1)) でもOK。評価結果も異常はないように見える。
    | また ((a=b[1],0,c=1)) とすると落ちる。((a=b[1],0)) は OK。
    | ((a=b[1],c,d=b[2])) も OK。
    | というか何故か分からないが配列に対する代入を実行しようとしている?
    | つまり、"配列添字" が次の tok にも適用されてしまっているという事か?
    |
    | ((a=b[1],1+1,d=b[2])) これは落ちるが、
    | ((a=b[1],c+1,d=b[2])) これはOK。
    | ((x=(c=123,a=b[1],c+1))) これもOK。評価結果 $x も問題ない。
    |
    | 所で速度比較を行ってみる。
    | ((a=arr[i%3]));((b=arr[i%2+1]))
    | ((a=arr[i%3],dummy,b=arr[i%2+1]))
    | 殆ど違いはない様だ。dummy= として挟んだ方が微妙に速いという程度。

    何れにしても ble-syntax.sh で大量の算術式を使ってしまったから、
    これは大変な書き換えだ…と思って実際に書き換えてみた所、
    意外とクラッシュのパターンになっている式は少ない様だ。
    書き換えたら簡単にはクラッシュしなくなったので取り敢えずはこれで一件落着とする。

    全ての実行パスについて試した訳ではないので未だクラッシュする罠が残っているかもしれないが、
    それは落ちてから考えれば良いという事にする。

  * ble-decode.sh: bind C-x の変更 [#D0148]

    改めてテストしてみた所 C-x 単体に対して bind して segfault するのは 4.2 だけの様だから、
    bash-4.2 の時にだけ "C-x *" のペアで bind する事にした。
    ペアで登録していると2文字目が入力されるまで C-x が届かないので、
    その他の bash の version では "C-x" 単体で bind する事にする。
    (とはいいつつ、emacs keymap の設定だと C-x C-x 等の key binding があるので結局は
    ble.sh の内部で 1 文字目の C-x が pending する事になる訳だが)。

    また、これに伴って既定で bind されている "\C-x *" が上書きされなくなるので、
    bind -sp で列挙した物を全て bind -r する事にした。
    今迄は "\e" で始まる物しか bind -r していなかったが、そんなに速度が変わる物でもないだろう。

    + C-x は 4.2 だけの問題化と思いきや、3.1 がクラッシュした。

      改めて複数の version で確認を取る事にする。
      3.1 は先に述べたように落ちた。具体的には C-x C-b C-b 等として落ちた。
      3.2 も同様に C-x C-b で落ちる。4.0 も同様に落ちる。
      結局 C-x C-b 等と打って落ちないのは bash-4.3 だけである。

      結果として bash-4.2 の時にだけ "C-x *" ではなくて、
      bash-4.2 以下の時は全て "C-x *" で bind する事にした。


  * <bug> 日本語を入力すると位置がずれる @ 4.0 bleopt_suppress_bash_output= [#D0147]

    →どうも 4.0 は 3 と同じ様に bind -x の前後でプロンプトを消去する様だ。
      という事で bind 前後のコードを 3 と共通の物にした。

    また、C-d を捕捉する事もできていない。これについても対応した。
    と思ったら、どうも C-d が捕捉できなかったのは、bind 前後のコードを
    3 と共通の物にした所為で IGNOREEOF が設定されてしまった所為であった。
    4.0 では READLINE_LINE が存在するからわざわざ IGNOREEOF を設定する必要はない。
    4.1 用のコードと同じように READLINE_LINE を設定すれば良い。

    という事で bind 前後のコードの分岐を増やす事にした。
    bash の bind -x 関数の呼出の前のプロンプトの消し方に応じて _ble_bash>=40100 で分岐するのと、
    bash が READLINE_LINE 変数を用意しているかどうかに応じて _ble_bash>=40100 で分岐するのを区別する。

    しかしそれでも未だログアウト時のメッセージの表示位置が変になっている気がする。
    その他のコマンドの実行の時にはずれていないからそれ程問題という訳でもない。
    これは後で対処する事にする。■

  * <bug> 4.0 日本語を入力すると (( の中で日本語を使ったという文句が出る。 [#D0146]
    どこかの算術式に文字列が紛れ込んでいるのだろうか。

    と思ったら関係ない所を直したら何故か動くようになった。
    と思ったが、直した箇所は adjusted をするかどうか、
    つまり READLINE_LINE を用いて bash の出力を制御するかどうかの部分である。
    つまり、問題点は adjusted の部分である。
    もう一度 READLINE_LINE を用いる様に正しく修正して試してみる。これで問題が再現するはず。

    再現した。カーソルの位置と出力されるタイミングから言って、
    これは明らかに adjusted の中から発生している。
    adjusted の中身は弄っていないから lc の計算方法を変更した事が原因であるのは明らかである。

    どうやら .ble-text.c2w が $ret 変数に値を返すはずなのが何も値を設定していない様である。
    前回の値の "あ" というのが残っている。
    もっと調べてみると、どうも ret に予め "あ" 等の文字列が入っていると
    ret を計算する為の筈の算術式の評価に失敗してしまう様である。
    ret は代入される側なので予め入っている値が何であれ関係ない等と思っていたが、
    良く考えてみたら算術式の評価の方法上 ret の中身を展開してまで数式として解釈する筈で、
    ret に何が入っているか分からない状態で算術式を起動するのは危険という事である。

    ble-decode-byte+UTF-8 でも似たような問題がないかと確認してみたら、
    此方の方は全く問題はなかった。こちらは計算した値を使ってそのまま
    decode-char を呼び出す様になっていて、
    外部の関数が用意した変数に値を設定して制御を返すという方式ではないので、
    未初期化の変数が算術式の中に登場するという事は無い。

  * <bug> bleopt_suppress_bash_output= にした時にプロンプトが二重になる [#D0145]

    暫く bash の出力を抑制して処理を行う様にしていたが、
    試しに bleopt_suppress_bash_output= を再度設定して動かしてみた所、
    bash がプロンプトを出力する様になっていた…。
    何故だろう。bind/tail の直後に PS1 をファイルに出力しても PS1 は空だ。
    bash が PS1 の内容を覚えているという事だろうか?
    でも同じ version で少し前には正しく動いていたはずである。

    どうも blerc デフォルトの .bashrc をロードした時になる様だ。
    しかし何故だろうか。何か変な PROMPT_COMMAND が設定されているのかとも思ったがそういう訳でもない。

    どうやら bind -x したコードの内部で PS1 を弄っても反映されない様だ。
    外で PS1 を設定する必要があるという事。
    今迄は ble.sh ロード時に PS1= を設定していたので、それがずっと生きていて動いていたが、
    .bashrc をロードすると PS1 に新しく値が設定されてしまうので駄目という事。

    よく考えたら、今迄もプロンプトが表示されてからすぐに入力をしたりすると
    表示が乱れるなど思い当たる事が他にもある。プロンプトが表示されるのが ble.sh をロードした直後なのに
    その後に未だ .bashrc 等の処理を行っていたのが原因である。
    その時間差の間に何かを入力した事によって表示がずれていた。

    思うに ble.sh のロード・初期化と、実際にアクティブにする attach の操作を分離すべきである。
    ble-initialize ble-attach ble-detach 関数を定義する事にした。
    また ble.sh に noattach の引数を渡した場合には、その場での attach をしない様にした。
    必要な場合は後で ble-attach を呼び出して貰う事にする。

    →これで一応 bleopt_suppress_bash_output= の時にも動作する様になった。
      bash-3.1 の場合にも C-d を正しく捕捉できない事を除けば正しく動作する様になった様に見える。
      (とはいいつつやはりちらつきは気になる。)

  * <bug> ble-detach が動かない [#D0144]

    まとめ
    - awk のエラーメッセージが tmp/$$.bind.save に混入していた
    - awk の -v var=value の中の value はエスケープシーケンスが解釈される
    - bash-4.3 bind -X で表示されるコマンドは特別なエスケープがされていて bind -x では使えない

    > 色々あるが取り敢えず $_ble_term_fghr と言った類の物が直接表示されている。
    >
    > 後、awk を呼び出そうとしたり何か変だ。取り敢えず分かり易い所から。
    > $$.bind.save の中を覗いてみる…と思ったら awk のエラーメッセージが bind.save の中に混入している:
    > awk: 警告: エスケープシーケンス `\'' は `'' と同等に扱われます
    >
    > するべき事は、
    > - awk のエラーメッセージは別の所に出力されるべき
    >   gawk の幾つかの version からは "/dev/fd/数字" を用いる事ができるのでそれが利用できる。
    >   但し少し古い version の gawk で動かなければ結局これは積極的には採用できない。
    > - メッセージの通りエスケープシーケンス \' に対する処理を行う。
    >
    > 何と awk -v APOS="'\\''" 'BEGIN{print APOS;exit}' だけでエラーになる…。
    > awk -v apos="'" 'BEGIN{print apos "\\" apos apos; exit}' はエラーにならない。
    > つまり -v で渡したパラメータに含まれるエスケープシーケンスを解釈するという事???
    > 調べてみたら POSIX レベルでそう動作する事になっている様だ。
    > [[bash - Should awk expand escape sequences in command-line assigned variables? - Stack Overflow>http://stackoverflow.com/questions/13808909/should-awk-expand-escape-sequences-in-command-line-assigned-variables]]
    >
    > 1回 ble-detach して再び ble-attach するとまたプロンプトが2重になる。
    > →これは .ble-edit/edit/attach での guard が1回しかロードされない事を前提とした物だった事による。修正した。
    >
    > 1回 ble-detach して再び ble-attach して、更に ble-detach すると
    > detach できていない。それに加えて "bash: : コマンド見付かりません" というエラーになる。
    > コマンドを実行しようとすると実行できずに、実行コード全体を一つのファイルと見做して実行しようとしている??
    >
    > と思ったら ble-decode-byte:bind が復元対象に入っていた。
    > 復元対象に入らない様に awk でチェックしていたはずなのにと思って確認したら
    > ble-decode-bind と指定していた事によりチェックが正しく機能していなかった。
    > また、それとは別に復元の仕方にも問題がある。
    > "à": "ble-decode-byte:bind 224; eval \\\"$_ble_decode_bind_hook\\\""
    > 等と、過剰にエスケープされている。これについてもう少し詳しく。
    >
    > 始めに attach した直後には bind -spX すると以下の様になる。
    > "\C-@\C-@": "ble-decode-byte:bind 0 0; eval \"$_ble_decode_bind_hook\""
    > その後で ble-detach してもこの結果は変わらない。
    > この次に ble-attach した後に bind.save を見ると
    > bind -x '"\C-@)": "ble-decode-byte:bind 0 41; eval \"$_ble_decode_bind_hook\""'
    > 等となっている。問題はない様に見える。が、これで登録すると先程の様な事になるという事か。
    >
    > →色々 bind -X の出力を調べるとコマンドの中に制御文字が含まれているとエスケープされる様だ。
    >   先ず " と \ は \" と \\ に変換されている。また DEL は \C-? になり ESC は \e になる。
    >   それ以外の制御文字 (0～31) は \C-なんとか の形に変換される。
    >   これらを元の文字に復元する簡便な方法は存在しない様に思われる (bash の機能を使ったとしても)。
    >   仕方がないので awk で変換のコードを書く。面倒なので gsub を繰り返し適用する方針で。
    > →これで取り敢えず正しい bind -x コードを出力する事ができる様になった。
    >
    > さて、これを解決したらすっかり ble-detach が動くようになった。
    > bleopt_suppress_bash_output=1 でもちゃんと問題なく動いている様に見える。
    > 何度も ble-attach, ble-detach を繰り返しても動いている。

2015-02-18

  * 履歴展開の対応 [#D0143]

    ^string1^string2^ の形式の履歴展開の場合、順に入力しても履歴展開と認識されない。
    というか :x 等の modifers も順に入力しても履歴展開に含まれない。

    解析再開点を履歴展開の直前に置いておくか、何らかの単語?として取り扱わないと駄目。
    (「この点までは stat に値を設定しない」という変数を用意して、
    先読みを実行した場合にその変数に値を設定するというのも興味深い方法である。)

    後、試して気付いた事だが !!$:a 等と定義されていない修飾子を指定すると、
    単に履歴展開をせずに実行されるのかと思いきや、履歴展開のエラーになってコマンドが実行できない。
    このエラー報告と整合性のある色付けにしたい。
    結局、履歴展開についても内部の文法構造を気にして実装するという事になるのだろうか。

    他にも s/../../ や ^..^..^ は途中で中断すると空文字列を指定したとして解釈される事も分かった。
    説明書に書かれていない動作が色々あるが、この動作であれば却って順に入力していけば
    正しく全体が履歴展開として解釈される。
    適当に実装したが現状で大体OKなのではないかという気がする。

  * CSI → ESC [ 翻訳について [#D0142]

    現在 bash-3.1 ESC [ → CSI や、ESC ESC → ... を default keymap に設定しているが、
    その他の keymap の時に処理されないのは問題である。
    例えば isearch の時に bash-3 では矢印キーが使えない事になる。
    もっと前の段階で変換をするべきなのではないか?

    charmap はそう切り替わる物でもないので charmap のレベルで受け取った CSI を
    ESC [ に変更するという方法があると良い。できればハードコードするのではなく一般的な枠組として。
    →と思ったが一般的な枠組にすると強力すぎる様に思うので取り敢えずは
      char==91 に対してハードコードして介入する事にした @ .ble-decode-char
      (utf-8 CSI を送信する様な端末があった場合にもこれで対応できた事になる…が、そんな端末があるかは不明。)

  * <完> bash-3 で C-d を捕捉する方法? [#D0141]

    今は IGNOREEOF を大きな値にして即座にログアウトされない様にしている。
    所で C-d を押すと
      Use "exit" to leave the shell.
    だとか
      ログアウトする為には exit を入力して下さい
    だとか
      シェルから脱出するには "exit" を使用してください。
    だとか言ったメッセージが出力される。

    現在 bleopt_suppress_bash_stdout を設定している場合には
    bash のエラーメッセージはファイルに書き込まれるので、
    このファイルを読み取る事で C-d を押した事を検知する事は出来る。

    但し、押された事が検知できるのは C-d が押された後に初めて別のキーが押された時である。
    C-d では何もイベントが起きてくれないので。

    強引な手だが、常にファイルを監視する子プロセスを作成して、ファイルに Use "exit" ... が書き込まれたら
    シグナルを $$ に送ってそこで処理するという手が使えるかも知れない。
    しかし子プロセスで常にファイルを開いて確認するのでリソースを食う。余り使いたくない方法である。

    また或いは bash のエラー出力先にコプロセスを置いておきそこで受信をするという手も…。
    こちらの方が未だましである。もしかしてこれで行けるんじゃないか…と思って実装してみた。
    動いている…と思いきやすぐにエラーを吐いて終了する。
      trap -- 'myfunc' USR1
    するだけでもエラーになって死ぬので、行っている処理の問題ではなさそう。
    代わりに RTMIN を使ってみたがそれでも同じエラーが発生する。
      trap -- 'echo hello' USR1
    という程度であれば何も起きない。trap の中で関数を呼び出すのが駄目という事だろうか。

    もしかしてシグナルハンドラの処理中にシグナルハンドラが呼び出されている??
    或る程度処理に時間が掛かる関数を設定するとエラーになって死ぬという事だろうか??
    →必要な時にだけ呼び出す様に変更したら動くようになった
      (とはいいつつもシグナルによって動作しているので流石に遅い。しかし何とか動いているので良しとする。)
    →と思ったが内部で呼び出している mv を止めたらそんなに遅くはなくなった。fork はやはり重いという事か。

    > 2013-06-13
    >
    >   * 制限: bash-3 では C-d を捕捉する事ができない。

    取り敢えずこれは解決したとして良いだろう。

  * ble-edit.sh, ble-decode.sh: bugfix, bash-3 でカーソルキーの類が動かない。履歴が読み込まれていない。 [#D0140]

    これらの原因は同じ物であった。高速化の為にコードを生成してそれを直接 source していたが、
    その為に source とプロセス置換を組み合わせたのがいけなかった様だ。
    bash-3 では source はプロセス置換から読み取ってくれない。
    (パイプからは読み取らないというポリシーなのか、
    或いはシークできないと実行できないという事なのか分からないが。)

    source <( ... ) を eval -- "$( ... )" に変更。

2015-02-17

  * ble-syntax (ble-syntax-highlight+syntax): 入れ子エラーの色の範囲 [#D0139]
    例えば "(( echo" 等の場合。
    閉じていない入れ子構造がある場合に、入れ子構造の開始字句をエラー色にしている。
    しかし、一文字目しか色を付けていない為、入れ子開始の字句が複数文字で構成される場合に不格好である。
    字句単位で色を付けられるように fill-g 関数を修正し、それを用いる事にした。

  * ble-edit.sh (accept-line): - で始まるコマンドを実行できない。 [#D0138]
    履歴展開の為にコマンドを history に渡した時に history へのオプションとして解釈されていた。
    というか eval も - で始まるコマンドを扱えないし、history -s で履歴に登録する事もできない。
    eval に関しては -- 以降はコマンド部分として解釈される様なのでそれを用いる。
    よく bash の man を読んでみたら組み込みコマンドの章の一番上の部分に -- について書かれていた。

  * <bug> ble-syntax.sh: 1"$1" と入力してから先頭の 1 を消すと単語情報が壊れる。 [#D0137]
    単語の長さが再計算されていない事による物と思われるが良く分からない。

    落ち着いて現在の実装でどの様な振る舞いになるはずかについて考える。
    1"$1" の時は 1 の部分に単語情報が格納されている。
    ここで 1 を削除すると単語情報も消えて無くなる。
    次に 1 の部分から解析が始まるがこの時に新しく単語の開始点が設置される。(長さ 0)
    所が (単語の開始点が前回と一緒である為) 単語の末端に達する前に解析が終了する。

    さて後段で前方の単語への参照を保持しているはずで、
    参照している単語開始点が編集の対象だった時は dirty 範囲をそこまで拡大する手はずになっていた筈だが。
    見てみると編集の対象かどうかの判定が [i1,i2) になっている。
    これは単語の先頭で編集が行われた場合にその単語は編集されていないという判定である。
    これについてはもう少し考え他方がよいのかも知れないが
    単純そうな [i1,i2] に変更する事にする。(単純な物の方が大概自然である。)

    % どの様にしなければならないかというと。
    % 単語情報を削除してその場に新しく単語情報を追加する場合、

  * <bug> ble-syntax.sh: ${1}1${1} の状態で真ん中の 1 の直前に空白を入れると壊れる。 [#D0136]
    他の部分に空白を入れたり空白以外の文字を入れても何も起こらないが、
    該当箇所に 1 を入れた時にだけ壊れる。

    試行錯誤
    > これについても現在の実装でどうなっているのかについて調べる。
    >
    > 先ず shift の際に何が起こるかについて。${1}2${3} → ${1} 2${3}
    > とずらした事で単語の先頭 (${1}の前) に対する参照が更新される事は無い。
    > 単語の先頭は編集位置よりも前にあるからである。
    > …よく考えたら、${3 を読み取ろうとした時点で inest/wbegin の値が一致してしまうので
    > 其処で単語の読み取りが終了してしまう事になる。
    > 別の単語の中にいながら局所的に同一の文法状態になる事が原因で途中で解析が終了しているという事だ。
    >
    > 本当か? ではなぜ echo ""2${3} → echo "" 2${3} の時には問題が発生しないのか?
    > 残っている情報
    >   ${ を読み取る直前の wbegin は "" の先頭にある。
    >   ${ を読み取る直前の inest は -1 である。
    >   ${ まで読み取った時の wbegin は -1 である。
    >   ${ まで読み取った時の inest は ${ の先頭の位置にある。
    > 新しい解析
    >   ${ を読み取る直前の wbegin は 2 の先頭にある。
    >   ${ を読み取る直前の inest は -1 である。ここは不一致なのでここで停止する事は無い。
    >   ${ まで読み取った時の wbegin は -1 である。
    >   ${ まで読み取った時の inest は ${ の先頭の位置にある。ここで一致する気がするのだが…。
    > dirty-range の拡大も考慮に入れる事にする。
    >   dirty-range の拡大は wbegin/inest の参照先が編集範囲内にある時に発生する。
    >   ${ の外側では wbegin inest は常に wbegin=0 inest=-1 になっている。
    >   これは dirty range の拡大には寄与しない。
    >   ${ の内側では wbegin inest は -1 及び ${} の先頭になっている。
    >   そしてこの先頭 of ${ は編集の対象ではない。つまり dirty-range の拡大は起きない。
    > →もっと色々試してみた結果
    >   (字句単位1)(字句単位2)(字句単位N)${3} の時に、
    >   字句単位1 の直後に空白を挿入する場合は OK で、
    >   字句単位2以後の直後に空白を挿入する場合に駄目になるという事が分かった。

    原因
    "(字句単位1)(字句単位2)(字句単位N)${3}" に空白挿入 の際:
    - 字句単位1の直後に空白を挿入する場合には再開点が単語の先頭になり、
      単語の先頭も編集対象としてマークされる為に単語全体が更新対象になり問題が発生しないという事の様だ。
    - しかし、字句単位2 の直後に空白を挿入する場合には再開点は字句単位2の先頭になり、
      単語全体は更新の対象とは見做されない事になる(ここまでは期待している動作である)。
      所が、その後で内側のネスト状態に入った所で局所的に前回の解析と同じ状態になり停止するという事のようだ。
    - また、字句単位N の直後に空白を挿入した場合には ${3} 全体が更新対象になるのでやはり問題は発生しない。

    対処

    局所的な文脈の一致ではなくて全体的な文脈の一致まで考慮しないと問題が残る。
    例えば現在の実装ではネストレベルが異なる場合でもネストの開始位置さえ同じであれば文脈が一致したと解釈してしまう。
    実装当初には「ネストの開始位置さえ一致していれば文脈的には同じ構造に戻ったと見做しても良い」
    という想定を行っていたが実際にはネストの開始位置が同じであっても文脈の構造が変化した可能性があるという事だ。

    例えば (CTX_EXPR の中で) ( を上書きして [ にした場合などがこれに含まれるのではないかと思う。
    これは類似のまた別の問題だ。現在の文脈情報に開始括弧の情報を含めていない事による。
    開始括弧の対応まで一致しているかどうかを確認する為には [inest] の type が同じかどうかまで確認しなければならない。
    これの比較を怠っている事は結構不味い。

    結局、細心の注意を払ってすれすれで実装するのではなく、安全確実な方法を採る方が良い。
    つまり、現在のネスト情報を親まで全部含めた形で記録して一致するか確認を行う。
    その為のネスト情報をどの様に記録するのが良いか?

    > 一番簡単なのは stat に全ての情報を入れてしまう事である。しかしもう少し効率化できないだろうか。
    > 再開の為に必要なのは stat に現在記録している 3 つ組だけである。
    > 後は自動的に pop によって情報が復元されていく。
    > さて、stat には3つ組しか記録しない様にして、
    > 更に比較を行う為にその場で inest を辿って stat を掘り返す事にするのは非効率である。
    > 代わりに初期の nest 状態だけ復元して、
    > その後は push/pop する時に nest 状態を更新するというのはどうだろう。
    > しかし、この方法で現在の解析の nest 状態を更新する事は出来るが、
    > 前回の解析の nest 状態を追跡する事は出来ない。push/pop の情報は記録していないからだ。
    >
    > 仕方がないので stat に全てを記録してしまう事にする。
    > 幸い _ble_syntax_stat を参照しているのは殆ど ble-syntax/parse だけなので、
    > この関数内での取り扱い方法だけ変更すればOKである。
    > と思ったが…もし stat にネストの全階層を記録していると shift が滅茶苦茶な事になる。
    >
    > というか現在 _ble_syntax_nest に対しては shift を実行していないがこれについても shift する必要があるという事か。
    > 前回使った _ble_syntax_nest は今回は使わないので shift を実行する意味はなかったのである。

    うーん。面倒だ。取り敢えず動くようにする為には
    1. _ble_syntax_nest もシフトする様にする
    2. _ble_syntax_nest を掘り返して文脈が一致するかどうか確認する
    という事になる。掘り返すのは効率的かどうかは疑問だが取り敢えず実装する。
    (今迄問題にならなかった事から、そもそもそんなに掘り返さなくてもすぐに不一致になるのかも。
    改めて考えてみるに其処まで性能の劣化になる様にも思われないのでこれで良い事にする)。

2015-02-16

  * ble-syntax.sh: 単語終了判定の処理の変更 [#D0135]

    ble-syntax/parse/word-end の判定は
    字句単位の開始時ではなくて字句単位の読み取りの終了時にするべき?
    というのも単語を部分編集するとその単語の長さが 0 になってしまうから。
    これは単語を部分編集した時の更新範囲が典型的にその単語の末端までになるので、
    解析もその単語の末端までで終了してしまう事が多いから。
    然し乍ら、word-end は次の字句単位の読み取りの際に呼び出されるので
    その字句単位の終端を設定する機会がないという事になる。

    % しかし、もし word-end の判定を字句単位の終端時に行う事にすると
    % 別の問題が発生する。単語の末尾に字句を追加した時に単語が伸張してくれない。
    % というのも字句の直前で既に単語が終了している事になっているからである。

    再開した時に正しく再開できる様にする為の簡単な条件は、
    その点での解析状態が次の文字に依存してはならない、という事である。
    しかしそれは少々無理がある。次の文字が分からなければ
    字句単位がそこで終わるのかどうかさえ定かではない為である。
    そこで、現在は解析の再開は変更のあった点ではなく「その点よりも前の最近の再開点」としている。

    従って、其処で単語が終了するかどうかの判定もやり直されるのではないかという気がする。
    例えば、単語の末尾に文字を追加する事を考える。文字を追加した時に解析の再開は
    追加した文字の箇所で起こる訳ではない。追加位置の一つ前の再開点から開始される。
    そして一つ前の再開点の時点では未だ単語は終了していない事になっている筈だから、
    正しく単語は伸張されると期待される。
    なので、取り敢えず字句単位の終わりの時点で単語の終了を判定する様に書き換えてみて動くか見る。

    呆気なく動いている。此方の方が実装としても単純だし自然である。
    →初めは CTX_CMDI の類の文脈が成功した時しか単語の終了判定をしていなかったが、
      実際に色々やってみると、nest から抜けた場合や
      CTX_CMDI の文脈で認識されないエラー文字があった場合にも
      そこに単語の終了が来る可能性があるという事に気付いたので、
      任意の ctx の処理の後に単語終了判定を置く事にした。
    →今後、"ctx の処理の後の ctx" に応じて適切な単語終了判定を行える様に
      WORDEND[ctx] 的な配列に関数を入れる事にしても良いかも知れない。

  * ble-edit.sh (_ble_edit_str, ble-edit/dirty-range): 変更範囲の合成について [#D0134]

    入力文字列に対する部分変更があった時に、全体を計算し直すのは非効率である。
    どの様な変更があったのかを記録しておき、変更がなかった部分の計算については省略するのが得策である。
    その為には部分変更を何らかの方法で表現・記録しておかなければならない。
    ここでは str1 → str2 への変更操作を
      str2="${str1::beg0}$ins${str1:end0}"
    の形に一般化して考える事にする。
    この時 str1 の [beg0,end0] の範囲が str2 の [beg,end] になったと考える。
    beg=beg0 であり end=beg0+${#ins} である。この時変更範囲を
      (beg, end, end0) の三つ組みで表す事ができる。

    今考えたいのはこの様な変更操作を 2 回行って str3 を得た時に、
    str1 から str3 への部分変更をどの様な三つ組みで表せるかという事である。
    ※勿論自明な解として (0, ${#str3}, ${#str1}) 等を考える事ができるが、
      今はできるだけ共通部分を長くしたい、
      つまり、変更部分の長さ end-beg を最小にしたいのである。

    式で考えようとしたが式の上での場合分けが面倒だ。
      str1 -(dbeg dend dend0)→ str2 -(beg end end0)→ str3 の時
      i2 = i1<begA?i1: i1<endA0?-1: i1+(endA-endA0)
      i3 = i2<begB?i2: i2<endB0?-1: i2+(endB-endB0)

    記号的に場合分けするのではなく、もう少し具体的に場合分けを考えた方が良い。
      str1 = A [ B ] C → str2 = A | X | C となったとする。
      更に str3 に入る時に何処に切れ目が入るか ("[]" で表す) で分類できる。
      (1) str3 = A0 [A1] A2 |     X      |     C
      (2) str3 = A0 [A1     | X0]     X1 |     C
      (3) str3 = A0 [A1     |     X      | C0] C1
      (4) str3 = A          | X0 [X1] X2 |     C
      (5) str3 = A          | X0     [X1 | C0] C1
      (6) str3 = A          |     X      | C0 [C1] C2
      先ず beg は明らかに min(begA, begB) である。
      次に end は max(endA-endB0+endB, endB) である。
      end0 は end から逆算できる。或いは end の由来を考えて場合分けすれば良い。
      end が endA-endB0+endB の時は endA0 がそのまま end0 になる。
      end が endB の時は end0 = endB0-endA+endA0 になる。

      式で書くと:
      beg = min(begA,begB)
      end = endB + max(endA-endB0,0)
      end0= endA>endB0? endA0 : endB0-endA+endA0
          = endA0 - (endA-endB0>0?0:endA-endB0)

      整理すると:
      beg = min(begA,begB)
      end = endB
      end0= endA0
      if((del=endA-endB0)>0)
        end+=del;
      else
        end0-=del;

    数式での間接参照?
      alpha=111 beta=alpha*2 pref=bet
      echo $((${pref}a))
      → ちゃんと 222 になる。。bash-4.3, bash-4.1, bash-3.1 で確認した。

2015-02-13

  * <完> グローバルで実行するという事? [#D0133]

    % 次の様な関数で eval すればグローバルで評価できるかも。
    % 少し試した段階では問題は生じていない。
    %
    % geval () { trap -- "$*" RTMAX; kill -RTMAX $$; }
    %
    % + 何とジョブ管理にも正しく登録される様である。
    %   グローバルな変数は勿論定義される。
    %
    % + 返却値については流石に kill の戻り値としては入っていないが中で適当に拾えば良い。
    %   geval () { trap -- "$*"$'\n'"echo exit=\$?" RTMAX; kill -RTMAX $$; }
    %   (改行で区切る様にしないと $* が & や ; で終わっていた時に文法エラーになる。)
    %
    %   後 trap の内容を復元する為に
    %   | originalTrap="$(trap -p RTMAX INT)"
    %   | ...
    %   | trap - RTMAX INT
    %   | test -n "$originalTrap" && eval "$originalTrap"
    %   等とすると良いかもしれない。
    %
    %   但し、この様にコマンド実行中だけ ble の用意した trap を実行していると、
    %   コマンド実行中はユーザの trap した内容が実行されないという事に注意する。
    %   (外部コマンドの場合には bash ではなく外部コマンドがシグナルを受け取れるので問題ないが、
    %   シェル関数の場合にはユーザが予め設定した trap でシグナルを受け取る筈だ。)
    %
    % + C-z 時の返却値 → OK 拾える
    %   C-c 時の返却値 → 駄目。拾えない。これは今迄と同じ。なので INT に trap する。
    %   INT の復元もした方が良い? → $(trap -p RTMAX INT) とするだけなので気にしなくて良い。
    %
    % + jobs で kill -RTMAX $$ と表示される。
    %   といっても kill -RTMAX の待ち状態という訳ではないようだ。
    %   証拠に geval の次のコマンドは geval 内のコマンドで C-z した直後に実行されるし、
    %   また、geval 内部で二つの less を呼び出して両方とも C-z しても正しく実行される。

    と思ったら幻想だった。そもそもグローバルで実行していない。
    現在の文脈のままでシグナルハンドラが呼び出されている様だ。
    つまり、シグナルハンドラが関数内の環境に影響を与えられるという事。

    今の所グローバルで実行できるのは bind -x だけしかない気がする。
    しかし bind -x した物を呼び出す為にはユーザに何か入力をして貰わないといけない。
    (入力を再現する方法が有れば良いがそれをシェル内から実行する方法はない気がする)。
    或いは何とかして readline の accept-line を呼び出す事ができればよいが。

    うーん。汚い方法ではあるが、
    bind -x で "ble-decode-byte:bind 1 2 3; eval \"$_ble_onafter_bind\""
    等として任意の物を外で実行できる様にしておくとか。。
    →この方針で実装してみた。存外問題なく動いている。

  * <完> 現在の C-c のトラップの実装に関する疑問 [#D0132]

    return で良いのか? return が使えない場合があるかも?
    →サブシェルを作らずに同じプロセスで実行する場合、
      内側の環境になるのは関数か source しかない。
      つまり、一番外側でない限りは return が使える。
      つまり、現状の様に関数内で実行している限りは return は常に使えるという事。

    return で正しく抜ける事ができるのか?
    一番内側の 関数/source しか抜けられないのでは?
    或いは、入れ子になっている場合に誰が受信するのか?

    | 実験
    |
    | trap INT はどの様な場合に働くのか?
    | 直接 $ sleep 10 に対して C-c しても trap されない。trap が動く条件は? 色々試した。
    | 何か変だ。殆どの場合で動かない様に思われる。
    | bind -x の中からだとまた違った結果になるのか、それとも現在の実装は問題があるのか…。
    | $ trap -- 'echo INT $a' SIGINT
    | $ sleep 10 →×
    | $ : $(sleep 10) →○
    | $ echo 10 && sleep 10 →×
    | $ sleep 10 && echo 10 →×
    | $ (sleep 10) && echo 10 →×
    | $ func1() { sleep 10;}; func1→×
    | $ プロンプトが表示されている時に C-c→○
    | $ for ((i=0;i<100000;i++)); do :; done→○中断する
    |   ループ内では trap できて、しかも自動的に中断されるという事
    | $ fib1() { (($1<=1)) && eval $2=1 && return; fib1 $(($1-1)) ${2}L ; fib1 $(($1-2)) ${2}R; let $2=${2}L+${2}R; }; fib 20 x→○中断する
    |   関数の再帰呼び出しも trap できて、しかも自動的に中断されるという事
    | $ trap 'echo INT $2=${!2};return' INT; fib 20 x→○中断しない
    |   →何度 C-c を押しても最後まで抜けられない…。return があるかないかで動作が異なる様だ。
    | $ for ((i=0;i<100000;i++)); do :; done→○中断する
    |   →これは単純に return ができない為に return をしなかった場合と同じ動作をしているという事。
    |     結局 trap の動作は return コマンドを書いたか書かなかったかではなく、実際に return しているかしていないかを見ている。
    |
    | 分かった事
    | - trap INT は現在の文脈 (関数内/source内) で最大1回だけ実行される
    |   子プロセスが INT を受け取った場合などには受け取らない。
    | - 唯単に trap INT するだけの場合、シェル内で行われている全ての処理が自動的に中断される
    | - trap INT の中で return 等を実行した場合は、return の後で処理が続行される
    |
    | これを受けて C-c を受信した時にどの階層まで抜けるかをコントロールする方法は:
    | - 一気にシェルの処理を終了したい場合には trap の中で return 等を書かない。
    | - 一つ上の関数・source に戻りたい場合は trap の中で return を書く。
    | - 但し、関数呼出を沢山行っている場合 C-c で抜ける事ができなくなる可能性がある。従って return は書かない方が良い。
    |   任意の階数の関数・source を抜ける方法はない。

    結論

    現在の実装は関数の再帰呼び出しなどを C-c で停止する事ができない。
    →実際に試してみた for ループは抜けるが再帰呼び出しはその場では抜けられない。
      (一応各再帰呼び出しは抜けている様である。その為に、
      C-c をすると fib1 の結果が変わる (前回の呼出の時の結果が残っていると正しい結果になるが))
    →これは C-c によってシェル内の無限ループを止める事ができなくなる可能性がある事を示す。よくない。

      trap で $_ble_hook_INT 等として後処理をする関数を付け加え、return はしない様にするべき?
      →これだと local で変数が被覆されている場合などに正しく対処できない。
        まあ _ble_... を宣言しなければ大丈夫である。

    実際にその様に実装してみたら問題がある。
    どうやら bind -x の中で実行している場合には return しないとそのまま実行が継続する様である。
    return すると現在の呼出階層だけは抜ける事ができるので以前はその様に実装していたという事か。
    以下はその前提で書いてみたコード。結局これは使えないという事になった。
    > &pre(agh-prog-bash){
    > function .ble-edit/exec2/eval-prologue {
    >   .ble-stty.leave
    >
    >   # 履歴置換
    >   set -H
    >
    >   # C-c に対する trap
    >   _ble_edit_exec_original_trapint="$(trap -p INT)"
    >   trap .ble-edit/exec/eval-TRAPINT INT
    >   trap 'echo INT' INT
    > }
    > function .ble-edit/exec2/eval {
    >   # BASH_COMMAND に return が含まれていても大丈夫な様に関数内で評価
    >   .ble-edit.accept-line.exec.setexit
    >   eval "$BASH_COMMAND"
    > }
    > function .ble-edit/exec2/eval-TRAPINT {
    >   # eval 中にシェルの処理で C-c (SIGINT) が来るとここに入る
    >
    >   # シェルが C-c で中断した時の終了値
    >   if ((_ble_bash>=40300)); then
    >     _ble_edit_accept_line_lastexit=130
    >   else
    >     _ble_edit_accept_line_lastexit=128
    >   fi
    >
    >   .ble-edit/exec2/eval-epilogue
    >
    >   # 未だ残っていれば続きを実行
    >   # (今迄実行していたコマンドは _ble_edit_accept_line[] から既に削除済)
    >   .ble-edit.accept-line.exec
    > }
    > function .ble-edit/exec2/eval-epilogue {
    >   # C-c trap を削除
    >   trap - INT
    >   eval "$_ble_edit_exec_original_trapint"
    >
    >   .ble-stty.enter
    >   _ble_edit_PS1="$PS1"
    >
    >   .ble-edit.accept-line.exec.adjust-eol
    >
    >   # SIGERR処理
    >   if [ "$_ble_edit_accept_line_lastexit" -ne 0 ]; then
    >     if declare -f TRAPERR &>/dev/null; then
    >       TRAPERR
    >     else
    >       echo "[91m[ble: exit $_ble_edit_accept_line_lastexit][m" 2>&1
    >     fi
    >   fi
    > }
    > function .ble-edit/exec2/recursive {
    >   (($1>=${#_ble_edit_accept_line})) && return
    >
    >   local BASH_COMMAND="${_ble_edit_accept_line[$1]}"
    >   _ble_edit_accept_line[$1]=
    >   if test -n "${BASH_COMMAND//[ 	]/}"; then
    >     # 実行
    >     local PS1="$_ble_edit_PS1" HISTCMD="${#_ble_edit_history[@]}"
    >     local _ble_edit_exec_original_trapint=
    >     .ble-edit/exec2/eval-prologue
    >     .ble-edit/exec2/eval
    >     _ble_edit_accept_line_lastexit="$?"
    >     .ble-edit/exec2/eval-epilogue
    >   fi
    >
    >   .ble-edit/exec2/recursive "$(($1+1))"
    > }
    > }

    ここで trap - RETURN という物を発見する。関数やソースを抜けるたびに実行されるという物のようだ。
    正にこれを使えるのではないか…? と思って trap '((_ble_edit_accept_line_INT)) && return' RETURN
    等としてみたら無限ループになる。それどころかメモリを食い荒らしている。
    ${FUNCNAME[*]} で確認すると RETURN が評価されるのは抜ける関数やソースの中である様だ。
    そこで return を呼び出すと再び trap RETURN が反応してしまうという事になっている様だ。
    つまり、trap - RETURN を用いても呼出元の文脈で評価される訳ではないので呼出元を更に抜ける事はできず、
    その上無限ループになってしまうという事になる。
    #trap '((_ble_edit_accept_line_INT)) && return' RETURN # 無限returnループになる

    今度は trap ERR して見ようとしたが…そもそも呼び出されないようだ。
    (それに trap ERR だと条件式の内部にあるコマンドについては呼び出されないというし確実に抜ける事は出来ない)
    #trap '((_ble_edit_accept_line_INT)) && echo hello && return 128' ERR # 呼び出されない

    或いは trap DEBUG というのを使う事ができるかもしれない。
    DEBUG について色々試してみた。
    - 先ず、trap 'command' DEBUG した command の中では DEBUG は一切発生しない。
      (もし発生していたら無限ループになってしまう。)
    - また、bind -x 関数の中で trap - DEBUG しても bind -x の関数を抜けると消える。
    - trap - DEBUG 等を用いて削除しようとしても何故かできない。trap -p でも何故か一覧に出ない
      | 更に、trap 'command' DEBUG の command の中で trap - DEBUG しようとしても消えない。
      | trap 'echo 123' DEBUG 等と DEBUG を上書きする事もできない。
      | というか trap の中でなくても上書きできない様だ。それどころか trap -p の一覧に出ない。
      | (通常のシェル環境で実行している場合にはちゃんと trap -p で出るのだが)。
      | trap DEBUG した関数内では trap -p の一覧にも出るし trap 'echo 123' DEBUG で後から書き換える事も出来る様だ。
    trap DEBUG をその場で削除できないという謎があるが取り敢えず動く様になったので良しとする。

2015-02-11

  * <bug> home, C-home, ... 等多くのキーに対して keymap が見付からないエラーになる [#D0131]

    やはり初めからシーケンスが登録されているキーに関しては
    中途半端に bind -x するとこのエラーになる様だ。
    bind -x が2文字までしかできないバグは bash-4.3 で解消された様だから、
    登録されているキーシーケンスを全て bind -x してしまう事にした。

    登録されていないキーシーケンスを入力した時には依然として
    keymap が見付からないエラーが発生するが、
    登録されていないエスケープシーケンスは先ず来ない事と、
    来たとしても自然に解釈する事ができないのでこのままでも良い。

    登録されているキーシーケンスの列挙は例によって時間が掛かる様なので、
    これもキャッシュとして出力してしまう事にした。
    実際にやってみて良好に動いているので良しとする。

  * <bug> ログアウトした後も stty の状態が正しくない。 [#D0130]

    % 1 stty が正しく呼ばれているか? 正しく適用されるにはどうすれば良いか?
    %
    %   - visible-bell が最後に勝手に enter しているのかもしれないと思って切ったが駄目。
    %   - enter した時に x と表示する様にして最後に enter が起こっていないか
    %     確認したが起こっていない。
    %   - stty してから暫くしないと適用されないのかと思って sleep して見たが駄目。
    %   - stty してから何か出力しないといけないのかと思って leave してから
    %     メッセージを表示する様にしたが駄目。
    %
    %   C-d の中で leave して cat を実行すると C-c 等で終了できない。
    %   通常のコマンド実行の際にはちゃんと C-c できるのに何故だろう。
    %   何か設定で間違えている事があるのか、関数のネストが関係するのか、...。
    %
    %   cat は C-c が効くのに exit 後は C-c が効かない
    %   そして exit コマンドを実行して終了する時にも stty は正しく設定されていない。
    %   cat の時には正しく設定されていて exit の時には正しく設定されていない理由は何か?
    %   或いは bash 自体が何処かの時点での stty の状態を記録していて
    %   exit の時にその記録した時点での stty に設定してしまうのだろうか。
    %
    %   改めて確認してみる。
    %   C-d の中で直接 cat すると C-c できないが accept-line.add して実行して貰うとちゃんと
    %   C-c で止める事ができる。そこで exit を accept-line.add してみる殊にしたが、
    %   終了後の stty の状態は壊れた状態の儘である。
    %
    %   1 何故かは分からないがその場で実行しても stty は適用されないが
    %     accept-line の実行の枠組を使用して実行すると stty が適用されている。
    %     しかし次の項目にある様にこの振る舞いは今回は訳には立たない。
    %   2 accept-line の枠組を使用して stty が適用された状態にしても、
    %     そこから exit した場合には stty の状態は反映されない。
    %     途中に外部コマンドを挟んでも駄目。
    %
    %   .ble-stty.setup を殺して一度も stty で undef をしない様にしてみたら、
    %   当然の事ながらログアウト後に壊れているという事はないようだ。
    %
    % 2 detach してから exit するという事
    %
    %   bind -x 内 で exit しても勝手に stty の設定が壊れた状態に戻ってしまう。
    %   一旦 stty を正常な状態にして ble だけを終了し、
    %   その後で手動で exit したらどうなるか?
    %   つまり、ble の "detach" だけを行って exit をしない時 stty が壊れなければ、
    %   その後に普通に exit をする事で stty が壊れない様にできる。
    %
    %   これを試す為に、ble の設定を全て解除するコードを書く必要がある。
    %   つまり bind -x した物を全て外し、元々 bind されていた物を再適用する。
    %   →stty が正常な状態で復帰できた。この後で exit をしても壊れない。
    %
    % 3 しかし detach するだけだと分かりにくいのでやはり exit についても実装する。
    %
    %   その場で detach をして bind -x から抜け、その後で時間差で抜ける。
    %   その為にシグナルを用いる。
    %
    %   所が、シグナルハンドラの中で exit をするとその stty の状態で終了する様なので、
    %   シグナルハンドラの中でも stty で正しい状態を設定する様にする。
    %   これで正しい stty の状態で抜ける事ができる様になった。
    %
    %   所が、また問題がある。どうやら入力待ち状態にある時にシグナルは受け付けない様だ。
    %   まあ、スレッドが止まっている状態なのだから当然と言えばそんな気もする。
    %   この所為で次の文字を入力した時に初めて exit される。
    %
    %   と、ここでその場でシグナルを自分に投げたらどうなるのか…と思う。
    %   シグナルハンドラの内部からならば設定した stty で exit できる…
    %   という事はその場で読んでしまって充分なのではないか。
    %   と思ってその様に実装したら期待通りに動く…。
    %
    % 4 残っているのはユーザが exit コマンドを使用した時である
    %
    %   そのまま exit/logout されるとやはり stty が壊れる。
    %   exit/logout 関数を上書きすれば良い。
    %
    %   exit() {
    %     if (($BASHPID==$$)); then
    %       _ble_edit_detach_flag=exit
    %     else
    %       exit "$@"
    %     fi
    %   }

    と、ここで man の exit の所に EXIT トラップについて書かれている…。
    もしかしてこれを設定すれば良いだけの話では…。。
    結局 trap .ble-stty.exit-trap EXIT の一行で済む話だった。

    一応 detach という機能が実装されたので今回の変更が完全に無駄になった訳ではないが。

  * rcfile として起動すると history がロードされない。 [#D0129]
    rcfile の中で history を参照しても中身が未だロードされていない様だ。
    history -n で読み込む事にした。

  * C-S-a 等の \e[2... が読み取れない。というか単なる [ に変換されている…? [#D0128]

    これも同様に bash_execute_unix_command のエラーが発生している様だ。
    試しに bash --norc として起動してから source ble.sh して見たら起きなくなった。
    なので、これに関しては余り気にする必要はない。
    bash --rcfile ble.sh 等として起動すればよい。

    所で --rcfile で起動すると history が正しく読み込まれていない。
    source ble.sh で起動した場合には正しく読み込まれている様である。
    rcfile の中では history を読み取る事が出来ないという事だろうか。

  * ちらつきを抑えるという事 [#D0127]

    ちらつきを抑える為に ble-decode-bind:bind が呼び出される前後で
    標準出力・標準入力を繋ぎ変えて見る事にした。

    % が、ちらつきは変わらない。
    % 今迄ちらつきの無かった所ではちらつきがない儘だし、
    % ちらつきが起こっていた所はちらつきが起こっている。
    %
    % 設定を間違えると何も表示されなくなるから標準出力・標準入力の繋ぎ替え自体は
    % 効いていて、bash が出している物は出力されなくなっている筈である。
    %
    % | 但し、他の可能性もある。
    % | もしかすると bash は fd を個別に持っていてそれに対して出力しているかも?
    % | そうすると繋ぎ替えを 1 2 に対して行っても bash 自体の出力先を変更できない。
    % | 上の実験で何も表示されなくなったように見えたのが勘違いの可能性もある。
    % | つまり、ble では PS1 を空欄にしているので bash が何も出力していない様に見えるが、
    % | 実際には行を消してしまう物を出力しているかもしれない。)
    % |
    % | 念のため簡単なテストをしてみる。
    % | $ exec 3>&1
    % | $ function on { exec 1>&3 2>&3; }
    % | $ function off { exec 1>/dev/null 2>/dev/null; }
    % | $ bind -x '"\C-o":"on"'
    % | $ bind -x '"\C-p":"off"'
    % | 以上の設定の後で C-o C-p で表示・非表示が切り替わる事を確認した。
    % |
    % | つまり bind -x の内部で exec してもちゃんと bash のプロンプト表示も影響を受ける。
    %
    % という事は、ちらつきは bash がプロンプトをクリアする事によって起こるのではなく、
    % ble 自体の再描画によって起こっていると結論する事ができる。
    % (bash がクリアしたプロンプトを直後に再描画しているのは功を奏しているという訳だ)

    改めて動かしてみるとちらつきは起こらなくなっていた。
    テストの時に新しい物をちゃんとロードできていなかったという事か。
    何か腑に落ちないが今後はこの方針で行く事にする。
    一応 ble_opt_suppress_bash_output オプションで繋ぎ替えを off にできる様に残しておく。

    一応註記しておくべき事は、exec で標準出力・標準入力を潰しても
    カーソルの位置などが乱れる事なく動作しているという事である。
    と思ったらカーソルの位置がずれている…。
    →.ble-edit-draw.update-adjusted の関数内で bash の出力に対する対策をしていたので
      exec を実行している場合にはその対策を行わないように修正した。これで動いている。
    →が、しかし今度は C-d で前触れ無く (後処理無く) ログアウトする様になってしまった。
      READLINE_LINE READLINE_POINT の設定はその儘にして位置調整のシーケンスの出力だけ
      を行わない様にした。

    もう一つの確認事項は vbell のクリアがちゃんと出力されるかという事。
    これは 1 2 が端末に繋がっている時に fork している筈だから出力されるのではないかと思うが。
    →実際に試してみた所ちゃんと vbell の消去が出力されている様なので問題ない。

2015-02-09

  * <bug> bind -x '"\"":...' 及び bind -x '"\\":...' [#D0126]

    cygwin の bash-4.1 で改めて動かしてみた所色々問題がある

    1 '\' と '"' が bind -r できていない
      良く考えたら bind -r している訳ではなくて bind -x で上書きをしているのであった。
      そして bind -x している物を調べたら先程弄ったコードの簡単なミスだった。修正。

    2 カーソルキーの類が全て M-\\ と解釈されている
      これは 1 に関連する物だった \\ に bind する代わりに \[ に bind していた所為で
      CSI が M-\\ に翻訳されてしまっていたというだけの話であった。

  * <bug> bash-4.3 日本語が入力できない。 [#D0125]
    8bit 文字は \ooo の形式で bind -x '"\ooo":...' しなければならなくなった。

    | 以前までは bind -x ではマルチバイト文字を 1 文字ずつしか受信できなかったのが、
    | いつの間にかに日本語として受信できるようになった様だ。
    | 今迄は octet の 256 文字を全て登録する事で入力を全て横取りできたが、
    | この所為で unicode にある全ての文字について bind しなければ日本語を受信できなくなった。
    | どうするか…。
    |
    | 例えば以下を設定した状態で "あ" と入力すると hello となる。tttqqqrrr とはならない。
    | hello を bind していない状態だと tttqqqrrr となる。あれ、受信できている…。
    |   bind '"\343\201\202":"hello"'
    |   bind '"\343":"ttt"'
    |   bind '"\201":"qqq"'
    |   bind '"\202":"rrr"'
    | つまり bind -x では受信できない、という事なのか? と思ったらちゃんと受信できる。
    |
    | では ble.sh で受信できないのは何故か? \ooo の形式で指定する必要がある?
    | と思って \ooo の形式で指定する様にしたら直ぐに入力できる様になった。

  * <bug> bash-4.3 "ESC [ 数字" 系のシーケンスを入れると [#D0124]
    bash_execute_unix_command: keymap云々 のエラーになる。

    問題: C-left C-right を使おうとするとキーマップがないと出る

    これは bash --norc から source しても変わらなかった。
    $ TERM=dumb bash --norc
    $ TERM=screen-256color; source ble.sh
    等としても同じだ…
    (というか source ble.sh する前に C-left C-right を試したら TERM=dumb でも動く。)

    他にも試してみたがどうも "ESC [ 数字" 系のシーケンスが全部駄目な様だ。

    仕様がないので "ESC [ *" を全て登録する事にする

  * <bug> bind -r すべき対象を bind -sp | fgrep していたが fgrep が結果をバイナリと判定する事がある [#D0123]

    fgrep -a とオプションを指定する事で解決した。

    | %%問題: bash で起動するとカーソルキーを使えるが bash --norc で起動するとカーソルキーを使えない%%
    |
    | これは謎である。~/.bashrc の中で設定しているものと関係があるのだろうか。
    | source ~/.mwg/bashrc; source ble.sh とするとカーソルキーを使える。
    | source ~/.mwg/share/mshex/shrc/bashrc_interactive でも使える。
    |
    | test-prebind.sh に bashrc_interactive の中から bind 関係の部分を抜き出してみても使える。
    |   どんどん絞り込みをしていく。複数の bind の組合せで起こっている?
    |   かなり不思議な事が起こっている…コメントの有無で結果が変わる…。
    |   そればかりか末尾の改行の数にも依存している。再現性がある事は明らか。
    |   改行の数が一定数以上ならばOK? でも改行の後に何があるかにも依存している。
    |
    |   bind よりも前に何を書いても大丈夫なように見えてコメントを沢山書いたら駄目になった。
    |   どうやら bind よりも前のコメントに何が書かれているかにも依存する様である。
    |   仕方がないのでコメントは以下に移動してくる。
    |
    |   # @bash-4.3
    |   # 以下を読み込んでから ble.sh を読まないと何故かカーソルキーが使えない
    |   #   bind よりも後の空白の数だとかコメントの文字数が
    |   #   違っただけで使えたり使えなかったりする。
    |   #   コメントの内容によっても結果が異なる様だ。
    |   #   bash のメモリ関連のバグだと思われる。セキュリティ的に危ないんじゃないか??
    |
    |   また気付いた事だが、暫く時間が経つと先程まで動いていた test-prebind.sh では動かなくなったりする。
    |
    | bash のバグとしか思えない動作なのでここでは置いておく事にする。
    |
    | →何と新たな事実が判明した…。
    |   カーソルキーが使えない場合については ble.sh 内の bind -r が走っていない。
    |   色々調べると bind -sp は色々物を出力しても、
    |   fgrep の段階で「バイナリ」と判断されたり判断されなかったりする様だ。
    |   fgrep でバイナリと判断されると中身が表示されない為に bind -r が走らない。
    |
    | 結局 何故 bind コマンドの周りのコメントやら何やらが fgrep のバイナリ判定に影響を与えるのかは分からなかった。
    | コメントの有無などで bind -sp で表示される順序などが変わるという事なのだろうか。
    | 或いは fork 元の bash のメモリの内容に fgrep の判定が影響を受けているとか。

  * "bash: bash_execute_unix_command: コマンドのキーマップがありません" と出る問題 [#D0122]

    久しぶりに起動してみたら色々と動かない? @bash-4.3 of padparadscha

    カーソルキーを入力しようとすると
    bash: bash_execute_unix_command: コマンドのキーマップがありません
    等と表示される。検索すると bind -x した時の bind 先が不明な場合に発生するエラーメッセージの様だ。
    ESC で始まるキーシーケンスに対応するキーは全てこれなので ESC 関係が悪さをしているのだろう。

    bind -x した物の一覧を取得する方法があれば良いのだが。
    以前に探した時には見付からなかった気がするが、改めて調べてみる。と、
    bash-4.3 以降では bind -X を用いて bind -x した物の一覧を表示する事ができる様だ。
    早速試してみると確かに bind -x した物の一覧を閲覧する事ができる。

    そこで bind -x した物の削除を試みる。
    普通に bind -r $'\ez' しても削除できない…。
    と思ったら実はちゃんと削除できているが bind -X の表示に反映されていないだけという事が分かった。

    <bashbug> bash-4.3.33, bind -r して削除した後のコマンドが bind -X の一覧から削除されない。

    分かった事: 2文字シーケンスを登録すると1文字目にkeymap変更が割り当てられる

    | どうやら一回でも 2 文字のシーケンスを登録してしまうと
    | それらを全て削除しても 2 文字のキーシーケンスに対応する keymap を探す様だ。
    | 例えば "ab" というシーケンスを登録すると
    | 「"a" は2文字のキーシーケンスの1文字目」という情報が登録されてしまい、
    | a に続けてどの様な文字を打っても対応する2文字のキーシーケンスが見付からない!
    | という状態になってしまう。(実際に "ab" で試してみたらそうなった。)
    |
    | ※唯単に bind -x '"ab":"echo"' && bind -r ab 等としただけでは再現しない。
    |   予めあらゆる 1 文字コマンドについて bind -r && bind -x ... しておくとなる。
    |   bind -x でない通常の readline 関数がそれぞれの文字に割り当てられている場合はそれが呼び出される様だ。
    |   しかし、全てを bind -x で処理する為に readline 関数を解除していると "見付からない" という事になる。
    |   再現方法は以下の通りになる:
    |
    |   $ bind -x '"ab":"echo"' && bind -r ab && bind -x '"a":"echo"'
    |
    |   1つ目のコマンドも3つ目のコマンドも -x でなければ再現しない様だ。つまり、
    |   $ bind '"ab":self-insert' && bind -r ab && bind -x '"a":"echo"' → 再現しない。問題なし。
    |   $ bind -x '"ab":"echo"' && bind -r ab && bind -x '"a":self-insert' → 再現しない。問題なし。
    |   という事である。
    |
    | これを解決する為には "a" で始まるあらゆる2文字のシーケンスを登録すれば良い。
    |
    | これは C-x の状況と似たような状況である。
    | (以前の bash で試した時には C-x に続けて何か入力すると bash 毎落ちていた。
    | これがエラーメッセージを表示するという状態に修正されたのだろう。)

    取り敢えず "ESC なんとか" は如何にも bind -x で登録されそうな組合せなので、
    "ESC *" の全ての組合せを登録してしまう事にする。
    実際には bind -x でどの様な2文字のシーケンスが登録されているのか分からないので、
    あらゆる "* *" の組合せについて登録しない限りは万全とは言えない。
    とはいいつつあらゆる組合せについて 2 文字単位でしか入力を読み取れない状態にもなる。
    これは明らかに不便だ。結局、"ESC *" の組合せを登録する程度が限界だろう。

    分かった事2: ESC は bash-4.3 では初めから2文字のシーケンスの一部と解釈される

    | bash --norc で起動した状態から source ble.sh した場合は ESC * に bind しなくても良いかと思ったが、
    | 実際に試してみた所同様のメッセージ bash: bash_execute_unix_command: コマンドのキーマップがありません
    | が出る。bind -X で確認したが、やはり bind -x は何も存在していない状態から source ble.sh だった。
    | その他の version の bash がどうなのかは試していない。

    つまり、bind -x を何もしていない状態でも "ESC *" に対して bind しなければならないという事。


2013-06-13

  [Done]

  * <bug> bash-3.2.48, bash-3.1: カーソルの表示位置がずれる。 [#D0121]
    と思ったら、そもそも READLINE_LINE 及び READLINE_POINT に対応していない様だ?
    これだと C-d で即座にログアウトしてしまう…。

    →これに関しては READLINE_LINE は空白のままで諦める事にした。
      この状態であれば bash による出力は何も為されないので、
      カーソル位置の修正などを行う必要はなく、ただ .ble-edit-draw.update を実行すればよい。

    →また、C-d に関しては IGNOREEOF を大きな値に設定して取り敢えず諦める事にした。
      制限としては C-d を受信する事が出来ないという事、C-d を押すと
      「ログアウトする為には exit を入力して下さい」と表示され、
      プロンプトの表示などが乱れる (というか何も表示されない) という事。

    [2013-06-13 21:24:46]

  * <bashbug> bash-3.1 [#D0120]
    パラメータ展開の部分文字列で、範囲外のインデックスを指定すると ^? が返ってくる。
    これはどうしようもない。部分文字列は他の場所でも多用している上に代替手段が存在しない。
    (勿論、別のプログラムを呼び出せばこの機能を再現する事は出来るが、
    それをするととても遅くなるので受け入れがたい。)

    bash の ChangeLog を見てみたが、このバグに関する情報は書かれていない様な気がする。
    一応 bash-3.2 から bash-4.0 へ変わる時に配列の ${array[@]:*:*} で stray の ^?
    が出るバグを修正したと書いてある。また、${var##..} で空白が絡む時の stray ^? についても
    バグの修正が為された様だ。

    →何故かは知らないが、a=; echo "(${a::})" とすると ^? が出力されるが、
      a=; x="${a::}"; echo "($x)" とすると正しい結果が返ってくる。
      また "(${a::})" や "a${a::}b" 等とすると ^? が出力されるが、
      "(""${a::}"")" や "a""${a::}""b" とすると ^? は出力されない。
      もし "" で文字列を区切るだけで良いのだとしたら、少ない修正で bash-3.1 にも対応可能である。

      取り敢えずこの修正によって見た目ちゃんと動いている様子である。
      [2013-06-13 21:25:43]

    →また、bash-3.2.48 で確認してみた所、このバグは既に取り除かれている様だ。

2013-06-12

  [Done]

  * <bug> bash-3 では bind -x されたコマンドを受け取った時、 [#D0119]
    一度改行してから実行される為に、行がずれていく。
    プロンプトは消去されないので再描画の必要はない。
    現在位置の情報を更新するだけで良かった。

  * <bug> ble-bind -D: cmap または kbd が全く定義されていない状態で [#D0118]
    ble-bind -D を実行すると内部の declare -p が無引数で実行されて、
    bash 内で定義されている全部の変数が出力されてしまう。
    これは、_ble_decode_cmap_@ または _ble_decode_kbd_@ が 1 つ以上あるか
    どうか確認してから declare -p を呼び出す様にすれば良い。

  * <bug> bash-3.1, ble-decode-kbd ESC の結果が 3 になる。 [#D0117]
    .ble-decode-kbd.get-keycode: tmp の要素を数える所で、
    tmp の先頭要素の文字数を数えていた。

  * <bug> bash-3.1: 何と bash-3.1 の算術式では ?: を数珠繋ぎに出来ない。 [#D0116]
    ちゃんと括弧で括っていかなければならない。これは結構痛いと思ったが、
    意外と書き直さなければならない所は少なかった。

    .ble-text.c2bc+UTF-8, .ble-text.c2w+emacs, .ble-text.c2w.ambiguous

  * <bug> bash-4 未満で _ble_decode_kbd__c2k を -A として宣言していた。 [#D0115]
    -a に書き換えるだけでよい。
    [2013-06-13 00:26:51]

  * <opti> スタイルを一つの整数で表現する。 [#D0114]

    文字列比較などをすると時間が掛かる為。
    ble-color.sh, ble-edit.sh 等を書き換えた。意外とすんなりできた。
    これで .ble-line-text.construct のループ内の処理をできるだけ算術式で記述し、速度向上を図る。
    →変更した。定量的に変化があったかどうかは分からないが。

  * ble-edit.sh: quoted-insert, self-insert, insert-string で [#D0113]
    _ble_edit_mark_active を解除するように変更

  * [ble: exit] の際の色を変更 [#D0112]

  * 履歴展開: 展開に失敗した時の対処。 [#D0111]
    その儘空白のコマンドを実行してしまっていた。
    履歴展開に失敗した時は bash では、前回編集中のコマンドが再度表示される。
    それに倣って書き換えた。
    [2013-06-12 15:15:47]

  * 履歴展開が使えない [#D0110]

    set -H としてみたが eval の中では有効には為らなかった
    (というか、多分、set -H は初めから設定されていたのではないかと思う)。
    history -p で変換してから実行すれば等価だろうか。
    ("" で囲んでも実行された、が、通常の履歴展開の動作もそうなっている様だ。)

    この方針で実装する事にした。
    [2013-06-12 15:14:22]

  * fword: IFS に加えて / も区切とする単語単位の操作を追加。 [#D0109]

  * uword: IFS を参照してそれを基準にして単語境界を決めるように変更。 [#D0108]

2013-06-11

  [Done]

  * <bug> 特定の操作をした時に accept-line の処理が中途半端で終了する [#D0107]
    C-c や C-z など。

    [C-z 完 2013-06-11 12:22:35]

    + C-\ の場合は問題なく続きが実行される。

    + 実は C-z をした時にも同様の事が起こっている様だ。

      こちらについては trap 'echo' TSTP, trap 'echo' 20, trap echo 'SIGTSTP' 等としても設定できない?
      trap -p をすると予め '' が割り当てられている様子である。
      その他にも予め '' が割り当てらｒている TTIN TTOU についても、
      trap を仕掛けても何も trap する事ができない様だ。

      念のため trap : 20; trap -p と、連続で実行してみたがやはり設定できていない。
      つまり、誰かが設定を戻しているという訳ではなく、初めから設定できないという事。
      また、stty susp undef としてから trap してみたが、それでも設定できない。

      然し乍ら C-z をした直後には、何故か redraw は実行される様だ。
      但し、stty の設定は元に戻っていないようで、
      C-c や C-z 等の文字を受け取る事は出来ない。

    + 然し C-z の直後には何故か prompt が表示されている。
      これは一体誰が表示しているのだろうか?
      →確かめてみた所、C-z した時は実行中のコマンド全てに失敗する訳ではないようだ。
        accept-line.exec 内のループを抜けるに留まるらしい。

        for コマンドが C-z を受信するという事だろうか?
        試しに accep-line.exec 呼出元で 1 回ループにくるんで見たところ、
        C-z でそのループまで抜けるようになった。
        つまり、for 等のコマンドを使わずに実行すれば良いという事だろうか。
        (一応再帰と条件分岐さえあればループは可能。)

        試してみた所 && による条件分岐は C-z で止まらない
        また、if 文による条件分岐も C-z では止まらない様だ。

2013-06-10

  [Done]

  * <opti> .ble-line-text.construct 文字連結最適化? [#D0106]
    [2013-06-11 03:37:38 余り効果は無かった]

    カーソル移動だけの時は配置の再計算を省略できるようにしたが、
    カーソル移動がそれ程速くなったとは思えない。(少しは軽くなった気がしないでもないが)
    何がボトルネックになっているのだろう。残りは、文字連結程度しかない。
    なので、文字連結の最適化について考え直してみる。

    色々試してみた結果、配列に格納していって最後に join するのが速いようである。
    また、${#out} の様な長さの評価の仕方は O(N) の計算量なので
    ループの中で毎回参照するのは避けた方が良い。
    →余り改善したようには思われない…。

    或いは単に関数の呼出に時間が掛かっているだけなのか?
    →でもこれはあり得ない。何故なら編集文字列が短い時にはきびきびと動くから。

    それとも cache_g[i] やら cache_ei[i] の代入に時間が掛かっているのか。
    →試しに off にしてみたがそれ程変わった雰囲気もない。

    或いは座標位置の再計算をしてしまっている? → 確認してみたが、ちゃんと再計算は省略されている。

    改めてどの場所で時間が掛かっているか確かめる為に、
    カーソル移動しか起こっていない場合には文字連結部分を省略してみる事にした。
    (この様にするとカーソル移動によって更新されるべき物が更新されないので、実際には使えない方法である。)
    →すると動作がとても速くなったので、やはりこの文字連結を行っている部分が悪い様だ。

    更に、ダミーで文字連結のループを回して何処に時間が掛かっているのか調べる事にした。
    →文字を配列に登録する部分はそんなに時間は掛かっていないようだ。
    →文字列の長さを計算する部分も関係ない。
    →cache_ei や cache_g に代入している部分も関係ない。

    # →と、ここで SGR 系列を追加している部分を有効にしてみたら急に遅くなった。
    #   先程やった時には余り変化が無かったように感じたが恐らく勘違いだった。
    # →どうも文字列比較 if test "$seq" != "$seq0"; then の部分が重い様子である。
    #   (seq, seq0 はそれぞれ3文字なのでそれ程重いとは思えないのだが)
    #   以下のような色々な物を試してみたが、速さに大差は無いようである (当然か)。
    #   if test -n "${seq#"$seq0"}"; then
    #   if test "$seq" != "$seq0"; then
    #   if [ -n "${seq#"$seq0"}" ]; then
    #   if [ "$seq" != "$seq0" ]; then
    #
    #   或いは、sgr の表現を整数にして、整数同士で比較する様にすると速いかも知れない。
    と、ここまでで SGR 系列の部分が怪しいのではないかと色々調べてきたが、
    やはり? 違うようだ。別の所をコメントアウトして SGR 系列の部分だけ残してみると充分速い。

    どうも、何処が特に重いという訳でもなく、これが bash の限界という事のようだ。
    早く dirty または色変更した部分だけしか再計算を実行しなくても済む様に変更した方が良いという事だろう。

  * カーソル移動では dirty を設定しない様に変更。 [#D0105]
    →意外と少なかった。移動は全て .ble-edit.goto-char を介して実行されていた為、
      .ble-edit.goto-char の中で実行されている .ble-edit.set-dirty を削除するだけで良かった。
      その他は set-mark, exchange-point-and-mark ぐらい。

    + と思ったらカーソルを移動しても、カーソルの移動が表示に適用されなくなった。
      良く考えたらカーソルの移動をした場合、文字の配置を再計算する必要はないが、
      表示の際の領域反転などは再度計算し直す必要があるので、
      描画に関しては再度実行する必要がある。

    # * 現在 cursor 移動も dirty として扱っているが、
    #   別にその様に扱う必要性はないのではないか?
    #
    #   dirty としたのは色付け関数によって括弧の強調などの色付けがカーソルの位置に
    #   依存して行われる可能性があったからである。
    #   色付け関数が region_highlight なり何なりを呼び出した時点で、
    #   set-dirty が自動的に為されるような仕組みにしておけば問題ない。

  * <bug> set-mark: 動作が emacs と違う。 [#D0104]
    emacs では既に mark が active な場合でも、
    active なまま新しく現在位置を mark の位置とする。
    active 状態をトグルするなどといった事はしない。
    [2013-06-11 00:23:12]

  * _ble_edit_mark_active [#D0103]
    今迄の型は整数型で 0 または 1 の値を取っていたが、
    今後は様々な種類のマーク (S-move によって有効になったマークなど) を区別する為に、
    + マークが設定されていない場合は ''
    + set-mark によってマークが設定されている場合は '1'
    + S-move によってマークが設定されている場合は 'S'
    + (その他のマークを設定する事が在れば必ず有限長の文字列)
    等のように文字列とする事にした。これに伴って何カ所か修正。
    [2013-06-11 00:14:30]

  * <bug> 今迄 sword としていたのは寧ろ unix-word の事だった。 [#D0102]
    名称を sword から uword に変更。
    [2013-06-10 22:41:22]

  * <bug> uword の定義で空白を SP HT にしているが、LF も含める。 [#D0101]
    [2013-06-10 22:41:28]

  * sword 関連に対応 [2013-06-10 22:43:42] [#D0100]

    IFS=$'|&;()<> \t\n' (シェルのメタ文字) を区切り文字として単語分割する。
    但し、quote については正しく処理していない。

    # unix-word の定義について調べて uword として実装する。

  * forward-word, backward-word を emacs や readline と同様の位置に移動する様に変更。 [#D0099]

  * <opti> 長い文字列を編集するのに時間が掛かる。 [#D0098]

    これは毎回 construct-line でカーソルの位置の計算と出力文字列の構築を行っているからである。
    特に、一つ一つの文字幅を毎回計算しているのが一番重い気がする。
    理想的には dirty な部分以降の計算を実行すれば良いはずである。

    と思ったが、カーソルの位置が変われば SCOSC, SCORC の埋込位置が変わる為、
    現状の実装方法ではやはりカーソルの位置から再度計算し直さなければならない。

    これの解決方法としては、
    + 先ず全ての文字の後で x y lc lg がどの様な状態になるべきかを計算し、これを cache 配列に記憶する。
    + また、全ての文字に対して esc_line 中の何文字目に対応するかも記憶しておく。
    + esc_line 自体も何処かに記憶しておく。
    construct-line 関数は以下の処理を実行する
    1 dirty が設定された場所から位置解析をやり直す。
      この解析では各文字だけを記録し、escape sequences の構築まではしない。
    2 更に色付けの処理を dirty が設定された場所からやり直す。
    3 色付けによって変更された箇所から escape sequences を構築し esc_line とする。
    4 esc_line のカーソル位置と末端に SC と RC を挿入して ret に入れる。
    5 カーソル位置の x y lc lg を取り出す。

    新しく .ble-line-text.construct という関数を作る事にした。

    + 先ず始めに .ble-line-text.update-positions で dirty から x y lc を更新する。

      i文字目を処理している時:

      1 cache_x[i], cache_y[i] の更新
        cache_x[i], cache_y[i] には i 文字目を出力する **前** のカーソル位置が格納される。
        (或いは、i-1 文字目を出力した **後** のカーソル位置とも言う事が出来る。)

      2 次に cache_lc[i] の更新を行う。
        cache_lc[i] は、cache_x[i]!=0 の場合は、その左側に位置する文字、即ち i-1 番目の文字のコードを保持する。
        cache_x[i]==0 の場合は、その次に同じ行に来る文字のコードを保持する。

        cache_lc[i] は x!=0 の時は、前回の文字コード (lc) をそのまま代入すれば良い。
        然し、x==0 の時は、次に x!=0 になるまで代入を実行する事は出来ない。
        ここで変数 li を導入する。li は、次に cache_lc を代入するべき位置を保持する。

        x!=0 の場合には cache_lc[li] ～ cache_lc[i] までの値を代入し、li=i+1 とする。
        x==0 の場合には cache_ic に対する代入は実行せず li の位置も進めない。
        cache_lc[li] ～ cache_lc[i] に対する代入は以下のように行う。
        x!=0 となった行 y が cache_y[j] と一致するならば lc を代入する。# これだと ^A 等の場合に A に化けるのでは?■
        x!=0 となった行 y が cache_y[j] と異なるならば 32 (空白) を代入する。

        for(j=li;j<i;j++)
          assert(_ble_line_text_cache_x[j]==0);

      3 cache_lg[i] の更新は未だ行わない。

    + その後紆余曲折を経て新しい「編集文字列構築器」ができた。
      古い関数
        .ble-cursor.construct-line.chk-cursor
        .ble-cursor.construct-line
      は削除する。
      [2013-06-10 22:02:41]

2013-06-09

  [Done]

  * <bug> source ble.sh でエラーが発生するようになった。 [#D0097]
    どうやら ble-bind で発生している様だ、
    と見てみたら OPTARGS の変数存在確認で "${OPTARGS+set}" を引用符で囲むのを忘れていた。
    [2013-06-10 04:00:03]

  * <opti> プロンプトの初期化が異様に遅い @ cygwin [#D0096]

    プロンプトで \j が3回参照されている。
    それぞれの \j の呼出で2つのプロセスが生成されているので、
    プロンプトの初期化で合わせて 6 つのプロセスが生成されている事になる。
    cygwin のプロセス生成の速度は測ってみたら秒間 10 程度であったので確かに時間を食う。
    (本来はプロセスを生成せずにこれを処理したいが。)

    プロンプトの初期化中にコマンドを実行する場合は、
    コマンドの実行結果をキャッシュするように変更。
    [2013-06-10 03:31:58]

    更に job の数を wc を使わずに数える様に変更。
    [2013-06-10 03:53:44]

    これらの変更によって cygwin でなくてもかなり軽くなった様に思われる。

  * <bug> /bin/printf, source ble.sh 時にエラー @ cygwin [#D0095]
    c2s: /bin/printf が使えない環境で source ble.sh 時にエラーメッセージが出る。
    /bin/printf の stderr を /dev/null に落とすように変更。
    [2013-06-10 03:37:02]

  * <bug> [ -v ] のエラーが発生する @ cygwin [#D0094]
    cygwin 環境で動かしてみる→エラーが発生して初期化に失敗する。
    ble-bind で OPTARGS の変数存在チェックに test -v を使用していた。
    bash-4.1 以下でも動くようにする為には test -n "${OPTARGS+set}" を使用するべき。
    [2013-06-10 03:34:53]

  * <bug> c2s-hex: /bin/printf を用いて [#D0093]
    function .ble-text.c2s-hex を定義するべき所を
    function .ble-text.c2s を定義していた。
    [2013-06-10 03:33:23]

  * <bug> 再描画の際に sgr 情報が失われる。 [#D0092]
    カーソル位置を設定する時、lc と共に sgr の情報として lg も記録するようにしたい。

    construct-prompt に関しては取り敢えず置いておき、
    construct-line の方での対応を済ませる。
    [2013-06-09 19:25:13]

  * <bug> 編集文字列が右端一杯の時に縦の位置がずれる。 [#D0091]
    <del>右端付近に tab があると縦の位置がずれて表示される。</del>

    多分、tab の所為で発生する改行についてちゃんと対策が取れていない為である。
    後でゆっくり考える必要がある。

    と思って色々試していたら、別に tab がなくても編集文字列末端が右端付近に位置している時には
    縦の位置がずれてしまうという事が分かった。
    原因は construct-line の中で SCORC を出力する位置にあった。
    最後の改行を出力する前に SCORC を設定していた。本当は最後の改行の出力も済ませてから
    SCORC を設定するべきだった。

    + これで丁度右端ぎりぎりまで編集文字列がある場合に常に (カーソルが何処にあっても)
      位置がずれると言う問題は解決した。

    + しかし、それでもカーソルが丁度右端にある時のカーソルの位置が変な事になっている。
      右端にあるので本来はカーソルは見えない (?) 筈であるのに最後の文字 (右端から一文
      字戻った場所) に表示されたり、次の行の最後の文字の位置に表示されたりする。

      そもそも一番右端にカーソルが来た場合に何処にカーソルを置くべきかという事だが、
      xenl が有効な端末でも無効な端末でも同様に表示するのであれば、次の行の先頭に表示する
      べきである。(その事も考えて編集文字列が丁度右端に到達している時に、xenl に対して
      改行を出力しているのである)

      問題は、SCOSC をしている時に行末端に位置している為に、SCORC で戻ってきた時に、
      (折角改行したのに) 行末端の位置に戻ってきてしまう事である。
      今迄は行末端に来た時、xenl であっても次に文字が来た時に次の行に自動的に移動するから
      敢えて改行は出力しないようにしていたが、SCORC で戻ってくる事も考えると、
      ちゃんと xenl の場合には明示的に次の行に移っておいて、その後で SCOSC される様にする
      べきである。

      その様に書き換えたらちゃんと期待通りにずれずに動くようになった。TAB がきても問題ない
      [2013-06-09 18:37:58]

  * <bug> 全ての文字に対して SGR を出力している。 [#D0090]
    編集文字列の表示で出力している escape sequence を見てみると SGR が変化していないのに
    毎回 SGR の設定を出力している様だという事が分かった。前回の文字と SGR の設定が同じ場合には、
    SGR の設定は出力しないようにしていた筈である。
    →改めて確認してみた所 seq0=seq としていた。seq0="$seq" でなければならない。
      「前回の SGR」の値が常に誤った設定になっていたから、毎回 SGR が出力されたのである。
    [2013-06-09 18:06:30]

  * <bug> 改行を含むコマンドを編集している時、 [#D0089]
    行の先頭にカーソルがある時に、そこに位置する文字が空白に化けて表示される。
    本来ならば行頭に文字がある場合、その文字を lc に設定する事になっているはずである。

    見てみた所、.ble-cursor.construct-line.chk-cursor までは正しく処理できている様に見える。
    と思ったら、update-adjusted で lc から READLINE_LINE を設定するのではなく、
    単に空白を READLINE_LINE に代入していた。
    [完 2013-06-09 16:53:31]

  * <bug> tab が幅ゼロで表示されている。 [#D0088]
    時々幅を持って表示されるがその規則は謎。

    と思ってみていたら tab の幅が負の大きな値になったりしている。
    絶対値は大体 x と同じぐらいである。と、ここで /it とするべき所を %it としている事に気付いた。
    同様のコードを色々な所に書き散らしていたので、それらも纏めて修正した。
    [2013-06-09 16:43:12]

  * <bug> 改行を含むコマンドを実行すると、実行後にカーソル位置がずれる。 [#D0087]
    [2013-06-09 16:14:26]

    これは前回のプロンプトが表示されていると勘違いして原点に移動する為である。
    _ble_line_x, _ble_line_y を 0 に設定するべき。

    →.ble-edit.accept-line.exec.adjust-eol で
      _ble_line_x, _ble_line_y を 0 に設定する事にした。

  * <bug> quoted-insert [#D0086]
    一部の文字を read -n で読む事が出来ない。
    →これは全ての文字を ble で処理できるようになったら
      ble の仕組みを通じて読む事にすれば良い。

    改めて試してみた所、大概の入力は読み取れている? 後で再度確認する必要有り。
    確認してみた所 ^I ^J ^M の入力をする事ができない。
    やはり、ble-decode-char 辺りに quoted-insert を仕掛ける必要がある。

    # * ble-edit-quoted-insert:
    #   現在はデバグの為に一部の文字列しか捕まえられないので、
    #   read -N を使って実装を行っているが、
    #   全部を ble で処理するようになった時は、
    #   ble-decode-char に対して干渉するだけで良い?

    .ble_decode-char:
    _ble_decode_char__hook 変数を追加、この変数が設定されている場合は、
    この変数に代入されている文字列をコマンドとして実行するように変更。
    [2013-06-09 16:09:46]

  * デフォルトの cmap である term+default を読み込むのに時間が掛かる。 [#D0085]
    [完 2013-06-09 15:46:02]

    恐らく ble-decode-kbd 辺りの処理に時間が掛かっているのではないかと思う。
    ble-bind に -D オプションでも追加して、これを追加した場合は、
    ble-bind コマンドによる設定ではなく、cmap 配列に直接値を代入する方式として、
    設定スクリプトを吐き出す様に変更するか?

    直接値を設定する様にすると既に何かを設定している時にそれを上書きする事で、
    データを破壊する事にもなるかもしれないので、その辺りについては確かめる必要がある。
    基本的には設定を追加・上書きするようにすれば良い。

    →試しに配列に直接値を代入する形式でデータを出力してみた。
      出力したデータは 100 KB にも及び巨大だが、
      それを source してみた所 0.1 秒以内にロードできた。
      速度としては充分である。

    + 既存の設定が存在している時にこれを追加して問題になりそうなのは
      "_" を代入する場合と "数字" を代入する場合である。
      "_" を代入する場合は既存の "数字" の設定があった場合に、その既存の設定を消す事になる。
      "数字" を代入する場合は既存の "_" の設定が存在する場合に、それを消す事になる。
      "数字_" を追加する場合については、既存の設定が何であれ完全に上書きしてしまうので関係ない。

      既存の設定に対して安全に追加する事が出来るように書き換えてみたが、
      やはり処理に時間が掛かるようになった。term+default.sh で生成したエントリを全て追加するのに 1 秒弱かかる。
      直接配列を設定する場合には 0.075 秒しかかかっていなかったので、12-13 倍の違いがある。

      また、dump 結果を source してから気付いた事だが、ただ cmap 内の情報を dump するだけでなく、
      キーとキーコードの対応表も一緒に読み込まなければ意味がない。
      そして、後から登録する方式だと、登録したいキーに対応するキーコードが既に使われている場合に、
      番号の再配置を実行しなければならないが、これはかなり重い処理になると思われるので現実的でない。

    + 結局、現実的には既存の cmap に対して追加登録をするのではなく、
      cmap、キーコード・キー対応表を全て入れ替える形にするしかない。

    + 所で良く考えたら declare -p "${!_ble_decode_...@}" 等とすれば

      特別にロジックを書かなくても変数の内容を直接 dump する事ができるのでは?
      実際に試してみた所、declare で出力した物も、
      自分で書いた配列要素を一つ一つ初期化する形式の物も、
      source するのにはそれ程時間の違いはなかった。両方とも 0.105 秒程度かかる。
      若干 declare の形式の方が時間が掛かっている気もするが、誤差の範囲内であろう。

      今後は declare -p を使って dump する事とし、今迄に書いた関数は削除する:
      [2013-06-09 14:37:52]

      function .ble-decode-char.dump-entry {
        local tseq="$1" ccode
        eval "local -a ccodes=(\${!_ble_decode_cmap_$tseq[@]})"
        echo "_ble_decode_cmap_$tseq=()"
        for ccode in "${ccodes[@]}"; do
          eval "local ent=\${_ble_decode_cmap_$tseq[$ccode]}"
          echo "_ble_decode_cmap_$tseq[$ccode]=$ent"
          if test "${ent//[0-9]/}" = _; then
            .ble-decode-char.dump-entry "${tseq}_$ccode"
          fi
        done
      }
      function .ble-decode-char.dump-entryA {
        local tseq="$1" ccode
        eval "local -a ccodes=(\${!_ble_decode_cmap_$tseq[@]})"
        for ccode in "${ccodes[@]}"; do
          eval "local ent=\${_ble_decode_cmap_$tseq[$ccode]}"
          echo ".ble-decode-char.add-entry $tseq $ccode $ent"
          if test "${ent//[0-9]/}" = _; then
            .ble-decode-char.dump-entryA "${tseq}_$ccode"
          fi
        done
      }
      function .ble-decode-char.add-entryA {
        local bseq="$1" byte="$2" val="$3"
        if test -z "${val##*[0-9]_}"; then
          eval "_ble_decode_cmap_$bseq[$byte]=$val"
        elif test -z "${val##*[0-9]}"; then
          eval "
           local ent=\"\${_ble_decode_cmap_$bseq[$byte]}\"
           _ble_decode_cmap_$bseq[$byte]=${val}\${ent##*[0-9]}
          "
        elif test "$val" = _; then
          eval "
           local ent=\"\${_ble_decode_cmap_$bseq[$byte]}\"
            _ble_decode_cmap_$bseq[$byte]=\${ent%_}${val}
          "
        else
          echo unexpected value 2>&1
        fi
      }

    + cmap+default.dump が存在すればそれを source する事にし、
      もしなければ cmap+default.sh から構築してから dump する様にする。

      と思ったら正しくロードされていない。新しく構築した場合にはちゃんと動いているが、
      cmap+default.dump からロードするとロードされていない。
      関数内から cmap+default.dump を source していて、
      cmap+default.dump 内では declare で変数を宣言している為、
      その関数内の局所的な変数としてロードされている。

      これをちゃんと動く様にする為には declare を宣言しなければ良いのだが、
      連想配列については、それが連想配列だという事を明示的に宣言できない。
      →しかし既に別の場所で宣言している筈だから問題ないのでは?
        実際に試してみた所、既に declare -A されている場合、
        新しく代入する場合でも問題は起こらないという事が分かった。

      と言う訳で先頭の declare -? を削除して dump を出力する事にしたが、
      今度はエラーが発生する。よく見たら代入の右辺に一々引用符がついていて、
      配列としての代入ではなくて一つの長い文字列としての代入になってしまっている。
      declare の時には、declare コマンドが文字列として受け取った右辺を展開してから代入するので問題にならないのだろう。

      今回は値としては常に一文字以上の [0-9_] だけで構成される物なので、引用符を全て外しても問題ないだろう。
      という訳で sed で引用符の類も全て削除する事にした。
      その上で source の時間を計測してみた所 0.064 秒にまで縮んだ (単にファイルサイズの問題のような気もしてきた…)。

    + 無事に cmap+default.dump で現実的な速度で初期化できる様になったので、
      <del>古いコード (必要最低限の物だけの設定) は削除する。</del>
      と思ったが、後でまた欲しくなるかも知れないので、cmap+minimal.sh として残しておく事にした。

2013-06-08

  [Done]

  * <bug> ble-line-info: 表示している間、編集文字列のカーソル位置の文字が空白になる。 [#D0084]
    [完 2013-06-09 01:42:41]

    これはカーソル位置を移動する時に _ble_edit_lc も変更してしまっているのが原因。
    _ble_edit_lc は描画関連の処理が終了してユーザの入力待ち状態になった時に、
    最終的にカーソルが存在しているべき位置の文字を示す物であって、
    これは一時的なカーソルの移動の際に変更するべき物ではない。

    現状では「最終的にカーソルが存在しているべき位置と其処の文字」と、
    「現在の描画処理の為に移動しているカーソルの位置と其処の文字」を一緒に扱っている。
    変数を分けるべきではないだろうか。
    + _ble_line_curx _ble_line_cury _ble_line_curlc は配列に纏める事にし、
      これは「最終的にカーソルがあるべき位置と文字」とする事にした。
      また、_ble_line_x, _ble_line_y という変数を追加し、これを
      「描画中の現在カーソルが存在している位置」とする事にした。

    + .ble-edit-draw.goto-origin, .ble-edit-draw.goto-end 関数を廃止し、
      .ble-edit-draw.goto-xy 関数を定義し、任意の座標に簡単に移動できるようにした。

    + この変更によって .ble-line-info.draw, .ble-line-info.clear で
      復帰する必要が無くなったかも知れない。
      現在のカーソルの位置が分かっているのだから、
      わざわざ元の位置に戻らなくても良い。
      次に移動する必要が生じた時に適切に移動すれば良いだけである。
      (勿論、その為には .ble-line-info.* で現在のカーソル位置の情報を更新する必要がある。)

      最終的に必ず update-adjusted が呼び出される。
      そして update-adjusted は必ず始めに update を呼び出す。
      update は現状の実装では必ず編集文字列部分は表示し直すから、
      結局必ずキャレットの場所へ移動する事になる。

    + と思って実際に試してみたら位置を移動するようになってしまった。

      これは単に _ble_line_x の変数名を _ble_edit_x としていた為であった。
      正しい変数に移動後の座標を書き込んでいなかった。

      しかしこれを修正しても未だカーソルの位置がおかしい。
      座標位置を勘違いしていると言うよりは、
      info 情報を出力した直後のカーソル位置になっていて、
      その後 update-adjusted 等の操作が行われた形跡がない。

      と思ったら _ble_line_y に対して数式をその儘代入していて、
      計算した結果を代入していなかった。
      しかしこのバグは今回の異常とは関係ない気もする。

      果たして実際に試してみると未だ直っていない。
      また、.ble-edit-draw.update の前後で現在の座標位置が変化していない。
      本来であればこの部分で適切な位置への移動が行われると期待している。
      という事で改めて .ble-edit-draw.update を見てみると、
      実は .ble-edit-draw.update の先頭で
      _ble_edit_dirty が全く設定されていない時には何の操作もせずに終了するようになっていた。
      _ble_edit_dirty が設定されていなくても、位置が異なる場合には移動を実施する様に変更する。
      →これで取り敢えずカーソル位置は正しくなった。
      [2013-06-09 01:42:41]

      また、その際に sgr の値を再設定する必要もある。(sgr は今迄は SCORC, DECRC 等に頼っていたが、
      本来は自分で管理できるようにしておきたい所である。)
      これについては別項目で取り扱う事にする。

  * <bug> 複数行に渡る編集を実行している時に、何かを入力する度に表示位置がずれていく。 [#D0083]
    [2013-06-09 01:17:29]

    ずれない様に設計している積もりだったが正しく動作していない様子である。
    先ず始めにずれて上にはみ出た行が消去されていない事から、
    .ble-edit-draw.clear の時点で原点に移動して削除するということができていない様である。
    可能性としては、現在の位置座標を勘違いしているか、原点へ移動する為の制御系列を誤って生成しているかのどちらかである。

    .ble-edit-draw.redraw-cache の始めで現在位置がどうなっているかについて確認を行う。
    →座標値については正しく計算されている様である。
    という事は goto-xy が怪しいと思って改めて考えてみたら、
    今回の場合は y の移動量 dy が負になる。その時に ESC [ A に渡す引数を絶対値にするのを忘れていた。

  * <bug> 色々変更している内にカーソルが先頭に移動するようになってしまった。 [#D0082]
    [完 2013-06-09 01:08:14]

    goto-xy の引数に文字列で式を指定できるようにしていたが、
    これをすると goto-xy の中で新しく宣言した変数に影響を受けて値が変わってしまうので、
    やはり goto-xy の引数にちゃんと評価した後の数値を指定する様に変更した。

  * 不要なデバグ用の古い関数 .ble-dbg,esc2a を削除 [2013-06-09 00:32:04] [#D0081]

  * ble-edit.sh (complete-filename): 引数が一意に確定した場合、 [#D0080]
    ディレクトリ名の場合には後に / を挿入し、それ以外の場合には SP を挿入する様に変更。
    今迄はディレクトリ名であっても後に / を挿入していた。
    [2013-06-08 16:50:34]

  * <bug> ble-decode-kbd: '*' を変換しようとすると、ファイル名展開が実行されてしまう。 [#D0079]
    仮定: * や ?, - が含まれるような single-key 指定は、
          必ず最後の一文字だけが * や ?, - 等の特殊文字である。
          それ以外の指定を行った場合の動作は保証しない。
    仮定: C- 等のような中途半端な指定は C-- と解釈される。
    [2013-06-08 16:01:32]

  * keyflag の定義を emacs と同じ物に変更。 [#D0078]
    Meta=1<<28 Ctrl=1<<27 Shft=1<<26 Hypr=1<<25 Supr=1<<24 Altr=1<<23

  * <bug> ble-decode-kbd: C-- や - 等を正しく変換する事が出来なかった。 [#D0077]

2013-06-06

  [Done]

  * 取り敢えず色付け関数 [#D0076]

  * <bug> C-c: プロセスを停止した直後、プロンプトが表示されない [#D0075]
    [完 2013-06-07 03:52:15]

    これは accept-line の処理が中途半端になったまま終了してしまうからである。

    + C-c 等でプロセスを停止した時に 正しく終了されるか?
      →正しく終了されていない様である。

    先ず何か入力するまでプロンプトが表示されない。
    (但し、^? などに対してはちゃんと読み取れる様である。
    ^? でも何でもいいから入力をすると復帰する。)
    これは accept-line の後の .ble-edit-draw.redraw が実行されていない為であろう。

    適当に trap 'echo hello' INT とすると、
    続きが実行される様になった。因みに hello の文字列は何処かに消える?
    なので trap : INT 等とする事にする。
    (既に存在している trap を上書きしてしまう事になるが仕方がない。)
    [2013-06-07 03:19]

    と思ったが、実際に試してみると、シェルの処理で重い場合に C-c をすると
    trap : INT や trap 'echo hello' INT 等としていた場合にシェルの応答がなくなってしまう
    という事が分かった。因みに trap を何も仕掛けていなければ正しく終了する。

    と、思っていたが trap return INT にしておけば一応問題は起こらない様だ。
    [2013-06-07 03:52:15]

    <del>しかし trap 'return 128' INT にすると今度は return は関数内でなければ
    使えないというエラーメッセージが表示される。</del>
    どうも trap を定義した場所が関数内なら return を書いてもエラーは出ない様だ。
    なので、.ble-edit.accept-line.exec.eval 内で trap をする事にした。
    しかし、return 128 等としても戻り値は常に 0 となる様子なので、
    _ble_edit_accept_line_INT という変数を介して 128 の値を返す事にした。
    [2013-06-07 04:12:50]

  * <bug> readline の accept-line をしない限り $? が設定されない? [#D0074]
    前回のコマンド実行の $? を何処か別の変数に覚えておいて、
    次のコマンドを実行する直前に設定し直せばよい。
    設定するには、return で好きな値を返すだけの適当な関数を作って、
    その関数を呼び出せばよい。
    [2013-06-07 02:20:26]

  * <bug> .ble-edit-comp.complete-filename: 変数リーク ret [2013-06-07 02:02:07] [#D0073]

  * <bug> return による accept-line 中断 [#D0072]
    [2013-06-07 02:09:41]

    C-c や C-z をした時の様に、
    コマンドライン中に return が含まれていた場合にも同様の事が発生する。
    これについてはコマンドを実行する際に一つ関数にくるんで実行すればよい

  * ジョブ管理にアクセスできるか? [#D0071]
    問題なくアクセスできるようである。

  * accept-line: 存在しないコマンドでも history に追加される。 [#D0070]
    [キャンセル 2013-06-07 01:55:03]

    history に追加する前にそのコマンドが存在するか確認。
    そもそも存在しない・実行できないコマンドに対しては history への追加を省略する。

    存在するかどうかの確認は type で確認できる物、及び、for などの文法要素?
    →試しに for を type -t に入れてみたら keyword となったので、
      for 等を特別に区別する必要性はない。

    と改めて調べてみたら、元々の bash でも存在しないコマンドもちゃんと history に追加されていた。
    なのでこれについて解決する必要性はない。

  * <bug> accept-line: [完 2013-06-07 01:53:25] [#D0069]

    ret 変数に値を設定できない。
    というか、accept-line を呼び出すまでにネストした
    関数で local として宣言されている変数名は全て使えない…。

    a. accept-line は呼出のネストの浅い所で実行する?
       (例えば ble-decode-byte などで)
    b. 内部変数として使用している変数名を重複の無い物 (_ble_* を予約) にする?

    a. の方針で行くとしたら、呼出が開始された一番浅い場所を見つける必要がある。
    ble-decode-byte から ble-decode-char, ble-decode-key と呼び出される過程で、
    何処が一番初めに呼ばれたかを判定するのは難しい。

    ble-decode-byte:bind が起点になる場合は明らか。
    ble-decode-char が起点になるかどうかの判定は難しい。
    代わりに内部の呼出では .ble-decode-char を使う事にして、
    外部からの呼出 (起点) では ble-decode-char を使い、
    ble-decode-char は .ble-decode-char の呼出 + 修飾処理、という事にすれば良い。

    従って、書き換えは
    1 全ての ble-decode-byte, ble-decode-char, ble-decode-key の内部呼出を
      .ble-decode-byte, .ble-decode-char, .ble-decode-key に書き換える。
      また、それぞれの関数名も書き換える。
    2 ble-decode-byte, ble-decode-char, ble-decode-key を定義し、
      中で .ble-decode-byte, .ble-decode-char, .ble-decode-key を呼び出すと共に、
      その他の前後の処理を追加する。
    という手順で行えば良い。

    先ず、ble-decode-byte は内部的には何処からも呼び出されていない様である。
    ble-decode-char は ble-decode.sh 内にしか存在しない。
    ble-decode-key は ble-decode.sh が殆どで、ble-edit.sh に一箇所だけ存在する。
    これらを書き換えて、呼出の起点に近い場所で実行するように変更した。

    しかし、未だ漏れている変数が存在するようだ。以下の変数は値が漏れている。
    arr file line ret spec

    spec: .ble-edit.history-add
    line: .ble-edit.history-load, ble-decode-bind
    file: .ble-term.initialize
    arr: ble-getopt
    ret: ble-edit+self-insert, ble-decode-bind, ble-bind,
      ble-decode-unkbd 定義直後にテストコードが残っていた
    _getopt_*: ble-bind

  * <bug> ble-decode-byte+C: 文字コードとして空文字列を返していた。 [#D0068]
    [2013-06-07 00:51:25]

  * C-c 等でプロセスを停止した後、次のコマンドを実行するまで行が二重化する [#D0067]
    [2013-06-07 00:19:05]

    C-c でプロセスが失敗した後に accept-line を押すと line が二重に表示される。
    これは実際に別のコマンドが実行されるまで続く。
    多分、これも stty の設定が変化しているから?
    多分エコーの設定が有効になっている為に、
    C-j/C-m が入力された時に行の位置がずれてしまうからだろう。

    これは空コマンドだった場合にも .ble-stty.enter を実行すればよい。
    というか寧ろ ble-decode-byte:bind 辺りで実行しても良いかも知れない。

  * <bug> accept-line: 時々コマンドを実行した時に現在位置が上の方に移動してしまう。 [#D0066]

    <del>どうも accept-line を実行した時に、カーソル直前に存在する文字が
    特殊文字であるとこの現象が発生するようである。</del>

    どうも特殊文字でなくても、カーソルの位置が line の最後の文字以外に置いてある時に、
    この現象が発生するようである。そして特殊文字を入力する時は大抵、先に引用符を書いておいてから、
    引用符の中に入って特殊文字を入力し、そのまま accept-line する為に、この条件に該当する。

    そしてこの条件が該当しそうな箇所が .ble-edit-draw.goto-end にある。
    と思ったら、_ble_line_cury に x 座標を代入していた。
    [2013-06-06 23:57:43]

  * <bug> カーソルの表示位置がおかしくなった [#D0065]
    construct-line で変数名を変更したのに、それを参照している construct-line.chk-cursor で
    変数名の変更していないのが原因だった。
    [2013-06-06 23:38:24]

  * <bug> \\ や \$ が含まれる時の位置計算が誤っている。 [#D0064]
    [2013-06-06 23:37:21]

  * .ble-line-info.clear: 既にクリアされている場合は動作を省略 [2013-06-06 23:05:49] [#D0063]

  * discard-line, accept-line: 実行の前に .ble-line-info.clear [2013-06-06 23:06:17] [#D0062]

  * construct-prompt: シェル変数 x y lc に計算結果を直接書込をする様に変更。 [#D0061]
    [完 2013-06-06 23:05:09]

    + キャッシュ情報は 配列 _ble_line_prompt に記録する事にした。
      _ble_cursor_prompt__LINENO, _ble_cursor_prompt__RESULT の変数を廃止
    + 呼出元を調整。

  * complete 候補一覧を表示 [#D0060]
    取り敢えず表示するだけ表示 [2013-06-06 18:07:53]

  * ble-decode: [#D0059]
    ble-edit-bind の部分にあった bash に対する bind のロジックを
    ble-decode.sh の方に移動させる事にした。
    [2013-06-06 17:41:05]

  * isearch: C-d を押した時に空欄だと即座に終了してしまう。 [#D0058]
    (C-d に delete-char-or-exit が設定されている場合)。
    なので、isearch で C-d を押した時は isearch モードを抜けてから
    唯の delete-char を実行する様に変更。
    [2013-06-06 17:40:50]

  * C-x に対する hook [#D0057]

  * ble-bind [#D0056]
    ESC → Meta が自動的に実行される様になったので、
    Meta について改めて登録する必要はなくなった。ので、その機能は削除。
    [完 2013-06-06 17:18:33]

  * <bug> ble-decode-char [#D0055]
    [完 2013-06-06 17:02:07]

    M-delete 等の操作が正しく key に翻訳されていない。
    これは ESC を meta に変換する機能を入れても入れなくても同様。
    更に ble-bind -k で Meta の付いた物を自動的に登録しても登録しなくても同じ。

    と思ったらそもそも ble-decode-char 自体に二つ連続した ESC は入ってこない様だ。
    screen または bash bind -x で消えてしまっている可能性がある。

    + 試しに bashrc 内で bind している '[D' と '[C', '[3;5~' を削除してみた。
      削除自体は正しく出来たようだが、依然として '' は消えた儘になっている。

    +  /etc/inputrc を見てみたが '\e\e' に関係する物は設定されていない。
      また、~/.inputrc は作っていなかった。

    + .screenrc を見てみたが C-M-tab に windowlist を割り当てている以外は怪しい所はない。
      それに emacs を起動している間はちゃんと ESC ESC を入力する事が出来ているのだから、
      screen は犯人ではない。やはり bash が怪しい。

    A 仕様がないので、直接 "" に対して bind を実行してしまえばよい。
      其処で bind -x '"":ble-decode-byte:bind 27 27' として見たが、
      そうすると今度は ESC ESC を受け取った時に、
        bash: bash_execute_unix_command: コマンドのキーマップがありません
      というエラーが発生してしまう。

    B 取り敢えず、苦肉の策として ESC ESC を何か別の物に変換して受信する事にした。
      ble-bind -k 'ESC [ 2 7 ^' __esc__
      ble-bind -@f __esc__ 'ble-decode-char 27'
      bind -s '"":"[27^[27^"'

      と思ったら、何故か "ESC ^ ^ ESC ^ ^ [ 2 7 [ 2 7" という謎の順番で受信される。訳が分からない。
      bind -s '"":"[1027~[1027~"' に変えてみたら、
      "ESC 2 2 7 ~ ESC 2 2 7 ~ [ 1 0 [ 1 0" となる。^ が悪かった訳ではない様だ。
      文字数の問題?
      bind -s '"":"[^[^"' → "ESC ESC ESC [ ^ [ ^"
      どうやら ESC 後の 3 番目の文字が繰り返される様である?
      bind -s '"\e\e":"\e[^\e[^"' → "ESC ESC ESC [ ^ [ ^" # bind で文字化けしているのかとも思ったがそうではないようだ。
      bind -s '"\e\e":"\e[~"' → "ESC [ ~ ESC [ ESC ESC ESC ..." # 理解不能

      もしかして、ble-decode-char の方のバグだろうか。。
      今度は ble-decode-byte の方で出力を行ってみる事にした。
      "[27^[27^" → "ESC ^ ESC ^ [ 2 7 [ 2 7"             この時点で謎
      "[1027~[1027~" → "ESC 2 7 ~ ESC 2 7 ~ [ 1 0 [ 1 0" ~ でも駄目
      "[^[^" → "ESC ESC [ ^ [ ^"                         短くしても駄目
      "[1027^" → "ESC 2 7 ^ [ 1 0"                         単体の ESC でも発生する
      "\e[~" → "ESC [ ~"                                     これは正しく受信されている
      "\e[^" → "ESC [ ^"                                     これも OK
      "\e[7^" → "ESC ^ [ 7"                                  これは駄目
      "\e[?^" → "ESC ^ [ ?"                                  これも駄目
      "\e[?~" → "ESC ~ [ ?"                                  これも駄目

      取り敢えず ESC を含んで 3 文字以上のシーケンスが何故か化ける様なので、
      3文字 で "ESC [ ^" とする事にした。
      これで受信される物は正しくなったと思われる。

    + BUG 受信しているバイトは正しいが ble-decode-char が正しく処理してくれない。

      動作を見ていると ESC [ ^ を受け取った時点で __esc__ が生成されている。
      そしてその直後に M-[ が出力されている。
      更に次の "[" を受け取った時に再び M-[ が出力される。

      一つの原因は、_ble_decode_key__seq をクリアしない内にコマンドを実行している為、
      コマンドの内部で新しいキーが来た時に _ble_decode_key__seq に追加されて処理されてしまう事である。
      これは、コマンドを実行する前に _ble_decode_key__seq= とする事で解決する。
      基本的にコマンドを実行する時には、ble-decode-key の内部状態を終了状態と同じにしてからにするべきである。
      要するに破壊的操作を全て終えてから、コマンドを実行する、という事。

      ble-decode-key の中の _ble_decode_char__seq についても同様である。
      これを修正した所、どうやらちゃんと期待通りに動くようになった。

  * ble-decode-char [#D0054]
    ESC を meta に翻訳するのは自動にするべき。
    例えば M-あ などまで考慮していたら、全てを登録し尽くす事は無理なので。

  * <bug> ble-decode-key でシーケンス全体の一致に失敗して、 [#D0053]
    部分一致に成功した時、一致部分の直後のキーが失われる。
    これは 一致した場合に ble-decode-key "$fail" を実行せずに関数を抜けていたのが原因である。
    依然 ble-decode-char で起こったのと同様の問題点。
    その時には ble-decode-key には問題がないと判断したが、問題は在ったようだ。
    [完 2013-06-06 16:58:25]

  * <bug> ble-edit-bind: "\e ": set-mark を unbind できていない。 [#D0052]
    [完 2013-06-06 15:26:53]

  * ble-edit-bind: bind -s についても表示できるから、これについても全て unbind する。 [#D0051]
    [完 2013-06-06 15:26:48]

  * <bug> ble-bind -d [#D0050]
    -m isearch 等を用いて登録したキーシーケンスが表示されない。
    現在登録されている kmap 名のリストを追加して、
    ble-bind -d で全ての kmap について表示するように変更した。

2013-06-05

  [Discussion]

  * COMP_KEY [#D0049]
    bash の manual には最後のキーとあるが、
    文字で表現するのか、名前で表現するのか文字コード (?) で表現するのか分からない。
    実際に、適当な関数を登録して確かめてみると良いだろう。

    →試してみた所文字コードが表示された。
      更に function キーに complete を割り当てて試してみた所、
      バイトシーケンスでの最後のバイトが渡される様である。
      (しかし、これでは不便? な気がするので、独自解釈で ble の keycode を用いる事にする。
      その際に C-* 系統の物は変換した方が良いかも知れない。)

  [Done]

  * visible-bell: 鳴った瞬間だけ緑色に点滅する様に変更。 [#D0048]
    これで連続で visible-bell が鳴った時でも見た目に分かる。

    # + 鳴った瞬間だけ赤くして直ぐに暗くする

  * <bug> isearch: self-insert で単に入力しているだけなのにどんどん遡ってしまう。 [#D0047]
    self-insert の時には現在行から一致を初める様に変更する。
    [完 2013-06-05 23:42:37]

  * <bug> quoted-insert, v だとか q が挿入される [#D0046]
    これは self-insert の仕様変更について行ってなかったのが原因。
    代わりに insert-string を使う実装に変更した。
    [完 2013-06-05 19:57:59]

  * clear-screen: vbell の削除トラップをクリアする [#D0045]
    [完　2013-06-05 19:18:02]

  * isearch: arr の top が行き先と同じであれば、arr に push せずに pop する [#D0044]
    [完 2013-06-05 19:03:41]

  * isearch: 表示位置への移動などをもっとまともな物に変更する。 [#D0043]
    [完 2013-06-05 18:47:07]

  * isearch: 終了時に isearch の表示を消す [#D0042]
    [完 2013-06-05 18:47:17]

  * isearch: prev でもうこれ以上戻れない時、isearch から抜けない [#D0041]
    [完 2013-06-05 18:48:15]

  * c2w 二分法: 0-161 の間の文字が怪しい? [#D0040]
    + 初めから範囲にない場合 (0-161) の場合は先に除外するべきだった。
    + l&1 を括弧で囲む必要があった。
    + while の条件は l<u ではなく l+1<u であった。
    [完 2013-06-05 18:27:32]

  * ble-core.sh (.ble-print-visible-bell): .time 削除で date +%s の値が overflow しない様に [#D0039]
      部分文字列を取りだす部分が間違っていた。
    [2013-06-05 16:14:46]

  * ble-core.sh (.ble-print-visible-bell): SC, RC を頻繁に使うので、後で変更しやすいように [#D0038]
    _ble_term_sc, _ble_term_rc 定数に定義。
    [2013-06-05 16:14:46]

  * __defchar__ は制御文字には適用しないように変更 [#D0037]

2013-06-04

  [Done]

  * <bug> どうも履歴の動作が怪しいような気がする。 [#D0036]
    C-p C-n で動くと変な出てき方をする…気がする。
    それに先程実行したはずのコマンドが出てきたり出てこなかったりする。

    →と思ったら history-add で実際に登録される場合だけ
      _ble_edit_history_ind, _ble_edit_history_edit を初期化していた。
      それ以外の場合は、前回の履歴位置・編集内容をそのまま使う事になっていた。
      そうすると例えば、前回履歴を遡って実行したコマンドは空白に変化し、
      また、現在の履歴の位置も途中の場所にいたりと変な事になる。

    [完 2013-06-05 02:50:10]

  * vbell: [#D0035]
    ble.sh をロードした時に、
    古い .time ファイルは全部削除する機能をつける。

  * ble-bind -c: meta も登録する [#D0034]
    → 完了 2013-06-05 02:40:02

  * ble-bind 引数はシェル変数で渡す様にした方が良い? (-f オプションの削除) [#D0033]
    + self-insert は KEYS[0] シェル変数を用いる様に変更した。
    + f オプションの削除

  * ble-bind -c, -k オプションの名前を変更する [#D0032]
    → それぞれ -k, -f に変更した。2013-06-05 02:40:06

  * bug? bind [#D0031]
    何と " を bind する事ができていない。
    と思って改めて試してみたらちゃんと bind されている??
    取り敢えず保留という事にする。

  * <bug> 次のコマンドを実行するまで prompt が更新されない [#D0030]
    CMD ではなく LINENO を参照するように変更

  * abell はロックするので vbell の後に送信するべき [完 2013-06-05 01:25:27] [#D0029]

  * 矢印キーなどの動作を取得する事が出来るかチェック [完 2013-06-05 01:25:41] [#D0028]
    (1) ESC で始まるシーケンスを全て削除する?
        試しに全て削除してみたら、(自分で bind -x で設定した物を除いて、)
        上下左右のキーや function キーも効かなくなった。
        ので、C-[ さえ bind -x してしまえば恐らく処理できると思われる。

        → source されたスクリプトの中で bind -r を実行しても削除されない?
        と思ったら bind の時は必要だった引用符 " が、bind -r の時には不要だった。

    (2) ESC に bind できるか?
        一応 ESC には bind できているみたいだが、delete を押してもそうと認識されない。
        しかも二回に一回だけ通常の文字列として delete が入力される。
        奇数回目の delete は何処へ行っているのか?

        ble-decode-key の受信する key を見てみた所、
        delete を入力した直後には ble-decode-key には delete が来ない。
        その次の文字を入力すると ble-decode-key に delete が渡される。
        その後に続く文字は一文字ずつ分解されて届く様である。

        先ず、問題点として
        a. ~ を受け取った時点で delete に確定している筈なので、
          その時点で delete が届かないのがおかしい
        b. また、delete が受信された後の文字が単体で必ず decode-key に渡ってくるのが問題である。
        c. delete は処理されなかったはずなのに、その事を表すエラーメッセージが表示されない

    + BUG: delete が届かない? [完 2013-06-05 00:00:50]

      と思って実際に初期化が終わった後の cmap を見てみたら
      最後の文字なのに「継続あり」の _ がついている。
      .ble-decode-char.bind を見たら条件が反対になっていた。
      (.ble-decode-key.bind の方は大丈夫かと思ってみたら大丈夫だった、
      .ble-decode-key.bind に合わせる形の方向で修正した。)

      ** デバグの為に一時的にバグ状態に戻してある **
      →他のバグも解決したのでこれはまた修正した。

    + BUG: 曖昧文字の失敗後に、その失敗に関連した文字がすぐに送信されてくる?
      [完 2013-06-05 01:25:41]

      と思って手でエスケープシーケンスを入力したりしてみたが、少し違うようだ。
      delete ESC [ まで入力した段階では delete までしか出力されていない。
      ここまでの動作は正しいが、次に A を入力した時点で、
      ESC [ A がその儘出力されて出て来る。

      本来は ESC [ A は up と翻訳されて欲しい。
      _ble_decode_cmap_* を見てみたがここの部分は問題ない様に見える。
      (a. の方の BUG の事を考えると、本当は ESC [ A だけでは未だ出力されないはず…。
      そして実際に、先行する delete がない状態では ESC [ A を送信してもその時点では何も出力されない。
      従って、cmap の問題ではなく内部状態に何らかの異常が出来ていると考える方が自然である。)

      と思ってみてみた所、delete ESC [ まで入力した段階では、
      実は未だ ESC [ は bash まで届いていない? 様である。
      screen だか或いは途中の何かが文字を止めているという事だろうか。。
      (と、ここで screen に C-TAB = [9;5^ に対する hook をかけているという事を思い出した)。

      そして、ble-decode-char は delete のシーケンスが残っている状態で
      ESC を受け取った時にそれを組み立てずにそのまま出力しているらしい。
      要するに奇数回目の入力と偶数回目の入力で何が違うかというと、
      偶数回目の入力の一番初めの文字 ESC が到着した時には、
      未だ奇数回目のシーケンスが残留しているという事である。

      という所で、怪しい部分を発見したが…その部分は今回と関係ないような気もする。
      しかし取り敢えず、その部分を修正する (余分な return を消す)。すると今度は、
       ble-decode-key に渡される key 自体は何も可笑しい所がないように見えるのに、
      実際に編集文字列に現れてくる文字列には違う入力されている。。
      先にエラーメッセージが表示されない謎を解決した方が早いかも。

      下のバグを解決したらこちらのバグも解決した。先程の修正で良かった様だ。
      今迄 ESC [ A が裸で出力されている様に見えたのは勘違いで、
      1 delete のシーケンスが残っている状態で ESC が来ると、
        delete だけ出力されて ESC は出力されずに終わる (一つ目のバグ)。
      2 delete のシーケンスが化けて (二つ目のバグ)
        (1) で出力し損ねた ESC になって、self-insert で入力される。
      という流れになっていたのだった。つまり
        ESC [ A ESC [ A
        ~~~~~~~~~~~
        delete      [ A
        ~~~~~~
        ESC         [ A
      と言う風に変換されていたのだった。


      因みに .ble-decode-key.emit の方には同様のバグがないかと確認してみたが、
      その様なバグはなかった。ちゃんと余分な return は消されていた…。

    + BUG: 知らないシーケンスが届いた筈なのにエラーメッセージが表示されない。
      [完 2013-06-05 01:13:43]

      と見てみたら、すぐに気付いた。「知らないシーケンスが届いた時に "$key" 単体を
      文字と解釈できる場合には __defchar__ で処理する」という所で $key の代わりに $fail と
      書いていた。そしてこの $fail は呼出元の ble-decode-char の $fail を参照して、
      出力していない筈の文字を出力してしまうという事になっていた。

      これで解決できたと思ったら、今度は up が変な文字として入力されてしまう様になった。
      これは __defchar__ で処理するのは unicode の16面までという制限をかければ良い。
      0x110000 という定数が何回か出てきたので ble_decode_function_key_base という定数として定義し直した。
      これを用いて文字として解釈できる unicode の範囲を絞って扱う事にした。

  * <bug> history add したコマンドの \ が消えている。 [#D0027]
    [完 2013-06-04 23:26:03]

    どうやら読み込む時に read が勝手に \ を消しているようだ。
    read に勝手に \ を解釈されたくなければ read -r とする。
    登録・書込の方には問題はないようだ。

    他にも read を使っている所があるのでそれについても修正をする必要がある。

  * <bug> .ble-edit.construct-prompt: \w でホームディレクトリ以下のパスが  ~// となる。 [#D0026]
    [完 2013-06-04 23:05:35]

    ~ に続きがある場合に / を追加する様に書いていたが、
    良く考えたら ~ に続きがある場合には / がどうせ先頭になっているので必要なかった。

  * <bug> HISTIGNORE の値に反して一文字のコマンドが history に追加されている [#D0025]
    [完 2013-06-04 22:50:16]

    単に配列変数の名前を間違えていただけだった。

  * <bug> (.ble-edit.construct-prompt): \! (HISTCMD) が常に 1 [#D0024]
    これは bind -x で登録された関数から見るとこうなってしまうという事なのだろうか。
    代わりに _ble_edit_history の要素数を返せば問題はないだろう。
    [完 2013-06-04 22:43:49]

  * <bug> ble-decode-byte を直接呼び出すと PS1 の値が破壊される [#D0023]
    [完 2013-06-04 22:32:33]

    PS1 が解除された状態で ble-decode-byte が呼び出され…?
    調べてみた所、ble-decode-byte の中で PS1 を代入していた。

    良く考えてみたら、再描画や adjust-cursor 等の呼出は、
    直接コマンドを叩いて呼び出した時には必要のない物である。
    なので、bind -x する時専用の ble-decode-byte を作って、
    その中で PS1 の設定や再描画、カーソル位置微調整を行えば良い。
    →その様に変更した。

  * suspend した時にどうなるか? [#D0022]

    特に問題が生じるという訳でもない様だ?
    但し、以下の点については意識する必要がある。

    (1) stty の設定がどうなっているか
        [完 2013-06-04 20:34:42]

        <del>恐らく stty を復元したままになっている。
        従って ^W ^U 等の操作を行う事ができないと思う。</del>

        <del>直後に直すのは諦めるとしても、
        次に ^W ^U など以外の文字が入力された時に、
        stty の状態を確認して元に戻すという事はするべきである。</del>

        と思っていたらどうやら suspend で止まった場合でも、
        スクリプトの続きから開始される様である。
        つまり、accept-line の後半部分も suspend の直後に実行される。
        なので何の問題も生じない。

    (2) コマンド履歴に suspend したプロセスが追加されていない。
        [完 2013-06-04 19:54:07]

        コマンド履歴に追加される前にコマンドが実行されている。
        これは登録を先に行うように変更するだけでよい。

        (但し bash ではコマンド見付からなかった場合には、
        コマンド履歴に追加されないようになっている。
        コマンドを実行に移す前に予め、
        そのコマンドが存在するかどうかぐらいは判定しても良さそう。)

    (3) 編集中のコマンドが残っている [完 2013-06-04 20:36:18]

        これも編集文字列をクリアする前にコマンドを実行しているからである。
        コマンドを実行に移す前に編集文字列をクリアする事にする。

  * ちらつきを抑える方法: 最初に再描画 [完 2013-06-04 18:32:52] [#D0021]
    ble-decode-byte に入った瞬間に .ble-decode-key.redraw を実施する?
    その時は、前回から内容が変わっていない筈なので、前回保存した情報をそのまま出力すれば良い。
    そして呼出が終わった後に変更があればその時点で再描画をまた実行する。

    + BUG: prompt の表示が省略されている [完]

      → 前回保存した内容が prompt 表示を省略する物だった為
      → prompt 表示の省略をしない物をキャッシュに入れておく事にした。

      関数 redraw-cached は「フル」で表示し直すが内容は「前回」のまま、という関数である。
      ので、表示の省略などは行わないので、この方法で良い。

    + BUG: 前回の残像が残っている [完]

      redraw をする際に前回表示した内容を消していないので残ってしまう。
      これは .ble-edit-draw.redraw, .ble-edit-draw.update でも同様に起こりうる問題である。
      (今迄は bash が1行目を勝手に消していたので気付かなかっただけである。)

    + BUG: 表示が滅茶苦茶になる

      原因は色々あった。
      事。
      "前回の表示内容" に関しては保存していたが、
      その内容を出力した際に現在のカーソルが何処に移動するかといった情報を保存・復元するのを忘れていた。
      唯単に前回の表示内容を出力しただけだと、内部的にカーソル位置が先頭から動いていない事になっている。
      なので、ちゃんと "前回の表示内容" を保存すると共に、その内容を表示した時にカーソルが何処へ移動するか等の情報も保存するように変更した。

    何とか、前回の表示内容を再度出力する物が完成したので、昔のコードは削除する。
    | function ble-decode-byte {
    |-  # bash によって描画された物が全部消されている
    |-  # .ble-edit-draw.set-dirty -1
    |+  .ble-edit-draw.redraw-cache

    これでちらつきはかなり改善された。

    しかし、ちらつきが全くないと迄は言えない。もし気になる様だったら

  * bug unkbd [2013-06-04 17:59:04] [#D0020]

    配列への追加で、添字に ${#kbd[@]} とするべき所 ${kbd[@]} としていた。

  * LINENO が更新されない? [#D0019]
    →これは一回 unset LINENO してから自分で設定すればよい。

    どうせ自分で LINENO は管理しなければならないのでこの方法でよい。

2013-06-04

  * X6 stty 関連 (tty が制御文字を奪うという事) [2013-06-04 13:33:26] [#D0018]

    * tty の設定で動かなくなるキーと tty で設定されていても動くキーがある。
      よく分からないので表にする事にする。

      ^S ^Q
        →stty で外すか -ixon の設定にすれば OK
          基本的に -ixon の設定で行く方針。常にこの状態という事にする。

      ^C
        →bind する時は stty intr "" でも問題ない。
          然し、実際に使う時には stty intr undef でないと読み取れない。
      ^Z
        →^C と同様 bind 時はどちらでも問題ない。
          実際に読み取りの時は stty susp undef でないと駄目。
      ^\ (quit) も ^C や ^Z と同様である。

      ^V
        →bind する前に stty lnext undef する必要がある。
          bind した後も stty lnext undef の儘保持しておく必要がある。

      ^U (kill) ^W (werase) も ^V と同じである

      ^?
        →bind する間だけ stty erase undef し、
          <del>その後で stty erase "" などと復元すれば良い?</del>
          と思ったが何故か stty erase undef でなくても動いたり、
          stty erase undef でないと動かなかったりよく分からない。
          取り敢えず ^V の時と同じようにずっと erase undef の儘にしておく事にする。


      <a href="http://lists.gnu.org/archive/html/bug-bash/2004-08/msg00157.html">'bind "\C-?": delete-char' does not work any more</a>

      ※文字列編集中だけ外されている stty 項目がある可能性?

      #              | key    bind  read
      # -------------+-------------------
      # -ixon        | ^S ^Q
      # kill undef   | ^U     必要  必要
      # lnext undef  | ^V     必要  必要
      # werase undef | ^W     必要  必要
      # erase undef  | ^?     必要  必要
      # intr undef   | ^C     不要  必要
      # susp undef   | ^Z     不要  必要
      # susp undef   | ^\     不要  必要
      # -------------+-------------------

    * ^? が偶に bind 出来ないように見える問題

      どうやら一回目に stty を解除して bind に挑戦すると失敗している様で、
      二回目に bind に挑戦すると成功している様だ?
      再度 stty の設定を元の状態に戻して ble.sh を設定してみたら、
      ^? ^U ^V ^W の四つについて bash の bind が機能していないという事が分かった。

      改めて bind -x '"":ble-decode-byte 127' を手で入力してみた所使える様になる。
      やはり stty を設定した直後には bind を設定する事が出来ないという事だろうか。

      色々試してみる
      (1) stty の後に適当に echo するとどうなるか?
          →適当に echo するだけでは駄目なようだ。

      (2) stty の後に sleep で待ってから設定するとどうなるか?
          →sleep で待っても駄目なようだ。

      (3) stty の後に >/dev/null で適当な文字列を書き込むとどうなるか?
          →やはり駄目。

      (4) read -n 1 で適当に文字を読み取るとどうなるか?
          →これでも駄目だった。

      (5) subshell ( date ) を呼び出す
          →駄目

      もしかして source ble.sh で一つのコマンドとして実行しているから設定が有効になっていないという事だろうか?
      後、一回 exit してから入るとうまく行くのは、C-d で exit する直前に .ble-stty.leave していなかったからであった。
      或いは bashrc 等のスクリプトから実行するとうまく行くのかも知れない。

      仕方がないので現状では .ble-decode-byte:bind で、
      既に ^U ^V ^W ^? に bind しているかどうか確認して、
      設定されていない様だったら設定を行う様にする事にした。

    * C-@: 効かないと思っていたら bind できていない [完]

      bind -x '" ":ble-decode-byte 0'
      →確かにこれでは bind できない
        bind は '"' という文字列を受け取ったと勘違いする。

      bind -x '"\C-@":ble-decode-byte 0'
      →これで正しく bind 出来るようになった。

    * 全ての文字を入力可能かどうか確認

      C-@ OK (bind する時に直接 ^@ の文字を引数に指定できない事に注意)
      C-a OK
      C-b OK
      C-c OK (stty intr undef)
      C-d OK (READLINE_LINE にダミー文字を設定。可成り苦労した…)
      C-e OK
      C-f OK
      C-g OK
      C-h OK
      C-i OK
      C-j OK
      C-m OK (stty の改行変換周りで状況が違うかも?)
      C-n OK
      C-o OK
      C-p OK
      C-q OK (stty -ixon)
      C-r OK
      C-s OK (stty -ixon)
      C-t OK
      C-u OK (stty kill undef)
      C-v OK (stty lnext undef)
      C-w OK (stty werase undef)
      C-x OK (二文字の組合せで bind すれば良い)
        * 直接 bind すると C-x に続けて何かの文字を打った瞬間に
          bash が segmentation fault する
        * C-x ? (? = \0 - \377) の組合せで全て登録しておけばよい。
          (恐らく C-x は C-x とそれに続く何らかの文字の組合せでしか使われないだろう。
          その場合にはこれで問題はない。)

      C-y OK
      C-z OK (stty susp undef)

      C-[ OK
        * 単独の C-[ は通常通りに bind するだけで OK。
        * C-[ C-[ の並びは何故か受信できないので、
          bind '"":"[27^[27^"' 等として、
          一旦別のシーケンスに翻訳してから受信する必要がある。

      C-\ OK (stty quit undef)
      C-] OK
      C-_ OK
      C-^ OK (.bashrc で設定しているのを解除する必要はある)
      C-? OK (stty erase undef)

2013-06-04

  * X5 C-x に bind -x すると死ぬ [2013-06-04 09:42:42] [#D0017]

    * 先ず第一に、C-x に対して bind しても、
      単体の C-x に対して bind で指定したコマンドは呼ばれない。
      (bind -r で予め元々登録されていた関数を全て削除しても同様である。)

    * 更に続けて何らかの入力をした場合、
      その sequence が bash bind で何も割り当てられていなかった場合、
      bash が segmentation fault で落ちる。

    * C-x は単体では割り当てられず、
      必ず C-x hoge の形で入ってくるとするならば、
      C-x ではなく C-x ? に対して bind をすれば良い。

2013-06-03


  * X4 history にアクセスする方法 [2013-06-03 08:19:09] [#D0016]

    * history -s で値を設定する事が出来る。

      但し、これは最新の履歴を置き換える形でしか追加する事が出来ない?
      と思ったが、最新の history -s コマンドを置き換えるだけであって、
      昔の履歴を削除する訳ではない様だ (多分)
      →実際に試してみた所期待通りに動いている様なので良しとする。

    * また history -s は HISTIGNORE に該当する物に関しては削除するようだ。
      なので HISTIGNORE などについての特別な配慮は要らず、
      とにかくコマンドを history -s で追加すればよい。

    * 次に isearch で history コマンドを検索する時にどの様にするのが良いのかという事。
      history | grep だと結構処理に時間が掛かりそう
      といって history の内容を何処かの配列に出してくるのも大変な気がする

    * また history 中のコマンドに改行が含まれていた場合、
      検索などの結果が乱れてしまう事になる。

    * 何故か、プロセス置換の中で history を呼び出すと HISTTIMEFORMAT= が有効にならない。
      cat < (HISTTIMEFORMAT=A history)  # 効かない
      cat < (HISTTIMEFORMAT=A; history) # 効く

2013-06-02

  [Done]

  * source 直後の prompt は PS1 をそのままに。 [#D0015]
    未だ一度も呼ばれていないのでそもそも自前でプロンプトを表示していない。
    →分かりにくいのでやめた。
      ble.sh の最後に、自分自身で明示的にプロンプト描画関数を呼び出す事にした。

  * quoted-insert C-@ の扱いについて [#D0014]
    →bash でも元から入力できない様なので気にしない
      self-insert で文字コード 0 を渡された場合には無視

  * 取り敢えず実装する物: [#D0013]
    現在の編集行を表示する機能?
    →これは暫定的に唯 print するだけの物でよい。

  * ble-decode-key, ble-bind: [#D0012]
    コマンドが設定されていない時の既定のコマンドを指定できる様にして、

    其処に self-insert を割り当てていたが、この様にしておくと、
    self-insert で変な文字が入力されてしまう
    (一応 self-insert 中で flag は外す様にしているが)。
    更に、どんなに変な操作をしてもエラーメッセージが表示されない。

    本来コマンドが設定されていないとしても flag の付いていない "文字" だけを
    self-insert で処理するべきである。従って、"文字" に対してだけ既定のコマンドを
    適用するように変更する。これは "文字" だけの既定動作なので変数名としても
    __default とするのは気分が悪い。其処で新しく __defchar__ という名前の keyname/keycode
    を定義し、そのキーに対してコマンドが定義されている場合に、"文字" をそのコマンドで処理するように変更した。

    また、空文字列の bind 呼出で __default に値を設定できる機能は削除した。
    <del>空文字列を指定した場合は、既定の動作を指定する。</del>

  * ble-decode-key: [#D0011]
    と思ったが、isearch-map 等を定義する時には、bind されていない key を指定した場合には、
    通常のモードに復帰してそのモードでの操作を実行したいから default の機能は使用したい。
    また、前の様な実装に戻す事も出来たが折角 __defchar__ を定義したので、
    それと同じ方式にした方が良いだろう。と言う事で __default__ というキーを定義する事にした。

2013-06-01

  * 現在の実装状況 [#D0010]

    ble-getopt
      取り敢えず枠組は完成している。
      後で拡張を行う余地はある。

    ble-decode
      ble-decode-byte
      ble-decode-char
      ble-decode-key

      ble-decode-bind
      ble-decode-kbd
      ble-decode-unkbd

    ble-text 文字幅
      例えば → 8594 が曖昧幅の文字である。
      設定の名称をどの様にするか
        narrow/wide/emacs
        west/east/emacs

  [Done]
  * ble-decode: ble-decode-* 関数の実装 [#D0009]
  * ble-getopt.sh: 短形式オプション引数 (':' 区切) で、'::' の様に、 [#D0008]
    区切が連続する場合に、正しく空引数として認識するように変更。
  * mwg.text.getCharFromCode, mwg.text.getCharCodeAt: [#D0007]
    それぞれ .ble-text.c2s, .ble-text.s2c に名称変更。
  * .ble-text.c2s: [#D0006]
    0x100 以上の文字コードを指定した場合に変な文字に変換されるバグを修正。
  * .ble-text.c2s: [#D0005]
    一度文字コードを取得した文字についてキャッシュする様に変更。

  * X3 末端に改行を置かずに終了したコマンドの扱い [#D0004]

    * その様なコマンドがあるとプロンプトの表示が乱れる原因である。
    * 右に或る回数だけ進んで其処で空白を出力してから行頭に復帰すれば良い?
      元々1桁目にいた場合にはぎりぎり改行をせずに済み、
      2桁目以降にいた場合には改行してしまうように調整をすれば良い。
      右に行くには ESC [ 桁数 C を出力すれば良い。

    * 適当にやってみたが色々やってもうまく行かない。ちゃんと端末の動作を考えるべき。

    * 先ずは xenl の場合。
      幾ら右に行っても一文字出力する分の余裕は必ず残る。
      従って右端に行ってから 2 文字は出力しないと行けない。

      例えば (1) COLS-2 だけ右に進んでから (2) 2 文字出力して、(3) それから復帰する。

      この様にすると
      何も出力していない場合   |   何か出力している場合
  　　(0) [_              ]    |   (0) [a_             ]
          [               ]    |       [               ]
      (1) [------------>_ ]    |   (1) [a------------>_]
          [               ]    |       [               ]
      (2) [             xx_    |   (2) [a             x]
          [               ]    |       [x_             ]
      (3) [_<-------------]    |   (3) [a             x]
          [               ]    |       [_<             ]

      xenl でない端末の場合は COLS-3 に変えれば良いだけか?
      (1) COLS-3 だけ右に進んでから (2) 2 文字出力して、(3) それから復帰する。

      何も出力していない場合   |   何か出力している場合
  　　(0) [_              ]    |   (0) [a_             ]
          [               ]    |       [               ]
      (1) [----------->_  ]    |   (1) [a----------->_ ]
          [               ]    |       [               ]
      (2) [            xx_]    |   (2) [a            xx]
          [               ]    |       [_              ]
      (3) [_<------------ ]    |   (3) [a            xx]
          [               ]    |       [_              ]

      多分これで OK。


  * X2 C-v に bind できない? [#D0003]

    * どうやら stty が C-v を食う設定になっていてこの設定が有効になっている間は、
      bind で C-v に割り当てをしたり C-v に対する割り当てを削除したりと言った操作ができない様だ。
      stty lnext undef で C-v に対する割り当てを削除した上で C-v に対して bind を行えばよい。
      (stty が食う所までは理解できるが、stty の設定によって bind すら出来なくなるのは何故か?)

    * 但し、その後で stty lnext $'\26' などとして設定を元に戻すと、
      やはり C-v は stty に食われて bash にシグナルとして伝達する。
      問題が生じなければ stty lnext undef で放置という事で良い気がする。

      然し C-z に bind 擦る為に結局 stty susp undef をして、
      コマンド実行直前に復元して、コマンド実行後にまた undef するという事をしたくなりそうだから、
      その際には lnext も復元させる事にすればよい。

    * 何故かスクリプトで stty lnext undef の直後に
      bind -x '"":ble-decode-byte 22' を実行すると、
      self-insert が割り当てられてしまう。
      bind -x の文と stty lnext の文を別の関数に配置したらこの様な事は起きなくなったが、謎。

  * X1 [#D0002]

    C-d を受け取る為には READLINE_LINE に何か設定する必要がある。
     するとオリジナルのプロンプトが表示されるがこれをどの様に殺すか?

    [振舞]
    + READLINE_LINE が空の状態だと C-d を受け取れない。
      受け取る前にログアウトしてしまう。
      (man bash には EOF への翻訳は delete-char で行われる様に書かれているが、
      それとは別に C-d を bash が受け取った段階でチェックされ、
      条件に適合すればログアウトしてしまう)
    + READLINE_POINT が READLINE_LINE 末端を指している時は、
      プロンプトを表示し終わった直後に位置の移動は行わない。
      表示後のカーソル位置は、書き込んだ最後の場所になる。
    + READLINE_POINT が READLINE_LINE 先頭を指している場合は、
      bash が其処にカーソルがあるべきと考えている位置にカーソルが移動してしまう。
      (プロンプトの幅?)
    + 制御文字を EADLINE_LINE に代入しても、表示される時には ^A 等の表示に翻訳される。
      従って、通常の文字を代入しておくのが無難である。
    + 試しに READLINE_LINE=$'\0' として READLINE_LINE='1' として見たが、
      これはどうやら READLINE_LINE は空文字列であると解釈されて、
      C-d は即座にログアウトと解釈されてしまうので駄目である。

    [目的]
    + C-d を読む為に READLINE_LINE の内容は何でも良いから 1 文字以上必要
    + プロンプトを表示し終わった時の位置を制御したい

    [対策]
    + PS1 は空欄にする
    + カーソル位置 x が 2 桁目以降にある場合は、
      x-1 桁目に移動して READLINE_LINE には x-1 桁目の文字を入れる。
      READLINE_POINT には 1 (正確には x-1 桁目の文字のバイト数) を代入しておけば良い。
      また SGR で予め x-1 桁目の文字のスタイルを吐き出しておく。
    + カーソル位置 x が 1 桁目にある場合は、
      READLINE_LINE には 1 桁目の文字を入れておく。
      READLINE_POINT には 0 を入れておく。
      また SGR で予め 1 桁目の文字のスタイルを吐き出しておく。
    + 全角文字などに対する対策も必要

    + これを正しく実装する為には、取り敢えず現在のカーソル位置を把握している必要がある。
      またカーソルの左側に位置している文字と、その幅を記録しておく必要もある。
      (幅を記録する必要はあるのか→ない気がする。)

    *rule*

    + lc はカーソルの左側に位置する文字の文字コードを表す。
      常に graphical な文字であり、bash によって直接表示される。
      x=0 の場合には lc に入っている文字コードの値は未定義であり、使用してはならない。
    　(つまり x, lc を設定する側では x=0 の時は lc の中身は気にしなくて良い。)。


    関数 x y lc ; .ble-cursor-move.text text ; x y lc

      .ble-cursor-move.text は指定した文字を現在位置 x y に書き込んだ時に、
      カーソルがどの様に移動するかを計算する。この時 lc の値も一緒に計算する。

      ** 注意点 **
      text に BS や VT が含まれる場合、lc を適切に計算する事が出来ない。
      BS, VT が含まれる場合、その直前の文字 (BS で消した文字の直前の文字、及び、VT で移動した先の左側にある文字)
      を今迄の出力から知る事は出来ない。この様な場合は暫定的に lc=32 (空白文字) を設定する。
      (この関数は prompt の幅を計算する為にある。PS1 に BS や VT などの制御文字を \[ \] で
      囲まずに設定する事は考えにくいので、現状ではこれについて対策する予定はない。)


    関数 .ble-cursor.construct-prompt ; ret=(x y lc ps1esc)

      プロンプト文字列を実体化し ps1esc とする。
      更に、プロンプトを端末の左端から表示し始めた時の、最後のカーソルの位置 x y を計算する。
      また、lc にはカーソルの位置の左側にある文字の文字コードを返す。

      ** 注意点 **
      エスケープシーケンスなど実際に prompt の位置に文字として表示されない物は、必ず \[ ... \] で囲む事。
      \[ \] で囲んだ中でカーソルの移動などを行うとカーソル位置を正しく計算できない可能性がある。
      \[ \] で囲んだ中でカーソルを移動させたとしても、また元の位置に戻す事が望ましい。


    関数 _ble_cursor_x _ble_cursor_lc ; .ble-edit.adjust-cursor

      ble-decode-byte の最後にこの関数を呼び出して、READLINE_LINE, READLINE_POINT
      の調整を実行する事にした。ちゃんと実装した物が完成したので、
      暫定的に書いた調整コードは削除 (以下)

      # # 何か入力されていないと C-d で exit してしまう。
      # # これは delete-char で判定するのではなく、
      # # あらゆる関数を呼び出す前にチェックされる様だ。
      # # また、READLINE_POINT が文字列末端に設定されていれば OK

      # [暫定v1]
      # READLINE_LINE="${_ble_edit_str:_ble_edit_str_ind:1}"
      # test -z "$READLINE_LINE" && READLINE_LINE=' '
      # READLINE_POINT=1

      # [暫定v2]
      # echo -n "[D"
      # if ((_ble_edit_ind>0)); then
      #   READLINE_LINE="${_ble_edit_str:_ble_edit_ind-1:1}"
      # else
      #   READLINE_LINE='_'
      # fi
      # READLINE_POINT=1

2013-05-29 highlight.sh

  * bash で highlight? [#D0001]

    一応、bind -x で通常文字に対して適当な関数を割り当てれば
    入力に対して hook をする事は可能なようである。
    但し、関数の呼出が終わった後に入力行が再度描画されるので、
    折角色を付けて出力したとしても上から塗り潰される事になる。

    後 bind -x のもう一つの問題として、
    複数行に亙る行を編集している時に bind -x の関数を呼び出すと、
    処理が終わった後に再描画される訳だが、
    その時の再描画で表示している行の位置が下にずれる。
    これは bind -x の関数で何の操作もしていなくても同様である。
    これを正しく処理する為には、

    (1) 現在の端末の幅を取得する
    (2) 文字列の表示上の長さを取得する
    (3) prompt の長さを取得する。

    などの機能を正しく実装する必要がある。
    (1) は shopt -s chkwinsize でもすれば取り敢えずできる。
    (3) は (2) さえ正確に記述でき、現在のカーソル位置が分かれば現在の位置から逆算できる。
    逆に言えば、(2) と (3) さえ正確に計算できれば現在のカーソル位置も端末に問い合わせることなく分かるという事でもある。

    + 現在のカーソルの位置を取得する関数は書けた。一応動いている。
      但し CSI 6 n (DSR CPR) に対応している端末でないと動かない。

    * 現在位置を予測するという事

      文字列の表示上の長さを計算するには、
      <del>文字列の文字コードを utf-8 と仮定すれば編集文字列を走査して、</del>
      文字コード列を生成し、更に其処から文字幅に変換して、
      加算するという事をすれば良い。

      と思ったが…実際には改行やら TAB やらがあるので、
      現在の正確な位置が分からないと文字列の表示上の長さなどの情報を取得する事は出来ない。
      やはり何とかして端末が表示される長さを算出する必要があるだろうか。
      端末が表示される長さを取得する方法:

      A READLINE_LINE が空だった時の位置を記録しておく?
        + 漢字や平仮名で始まるコマンドを入力した場合に対処できない。しかしそんなコマンドは存在するだろうか。
        + 前のコマンドの出力が改行で終わらなかった場合にどうなるか?
          →1 文字でも入力すれば再描画されてプロンプトは行頭に出て来る。
            0 文字の時に取得した位置はその時にしか信用できないので、1 文字の時に取得した文字の方が良い?
        + <strong>×</strong> プロンプトは複数行に跨らないという仮定をしないとできない。
          然し、人によってはプロンプトを複数行に分けるという人もいる (cygwin の人みたいに)。

      B 自分で PS1 を解析して長さを計算する?
        + <strong>△</strong> 実装が大変。エスケープシーケンスの類にも対応しなければならない。
        + (\a \n \r \ooo はCと同じ意味, \x \f \b はそのまま出力, \v \t \u は別の意味, \e は ESC)
