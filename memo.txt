# -*- coding:utf-8 -*-

設定項目

: ${ble_opt_input_encoding:=UTF-8}
: ${ble_opt_vbell_default_message=' Wuff, Wuff!! '}
: ${ble_opt_vbell_duration=2000}
: ${ble_opt_error_char_abell=}
: ${ble_opt_error_char_vbell=1}
: ${ble_opt_error_char_discard=}
: ${ble_opt_error_kseq_abell=1}
: ${ble_opt_error_kseq_vbell=1}
: ${ble_opt_error_kseq_discard=1}



*******************************************************************************
    ToDo
-------------------------------------------------------------------------------

2015-02-09

  * 既に bind -x してある物を削除するという事?
    bash-4.3 では bind -X が実装されたので bind -x した物を列挙できる。
    (但し、bind -r しても bind -X のリストには残ってしまう様だ @bash-4.3.33
    リストには残っているが実際には削除されている。)

  * 現在のボトルネックは圧倒的に history である
    →.ble-edit.history-load を多少最適化した。読み取り時間が約半分になった。
      それでも未だ全体の半分が history 読み取りである
      (しかし history を 16k も溜めている場合は少ないから、実際は無視できるかも)。

2013-06-13

  * 制限: bash-3 では C-d を捕捉する事が出来ない。

  [Done]

2013-06-12

  * ble-decode-byte:bind の先頭でプロンプトを再描画する必要がある version の境を調べる。

  * <bug> ps1, \D{format} に対応していない。

  * <bug> ウィンドウサイズを変更するとプロンプトが bash の表示する物になる
    これはウィンドウサイズを変更した時に bash が自動的にプロンプトを再描画する為。
    SIGWINCH を trap して自前で描画し直せばよい?

    2015-02-09 bash-4.3 で試したが問題が再現しない。

  [Done]

2013-06-10, X7 解析器

  # bash script の解析器を作る。
  # これは syntax-highlight, complete 等から用いる。

  先ず、シェルスクリプトの文法について整理する。

  !   履歴展開
      ! に非空白の文字列が続いている時
  "   二重引用符の開始
  '   単引用符の開始
  `   コマンド
  $'  引用符の開始
  ${  パラメータ展開 {} の開始
  $(  コマンド置換
  $(( 算術式置換
  $他 パラメータ展開

  コマンド修飾 (コマンドよりも前に来る事ができる物)
    [0-9]*(>|>>|&>|&>>|<|<>)(&[0-9]+|arg)
    [<>]( プロセス置換開始

  コマンド
    ((  算術式の開始
    [[  条件式の開始
    {   重文開始
    (   サブシェル開始
    aaa=hoge
    aaa[]=hoge
    aaa=(hoge)
      コマンドが続く
    time
    time -p
      コマンドが続く

  ; & | && || |&
    コマンドが続く

  ;; ;& ;;&
    case パターンが続く


2013-06-10

  * ble-bind キーボードマクロの定義に対応
    + DEL を BS にマップする
    + C-_ を C-BS にマップする
    + C-m を RET にマップする
    + C-i を TAB にマップする
    + M-大文字 を M-S-小文字 にマップする? → これは CapsLock に依存するので止めておく
    + DEL の bind している物を BS から bind する。
    + C-_ の bind している物を C-BS から bind する。

  * sword で quote を正しく処理する?
    
    これは少なくとも解析器が出来た後に考える。

  * <lbug> complete: ~ で始まるパス名の場合、
    ディレクトリ名の末端に / を追加したり、
    ファイル名の末端に SP を追加したりする機能が機能しない。
    これは test -e "$hoge" としてファイル名がどうかを判定している時に、
    hoge の中に含まれている ~ が展開されない為である。
    同様に ~user で始まる形式のパスについても期待通りに働かない。

  [Done]

2013-06-09

  * split, 書きかけたけれど結局使っていない関数
    function .ble-text.split {
      local GLOBIGNORE='*'
      test -n "${3+set}" && local IFS="$3"
      eval "$1=(\$2)"
    }

  * ble-decode-char: cmap+default.sh を統合する?

    改めてコードを見てみたが、それ程サイズが大きい訳でもないので、
    ble.sh の中に埋め込んでしまっても良いかも知れない。
    しかし、ユーザにカスタマイズの余地を残す、という意味では別のファイルになっていた方が親切である。

  * ble-decode-char:

    これをユーザの側で生成するのには時間が掛かるので、
    予め作成しておいた dump ファイルも一緒に配布するのが良い。

    連想配列を使う版と使わない版の二種類だけで良い。
    と思ったが、連想配列を使うか使わないかが影響を受けるのは、
    cmap の側と言うよりは keyname の方なので、元々巨大ではない。
    keyname の部分だけは ble.sh に統合してしまうと言う手もある。

    *.dump についても統合してしまうという手もあるが、
    これについては中身が巨大なので余り統合する気にはなれない。
    (でも、最終的には統合した方が綺麗かも知れない。)

    もしも統合しないのだとしたら、何れにしても複数ファイルになってしまう訳だから、
    cmap+default.sh を ble.sh 内部に統合する意味も余り無い…。
    というか、dump を一緒に配布する場合、
    そもそも cmap+default.sh を実行する事はない筈である。

  * <bug> キャレットが編集文字列の先頭にある場合、prompt の最後の文字の SGR が反映されない。

    これに対応する為には prompt の指定から SGR を抽出するしかない。
    普通は prompt の最後の文字は空白にする (本当か?) ので気にしなくても良い気もするが。

    これを真面目に実装するには二通りの方向性が考えられる。

    一つは zsh の様に PS1 の色・スタイルの指定を %[] の中でやって貰うという方法である。
    これならば TERM に依存せずに解析できるので良い。但し、これは bash に非互換なので、
    bash から何も設定を変えずに移る、という事ができなくなる。また、% の指定に対応し始めると、
    その他の zsh の指定についても対応しないと収まりが悪い。全て実装しようと重うと大変である。

    もう一つは PS1 を頑張って解析して、ESC [ ... m から SGR の指定を取り出す方法である。
    現実的には ESC [ m 以外で SGR を解釈する端末が存在するとは思えないから、
    これでも良い気がする。

2013-06-08

  * <bug> source を実行している間に C-c をして中断しようとするとその儘動きが止まる。
    通常のループなどで時間が掛かっている場合に C-c で止まる様にするには
    trap return INT 等とすれば良かったが、source の内部で時間が掛かっている場合には、
    C-c で止めようとするとそのまま全体の動きが止まってしまう様である。

    序でに関数内のループで時間が掛かっている場合に関しても調べてみたが、
    こちらは C-c で正常に中断する事が出来るようである。

    + 2013-06-11 12:29:07
      改めて試してみたら、ちゃんと停止はする様である。
      accept-line.exec でループ構文を使わずに再帰に書き換えたがその事が影響を与えたかも知れない?
      或いは、これは前に試した時の勘違い?

      しかしながらまた例によって .ble-stty.enter が実行されていない様である。
      何故か分からないが処理の流れ的には正しくできている気がする。
      しかし、処理の順番が入れ替わっている気がする。
      exec.recursive から先に出力されるべき物が、プロンプトの表示よりも後になっている。
      後で再度調べ直す必要がある?

2013-06-06

  * <bug> PS1 に $() などが含まれているとプロンプト位置を正確に計算する事が出来ない。
    _ps1txt の方を eval してから再度位置の計算をする?

    例えば \[ ... \] を [ - ] などに変換して出力し、
    その後で [ ... ] を除いた物を用いて位置の計算をする?

  * complete: 入力する側から候補を表示?
  * complete: complete -F に対する対応
  * complete: 空白文字や " や ' などをエスケープしている時も正しく単語分割する
  * complete: コマンド先頭位置の検出 (複合文の途中からコマンドが始まっている場合など)
  * complete: 候補一覧の整列

  * ble-line-info の描画のタイミングを ble-edit-draw.update と同じ時にする?
    それ以外の時に描画したければ、必要に応じてその場で明示的に描画させる。

  * overwrite mode
    + 開始時は insert
    + self-insert, delete-backward-char で対応するだけで OK
    + 現在のカーソル位置を反転して表示する

  [Done]

2013-06-05

  * bashfc
  * RPS1

  * ^U ^V ^W ^? bind 関連
    + 説明書にその事を書いておく。
    + ^U ^V ^W ^? を bind するより良い方法があれば考える
    + bashrc の中でも同様に問題が起こるのか?

    + 一旦 bind '"":"hogehoge"' 等として変換したら受信できる可能性?

2013-06-04

  * vbell .time の置き場所を変更?

  * 説明書:
    + 問題点: 既存の bind を上書きする事
    + 問題点: 既存の trap を上書きする事
    →これらは説明書にその様に書いておけば問題ない

2013-06-02

  * ble-edit+discard-line: 灰色にする

2013-06-01 以前

  * vbell
    + スタイルを指定できる様にする
    + 位置を指定できる様にする
    + メッセージが長い場合に適度に長さを制限する

  * ble-decode
    + [kbd] terminfo からの読み取り (entry 名は tmux が参考になる)
    + ble-bind: -x オプションに対する対応: BLE_LINE, BLE_POINT, 再描画
    * ble-bind: -s オプションで文字入力の羅列を指定できる様にする。
    
  * 編集文字列の表示
    + スタイル指定文字列
    + color fall backs
    + forward-char
    + goto-char
    + insert-string
    + insert-char

  * デフォルトで bind されている readline 関数の一覧をチェック
  compgen, history コマンドを関数内から自由にから利用する事が出来るか

  * 説明書
    + 文字コード decoder の追加方法
    + keysequence を指定する文字列の文法
    + スタイルを指定する文字列の文法

  * 問題点
    + コマンドが完結していない状態で accept-line すると
      既定の動作では続きを入力する事が出来るが、
      eval をすると単にエラーになってしまう。

      →これは寧ろこの様な動作の方が分かりやすいかも知れない。
        取り敢えずそういう仕様と言う事にする。


*******************************************************************************
    ChangeLog
-------------------------------------------------------------------------------

2015-02-09
  * git repos
  * ble-edit: bugfix, locate-xword マクロが展開されていなかった
  * ble-decode: bash-4.3 に対応する為に色々変更
    - bind 指定の場合分けを整理
    - bugfix, ESC ?, ESC [ ? に対して全て bind
    - bugfix, 場合によって全く bind -r できていない
      →"bind -sp | fgrep" が "バイナリ" という結果になる事がある様だ。
        fgrep に -a を指定する。
    - bugfix, 日本語が入力できない。8bit 文字が認識されない。
      →8bit 文字はエスケープシーケンスで bind に指定する様に変更。

2013-06-12
  * ble-edit: history-beginning, history-end, accept-and-next

2013-06-12
  * ble-edit:
    kill-forward-fword, kill-backward-fword, kill-fword,
    copy-forward-fword, copy-backward-fword, copy-fword,
    delete-forward-fword, delete-backward-fword, delete-fword,
    forward-fword, backward-fword
  * ble-edit: history-expand-line, display-shell-version

2013-06-10
  * ble-edit:
    kill-forward-uword, kill-backward-uword, kill-uword, kill-region-or-uword,
    copy-forward-uword, copy-backward-uword, copy-uword, copy-region-or-uword,
    forward-uword, backward-uword

  * ble-edit:
    delete-forward-uword, delete-backward-uword, delete-uword, delete-region-or-uword,
    delete-forward-sword, delete-backward-sword, delete-sword, delete-region-or-sword,
    delete-forward-cword, delete-backward-cword, delete-cword, delete-region-or-cword

  * ble-edit:
    以下の編集関数を廃止:
      delete-region-or-uword, kill-region-or-uword, copy-region-or-uword,
      delete-region-or-sword, kill-region-or-sword, copy-region-or-sword,
      delete-region-or-cword, kill-region-or-cword, copy-region-or-cword.
    代わりに以下の編集関数を用いる:
      delete-region-or type, kill-region-or type, copy-region-or type.

2013-06-09
  * ble-edit: kill-region, copy-region
  * ble-edit:
    kill-forward-sword, kill-backward-sword, kill-sword, kill-region-or-sword,
    copy-forward-sword, copy-backward-sword, copy-sword, copy-region-or-sword
  * ble-edit:
    kill-forward-cword, kill-backward-cword, kill-cword, kill-region-or-cword,
    copy-forward-cword, copy-backward-cword, copy-cword, copy-region-or-cword
  * ble-edit: forward-sword, backward-sword, forward-cword, backward-cword

2013-06-06
  * ble-edit-bind: 全ての文字・キーが入力可能に。
  * complete: 候補一覧の表示 (簡易版)
  * ble-color.sh: 色付け機能を highlight.sh から移植

2013-06-05
  * ble-edit: history-isearch-backward, history-isearch-forward,
    isearch/self-insert,
    isearch/next, isearch/forward, isearch/backward,
    isearch/exit, isearch/cancel, isearch/default,
    isearch/prev, isearch/accept
  * ble-edit: yank
  * ble-bind -d で今迄に bind した物を表示できる様に。
  * ble-edit: complete, 取り敢えずファイル名補完だけ
  * ble-edit: command-help

2013-06-04
  * ble-edit: discard-line, accept-line
  * ble-edit: history-prev, history-next
  * ble-edit: set-mark, kill-line, kill-backward-line, exchange-point-and-mark
  * ble-edit: clear-screen
  * ble-edit: transpose-chars
  * ble-edit: insert-string

2013-06-03
  * ble-edit: bell, self-insert, redraw-line,
  * ble-edit: delete-char, delete-backward-char, delete-char-or-exit,
    delete-forward-backward-char
  * ble-edit: forward-char, backward-char, end-of-line, beginning-of-line
  * ble-edit: quoted-insert
  * ble.sh: 取り敢えず簡単に文字列を入力できる程度までは完成

2013-06-02
  * ble-getopt.sh: bugfixes
  * ble-getopt.sh: 無事に完了した場合に OPTARGS を unset する様に変更
  * ble-decode-kbd, ble-decode-unkbd

2013-05-31
  * ble-getopt.sh: created
  * ble-decode: 大枠が完成

2013-05-30
  * highlight.sh: 取り敢えず簡単な色付け
  * ble.sh:

    -- 経緯 --
    highlight.sh の方針だと bash が表示する編集中の内容を消す事が出来ないし、
    カーソルの位置も bash が表示する物の場所を指している。
    色を付けて表示した物は、補助的に bash が表示する物の下に並べて表示する
    ぐらいしか方法がない。

    また readline 関数をスクリプトから呼び出す事が出来ないので、
    結局、色付けを更新したいタイミングで READLINE_LINE や READLINE_POINT の動作を
    スクリプトの側で全て模倣して再現しなければならない。
    READLINE_LINE, READLINE_POINT の bash の仕様が変な所為で、日本語など
    のマルチバイトで正しく処理する為に、色々と汚い事をしなければならない。

    以上の事から、文字列の編集などの操作からスクリプトの実行まで
    全部自分で好きな様に実装して bash readline の機能を全て上書きする事にした。
    その為に、スクリプトを新しく書き直す。zle を真似て ble (bash line editor)
    と名付ける。

    -- 方針としては --
    a. read -n 1 を用いて 1 文字ずつ標準入力から文字を取り出してそれを処理していく
    b. bash の bind で全ての文字に ble のバイト受信関数を繋げて、
       バイト列を受信しながら処理する。

    highlight.sh の延長線上で b. の方針にしたが、
    もしかすると a. の方針も可能かも知れない。

2013-05-29
  * highlight.sh: 作成


*******************************************************************************
    実装ログ
-------------------------------------------------------------------------------

2015-02-09

  * <bug> bind -x '"\"":...' 及び bind -x '"\\":...'

    cygwin の bash-4.1 で改めて動かしてみた所色々問題がある

    1 '\' と '"' が bind -r できていない
      良く考えたら bind -r している訳ではなくて bind -x で上書きをしているのであった。
      そして bind -x している物を調べたら先程弄ったコードの簡単なミスだった。修正。

    2 カーソルキーの類が全て M-\\ と解釈されている
      これは 1 に関連する物だった \\ に bind する代わりに \[ に bind していた所為で
      CSI が M-\\ に翻訳されてしまっていたというだけの話であった。

  * <bug> bash-4.3 日本語が入力できない。
    8bit 文字は \ooo の形式で bind -x '"\ooo":...' しなければならなくなった。

    | 以前までは bind -x ではマルチバイト文字を 1 文字ずつしか受信できなかったのが、
    | いつの間にかに日本語として受信できるようになった様だ。
    | 今迄は octet の 256 文字を全て登録する事で入力を全て横取りできたが、
    | この所為で unicode にある全ての文字について bind しなければ日本語を受信できなくなった。
    | どうするか…。
    | 
    | 例えば以下を設定した状態で "あ" と入力すると hello となる。tttqqqrrr とはならない。
    | hello を bind していない状態だと tttqqqrrr となる。あれ、受信できている…。
    |   bind '"\343\201\202":"hello"'
    |   bind '"\343":"ttt"'
    |   bind '"\201":"qqq"'
    |   bind '"\202":"rrr"'
    | つまり bind -x では受信できない、という事なのか? と思ったらちゃんと受信できる。
    | 
    | では ble.sh で受信できないのは何故か? \ooo の形式で指定する必要がある?
    | と思って \ooo の形式で指定する様にしたら直ぐに入力できる様になった。

  * <bug> bash-4.3 "ESC [ 数字" 系のシーケンスを入れると
    bash_execute_unix_command: keymap云々 のエラーになる。

    問題: C-left C-right を使おうとするとキーマップがないと出る

    これは bash --norc から source しても変わらなかった。
    $ TERM=dumb bash --norc
    $ TERM=screen-256color; source ble.sh
    等としても同じだ…
    (というか source ble.sh する前に C-left C-right を試したら TERM=dumb でも動く。)

    他にも試してみたがどうも "ESC [ 数字" 系のシーケンスが全部駄目な様だ。

    仕様がないので "ESC [ *" を全て登録する事にする

  * <bug> bind -r すべき対象を bind -sp | fgrep していたが fgrep が結果をバイナリと判定する事がある

    fgrep -a とオプションを指定する事で解決した。

    | %%問題: bash で起動するとカーソルキーを使えるが bash --norc で起動するとカーソルキーを使えない%%
    | 
    | これは謎である。~/.bashrc の中で設定しているものと関係があるのだろうか。
    | source ~/.mwg/bashrc; source ble.sh とするとカーソルキーを使える。
    | source ~/.mwg/share/mshex/shrc/bashrc_interactive でも使える。
    | 
    | test-prebind.sh に bashrc_interactive の中から bind 関係の部分を抜き出してみても使える。
    |   どんどん絞り込みをしていく。複数の bind の組合せで起こっている?
    |   かなり不思議な事が起こっている…コメントの有無で結果が変わる…。
    |   そればかりか末尾の改行の数にも依存している。再現性がある事は明らか。
    |   改行の数が一定数以上ならばOK? でも改行の後に何があるかにも依存している。
    | 
    |   bind よりも前に何を書いても大丈夫なように見えてコメントを沢山書いたら駄目になった。
    |   どうやら bind よりも前のコメントに何が書かれているかにも依存する様である。
    |   仕方がないのでコメントは以下に移動してくる。
    | 
    |   # @bash-4.3
    |   # 以下を読み込んでから ble.sh を読まないと何故かカーソルキーが使えない
    |   #   bind よりも後の空白の数だとかコメントの文字数が
    |   #   違っただけで使えたり使えなかったりする。
    |   #   コメントの内容によっても結果が異なる様だ。
    |   #   bash のメモリ関連のバグだと思われる。セキュリティ的に危ないんじゃないか??
    | 
    |   また気付いた事だが、暫く時間が経つと先程まで動いていた test-prebind.sh では動かなくなったりする。
    | 
    | bash のバグとしか思えない動作なのでここでは置いておく事にする。
    | 
    | →何と新たな事実が判明した…。
    |   カーソルキーが使えない場合については ble.sh 内の bind -r が走っていない。
    |   色々調べると bind -sp は色々物を出力しても、
    |   fgrep の段階で「バイナリ」と判断されたり判断されなかったりする様だ。
    |   fgrep でバイナリと判断されると中身が表示されない為に bind -r が走らない。
    | 
    | 結局 何故 bind コマンドの周りのコメントやら何やらが fgrep のバイナリ判定に影響を与えるのかは分からなかった。
    | コメントの有無などで bind -sp で表示される順序などが変わるという事なのだろうか。
    | 或いは fork 元の bash のメモリの内容に fgrep の判定が影響を受けているとか。

  * "bash: bash_execute_unix_command: コマンドのキーマップがありません" と出る問題

    久しぶりに起動してみたら色々と動かない? @bash-4.3 of padparadscha

    カーソルキーを入力しようとすると
    bash: bash_execute_unix_command: コマンドのキーマップがありません
    等と表示される。検索すると bind -x した時の bind 先が不明な場合に発生するエラーメッセージの様だ。
    ESC で始まるキーシーケンスに対応するキーは全てこれなので ESC 関係が悪さをしているのだろう。

    bind -x した物の一覧を取得する方法があれば良いのだが。
    以前に探した時には見付からなかった気がするが、改めて調べてみる。と、
    bash-4.3 以降では bind -X を用いて bind -x した物の一覧を表示する事ができる様だ。
    早速試してみると確かに bind -x した物の一覧を閲覧する事ができる。

    そこで bind -x した物の削除を試みる。
    普通に bind -r $'\ez' しても削除できない…。
    と思ったら実はちゃんと削除できているが bind -X の表示に反映されていないだけという事が分かった。

    <bashbug> bash-4.3.33, bind -r して削除した後のコマンドが bind -X の一覧から削除されない。

    分かった事: 2文字シーケンスを登録すると1文字目にkeymap変更が割り当てられる

    | どうやら一回でも 2 文字のシーケンスを登録してしまうと
    | それらを全て削除しても 2 文字のキーシーケンスに対応する keymap を探す様だ。
    | 例えば "ab" というシーケンスを登録すると
    | 「"a" は2文字のキーシーケンスの1文字目」という情報が登録されてしまい、
    | a に続けてどの様な文字を打っても対応する2文字のキーシーケンスが見付からない!
    | という状態になってしまう。(実際に "ab" で試してみたらそうなった。)
    |
    | ※唯単に bind -x '"ab":"echo"' && bind -r ab 等としただけでは再現しない。
    |   予めあらゆる 1 文字コマンドについて bind -r && bind -x ... しておくとなる。
    |   bind -x でない通常の readline 関数がそれぞれの文字に割り当てられている場合はそれが呼び出される様だ。
    |   しかし、全てを bind -x で処理する為に readline 関数を解除していると "見付からない" という事になる。
    |   再現方法は以下の通りになる:
    |
    |   $ bind -x '"ab":"echo"' && bind -r ab && bind -x '"a":"echo"'
    |
    |   1つ目のコマンドも3つ目のコマンドも -x でなければ再現しない様だ。つまり、
    |   $ bind '"ab":self-insert' && bind -r ab && bind -x '"a":"echo"' → 再現しない。問題なし。
    |   $ bind -x '"ab":"echo"' && bind -r ab && bind -x '"a":self-insert' → 再現しない。問題なし。
    |   という事である。
    |
    | これを解決する為には "a" で始まるあらゆる2文字のシーケンスを登録すれば良い。
    |
    | これは C-x の状況と似たような状況である。
    | (以前の bash で試した時には C-x に続けて何か入力すると bash 毎落ちていた。
    | これがエラーメッセージを表示するという状態に修正されたのだろう。)

    取り敢えず "ESC なんとか" は如何にも bind -x で登録されそうな組合せなので、
    "ESC *" の全ての組合せを登録してしまう事にする。
    実際には bind -x でどの様な2文字のシーケンスが登録されているのか分からないので、
    あらゆる "* *" の組合せについて登録しない限りは万全とは言えない。
    とはいいつつあらゆる組合せについて 2 文字単位でしか入力を読み取れない状態にもなる。
    これは明らかに不便だ。結局、"ESC *" の組合せを登録する程度が限界だろう。

    分かった事2: ESC は bash-4.3 では初めから2文字のシーケンスの一部と解釈される

    | bash --norc で起動した状態から source ble.sh した場合は ESC * に bind しなくても良いかと思ったが、
    | 実際に試してみた所同様のメッセージ bash: bash_execute_unix_command: コマンドのキーマップがありません
    | が出る。bind -X で確認したが、やはり bind -x は何も存在していない状態から source ble.sh だった。
    | その他の version の bash がどうなのかは試していない。

    つまり、bind -x を何もしていない状態でも "ESC *" に対して bind しなければならないという事。


2013-06-13

  [Done]

  * <bug> bash-3.2.48, bash-3.1: カーソルの表示位置がずれる。
    と思ったら、そもそも READLINE_LINE 及び READLINE_POINT に対応していない様だ?
    これだと C-d で即座にログアウトしてしまう…。

    →これに関しては READLINE_LINE は空白のままで諦める事にした。
      この状態であれば bash による出力は何も為されないので、
      カーソル位置の修正などを行う必要はなく、ただ .ble-edit-draw.update を実行すればよい。
    
    →また、C-d に関しては IGNOREEOF を大きな値に設定して取り敢えず諦める事にした。
      制限としては C-d を受信する事が出来ないという事、C-d を押すと
      「ログアウトする為には exit を入力して下さい」と表示され、
      プロンプトの表示などが乱れる (というか何も表示されない) という事。

    [2013-06-13 21:24:46]

  * <bashbug> bash-3.1
    パラメータ展開の部分文字列で、範囲外のインデックスを指定すると ^? が返ってくる。
    これはどうしようもない。部分文字列は他の場所でも多用している上に代替手段が存在しない。
    (勿論、別のプログラムを呼び出せばこの機能を再現する事は出来るが、
    それをするととても遅くなるので受け入れがたい。)

    bash の ChangeLog を見てみたが、このバグに関する情報は書かれていない様な気がする。
    一応 bash-3.2 から bash-4.0 へ変わる時に配列の ${array[@]:*:*} で stray の ^?
    が出るバグを修正したと書いてある。また、${var##..} で空白が絡む時の stray ^? についても
    バグの修正が為された様だ。

    →何故かは知らないが、a=; echo "(${a::})" とすると ^? が出力されるが、
      a=; x="${a::}"; echo "($x)" とすると正しい結果が返ってくる。
      また "(${a::})" や "a${a::}b" 等とすると ^? が出力されるが、
      "(""${a::}"")" や "a""${a::}""b" とすると ^? は出力されない。
      もし "" で文字列を区切るだけで良いのだとしたら、少ない修正で bash-3.1 にも対応可能である。

      取り敢えずこの修正によって見た目ちゃんと動いている様子である。
      [2013-06-13 21:25:43]

    →また、bash-3.2.48 で確認してみた所、このバグは既に取り除かれている様だ。


2013-06-12

  [Done]

  * <bug> bash-3 では bind -x されたコマンドを受け取った時、
    一度改行してから実行される為に、行がずれていく。
    プロンプトは消去されないので再描画の必要はない。
    現在位置の情報を更新するだけで良かった。

  * <bug> ble-bind -D: cmap または kbd が全く定義されていない状態で
    ble-bind -D を実行すると内部の declare -p が無引数で実行されて、
    bash 内で定義されている全部の変数が出力されてしまう。
    これは、_ble_decode_cmap_@ または _ble_decode_kbd_@ が 1 つ以上あるか
    どうか確認してから declare -p を呼び出す様にすれば良い。

  * <bug> bash-3.1, ble-decode-kbd ESC の結果が 3 になる。
    .ble-decode-kbd.get-keycode: tmp の要素を数える所で、
    tmp の先頭要素の文字数を数えていた。

  * <bug> bash-3.1: 何と bash-3.1 の算術式では ?: を数珠繋ぎに出来ない。
    ちゃんと括弧で括っていかなければならない。これは結構痛いと思ったが、
    意外と書き直さなければならない所は少なかった。

    .ble-text.c2bc+UTF-8, .ble-text.c2w+emacs, .ble-text.c2w.ambiguous

  * <bug> bash-4 未満で _ble_decode_kbd__c2k を -A として宣言していた。
    -a に書き換えるだけでよい。
    [2013-06-13 00:26:51]

  * <opti> スタイルを一つの整数で表現する。

    文字列比較などをすると時間が掛かる為。
    ble-color.sh, ble-edit.sh 等を書き換えた。意外とすんなりできた。
    これで .ble-line-text.construct のループ内の処理をできるだけ算術式で記述し、速度向上を図る。
    →変更した。定量的に変化があったかどうかは分からないが。

  * ble-edit.sh: quoted-insert, self-insert, insert-string で
    _ble_edit_mark_active を解除するように変更

  * [ble: exit] の際の色を変更

  * 履歴展開: 展開に失敗した時の対処。
    その儘空白のコマンドを実行してしまっていた。
    履歴展開に失敗した時は bash では、前回編集中のコマンドが再度表示される。
    それに倣って書き換えた。
    [2013-06-12 15:15:47]

  * 履歴展開が使えない

    set -H としてみたが eval の中では有効には為らなかった
    (というか、多分、set -H は初めから設定されていたのではないかと思う)。
    history -p で変換してから実行すれば等価だろうか。
    ("" で囲んでも実行された、が、通常の履歴展開の動作もそうなっている様だ。)

    この方針で実装する事にした。
    [2013-06-12 15:14:22]

  * fword: IFS に加えて / も区切とする単語単位の操作を追加。

  * uword: IFS を参照してそれを基準にして単語境界を決めるように変更。


2013-06-11

  [Done]

  * <bug> 特定の操作をした時に accept-line の処理が中途半端で終了する
    C-c や C-z など。

    [C-z 完 2013-06-11 12:22:35]

    + C-\ の場合は問題なく続きが実行される。

    + 実は C-z をした時にも同様の事が起こっている様だ。

      こちらについては trap 'echo' TSTP, trap 'echo' 20, trap echo 'SIGTSTP' 等としても設定できない?
      trap -p をすると予め '' が割り当てられている様子である。
      その他にも予め '' が割り当てらｒている TTIN TTOU についても、
      trap を仕掛けても何も trap する事ができない様だ。

      念のため trap : 20; trap -p と、連続で実行してみたがやはり設定できていない。
      つまり、誰かが設定を戻しているという訳ではなく、初めから設定できないという事。
      また、stty susp undef としてから trap してみたが、それでも設定できない。

      然し乍ら C-z をした直後には、何故か redraw は実行される様だ。
      但し、stty の設定は元に戻っていないようで、
      C-c や C-z 等の文字を受け取る事は出来ない。

    + 然し C-z の直後には何故か prompt が表示されている。
      これは一体誰が表示しているのだろうか?
      →確かめてみた所、C-z した時は実行中のコマンド全てに失敗する訳ではないようだ。
        accept-line.exec 内のループを抜けるに留まるらしい。

        for コマンドが C-z を受信するという事だろうか?
        試しに accep-line.exec 呼出元で 1 回ループにくるんで見たところ、
        C-z でそのループまで抜けるようになった。
        つまり、for 等のコマンドを使わずに実行すれば良いという事だろうか。
        (一応再帰と条件分岐さえあればループは可能。)

        試してみた所 && による条件分岐は C-z で止まらない
        また、if 文による条件分岐も C-z では止まらない様だ。


2013-06-10

  [Done]

  * <opti> .ble-line-text.construct 文字連結最適化?
    [2013-06-11 03:37:38 余り効果は無かった]

    カーソル移動だけの時は配置の再計算を省略できるようにしたが、
    カーソル移動がそれ程速くなったとは思えない。(少しは軽くなった気がしないでもないが)
    何がボトルネックになっているのだろう。残りは、文字連結程度しかない。
    なので、文字連結の最適化について考え直してみる。

    色々試してみた結果、配列に格納していって最後に join するのが速いようである。
    また、${#out} の様な長さの評価の仕方は O(N) の計算量なので
    ループの中で毎回参照するのは避けた方が良い。
    →余り改善したようには思われない…。

    或いは単に関数の呼出に時間が掛かっているだけなのか?
    →でもこれはあり得ない。何故なら編集文字列が短い時にはきびきびと動くから。

    それとも cache_g[i] やら cache_ei[i] の代入に時間が掛かっているのか。
    →試しに off にしてみたがそれ程変わった雰囲気もない。

    或いは座標位置の再計算をしてしまっている? → 確認してみたが、ちゃんと再計算は省略されている。

    改めてどの場所で時間が掛かっているか確かめる為に、
    カーソル移動しか起こっていない場合には文字連結部分を省略してみる事にした。
    (この様にするとカーソル移動によって更新されるべき物が更新されないので、実際には使えない方法である。)
    →すると動作がとても速くなったので、やはりこの文字連結を行っている部分が悪い様だ。

    更に、ダミーで文字連結のループを回して何処に時間が掛かっているのか調べる事にした。
    →文字を配列に登録する部分はそんなに時間は掛かっていないようだ。
    →文字列の長さを計算する部分も関係ない。
    →cache_ei や cache_g に代入している部分も関係ない。

    # →と、ここで SGR 系列を追加している部分を有効にしてみたら急に遅くなった。
    #   先程やった時には余り変化が無かったように感じたが恐らく勘違いだった。
    # →どうも文字列比較 if test "$seq" != "$seq0"; then の部分が重い様子である。
    #   (seq, seq0 はそれぞれ3文字なのでそれ程重いとは思えないのだが)
    #   以下のような色々な物を試してみたが、速さに大差は無いようである (当然か)。
    #   if test -n "${seq#"$seq0"}"; then
    #   if test "$seq" != "$seq0"; then
    #   if [ -n "${seq#"$seq0"}" ]; then
    #   if [ "$seq" != "$seq0" ]; then
    # 
    #   或いは、sgr の表現を整数にして、整数同士で比較する様にすると速いかも知れない。
    と、ここまでで SGR 系列の部分が怪しいのではないかと色々調べてきたが、
    やはり? 違うようだ。別の所をコメントアウトして SGR 系列の部分だけ残してみると充分速い。

    どうも、何処が特に重いという訳でもなく、これが bash の限界という事のようだ。
    早く dirty または色変更した部分だけしか再計算を実行しなくても済む様に変更した方が良いという事だろう。

  * カーソル移動では dirty を設定しない様に変更。
    →意外と少なかった。移動は全て .ble-edit.goto-char を介して実行されていた為、
      .ble-edit.goto-char の中で実行されている .ble-edit.set-dirty を削除するだけで良かった。
      その他は set-mark, exchange-point-and-mark ぐらい。

    + と思ったらカーソルを移動しても、カーソルの移動が表示に適用されなくなった。
      良く考えたらカーソルの移動をした場合、文字の配置を再計算する必要はないが、
      表示の際の領域反転などは再度計算し直す必要があるので、
      描画に関しては再度実行する必要がある。

    # * 現在 cursor 移動も dirty として扱っているが、
    #   別にその様に扱う必要性はないのではないか?
    # 
    #   dirty としたのは色付け関数によって括弧の強調などの色付けがカーソルの位置に
    #   依存して行われる可能性があったからである。
    #   色付け関数が region_highlight なり何なりを呼び出した時点で、
    #   set-dirty が自動的に為されるような仕組みにしておけば問題ない。

  * <bug> set-mark: 動作が emacs と違う。
    emacs では既に mark が active な場合でも、
    active なまま新しく現在位置を mark の位置とする。
    active 状態をトグルするなどといった事はしない。
    [2013-06-11 00:23:12]

  * _ble_edit_mark_active
    今迄の型は整数型で 0 または 1 の値を取っていたが、
    今後は様々な種類のマーク (S-move によって有効になったマークなど) を区別する為に、
    + マークが設定されていない場合は ''
    + set-mark によってマークが設定されている場合は '1'
    + S-move によってマークが設定されている場合は 'S'
    + (その他のマークを設定する事が在れば必ず有限長の文字列)
    等のように文字列とする事にした。これに伴って何カ所か修正。
    [2013-06-11 00:14:30]

  * <bug> 今迄 sword としていたのは寧ろ unix-word の事だった。
    名称を sword から uword に変更。
    [2013-06-10 22:41:22]

  * <bug> uword の定義で空白を SP HT にしているが、LF も含める。
    [2013-06-10 22:41:28]

  * sword 関連に対応 [2013-06-10 22:43:42]

    IFS=$'|&;()<> \t\n' (シェルのメタ文字) を区切り文字として単語分割する。
    但し、quote については正しく処理していない。

    # unix-word の定義について調べて uword として実装する。

  * forward-word, backward-word を emacs や readline と同様の位置に移動する様に変更。

  * <opti> 長い文字列を編集するのに時間が掛かる。

    これは毎回 construct-line でカーソルの位置の計算と出力文字列の構築を行っているからである。
    特に、一つ一つの文字幅を毎回計算しているのが一番重い気がする。
    理想的には dirty な部分以降の計算を実行すれば良いはずである。

    と思ったが、カーソルの位置が変われば SCOSC, SCORC の埋込位置が変わる為、
    現状の実装方法ではやはりカーソルの位置から再度計算し直さなければならない。

    これの解決方法としては、
    + 先ず全ての文字の後で x y lc lg がどの様な状態になるべきかを計算し、これを cache 配列に記憶する。
    + また、全ての文字に対して esc_line 中の何文字目に対応するかも記憶しておく。
    + esc_line 自体も何処かに記憶しておく。
    construct-line 関数は以下の処理を実行する
    1 dirty が設定された場所から位置解析をやり直す。
      この解析では各文字だけを記録し、escape sequences の構築まではしない。
    2 更に色付けの処理を dirty が設定された場所からやり直す。
    3 色付けによって変更された箇所から escape sequences を構築し esc_line とする。
    4 esc_line のカーソル位置と末端に SC と RC を挿入して ret に入れる。
    5 カーソル位置の x y lc lg を取り出す。

    新しく .ble-line-text.construct という関数を作る事にした。

    + 先ず始めに .ble-line-text.update-positions で dirty から x y lc を更新する。

      i文字目を処理している時:

      1 cache_x[i], cache_y[i] の更新
        cache_x[i], cache_y[i] には i 文字目を出力する **前** のカーソル位置が格納される。
        (或いは、i-1 文字目を出力した **後** のカーソル位置とも言う事が出来る。)

      2 次に cache_lc[i] の更新を行う。
        cache_lc[i] は、cache_x[i]!=0 の場合は、その左側に位置する文字、即ち i-1 番目の文字のコードを保持する。
        cache_x[i]==0 の場合は、その次に同じ行に来る文字のコードを保持する。

        cache_lc[i] は x!=0 の時は、前回の文字コード (lc) をそのまま代入すれば良い。
        然し、x==0 の時は、次に x!=0 になるまで代入を実行する事は出来ない。
        ここで変数 li を導入する。li は、次に cache_lc を代入するべき位置を保持する。

        x!=0 の場合には cache_lc[li] ～ cache_lc[i] までの値を代入し、li=i+1 とする。
        x==0 の場合には cache_ic に対する代入は実行せず li の位置も進めない。
        cache_lc[li] ～ cache_lc[i] に対する代入は以下のように行う。
        x!=0 となった行 y が cache_y[j] と一致するならば lc を代入する。# これだと ^A 等の場合に A に化けるのでは?■
        x!=0 となった行 y が cache_y[j] と異なるならば 32 (空白) を代入する。

        for(j=li;j<i;j++)
          assert(_ble_line_text_cache_x[j]==0);

      3 cache_lg[i] の更新は未だ行わない。

    + その後紆余曲折を経て新しい「編集文字列構築器」ができた。
      古い関数 
        .ble-cursor.construct-line.chk-cursor
        .ble-cursor.construct-line
      は削除する。
      [2013-06-10 22:02:41]


2013-06-09

  [Done]

  * <bug> source ble.sh でエラーが発生するようになった。
    どうやら ble-bind で発生している様だ、
    と見てみたら OPTARGS の変数存在確認で "${OPTARGS+set}" を引用符で囲むのを忘れていた。
    [2013-06-10 04:00:03]

  * <opti> プロンプトの初期化が異様に遅い @ cygwin

    プロンプトで \j が3回参照されている。
    それぞれの \j の呼出で2つのプロセスが生成されているので、
    プロンプトの初期化で合わせて 6 つのプロセスが生成されている事になる。
    cygwin のプロセス生成の速度は測ってみたら秒間 10 程度であったので確かに時間を食う。
    (本来はプロセスを生成せずにこれを処理したいが。)

    プロンプトの初期化中にコマンドを実行する場合は、
    コマンドの実行結果をキャッシュするように変更。
    [2013-06-10 03:31:58]

    更に job の数を wc を使わずに数える様に変更。
    [2013-06-10 03:53:44]

    これらの変更によって cygwin でなくてもかなり軽くなった様に思われる。

  * <bug> /bin/printf, source ble.sh 時にエラー @ cygwin
    c2s: /bin/printf が使えない環境で source ble.sh 時にエラーメッセージが出る。
    /bin/printf の stderr を /dev/null に落とすように変更。
    [2013-06-10 03:37:02]

  * <bug> [ -v ] のエラーが発生する @ cygwin
    cygwin 環境で動かしてみる→エラーが発生して初期化に失敗する。
    ble-bind で OPTARGS の変数存在チェックに test -v を使用していた。
    bash-4.1 以下でも動くようにする為には test -n "${OPTARGS+set}" を使用するべき。
    [2013-06-10 03:34:53]

  * <bug> c2s-hex: /bin/printf を用いて
    function .ble-text.c2s-hex を定義するべき所を
    function .ble-text.c2s を定義していた。
    [2013-06-10 03:33:23]

  * <bug> 再描画の際に sgr 情報が失われる。
    カーソル位置を設定する時、lc と共に sgr の情報として lg も記録するようにしたい。
    
    construct-prompt に関しては取り敢えず置いておき、
    construct-line の方での対応を済ませる。
    [2013-06-09 19:25:13]

  * <bug> 編集文字列が右端一杯の時に縦の位置がずれる。
    <del>右端付近に tab があると縦の位置がずれて表示される。</del>

    多分、tab の所為で発生する改行についてちゃんと対策が取れていない為である。
    後でゆっくり考える必要がある。

    と思って色々試していたら、別に tab がなくても編集文字列末端が右端付近に位置している時には
    縦の位置がずれてしまうという事が分かった。
    原因は construct-line の中で SCORC を出力する位置にあった。
    最後の改行を出力する前に SCORC を設定していた。本当は最後の改行の出力も済ませてから
    SCORC を設定するべきだった。

    + これで丁度右端ぎりぎりまで編集文字列がある場合に常に (カーソルが何処にあっても)
      位置がずれると言う問題は解決した。

    + しかし、それでもカーソルが丁度右端にある時のカーソルの位置が変な事になっている。
      右端にあるので本来はカーソルは見えない (?) 筈であるのに最後の文字 (右端から一文
      字戻った場所) に表示されたり、次の行の最後の文字の位置に表示されたりする。

      そもそも一番右端にカーソルが来た場合に何処にカーソルを置くべきかという事だが、
      xenl が有効な端末でも無効な端末でも同様に表示するのであれば、次の行の先頭に表示する
      べきである。(その事も考えて編集文字列が丁度右端に到達している時に、xenl に対して
      改行を出力しているのである)

      問題は、SCOSC をしている時に行末端に位置している為に、SCORC で戻ってきた時に、
      (折角改行したのに) 行末端の位置に戻ってきてしまう事である。
      今迄は行末端に来た時、xenl であっても次に文字が来た時に次の行に自動的に移動するから
      敢えて改行は出力しないようにしていたが、SCORC で戻ってくる事も考えると、
      ちゃんと xenl の場合には明示的に次の行に移っておいて、その後で SCOSC される様にする
      べきである。

      その様に書き換えたらちゃんと期待通りにずれずに動くようになった。TAB がきても問題ない
      [2013-06-09 18:37:58]

  * <bug> 全ての文字に対して SGR を出力している。
    編集文字列の表示で出力している escape sequence を見てみると SGR が変化していないのに
    毎回 SGR の設定を出力している様だという事が分かった。前回の文字と SGR の設定が同じ場合には、
    SGR の設定は出力しないようにしていた筈である。
    →改めて確認してみた所 seq0=seq としていた。seq0="$seq" でなければならない。
      「前回の SGR」の値が常に誤った設定になっていたから、毎回 SGR が出力されたのである。
    [2013-06-09 18:06:30]

  * <bug> 改行を含むコマンドを編集している時、
    行の先頭にカーソルがある時に、そこに位置する文字が空白に化けて表示される。
    本来ならば行頭に文字がある場合、その文字を lc に設定する事になっているはずである。

    見てみた所、.ble-cursor.construct-line.chk-cursor までは正しく処理できている様に見える。
    と思ったら、update-adjusted で lc から READLINE_LINE を設定するのではなく、
    単に空白を READLINE_LINE に代入していた。
    [完 2013-06-09 16:53:31]

  * <bug> tab が幅ゼロで表示されている。
    時々幅を持って表示されるがその規則は謎。

    と思ってみていたら tab の幅が負の大きな値になったりしている。
    絶対値は大体 x と同じぐらいである。と、ここで /it とするべき所を %it としている事に気付いた。
    同様のコードを色々な所に書き散らしていたので、それらも纏めて修正した。
    [2013-06-09 16:43:12]

  * <bug> 改行を含むコマンドを実行すると、実行後にカーソル位置がずれる。
    [2013-06-09 16:14:26]

    これは前回のプロンプトが表示されていると勘違いして原点に移動する為である。
    _ble_line_x, _ble_line_y を 0 に設定するべき。

    →.ble-edit.accept-line.exec.adjust-eol で
      _ble_line_x, _ble_line_y を 0 に設定する事にした。

  * <bug> quoted-insert
    一部の文字を read -n で読む事が出来ない。
    →これは全ての文字を ble で処理できるようになったら
      ble の仕組みを通じて読む事にすれば良い。

    改めて試してみた所、大概の入力は読み取れている? 後で再度確認する必要有り。
    確認してみた所 ^I ^J ^M の入力をする事ができない。
    やはり、ble-decode-char 辺りに quoted-insert を仕掛ける必要がある。

    # * ble-edit-quoted-insert:
    #   現在はデバグの為に一部の文字列しか捕まえられないので、
    #   read -N を使って実装を行っているが、
    #   全部を ble で処理するようになった時は、
    #   ble-decode-char に対して干渉するだけで良い?

    .ble_decode-char:
    _ble_decode_char__hook 変数を追加、この変数が設定されている場合は、
    この変数に代入されている文字列をコマンドとして実行するように変更。
    [2013-06-09 16:09:46]

  * デフォルトの cmap である term+default を読み込むのに時間が掛かる。
    [完 2013-06-09 15:46:02]

    恐らく ble-decode-kbd 辺りの処理に時間が掛かっているのではないかと思う。
    ble-bind に -D オプションでも追加して、これを追加した場合は、
    ble-bind コマンドによる設定ではなく、cmap 配列に直接値を代入する方式として、
    設定スクリプトを吐き出す様に変更するか?

    直接値を設定する様にすると既に何かを設定している時にそれを上書きする事で、
    データを破壊する事にもなるかもしれないので、その辺りについては確かめる必要がある。
    基本的には設定を追加・上書きするようにすれば良い。

    →試しに配列に直接値を代入する形式でデータを出力してみた。
      出力したデータは 100 KB にも及び巨大だが、
      それを source してみた所 0.1 秒以内にロードできた。
      速度としては充分である。

    + 既存の設定が存在している時にこれを追加して問題になりそうなのは
      "_" を代入する場合と "数字" を代入する場合である。
      "_" を代入する場合は既存の "数字" の設定があった場合に、その既存の設定を消す事になる。
      "数字" を代入する場合は既存の "_" の設定が存在する場合に、それを消す事になる。
      "数字_" を追加する場合については、既存の設定が何であれ完全に上書きしてしまうので関係ない。

      既存の設定に対して安全に追加する事が出来るように書き換えてみたが、
      やはり処理に時間が掛かるようになった。term+default.sh で生成したエントリを全て追加するのに 1 秒弱かかる。
      直接配列を設定する場合には 0.075 秒しかかかっていなかったので、12-13 倍の違いがある。

      また、dump 結果を source してから気付いた事だが、ただ cmap 内の情報を dump するだけでなく、
      キーとキーコードの対応表も一緒に読み込まなければ意味がない。
      そして、後から登録する方式だと、登録したいキーに対応するキーコードが既に使われている場合に、
      番号の再配置を実行しなければならないが、これはかなり重い処理になると思われるので現実的でない。

    + 結局、現実的には既存の cmap に対して追加登録をするのではなく、
      cmap、キーコード・キー対応表を全て入れ替える形にするしかない。

    + 所で良く考えたら declare -p "${!_ble_decode_...@}" 等とすれば

      特別にロジックを書かなくても変数の内容を直接 dump する事ができるのでは?
      実際に試してみた所、declare で出力した物も、
      自分で書いた配列要素を一つ一つ初期化する形式の物も、
      source するのにはそれ程時間の違いはなかった。両方とも 0.105 秒程度かかる。
      若干 declare の形式の方が時間が掛かっている気もするが、誤差の範囲内であろう。

      今後は declare -p を使って dump する事とし、今迄に書いた関数は削除する:
      [2013-06-09 14:37:52]

      function .ble-decode-char.dump-entry {
        local tseq="$1" ccode
        eval "local -a ccodes=(\${!_ble_decode_cmap_$tseq[@]})"
        echo "_ble_decode_cmap_$tseq=()"
        for ccode in "${ccodes[@]}"; do
          eval "local ent=\${_ble_decode_cmap_$tseq[$ccode]}"
          echo "_ble_decode_cmap_$tseq[$ccode]=$ent"
          if test "${ent//[0-9]/}" = _; then
            .ble-decode-char.dump-entry "${tseq}_$ccode"
          fi
        done
      }
      function .ble-decode-char.dump-entryA {
        local tseq="$1" ccode
        eval "local -a ccodes=(\${!_ble_decode_cmap_$tseq[@]})"
        for ccode in "${ccodes[@]}"; do
          eval "local ent=\${_ble_decode_cmap_$tseq[$ccode]}"
          echo ".ble-decode-char.add-entry $tseq $ccode $ent"
          if test "${ent//[0-9]/}" = _; then
            .ble-decode-char.dump-entryA "${tseq}_$ccode"
          fi
        done
      }
      function .ble-decode-char.add-entryA {
        local bseq="$1" byte="$2" val="$3"
        if test -z "${val##*[0-9]_}"; then
          eval "_ble_decode_cmap_$bseq[$byte]=$val"
        elif test -z "${val##*[0-9]}"; then
          eval "
           local ent=\"\${_ble_decode_cmap_$bseq[$byte]}\"
           _ble_decode_cmap_$bseq[$byte]=${val}\${ent##*[0-9]}
          "
        elif test "$val" = _; then
          eval "
           local ent=\"\${_ble_decode_cmap_$bseq[$byte]}\"
            _ble_decode_cmap_$bseq[$byte]=\${ent%_}${val}
          "
        else
          echo unexpected value 2>&1
        fi
      }

    + cmap+default.dump が存在すればそれを source する事にし、
      もしなければ cmap+default.sh から構築してから dump する様にする。

      と思ったら正しくロードされていない。新しく構築した場合にはちゃんと動いているが、
      cmap+default.dump からロードするとロードされていない。
      関数内から cmap+default.dump を source していて、
      cmap+default.dump 内では declare で変数を宣言している為、
      その関数内の局所的な変数としてロードされている。

      これをちゃんと動く様にする為には declare を宣言しなければ良いのだが、
      連想配列については、それが連想配列だという事を明示的に宣言できない。
      →しかし既に別の場所で宣言している筈だから問題ないのでは?
        実際に試してみた所、既に declare -A されている場合、
        新しく代入する場合でも問題は起こらないという事が分かった。

      と言う訳で先頭の declare -? を削除して dump を出力する事にしたが、
      今度はエラーが発生する。よく見たら代入の右辺に一々引用符がついていて、
      配列としての代入ではなくて一つの長い文字列としての代入になってしまっている。
      declare の時には、declare コマンドが文字列として受け取った右辺を展開してから代入するので問題にならないのだろう。
      
      今回は値としては常に一文字以上の [0-9_] だけで構成される物なので、引用符を全て外しても問題ないだろう。
      という訳で sed で引用符の類も全て削除する事にした。
      その上で source の時間を計測してみた所 0.064 秒にまで縮んだ (単にファイルサイズの問題のような気もしてきた…)。

    + 無事に cmap+default.dump で現実的な速度で初期化できる様になったので、
      <del>古いコード (必要最低限の物だけの設定) は削除する。</del>
      と思ったが、後でまた欲しくなるかも知れないので、cmap+minimal.sh として残しておく事にした。


2013-06-08

  [Done]

  * <bug> ble-line-info: 表示している間、編集文字列のカーソル位置の文字が空白になる。
    [完 2013-06-09 01:42:41]

    これはカーソル位置を移動する時に _ble_edit_lc も変更してしまっているのが原因。
    _ble_edit_lc は描画関連の処理が終了してユーザの入力待ち状態になった時に、
    最終的にカーソルが存在しているべき位置の文字を示す物であって、
    これは一時的なカーソルの移動の際に変更するべき物ではない。

    現状では「最終的にカーソルが存在しているべき位置と其処の文字」と、
    「現在の描画処理の為に移動しているカーソルの位置と其処の文字」を一緒に扱っている。
    変数を分けるべきではないだろうか。
    + _ble_line_curx _ble_line_cury _ble_line_curlc は配列に纏める事にし、
      これは「最終的にカーソルがあるべき位置と文字」とする事にした。
      また、_ble_line_x, _ble_line_y という変数を追加し、これを
      「描画中の現在カーソルが存在している位置」とする事にした。

    + .ble-edit-draw.goto-origin, .ble-edit-draw.goto-end 関数を廃止し、
      .ble-edit-draw.goto-xy 関数を定義し、任意の座標に簡単に移動できるようにした。

    + この変更によって .ble-line-info.draw, .ble-line-info.clear で
      復帰する必要が無くなったかも知れない。
      現在のカーソルの位置が分かっているのだから、
      わざわざ元の位置に戻らなくても良い。
      次に移動する必要が生じた時に適切に移動すれば良いだけである。
      (勿論、その為には .ble-line-info.* で現在のカーソル位置の情報を更新する必要がある。)

      最終的に必ず update-adjusted が呼び出される。
      そして update-adjusted は必ず始めに update を呼び出す。
      update は現状の実装では必ず編集文字列部分は表示し直すから、
      結局必ずキャレットの場所へ移動する事になる。

    + と思って実際に試してみたら位置を移動するようになってしまった。

      これは単に _ble_line_x の変数名を _ble_edit_x としていた為であった。
      正しい変数に移動後の座標を書き込んでいなかった。

      しかしこれを修正しても未だカーソルの位置がおかしい。
      座標位置を勘違いしていると言うよりは、
      info 情報を出力した直後のカーソル位置になっていて、
      その後 update-adjusted 等の操作が行われた形跡がない。

      と思ったら _ble_line_y に対して数式をその儘代入していて、
      計算した結果を代入していなかった。
      しかしこのバグは今回の異常とは関係ない気もする。

      果たして実際に試してみると未だ直っていない。
      また、.ble-edit-draw.update の前後で現在の座標位置が変化していない。
      本来であればこの部分で適切な位置への移動が行われると期待している。
      という事で改めて .ble-edit-draw.update を見てみると、
      実は .ble-edit-draw.update の先頭で
      _ble_edit_dirty が全く設定されていない時には何の操作もせずに終了するようになっていた。
      _ble_edit_dirty が設定されていなくても、位置が異なる場合には移動を実施する様に変更する。
      →これで取り敢えずカーソル位置は正しくなった。
      [2013-06-09 01:42:41]

      また、その際に sgr の値を再設定する必要もある。(sgr は今迄は SCORC, DECRC 等に頼っていたが、
      本来は自分で管理できるようにしておきたい所である。)
      これについては別項目で取り扱う事にする。

  * <bug> 複数行に渡る編集を実行している時に、何かを入力する度に表示位置がずれていく。
    [2013-06-09 01:17:29]

    ずれない様に設計している積もりだったが正しく動作していない様子である。
    先ず始めにずれて上にはみ出た行が消去されていない事から、
    .ble-edit-draw.clear の時点で原点に移動して削除するということができていない様である。
    可能性としては、現在の位置座標を勘違いしているか、原点へ移動する為の制御系列を誤って生成しているかのどちらかである。

    .ble-edit-draw.redraw-cache の始めで現在位置がどうなっているかについて確認を行う。
    →座標値については正しく計算されている様である。
    という事は goto-xy が怪しいと思って改めて考えてみたら、
    今回の場合は y の移動量 dy が負になる。その時に ESC [ A に渡す引数を絶対値にするのを忘れていた。

  * <bug> 色々変更している内にカーソルが先頭に移動するようになってしまった。
    [完 2013-06-09 01:08:14]

    goto-xy の引数に文字列で式を指定できるようにしていたが、
    これをすると goto-xy の中で新しく宣言した変数に影響を受けて値が変わってしまうので、
    やはり goto-xy の引数にちゃんと評価した後の数値を指定する様に変更した。

  * 不要なデバグ用の古い関数 .ble-dbg,esc2a を削除 [2013-06-09 00:32:04]

  * ble-edit.sh (complete-filename): 引数が一意に確定した場合、
    ディレクトリ名の場合には後に / を挿入し、それ以外の場合には SP を挿入する様に変更。
    今迄はディレクトリ名であっても後に / を挿入していた。
    [2013-06-08 16:50:34]

  * <bug> ble-decode-kbd: '*' を変換しようとすると、ファイル名展開が実行されてしまう。
    仮定: * や ?, - が含まれるような single-key 指定は、
          必ず最後の一文字だけが * や ?, - 等の特殊文字である。
          それ以外の指定を行った場合の動作は保証しない。
    仮定: C- 等のような中途半端な指定は C-- と解釈される。
    [2013-06-08 16:01:32]

  * keyflag の定義を emacs と同じ物に変更。
    Meta=1<<28 Ctrl=1<<27 Shft=1<<26 Hypr=1<<25 Supr=1<<24 Altr=1<<23

  * <bug> ble-decode-kbd: C-- や - 等を正しく変換する事が出来なかった。


2013-06-06

  [Done]

  * 取り敢えず色付け関数

  * <bug> C-c: プロセスを停止した直後、プロンプトが表示されない
    [完 2013-06-07 03:52:15]

    これは accept-line の処理が中途半端になったまま終了してしまうからである。

    + C-c 等でプロセスを停止した時に 正しく終了されるか?
      →正しく終了されていない様である。

    先ず何か入力するまでプロンプトが表示されない。
    (但し、^? などに対してはちゃんと読み取れる様である。
    ^? でも何でもいいから入力をすると復帰する。)
    これは accept-line の後の .ble-edit-draw.redraw が実行されていない為であろう。

    適当に trap 'echo hello' INT とすると、
    続きが実行される様になった。因みに hello の文字列は何処かに消える?
    なので trap : INT 等とする事にする。
    (既に存在している trap を上書きしてしまう事になるが仕方がない。)
    [2013-06-07 03:19]
    
    と思ったが、実際に試してみると、シェルの処理で重い場合に C-c をすると
    trap : INT や trap 'echo hello' INT 等としていた場合にシェルの応答がなくなってしまう
    という事が分かった。因みに trap を何も仕掛けていなければ正しく終了する。

    と、思っていたが trap return INT にしておけば一応問題は起こらない様だ。
    [2013-06-07 03:52:15]

    <del>しかし trap 'return 128' INT にすると今度は return は関数内でなければ
    使えないというエラーメッセージが表示される。</del>
    どうも trap を定義した場所が関数内なら return を書いてもエラーは出ない様だ。
    なので、.ble-edit.accept-line.exec.eval 内で trap をする事にした。
    しかし、return 128 等としても戻り値は常に 0 となる様子なので、
    _ble_edit_accept_line_INT という変数を介して 128 の値を返す事にした。
    [2013-06-07 04:12:50]

  * <bug> readline の accept-line をしない限り $? が設定されない?
    前回のコマンド実行の $? を何処か別の変数に覚えておいて、
    次のコマンドを実行する直前に設定し直せばよい。
    設定するには、return で好きな値を返すだけの適当な関数を作って、
    その関数を呼び出せばよい。
    [2013-06-07 02:20:26]

  * <bug> .ble-edit-comp.complete-filename: 変数リーク ret [2013-06-07 02:02:07]

  * <bug> return による accept-line 中断
    [2013-06-07 02:09:41]

    C-c や C-z をした時の様に、
    コマンドライン中に return が含まれていた場合にも同様の事が発生する。
    これについてはコマンドを実行する際に一つ関数にくるんで実行すればよい

  * ジョブ管理にアクセスできるか?
    問題なくアクセスできるようである。

  * accept-line: 存在しないコマンドでも history に追加される。
    [キャンセル 2013-06-07 01:55:03]

    history に追加する前にそのコマンドが存在するか確認。
    そもそも存在しない・実行できないコマンドに対しては history への追加を省略する。

    存在するかどうかの確認は type で確認できる物、及び、for などの文法要素?
    →試しに for を type -t に入れてみたら keyword となったので、
      for 等を特別に区別する必要性はない。

    と改めて調べてみたら、元々の bash でも存在しないコマンドもちゃんと history に追加されていた。
    なのでこれについて解決する必要性はない。

  * <bug> accept-line: [完 2013-06-07 01:53:25]

    ret 変数に値を設定できない。
    というか、accept-line を呼び出すまでにネストした
    関数で local として宣言されている変数名は全て使えない…。

    a. accept-line は呼出のネストの浅い所で実行する?
       (例えば ble-decode-byte などで)
    b. 内部変数として使用している変数名を重複の無い物 (_ble_* を予約) にする?

    a. の方針で行くとしたら、呼出が開始された一番浅い場所を見つける必要がある。
    ble-decode-byte から ble-decode-char, ble-decode-key と呼び出される過程で、
    何処が一番初めに呼ばれたかを判定するのは難しい。

    ble-decode-byte:bind が起点になる場合は明らか。
    ble-decode-char が起点になるかどうかの判定は難しい。
    代わりに内部の呼出では .ble-decode-char を使う事にして、
    外部からの呼出 (起点) では ble-decode-char を使い、
    ble-decode-char は .ble-decode-char の呼出 + 修飾処理、という事にすれば良い。

    従って、書き換えは
    1 全ての ble-decode-byte, ble-decode-char, ble-decode-key の内部呼出を
      .ble-decode-byte, .ble-decode-char, .ble-decode-key に書き換える。
      また、それぞれの関数名も書き換える。
    2 ble-decode-byte, ble-decode-char, ble-decode-key を定義し、
      中で .ble-decode-byte, .ble-decode-char, .ble-decode-key を呼び出すと共に、
      その他の前後の処理を追加する。
    という手順で行えば良い。

    先ず、ble-decode-byte は内部的には何処からも呼び出されていない様である。
    ble-decode-char は ble-decode.sh 内にしか存在しない。
    ble-decode-key は ble-decode.sh が殆どで、ble-edit.sh に一箇所だけ存在する。
    これらを書き換えて、呼出の起点に近い場所で実行するように変更した。

    しかし、未だ漏れている変数が存在するようだ。以下の変数は値が漏れている。
    arr file line ret spec

    spec: .ble-edit.history-add
    line: .ble-edit.history-load, ble-decode-bind
    file: .ble-term.initialize
    arr: ble-getopt
    ret: ble-edit+self-insert, ble-decode-bind, ble-bind,
      ble-decode-unkbd 定義直後にテストコードが残っていた
    _getopt_*: ble-bind

  * <bug> ble-decode-byte+C: 文字コードとして空文字列を返していた。
    [2013-06-07 00:51:25]

  * C-c 等でプロセスを停止した後、次のコマンドを実行するまで行が二重化する
    [2013-06-07 00:19:05]

    C-c でプロセスが失敗した後に accept-line を押すと line が二重に表示される。
    これは実際に別のコマンドが実行されるまで続く。
    多分、これも stty の設定が変化しているから?
    多分エコーの設定が有効になっている為に、
    C-j/C-m が入力された時に行の位置がずれてしまうからだろう。

    これは空コマンドだった場合にも .ble-stty.enter を実行すればよい。
    というか寧ろ ble-decode-byte:bind 辺りで実行しても良いかも知れない。

  * <bug> accept-line: 時々コマンドを実行した時に現在位置が上の方に移動してしまう。

    <del>どうも accept-line を実行した時に、カーソル直前に存在する文字が
    特殊文字であるとこの現象が発生するようである。</del>

    どうも特殊文字でなくても、カーソルの位置が line の最後の文字以外に置いてある時に、
    この現象が発生するようである。そして特殊文字を入力する時は大抵、先に引用符を書いておいてから、
    引用符の中に入って特殊文字を入力し、そのまま accept-line する為に、この条件に該当する。

    そしてこの条件が該当しそうな箇所が .ble-edit-draw.goto-end にある。
    と思ったら、_ble_line_cury に x 座標を代入していた。
    [2013-06-06 23:57:43]

  * <bug> カーソルの表示位置がおかしくなった
    construct-line で変数名を変更したのに、それを参照している construct-line.chk-cursor で
    変数名の変更していないのが原因だった。
    [2013-06-06 23:38:24]

  * <bug> \\ や \$ が含まれる時の位置計算が誤っている。
    [2013-06-06 23:37:21]

  * .ble-line-info.clear: 既にクリアされている場合は動作を省略 [2013-06-06 23:05:49]

  * discard-line, accept-line: 実行の前に .ble-line-info.clear [2013-06-06 23:06:17]

  * construct-prompt: シェル変数 x y lc に計算結果を直接書込をする様に変更。
    [完 2013-06-06 23:05:09]

    + キャッシュ情報は 配列 _ble_line_prompt に記録する事にした。
      _ble_cursor_prompt__LINENO, _ble_cursor_prompt__RESULT の変数を廃止
    + 呼出元を調整。

  * complete 候補一覧を表示
    取り敢えず表示するだけ表示 [2013-06-06 18:07:53]

  * ble-decode:
    ble-edit-bind の部分にあった bash に対する bind のロジックを
    ble-decode.sh の方に移動させる事にした。
    [2013-06-06 17:41:05]

  * isearch: C-d を押した時に空欄だと即座に終了してしまう。
    (C-d に delete-char-or-exit が設定されている場合)。
    なので、isearch で C-d を押した時は isearch モードを抜けてから
    唯の delete-char を実行する様に変更。
    [2013-06-06 17:40:50]

  * C-x に対する hook

  * ble-bind
    ESC → Meta が自動的に実行される様になったので、
    Meta について改めて登録する必要はなくなった。ので、その機能は削除。
    [完 2013-06-06 17:18:33]

  * <bug> ble-decode-char
    [完 2013-06-06 17:02:07]

    M-delete 等の操作が正しく key に翻訳されていない。
    これは ESC を meta に変換する機能を入れても入れなくても同様。
    更に ble-bind -k で Meta の付いた物を自動的に登録しても登録しなくても同じ。

    と思ったらそもそも ble-decode-char 自体に二つ連続した ESC は入ってこない様だ。
    screen または bash bind -x で消えてしまっている可能性がある。

    + 試しに bashrc 内で bind している '[D' と '[C', '[3;5~' を削除してみた。
      削除自体は正しく出来たようだが、依然として '' は消えた儘になっている。

    +  /etc/inputrc を見てみたが '\e\e' に関係する物は設定されていない。
      また、~/.inputrc は作っていなかった。

    + .screenrc を見てみたが C-M-tab に windowlist を割り当てている以外は怪しい所はない。
      それに emacs を起動している間はちゃんと ESC ESC を入力する事が出来ているのだから、
      screen は犯人ではない。やはり bash が怪しい。

    A 仕様がないので、直接 "" に対して bind を実行してしまえばよい。
      其処で bind -x '"":ble-decode-byte:bind 27 27' として見たが、
      そうすると今度は ESC ESC を受け取った時に、
        bash: bash_execute_unix_command: コマンドのキーマップがありません
      というエラーが発生してしまう。

    B 取り敢えず、苦肉の策として ESC ESC を何か別の物に変換して受信する事にした。
      ble-bind -k 'ESC [ 2 7 ^' __esc__
      ble-bind -@f __esc__ 'ble-decode-char 27'
      bind -s '"":"[27^[27^"'

      と思ったら、何故か "ESC ^ ^ ESC ^ ^ [ 2 7 [ 2 7" という謎の順番で受信される。訳が分からない。
      bind -s '"":"[1027~[1027~"' に変えてみたら、
      "ESC 2 2 7 ~ ESC 2 2 7 ~ [ 1 0 [ 1 0" となる。^ が悪かった訳ではない様だ。
      文字数の問題?
      bind -s '"":"[^[^"' → "ESC ESC ESC [ ^ [ ^"
      どうやら ESC 後の 3 番目の文字が繰り返される様である?
      bind -s '"\e\e":"\e[^\e[^"' → "ESC ESC ESC [ ^ [ ^" # bind で文字化けしているのかとも思ったがそうではないようだ。
      bind -s '"\e\e":"\e[~"' → "ESC [ ~ ESC [ ESC ESC ESC ..." # 理解不能

      もしかして、ble-decode-char の方のバグだろうか。。
      今度は ble-decode-byte の方で出力を行ってみる事にした。
      "[27^[27^" → "ESC ^ ESC ^ [ 2 7 [ 2 7"             この時点で謎
      "[1027~[1027~" → "ESC 2 7 ~ ESC 2 7 ~ [ 1 0 [ 1 0" ~ でも駄目
      "[^[^" → "ESC ESC [ ^ [ ^"                         短くしても駄目
      "[1027^" → "ESC 2 7 ^ [ 1 0"                         単体の ESC でも発生する
      "\e[~" → "ESC [ ~"                                     これは正しく受信されている
      "\e[^" → "ESC [ ^"                                     これも OK
      "\e[7^" → "ESC ^ [ 7"                                  これは駄目
      "\e[?^" → "ESC ^ [ ?"                                  これも駄目
      "\e[?~" → "ESC ~ [ ?"                                  これも駄目

      取り敢えず ESC を含んで 3 文字以上のシーケンスが何故か化ける様なので、
      3文字 で "ESC [ ^" とする事にした。
      これで受信される物は正しくなったと思われる。

    + BUG 受信しているバイトは正しいが ble-decode-char が正しく処理してくれない。

      動作を見ていると ESC [ ^ を受け取った時点で __esc__ が生成されている。
      そしてその直後に M-[ が出力されている。
      更に次の "[" を受け取った時に再び M-[ が出力される。

      一つの原因は、_ble_decode_key__seq をクリアしない内にコマンドを実行している為、
      コマンドの内部で新しいキーが来た時に _ble_decode_key__seq に追加されて処理されてしまう事である。
      これは、コマンドを実行する前に _ble_decode_key__seq= とする事で解決する。
      基本的にコマンドを実行する時には、ble-decode-key の内部状態を終了状態と同じにしてからにするべきである。
      要するに破壊的操作を全て終えてから、コマンドを実行する、という事。

      ble-decode-key の中の _ble_decode_char__seq についても同様である。
      これを修正した所、どうやらちゃんと期待通りに動くようになった。

  * ble-decode-char
    ESC を meta に翻訳するのは自動にするべき。
    例えば M-あ などまで考慮していたら、全てを登録し尽くす事は無理なので。

  * <bug> ble-decode-key でシーケンス全体の一致に失敗して、
    部分一致に成功した時、一致部分の直後のキーが失われる。
    これは 一致した場合に ble-decode-key "$fail" を実行せずに関数を抜けていたのが原因である。
    依然 ble-decode-char で起こったのと同様の問題点。
    その時には ble-decode-key には問題がないと判断したが、問題は在ったようだ。
    [完 2013-06-06 16:58:25]

  * <bug> ble-edit-bind: "\e ": set-mark を unbind できていない。
    [完 2013-06-06 15:26:53]

  * ble-edit-bind: bind -s についても表示できるから、これについても全て unbind する。
    [完 2013-06-06 15:26:48]

  * <bug> ble-bind -d
    -m isearch 等を用いて登録したキーシーケンスが表示されない。
    現在登録されている kmap 名のリストを追加して、
    ble-bind -d で全ての kmap について表示するように変更した。


2013-06-05

  [Discussion]

  * COMP_KEY
    bash の manual には最後のキーとあるが、
    文字で表現するのか、名前で表現するのか文字コード (?) で表現するのか分からない。
    実際に、適当な関数を登録して確かめてみると良いだろう。

    →試してみた所文字コードが表示された。
      更に function キーに complete を割り当てて試してみた所、
      バイトシーケンスでの最後のバイトが渡される様である。
      (しかし、これでは不便? な気がするので、独自解釈で ble の keycode を用いる事にする。
      その際に C-* 系統の物は変換した方が良いかも知れない。)

  [Done]

  * visible-bell: 鳴った瞬間だけ緑色に点滅する様に変更。
    これで連続で visible-bell が鳴った時でも見た目に分かる。

    # + 鳴った瞬間だけ赤くして直ぐに暗くする

  * <bug> isearch: self-insert で単に入力しているだけなのにどんどん遡ってしまう。
    self-insert の時には現在行から一致を初める様に変更する。
    [完 2013-06-05 23:42:37]
  
  * <bug> quoted-insert, v だとか q が挿入される
    これは self-insert の仕様変更について行ってなかったのが原因。
    代わりに insert-string を使う実装に変更した。
    [完 2013-06-05 19:57:59]

  * clear-screen: vbell の削除トラップをクリアする
    [完　2013-06-05 19:18:02]
    
  * isearch: arr の top が行き先と同じであれば、arr に push せずに pop する
    [完 2013-06-05 19:03:41]

  * isearch: 表示位置への移動などをもっとまともな物に変更する。
    [完 2013-06-05 18:47:07]

  * isearch: 終了時に isearch の表示を消す
    [完 2013-06-05 18:47:17]

  * isearch: prev でもうこれ以上戻れない時、isearch から抜けない
    [完 2013-06-05 18:48:15]

  * c2w 二分法: 0-161 の間の文字が怪しい?
    + 初めから範囲にない場合 (0-161) の場合は先に除外するべきだった。
    + l&1 を括弧で囲む必要があった。
    + while の条件は l<u ではなく l+1<u であった。
    [完 2013-06-05 18:27:32]

  * ble-core.sh (.ble-print-visible-bell): .time 削除で date +%s の値が overflow しない様に
      部分文字列を取りだす部分が間違っていた。
    [2013-06-05 16:14:46]

  * ble-core.sh (.ble-print-visible-bell): SC, RC を頻繁に使うので、後で変更しやすいように
    _ble_term_sc, _ble_term_rc 定数に定義。
    [2013-06-05 16:14:46]

  * __defchar__ は制御文字には適用しないように変更


2013-06-04

  [Done]

  * <bug> どうも履歴の動作が怪しいような気がする。
    C-p C-n で動くと変な出てき方をする…気がする。
    それに先程実行したはずのコマンドが出てきたり出てこなかったりする。

    →と思ったら history-add で実際に登録される場合だけ
      _ble_edit_history_ind, _ble_edit_history_edit を初期化していた。
      それ以外の場合は、前回の履歴位置・編集内容をそのまま使う事になっていた。
      そうすると例えば、前回履歴を遡って実行したコマンドは空白に変化し、
      また、現在の履歴の位置も途中の場所にいたりと変な事になる。

    [完 2013-06-05 02:50:10]
      
  * vbell:
    ble.sh をロードした時に、
    古い .time ファイルは全部削除する機能をつける。

  * ble-bind -c: meta も登録する
    → 完了 2013-06-05 02:40:02

  * ble-bind 引数はシェル変数で渡す様にした方が良い? (-f オプションの削除)
    + self-insert は KEYS[0] シェル変数を用いる様に変更した。
    + f オプションの削除

  * ble-bind -c, -k オプションの名前を変更する
    → それぞれ -k, -f に変更した。2013-06-05 02:40:06

  * bug? bind
    何と " を bind する事ができていない。
    と思って改めて試してみたらちゃんと bind されている??
    取り敢えず保留という事にする。

  * <bug> 次のコマンドを実行するまで prompt が更新されない
    CMD ではなく LINENO を参照するように変更
    
  * abell はロックするので vbell の後に送信するべき [完 2013-06-05 01:25:27]

  * 矢印キーなどの動作を取得する事が出来るかチェック [完 2013-06-05 01:25:41]
    (1) ESC で始まるシーケンスを全て削除する?
        試しに全て削除してみたら、(自分で bind -x で設定した物を除いて、)
        上下左右のキーや function キーも効かなくなった。
        ので、C-[ さえ bind -x してしまえば恐らく処理できると思われる。

        → source されたスクリプトの中で bind -r を実行しても削除されない?
        と思ったら bind の時は必要だった引用符 " が、bind -r の時には不要だった。

    (2) ESC に bind できるか?
        一応 ESC には bind できているみたいだが、delete を押してもそうと認識されない。
        しかも二回に一回だけ通常の文字列として delete が入力される。
        奇数回目の delete は何処へ行っているのか?

        ble-decode-key の受信する key を見てみた所、
        delete を入力した直後には ble-decode-key には delete が来ない。
        その次の文字を入力すると ble-decode-key に delete が渡される。
        その後に続く文字は一文字ずつ分解されて届く様である。

        先ず、問題点として
        a. ~ を受け取った時点で delete に確定している筈なので、
          その時点で delete が届かないのがおかしい
        b. また、delete が受信された後の文字が単体で必ず decode-key に渡ってくるのが問題である。
        c. delete は処理されなかったはずなのに、その事を表すエラーメッセージが表示されない

    + BUG: delete が届かない? [完 2013-06-05 00:00:50]

      と思って実際に初期化が終わった後の cmap を見てみたら
      最後の文字なのに「継続あり」の _ がついている。
      .ble-decode-char.bind を見たら条件が反対になっていた。
      (.ble-decode-key.bind の方は大丈夫かと思ってみたら大丈夫だった、
      .ble-decode-key.bind に合わせる形の方向で修正した。)

      ** デバグの為に一時的にバグ状態に戻してある **
      →他のバグも解決したのでこれはまた修正した。

    + BUG: 曖昧文字の失敗後に、その失敗に関連した文字がすぐに送信されてくる?
      [完 2013-06-05 01:25:41]
    
      と思って手でエスケープシーケンスを入力したりしてみたが、少し違うようだ。
      delete ESC [ まで入力した段階では delete までしか出力されていない。
      ここまでの動作は正しいが、次に A を入力した時点で、
      ESC [ A がその儘出力されて出て来る。

      本来は ESC [ A は up と翻訳されて欲しい。
      _ble_decode_cmap_* を見てみたがここの部分は問題ない様に見える。
      (a. の方の BUG の事を考えると、本当は ESC [ A だけでは未だ出力されないはず…。
      そして実際に、先行する delete がない状態では ESC [ A を送信してもその時点では何も出力されない。
      従って、cmap の問題ではなく内部状態に何らかの異常が出来ていると考える方が自然である。)

      と思ってみてみた所、delete ESC [ まで入力した段階では、
      実は未だ ESC [ は bash まで届いていない? 様である。
      screen だか或いは途中の何かが文字を止めているという事だろうか。。
      (と、ここで screen に C-TAB = [9;5^ に対する hook をかけているという事を思い出した)。

      そして、ble-decode-char は delete のシーケンスが残っている状態で
      ESC を受け取った時にそれを組み立てずにそのまま出力しているらしい。
      要するに奇数回目の入力と偶数回目の入力で何が違うかというと、
      偶数回目の入力の一番初めの文字 ESC が到着した時には、
      未だ奇数回目のシーケンスが残留しているという事である。

      という所で、怪しい部分を発見したが…その部分は今回と関係ないような気もする。
      しかし取り敢えず、その部分を修正する (余分な return を消す)。すると今度は、
       ble-decode-key に渡される key 自体は何も可笑しい所がないように見えるのに、
      実際に編集文字列に現れてくる文字列には違う入力されている。。
      先にエラーメッセージが表示されない謎を解決した方が早いかも。

      下のバグを解決したらこちらのバグも解決した。先程の修正で良かった様だ。
      今迄 ESC [ A が裸で出力されている様に見えたのは勘違いで、
      1 delete のシーケンスが残っている状態で ESC が来ると、
        delete だけ出力されて ESC は出力されずに終わる (一つ目のバグ)。
      2 delete のシーケンスが化けて (二つ目のバグ)
        (1) で出力し損ねた ESC になって、self-insert で入力される。
      という流れになっていたのだった。つまり
        ESC [ A ESC [ A
        ~~~~~~~~~~~
        delete      [ A
        ~~~~~~
        ESC         [ A
      と言う風に変換されていたのだった。


      因みに .ble-decode-key.emit の方には同様のバグがないかと確認してみたが、
      その様なバグはなかった。ちゃんと余分な return は消されていた…。

    + BUG: 知らないシーケンスが届いた筈なのにエラーメッセージが表示されない。
      [完 2013-06-05 01:13:43]

      と見てみたら、すぐに気付いた。「知らないシーケンスが届いた時に "$key" 単体を
      文字と解釈できる場合には __defchar__ で処理する」という所で $key の代わりに $fail と
      書いていた。そしてこの $fail は呼出元の ble-decode-char の $fail を参照して、
      出力していない筈の文字を出力してしまうという事になっていた。

      これで解決できたと思ったら、今度は up が変な文字として入力されてしまう様になった。
      これは __defchar__ で処理するのは unicode の16面までという制限をかければ良い。
      0x110000 という定数が何回か出てきたので ble_decode_function_key_base という定数として定義し直した。
      これを用いて文字として解釈できる unicode の範囲を絞って扱う事にした。
      
  * <bug> history add したコマンドの \ が消えている。
    [完 2013-06-04 23:26:03]

    どうやら読み込む時に read が勝手に \ を消しているようだ。
    read に勝手に \ を解釈されたくなければ read -r とする。
    登録・書込の方には問題はないようだ。

    他にも read を使っている所があるのでそれについても修正をする必要がある。

  * <bug> .ble-edit.construct-prompt: \w でホームディレクトリ以下のパスが  ~// となる。
    [完 2013-06-04 23:05:35]

    ~ に続きがある場合に / を追加する様に書いていたが、
    良く考えたら ~ に続きがある場合には / がどうせ先頭になっているので必要なかった。

  * <bug> HISTIGNORE の値に反して一文字のコマンドが history に追加されている
    [完 2013-06-04 22:50:16]

    単に配列変数の名前を間違えていただけだった。

  * <bug> (.ble-edit.construct-prompt): \! (HISTCMD) が常に 1
    これは bind -x で登録された関数から見るとこうなってしまうという事なのだろうか。
    代わりに _ble_edit_history の要素数を返せば問題はないだろう。
    [完 2013-06-04 22:43:49]

  * <bug> ble-decode-byte を直接呼び出すと PS1 の値が破壊される
    [完 2013-06-04 22:32:33]

    PS1 が解除された状態で ble-decode-byte が呼び出され…?
    調べてみた所、ble-decode-byte の中で PS1 を代入していた。

    良く考えてみたら、再描画や adjust-cursor 等の呼出は、
    直接コマンドを叩いて呼び出した時には必要のない物である。
    なので、bind -x する時専用の ble-decode-byte を作って、
    その中で PS1 の設定や再描画、カーソル位置微調整を行えば良い。
    →その様に変更した。

  * suspend した時にどうなるか?

    特に問題が生じるという訳でもない様だ?
    但し、以下の点については意識する必要がある。

    (1) stty の設定がどうなっているか
        [完 2013-06-04 20:34:42]

        <del>恐らく stty を復元したままになっている。
        従って ^W ^U 等の操作を行う事ができないと思う。</del>

        <del>直後に直すのは諦めるとしても、
        次に ^W ^U など以外の文字が入力された時に、
        stty の状態を確認して元に戻すという事はするべきである。</del>

        と思っていたらどうやら suspend で止まった場合でも、
        スクリプトの続きから開始される様である。
        つまり、accept-line の後半部分も suspend の直後に実行される。
        なので何の問題も生じない。

    (2) コマンド履歴に suspend したプロセスが追加されていない。
        [完 2013-06-04 19:54:07]
        
        コマンド履歴に追加される前にコマンドが実行されている。
        これは登録を先に行うように変更するだけでよい。

        (但し bash ではコマンド見付からなかった場合には、
        コマンド履歴に追加されないようになっている。
        コマンドを実行に移す前に予め、
        そのコマンドが存在するかどうかぐらいは判定しても良さそう。)
    
    (3) 編集中のコマンドが残っている [完 2013-06-04 20:36:18]

        これも編集文字列をクリアする前にコマンドを実行しているからである。
        コマンドを実行に移す前に編集文字列をクリアする事にする。

  * ちらつきを抑える方法: 最初に再描画 [完 2013-06-04 18:32:52]
    ble-decode-byte に入った瞬間に .ble-decode-key.redraw を実施する?
    その時は、前回から内容が変わっていない筈なので、前回保存した情報をそのまま出力すれば良い。
    そして呼出が終わった後に変更があればその時点で再描画をまた実行する。
    
    + BUG: prompt の表示が省略されている [完]

      → 前回保存した内容が prompt 表示を省略する物だった為
      → prompt 表示の省略をしない物をキャッシュに入れておく事にした。

      関数 redraw-cached は「フル」で表示し直すが内容は「前回」のまま、という関数である。
      ので、表示の省略などは行わないので、この方法で良い。

    + BUG: 前回の残像が残っている [完]

      redraw をする際に前回表示した内容を消していないので残ってしまう。
      これは .ble-edit-draw.redraw, .ble-edit-draw.update でも同様に起こりうる問題である。
      (今迄は bash が1行目を勝手に消していたので気付かなかっただけである。)

    + BUG: 表示が滅茶苦茶になる

      原因は色々あった。
      事。
      "前回の表示内容" に関しては保存していたが、
      その内容を出力した際に現在のカーソルが何処に移動するかといった情報を保存・復元するのを忘れていた。
      唯単に前回の表示内容を出力しただけだと、内部的にカーソル位置が先頭から動いていない事になっている。
      なので、ちゃんと "前回の表示内容" を保存すると共に、その内容を表示した時にカーソルが何処へ移動するか等の情報も保存するように変更した。

    何とか、前回の表示内容を再度出力する物が完成したので、昔のコードは削除する。
    | function ble-decode-byte {
    |-  # bash によって描画された物が全部消されている
    |-  # .ble-edit-draw.set-dirty -1
    |+  .ble-edit-draw.redraw-cache

    これでちらつきはかなり改善された。

    しかし、ちらつきが全くないと迄は言えない。もし気になる様だったら

  * bug unkbd [2013-06-04 17:59:04]

    配列への追加で、添字に ${#kbd[@]} とするべき所 ${kbd[@]} としていた。

  * LINENO が更新されない?
    →これは一回 unset LINENO してから自分で設定すればよい。

    どうせ自分で LINENO は管理しなければならないのでこの方法でよい。


2013-06-04, X6

  stty 関連 (tty が制御文字を奪うという事) [2013-06-04 13:33:26]

  * tty の設定で動かなくなるキーと tty で設定されていても動くキーがある。
    よく分からないので表にする事にする。
  
    ^S ^Q
      →stty で外すか -ixon の設定にすれば OK
        基本的に -ixon の設定で行く方針。常にこの状態という事にする。
  
    ^C
      →bind する時は stty intr "" でも問題ない。
        然し、実際に使う時には stty intr undef でないと読み取れない。
    ^Z
      →^C と同様 bind 時はどちらでも問題ない。
        実際に読み取りの時は stty susp undef でないと駄目。
    ^\ (quit) も ^C や ^Z と同様である。
  
    ^V
      →bind する前に stty lnext undef する必要がある。
        bind した後も stty lnext undef の儘保持しておく必要がある。

    ^U (kill) ^W (werase) も ^V と同じである
  
    ^?
      →bind する間だけ stty erase undef し、
        <del>その後で stty erase "" などと復元すれば良い?</del>
        と思ったが何故か stty erase undef でなくても動いたり、
        stty erase undef でないと動かなかったりよく分からない。
        取り敢えず ^V の時と同じようにずっと erase undef の儘にしておく事にする。

  
    <a href="http://lists.gnu.org/archive/html/bug-bash/2004-08/msg00157.html">'bind "\C-?": delete-char' does not work any more</a>
  
    ※文字列編集中だけ外されている stty 項目がある可能性?

    #              | key    bind  read
    # -------------+-------------------
    # -ixon        | ^S ^Q  
    # kill undef   | ^U     必要  必要
    # lnext undef  | ^V     必要  必要
    # werase undef | ^W     必要  必要
    # erase undef  | ^?     必要  必要
    # intr undef   | ^C     不要  必要
    # susp undef   | ^Z     不要  必要
    # susp undef   | ^\     不要  必要
    # -------------+-------------------

  * ^? が偶に bind 出来ないように見える問題

    どうやら一回目に stty を解除して bind に挑戦すると失敗している様で、
    二回目に bind に挑戦すると成功している様だ?
    再度 stty の設定を元の状態に戻して ble.sh を設定してみたら、
    ^? ^U ^V ^W の四つについて bash の bind が機能していないという事が分かった。

    改めて bind -x '"":ble-decode-byte 127' を手で入力してみた所使える様になる。
    やはり stty を設定した直後には bind を設定する事が出来ないという事だろうか。

    色々試してみる
    (1) stty の後に適当に echo するとどうなるか?
        →適当に echo するだけでは駄目なようだ。

    (2) stty の後に sleep で待ってから設定するとどうなるか?
        →sleep で待っても駄目なようだ。

    (3) stty の後に >/dev/null で適当な文字列を書き込むとどうなるか?
        →やはり駄目。

    (4) read -n 1 で適当に文字を読み取るとどうなるか?
        →これでも駄目だった。

    (5) subshell ( date ) を呼び出す
        →駄目

    もしかして source ble.sh で一つのコマンドとして実行しているから設定が有効になっていないという事だろうか?
    後、一回 exit してから入るとうまく行くのは、C-d で exit する直前に .ble-stty.leave していなかったからであった。
    或いは bashrc 等のスクリプトから実行するとうまく行くのかも知れない。

    仕方がないので現状では .ble-decode-byte:bind で、
    既に ^U ^V ^W ^? に bind しているかどうか確認して、
    設定されていない様だったら設定を行う様にする事にした。

  * C-@: 効かないと思っていたら bind できていない [完]

    bind -x '" ":ble-decode-byte 0'
    →確かにこれでは bind できない
      bind は '"' という文字列を受け取ったと勘違いする。

    bind -x '"\C-@":ble-decode-byte 0'
    →これで正しく bind 出来るようになった。

  * 全ての文字を入力可能かどうか確認

    C-@ OK (bind する時に直接 ^@ の文字を引数に指定できない事に注意)
    C-a OK
    C-b OK
    C-c OK (stty intr undef)
    C-d OK (READLINE_LINE にダミー文字を設定。可成り苦労した…)
    C-e OK
    C-f OK
    C-g OK
    C-h OK
    C-i OK
    C-j OK
    C-m OK (stty の改行変換周りで状況が違うかも?)
    C-n OK
    C-o OK
    C-p OK
    C-q OK (stty -ixon)
    C-r OK
    C-s OK (stty -ixon)
    C-t OK
    C-u OK (stty kill undef)
    C-v OK (stty lnext undef)
    C-w OK (stty werase undef)
    C-x OK (二文字の組合せで bind すれば良い)
      * 直接 bind すると C-x に続けて何かの文字を打った瞬間に
        bash が segmentation fault する
      * C-x ? (? = \0 - \377) の組合せで全て登録しておけばよい。
        (恐らく C-x は C-x とそれに続く何らかの文字の組合せでしか使われないだろう。
        その場合にはこれで問題はない。)

    C-y OK
    C-z OK (stty susp undef)

    C-[ OK
      * 単独の C-[ は通常通りに bind するだけで OK。
      * C-[ C-[ の並びは何故か受信できないので、
        bind '"":"[27^[27^"' 等として、
        一旦別のシーケンスに翻訳してから受信する必要がある。

    C-\ OK (stty quit undef)
    C-] OK
    C-_ OK
    C-^ OK (.bashrc で設定しているのを解除する必要はある)
    C-? OK (stty erase undef)


2013-06-04, X5

  C-x に bind -x すると死ぬ [2013-06-04 09:42:42]

  * 先ず第一に、C-x に対して bind しても、
    単体の C-x に対して bind で指定したコマンドは呼ばれない。
    (bind -r で予め元々登録されていた関数を全て削除しても同様である。)

  * 更に続けて何らかの入力をした場合、
    その sequence が bash bind で何も割り当てられていなかった場合、
    bash が segmentation fault で落ちる。

  * C-x は単体では割り当てられず、
    必ず C-x hoge の形で入ってくるとするならば、
    C-x ではなく C-x ? に対して bind をすれば良い。


2013-06-03, X4

  history にアクセスする方法 [2013-06-03 08:19:09]

  * history -s で値を設定する事が出来る。

    但し、これは最新の履歴を置き換える形でしか追加する事が出来ない?
    と思ったが、最新の history -s コマンドを置き換えるだけであって、
    昔の履歴を削除する訳ではない様だ (多分)
    →実際に試してみた所期待通りに動いている様なので良しとする。

  * また history -s は HISTIGNORE に該当する物に関しては削除するようだ。
    なので HISTIGNORE などについての特別な配慮は要らず、
    とにかくコマンドを history -s で追加すればよい。

  * 次に isearch で history コマンドを検索する時にどの様にするのが良いのかという事。
    history | grep だと結構処理に時間が掛かりそう
    といって history の内容を何処かの配列に出してくるのも大変な気がする

  * また history 中のコマンドに改行が含まれていた場合、
    検索などの結果が乱れてしまう事になる。

  * 何故か、プロセス置換の中で history を呼び出すと HISTTIMEFORMAT= が有効にならない。
    cat < (HISTTIMEFORMAT=A history)  # 効かない
    cat < (HISTTIMEFORMAT=A; history) # 効く
    

2013-06-02

  [Done]

  * source 直後の prompt は PS1 をそのままに。
    未だ一度も呼ばれていないのでそもそも自前でプロンプトを表示していない。
    →分かりにくいのでやめた。
      ble.sh の最後に、自分自身で明示的にプロンプト描画関数を呼び出す事にした。

  * quoted-insert C-@ の扱いについて
    →bash でも元から入力できない様なので気にしない
      self-insert で文字コード 0 を渡された場合には無視

  * 取り敢えず実装する物:
    現在の編集行を表示する機能?
    →これは暫定的に唯 print するだけの物でよい。

  * ble-decode-key, ble-bind:
    コマンドが設定されていない時の既定のコマンドを指定できる様にして、

    其処に self-insert を割り当てていたが、この様にしておくと、
    self-insert で変な文字が入力されてしまう
    (一応 self-insert 中で flag は外す様にしているが)。
    更に、どんなに変な操作をしてもエラーメッセージが表示されない。

    本来コマンドが設定されていないとしても flag の付いていない "文字" だけを
    self-insert で処理するべきである。従って、"文字" に対してだけ既定のコマンドを
    適用するように変更する。これは "文字" だけの既定動作なので変数名としても
    __default とするのは気分が悪い。其処で新しく __defchar__ という名前の keyname/keycode
    を定義し、そのキーに対してコマンドが定義されている場合に、"文字" をそのコマンドで処理するように変更した。

    また、空文字列の bind 呼出で __default に値を設定できる機能は削除した。
    <del>空文字列を指定した場合は、既定の動作を指定する。</del>

  * ble-decode-key:
    と思ったが、isearch-map 等を定義する時には、bind されていない key を指定した場合には、
    通常のモードに復帰してそのモードでの操作を実行したいから default の機能は使用したい。
    また、前の様な実装に戻す事も出来たが折角 __defchar__ を定義したので、
    それと同じ方式にした方が良いだろう。と言う事で __default__ というキーを定義する事にした。


2013-06-01

  [現在の実装状況]

  ble-getopt
    取り敢えず枠組は完成している。
    後で拡張を行う余地はある。

  ble-decode
    ble-decode-byte
    ble-decode-char
    ble-decode-key

    ble-decode-bind
    ble-decode-kbd
    ble-decode-unkbd

  ble-text 文字幅
    例えば → 8594 が曖昧幅の文字である。
    設定の名称をどの様にするか
      narrow/wide/emacs
      west/east/emacs

  [Done]
  * ble-decode: ble-decode-* 関数の実装
  * ble-getopt.sh: 短形式オプション引数 (':' 区切) で、'::' の様に、
    区切が連続する場合に、正しく空引数として認識するように変更。
  * mwg.text.getCharFromCode, mwg.text.getCharCodeAt:
    それぞれ .ble-text.c2s, .ble-text.s2c に名称変更。
  * .ble-text.c2s:
    0x100 以上の文字コードを指定した場合に変な文字に変換されるバグを修正。
  * .ble-text.c2s:
    一度文字コードを取得した文字についてキャッシュする様に変更。


X3

  末端に改行を置かずに終了したコマンドの扱い

  * その様なコマンドがあるとプロンプトの表示が乱れる原因である。
  * 右に或る回数だけ進んで其処で空白を出力してから行頭に復帰すれば良い?
    元々1桁目にいた場合にはぎりぎり改行をせずに済み、
    2桁目以降にいた場合には改行してしまうように調整をすれば良い。
    右に行くには ESC [ 桁数 C を出力すれば良い。

  * 適当にやってみたが色々やってもうまく行かない。ちゃんと端末の動作を考えるべき。

  * 先ずは xenl の場合。
    幾ら右に行っても一文字出力する分の余裕は必ず残る。
    従って右端に行ってから 2 文字は出力しないと行けない。

    例えば (1) COLS-2 だけ右に進んでから (2) 2 文字出力して、(3) それから復帰する。

    この様にすると
    何も出力していない場合   |   何か出力している場合
　　(0) [_              ]    |   (0) [a_             ]
        [               ]    |       [               ]
    (1) [------------>_ ]    |   (1) [a------------>_]
        [               ]    |       [               ]
    (2) [             xx_    |   (2) [a             x]
        [               ]    |       [x_             ]
    (3) [_<-------------]    |   (3) [a             x]
        [               ]    |       [_<             ]

    xenl でない端末の場合は COLS-3 に変えれば良いだけか?    
    (1) COLS-3 だけ右に進んでから (2) 2 文字出力して、(3) それから復帰する。

    何も出力していない場合   |   何か出力している場合
　　(0) [_              ]    |   (0) [a_             ]
        [               ]    |       [               ]
    (1) [----------->_  ]    |   (1) [a----------->_ ]
        [               ]    |       [               ]
    (2) [            xx_]    |   (2) [a            xx]
        [               ]    |       [_              ]
    (3) [_<------------ ]    |   (3) [a            xx]
        [               ]    |       [_              ]
    
    多分これで OK。    



X2

  C-v に bind できない?

  * どうやら stty が C-v を食う設定になっていてこの設定が有効になっている間は、
    bind で C-v に割り当てをしたり C-v に対する割り当てを削除したりと言った操作ができない様だ。
    stty lnext undef で C-v に対する割り当てを削除した上で C-v に対して bind を行えばよい。
    (stty が食う所までは理解できるが、stty の設定によって bind すら出来なくなるのは何故か?)

  * 但し、その後で stty lnext $'\26' などとして設定を元に戻すと、
    やはり C-v は stty に食われて bash にシグナルとして伝達する。
    問題が生じなければ stty lnext undef で放置という事で良い気がする。

    然し C-z に bind 擦る為に結局 stty susp undef をして、
    コマンド実行直前に復元して、コマンド実行後にまた undef するという事をしたくなりそうだから、
    その際には lnext も復元させる事にすればよい。

  * 何故かスクリプトで stty lnext undef の直後に
    bind -x '"":ble-decode-byte 22' を実行すると、
    self-insert が割り当てられてしまう。
    bind -x の文と stty lnext の文を別の関数に配置したらこの様な事は起きなくなったが、謎。


X1

  C-d を受け取る為には READLINE_LINE に何か設定する必要がある。
   するとオリジナルのプロンプトが表示されるがこれをどの様に殺すか?

  [振舞]
  + READLINE_LINE が空の状態だと C-d を受け取れない。
    受け取る前にログアウトしてしまう。
    (man bash には EOF への翻訳は delete-char で行われる様に書かれているが、
    それとは別に C-d を bash が受け取った段階でチェックされ、
    条件に適合すればログアウトしてしまう)
  + READLINE_POINT が READLINE_LINE 末端を指している時は、
    プロンプトを表示し終わった直後に位置の移動は行わない。
    表示後のカーソル位置は、書き込んだ最後の場所になる。
  + READLINE_POINT が READLINE_LINE 先頭を指している場合は、
    bash が其処にカーソルがあるべきと考えている位置にカーソルが移動してしまう。
    (プロンプトの幅?)
  + 制御文字を EADLINE_LINE に代入しても、表示される時には ^A 等の表示に翻訳される。
    従って、通常の文字を代入しておくのが無難である。
  + 試しに READLINE_LINE=$'\0' として READLINE_LINE='1' として見たが、
    これはどうやら READLINE_LINE は空文字列であると解釈されて、
    C-d は即座にログアウトと解釈されてしまうので駄目である。

  [目的]
  + C-d を読む為に READLINE_LINE の内容は何でも良いから 1 文字以上必要
  + プロンプトを表示し終わった時の位置を制御したい

  [対策]
  + PS1 は空欄にする
  + カーソル位置 x が 2 桁目以降にある場合は、
    x-1 桁目に移動して READLINE_LINE には x-1 桁目の文字を入れる。
    READLINE_POINT には 1 (正確には x-1 桁目の文字のバイト数) を代入しておけば良い。
    また SGR で予め x-1 桁目の文字のスタイルを吐き出しておく。
  + カーソル位置 x が 1 桁目にある場合は、
    READLINE_LINE には 1 桁目の文字を入れておく。
    READLINE_POINT には 0 を入れておく。
    また SGR で予め 1 桁目の文字のスタイルを吐き出しておく。
  + 全角文字などに対する対策も必要

  + これを正しく実装する為には、取り敢えず現在のカーソル位置を把握している必要がある。
    またカーソルの左側に位置している文字と、その幅を記録しておく必要もある。
    (幅を記録する必要はあるのか→ない気がする。)

  *rule*

  + lc はカーソルの左側に位置する文字の文字コードを表す。
    常に graphical な文字であり、bash によって直接表示される。
    x=0 の場合には lc に入っている文字コードの値は未定義であり、使用してはならない。
  　(つまり x, lc を設定する側では x=0 の時は lc の中身は気にしなくて良い。)。


  関数 x y lc ; .ble-cursor-move.text text ; x y lc

    .ble-cursor-move.text は指定した文字を現在位置 x y に書き込んだ時に、
    カーソルがどの様に移動するかを計算する。この時 lc の値も一緒に計算する。

    ** 注意点 **
    text に BS や VT が含まれる場合、lc を適切に計算する事が出来ない。
    BS, VT が含まれる場合、その直前の文字 (BS で消した文字の直前の文字、及び、VT で移動した先の左側にある文字)
    を今迄の出力から知る事は出来ない。この様な場合は暫定的に lc=32 (空白文字) を設定する。
    (この関数は prompt の幅を計算する為にある。PS1 に BS や VT などの制御文字を \[ \] で
    囲まずに設定する事は考えにくいので、現状ではこれについて対策する予定はない。)


  関数 .ble-cursor.construct-prompt ; ret=(x y lc ps1esc)

    プロンプト文字列を実体化し ps1esc とする。
    更に、プロンプトを端末の左端から表示し始めた時の、最後のカーソルの位置 x y を計算する。
    また、lc にはカーソルの位置の左側にある文字の文字コードを返す。

    ** 注意点 **
    エスケープシーケンスなど実際に prompt の位置に文字として表示されない物は、必ず \[ ... \] で囲む事。
    \[ \] で囲んだ中でカーソルの移動などを行うとカーソル位置を正しく計算できない可能性がある。
    \[ \] で囲んだ中でカーソルを移動させたとしても、また元の位置に戻す事が望ましい。


  関数 _ble_cursor_x _ble_cursor_lc ; .ble-edit.adjust-cursor

    ble-decode-byte の最後にこの関数を呼び出して、READLINE_LINE, READLINE_POINT
    の調整を実行する事にした。ちゃんと実装した物が完成したので、
    暫定的に書いた調整コードは削除 (以下)

    # # 何か入力されていないと C-d で exit してしまう。
    # # これは delete-char で判定するのではなく、
    # # あらゆる関数を呼び出す前にチェックされる様だ。
    # # また、READLINE_POINT が文字列末端に設定されていれば OK

    # [暫定v1]
    # READLINE_LINE="${_ble_edit_str:_ble_edit_str_ind:1}"
    # test -z "$READLINE_LINE" && READLINE_LINE=' '
    # READLINE_POINT=1

    # [暫定v2]
    # echo -n "[D"
    # if ((_ble_edit_ind>0)); then
    #   READLINE_LINE="${_ble_edit_str:_ble_edit_ind-1:1}"
    # else
    #   READLINE_LINE='_'
    # fi
    # READLINE_POINT=1


2013-05-29 highlight.sh

  bash で highlight?

  一応、bind -x で通常文字に対して適当な関数を割り当てれば
  入力に対して hook をする事は可能なようである。
  但し、関数の呼出が終わった後に入力行が再度描画されるので、
  折角色を付けて出力したとしても上から塗り潰される事になる。

  後 bind -x のもう一つの問題として、
  複数行に亙る行を編集している時に bind -x の関数を呼び出すと、
  処理が終わった後に再描画される訳だが、
  その時の再描画で表示している行の位置が下にずれる。
  これは bind -x の関数で何の操作もしていなくても同様である。
  これを正しく処理する為には、

  (1) 現在の端末の幅を取得する
  (2) 文字列の表示上の長さを取得する
  (3) prompt の長さを取得する。

  などの機能を正しく実装する必要がある。
  (1) は shopt -s setwinsize でもすれば取り敢えずできる。
  (3) は (2) さえ正確に記述でき、現在のカーソル位置が分かれば現在の位置から逆算できる。
  逆に言えば、(2) と (3) さえ正確に計算できれば現在のカーソル位置も端末に問い合わせることなく分かるという事でもある。

  + 現在のカーソルの位置を取得する関数は書けた。一応動いている。
    但し CSI 6 n (DSR CPR) に対応している端末でないと動かない。

  * 現在位置を予測するという事

    文字列の表示上の長さを計算するには、
    <del>文字列の文字コードを utf-8 と仮定すれば編集文字列を走査して、</del>
    文字コード列を生成し、更に其処から文字幅に変換して、
    加算するという事をすれば良い。

    と思ったが…実際には改行やら TAB やらがあるので、
    現在の正確な位置が分からないと文字列の表示上の長さなどの情報を取得する事は出来ない。
    やはり何とかして端末が表示される長さを算出する必要があるだろうか。
    端末が表示される長さを取得する方法:

    A READLINE_LINE が空だった時の位置を記録しておく?
      + 漢字や平仮名で始まるコマンドを入力した場合に対処できない。しかしそんなコマンドは存在するだろうか。</li>
      + 前のコマンドの出力が改行で終わらなかった場合にどうなるか?
        →1 文字でも入力すれば再描画されてプロンプトは行頭に出て来る。
          0 文字の時に取得した位置はその時にしか信用できないので、1 文字の時に取得した文字の方が良い?
      + <strong>×</strong> プロンプトは複数行に跨らないという仮定をしないとできない。
        然し、人によってはプロンプトを複数行に分けるという人もいる (cygwin の人みたいに)。

    B 自分で PS1 を解析して長さを計算する?
      + <strong>△</strong> 実装が大変。エスケープシーケンスの類にも対応しなければならない。</li>
      + (\a \n \r \ooo はCと同じ意味, \x \f \b はそのまま出力, \v \t \u は別の意味, \e は ESC)</li>
