# -*- coding:utf-8 -*-

設定項目
: ${ble_opt_input_encoding:=UTF-8}
: ${ble_opt_vbell_default_message=' Wuff, Wuff!! '}
: ${ble_opt_vbell_duration=2000}
: ${ble_opt_error_char_abell=}
: ${ble_opt_error_char_vbell=1}
: ${ble_opt_error_char_discard=}
: ${ble_opt_error_kseq_abell=1}
: ${ble_opt_error_kseq_vbell=1}
: ${ble_opt_error_kseq_discard=1}

制限

  * bash-3 C-d について

    今は何とか C-d を処理する事に成功しているが完全ではない。

    1 C-d を押した時に bash が出力するエラーメッセージを使って捕捉している。
      このエラーメッセージは言語や設定によって異なると思われる。
      現在は以下のメッセージを調べている。
      - 'Use "exit" to leave the shell.'
      - 'ログアウトする為には exit を入力して下さい'
      - 'シェルから脱出するには "exit" を使用してください。'
      自分の bash が異なるメッセージを出力する時は
      それを bleopt_ignoreeof_message に設定する。
    2 連続で沢山 C-d を押すと "^D" が echo されて表示が乱れるかもしれない。
      最悪の場合 C-d によって bash プロセスが落ちる可能性もあるかもしれない。
      (未だ落ちた事はないが)。
    3 C-d を処理する為に SIGUSR1 を使用している。
      その為 SIGUSR1 を別の目的で使用する事は出来ない。

  * 文字コードについて

    現在は基本的に UTF-8 を想定している。
    それ以外の環境の場合には少なくとも以下の修正が必要になる。

    - ble.sh 自体を iconv で変換する事。或いは日本語を完全に排除する事。

    - 使いたい文字コード → unicode のデコーダを自分でかく事:
      これは "function ble-decode-byte+文字コード" を実装すれば良い。

    - unicode → 文字のコードが正しく動作する様にする事:
      これは .ble-text.c2s (ble-core.sh) の辺りを直せばよい。
      "ble-text-c2b+文字コード"
      "ble-text-b2c+文字コード"
      も実装する必要がある。

    - ble-decode.sh (function .ble-decode-bind):
      bash-3 で "ESC [" を bind する為に ESC [ を
      utf-8 の非正規な符号 "\xC0\x9B[" に変換している。
      bash-4.3 で "C-@" を bind する為に \C-@ を
      utf-8 の非正規な符号 "\xC0\x80" に変換している。

      UTF-8 以外の文字コードを使う場合には
      これらのバイト列を特別に認識する様にするか、
      別のバイト列を指定する必要がある。
      (これらは bind にハードコードされているが、
      外部から指定できる様に変更する必要がある。)

    他の文字コードは未だ一回も実装していないので上記以外にも必要な作業が出て来る可能性がある。

bash 実装上で注意するべき事

  * arr=(1 2 3) func の形式で配列をシェル関数に渡そうとすると、
    export arr='(1 2 3)' で渡されてしまう。

  * コマンドをつなぐ && と || の優先順位は同じで左結合である
    但し、算術式や [[ ]] に登場する && と || はC言語と同じ優先順位である。

  [complete 仕様について]

  * compgen -f はクォート除去、チルダ展開を実行する
    理解できないのはクォート除去した後にチルダ展開をするという事。
    compgen -f "'~/'" としても '~' というディレクトリには決して一致しない。
    compgen -f "'\~/'" 等とクォートした上に backslash も指定しないと行けない。
    結局どういう規則なのか分からないので、寧ろ arr=('~/'*) 等の様にするべき。

  * $ complete -F foo -C bar command と登録すると foo, bar の両方が foo bar の順に実行される。
    $ complete -C bar -F foo command と登録すると bar foo の順に実行される。
    しかし、complete -p とすると両者とも
    complete -C 'bar' -F foo
    と表示され登録順・実行順についての情報を取り出す事ができない。

  * $ complete -F hoge1 -F hoge2 command とすると、-F hoge2 だけ有効になる
    (complete -p による表示もそうだし、実際に実行されるのも hoge2 だけであった)。
    -F オプションは後からものによって上書きされるという事の様だ。

bashbug: 実装上で注意するべき事

  * 算術式:
    条件分岐で実行されない部分でも配列の添字は 0 以上でなければならない。
    例えば以下はエラーになる @ bash-3.1, 3.2, 4.0, 4.2, 4.3
    ((a=-1,a>=0?b[a]:0))

  * bash-4.3 \C-@ 関係に bind -x すると正しく動かない

  * bash-4.2

    算術式の中で配列要素の参照に関係して特定の式構造になると segfault する。
    多分、配列要素の読み出しの次の token が整数または代入式の左辺だと落ちる。
    配列要素を参照したら一旦算術式を閉じるのが良い。
    $ ((a=b[0],c=0))

    以下でも segmentation fault が起こった。
    $ (((klen=node[nofs+k])<0||(kbeg=j-klen)>end0))
    $ (((a=node[1])<2||(b=3)))
    $ (((a=node[1])||(b=3)))
    $ (((a=node[1])<2||b)) # OK
    $ (((a=node[1])||b))   # OK
    $ (((node[1])||(b=3))) # OK
    やはり起こる条件が良く分からない。
    代入式の右辺に配列が来て、
    その後に代入式の左辺に token があると駄目なのか?

  * bash-4.2, 4.0, 3.2, etc

    rex="^([^\$]|\\'[^\\']*\\')+\$" && [[ 'i$' =~ $rex ]] && echo hello

    が一致する。\' の解釈が謎である。単に ' とすれば問題ない。


  * bash-4.2 以下
    bash-4.2 ～ bash-3.0

    \C-x 単体に bind -x して C-x に続けて何か打つと segfault する。
    $ bind -x '"\C-x":echo' → 続けて C-x a 等と入力

  * bash-4.1 以下 (bash-3.0 ～ bash-4.1)

    配列要素に対して修飾付きのパラメータ展開を実行すると、
    配列添字に指定した算術式が2回評価される。
    例えば "${arr[i++]#a}" を実行すると i が 2 増える。

  * bash-4.1, 4.0

    [問題]
    関数内で local arr としただけで ${#arr[*]} が 1 になっている。
    その後、要素 #1 を設定しても ${#arr[*]} は 1 のままである。
    これの所為で以下のコードが破綻する:
      arr[${#arr[*]}]=...
    常に要素 #1 にしか代入されない事になる。

    [解決]
    local -a arr とすれば問題は起きない。
    ※local arr=() としても問題は起きないがこの記述だと
      今度は bash-3.0 で文字列 '()' が代入されて問題である。

  * bash-4.0 ～ bash-3.0

    $'' 内に \' を入れていると履歴展開が '' の中で起こる?
    例えば rex='a'$'\'\'''!a' とすると !a の部分が展開される。

  * bash-4.0 他 算術式を使って値を計算する時の注意

    算術式の中に初期化されていない変数…例えば ret 等がある場合、
    ret の中身に不正な数式的な物が入っていたりコマンド置換が入っていたりすると、
    文法エラーになったりこれが eval されてしまう。
    実際に 4.0 では 'あ' という文字列が入っているだけでエラーになる。
    (より上の version では識別子名と解釈されているからなのかエラーにはならない。
    しかし、今迄は毎回「あ」等という変数を探していたのだろう。

  * bash-3.2.48 で以下の評価に失敗する。
    bash-3.1 以下は大丈夫。bash-4.2, bash-4.3 も大丈夫。bash-4.0 は駄目。

    dbg=()
    ((a=0,b=0,0&&(a=1,x=dbg[0],b=1))) # NG
    配列添字で値を参照 (代入はOK) すると、その部分以降が必ず実行される。
    複合代入であっても駄目である。

    bash-4.0 bash-4.1 でも以下の式で必ず _pos[1]++ が実行されていた。
    ((_eoc[2]&&(_pos[0]=0,_pos[1]++)))

  * bash-3.2, bash-3.1 では source にプロセス置換を渡しても読み取ってくれない。
    つまり source <( ... ) としても何も起こらない。
    代わりに eval -- "$( ... )" すると良い。

  * bash-3.1 では declare -f funcname の funcname に + 等の文字を含める事ができない。
    一応 declare -F 等とすれば名前は列挙される様ではある。
    bash-3.2 未満では declare -f ではなく type -t で関数かどうかの確認を行う。

  * bash-3.1 での bind -r について
    bind -sp とすると "\M-[C" 等と表示されるがそれに従って bind -r '\M-[C'
    としても削除する事は出来ない。代わりに bind -r '\e[C' とすれば削除できる。

    eval -- "$(bind -sp | awk '/M-\[/{sub(/:$/,"",$1);gsub(/\\M-/,"\\e");print "bind -r " $1}')"

  * bash-3.1
    呼出先の関数で、呼出元で定義されているのと同名の配列を作っても、中が空になる。
    > $ function dbg/test2 { local -a hello=(1 2 3); echo "hello=(${hello[*]})";}
    > $ function dbg/test1 { local -a hello=(3 2 1); dbg/test2;}
    > $ dbg/test1
    > hello=()

    これは bash-3.1-patches/bash31-004 で修正されている様だ。

  * bash-3.1

    - ${#arr[n]} は文字数ではなくバイト数を返す様だ。

    - "${var//%d/123}" は動かない。"${var//'%d'/123}" 等とすればOK。

    - bash-3.0, bash-3.1: local GLOBIGNORE すると、
      関数を出てもパス名展開の時にその影響が残っている。
      (直接変数の中身を見ても何もない様に見えるが。)
      unset GLOBIGNORE などとすると直る。

  * bash-3.0

    - ${#param} は文字数ではなくバイト数を返す、という事になっているらしいが、
      実際に試してみると文字数になっている (bash-3.0.22)。
      何処かで patch が当たったのだろうか。まあいいか…。

      (※${param:ofs:len} は 3.0-beta1 以降であれば文字数でカウントされる)

    - local a=(...) や declare a=(...) とすると、"(...)" と同じ事になる。
      a=() の形式ならば問題ない。

    - declare -p A で改行を含む変数を出力すると改行が消える。
      例: 一見正しく出力されている様に錯覚するが "\ + 改行" は改行のエスケープではなく、
        長い文字列リテラルを二行に書く為の記法である。つまり、無視される。
      $ A=$'\n'; declare -p A
      | A="\
      | "

    - history -p を実行する度に history のリストの項目が削除される。

bash_features

  * printf -v var %s value

    bash-3.1 以降で使える。
    bash-4.1 以降で var として配列要素 (arr[123] 等) を指定できる。

  * read -t timeout

    -t オプションの対応は 2.04 である。
    TMOUT 変数の対応は 2.05b-alpha1 以降である。
    小数を指定できる様になったのは 4.0-alpha 以降である。
    `-t 0' で次の文字を読み取り可能かどうかチェックできるのは 4.0 以降である。

tech

  * swap の仕方
    local a="$b" b="$a"
    local や declare などは必要である。

*******************************************************************************
    Memo
-------------------------------------------------------------------------------

2015-11-28

  * デモ画像の作り方

    準備
    $ # PS1=$'[\e[4;38;5;202mfoo@bar\e[m \\j \\W]\\$ '
    $ TTYREC=1
    $ ttyrec demo.tty

    echo hello, world
    printf hello
    [[ a == b ]]
    echo "hello $(echo bash $(echo world))"
    C-r for
    echo 'select, copy and paste' コピーする
    echo insert mode -> overwrite mode
    ls
    echo complete ble-TABdTAB histexpand !#:2
    echo "$HIST[TAB]"

    $ seq2gif -f 0 -b 15 -h 14 --render-interval=10 -p rosa --play-speed=1.5 < demo.tty > demo2.gif


2015-08-14

  * [memo] builtin check

    eval "grc --color --exclude=./test '\b(builtin[[:space:]]+)?$command\b' | grep -Ev '\bbuiltin[[:space:]]+$command\b'"

  * [memo] leak variables check

    set | sort | sed -e '/()[[:space:]]*$\|^_\{0,1\}\(BLE\|ble\)/d' -e '/^[[:alnum:]_]\{1,\}=/!d' > a.txt

  * [memo] 解析(ble-syntax/parse)の際の原則

    データ配列とは _ble_syntax_stat, _ble_syntax_nest, _ble_syntax_tree を指すとする。
    或る点 p1 から或る点 p2 に解析を進める場合を考える。

    1 この時データ配列に対する変更は p1-p2 (exclusive) の間にだけ行われる。
      これは解析状態の復元と再開が適切に動作する為に必要である。

    2 解析の過程でデータ配列に格納されている情報は使用しない。
      これは解析状態の一致チェックの為に必要である。
      データ配列の内容に依存して動作が代わる場合、
      解析状態が一致しても解析結果が異なってしまう可能性があり、不整合を生む。

      但し、_ble_syntax_nest については専用の関数を通して 0-p2 の任意の場所を参照しうる。
      これ(専用の関数を通して得られる情報)については
      解析状態の一致チェックの対象に含まれているからである。
      (_ble_syntax_nest の任意の情報を参照して良いという意味ではない。)


*******************************************************************************
    ToDo
-------------------------------------------------------------------------------

2015-11-30

  * bug: ble-assert

      "$f" --date="$(date +'%F %T %Z' -r "$f")"
      "${f}" --date="$(date +'%F %T %Z' -r "$f")"

    の過程でエラー。最小化:

      echo "$f" "$(B 'D' "$f")"

  * bug: tab 補完が効かない

  * Note: ble-decode.sh (generate-source-to-unbind-default)

    文字コード実装時に問題があるかも。

    現在、bind -sp が出力する中途半端なバイトを解釈する為に、LANG=C で awk を起動している。
    UTF-8 の場合には複数バイト文字を構成するバイトは ASCII 文字と被らないので問題ないが、
    Shift_JIS 等の場合には ASCII 文字、特に \ や " を含む可能性がある。
    この場合には LANG=C にしていると問題が生じる。
    というか、bind -sp の出力する中途半端な文字と、複数バイト文字の一部を本質的に区別する方法はない様に思われる。

    ただし、救いは、もし ble.sh を plain な bash の上で起動するとすれば
    日本語で bind -sp に登録がなされていることはないだろうということである。
    つまり、ユーザが手で (或いは .inputrc に) bind '"日本語":"にほんご"' などとしない限りは問題は生じない。

2015-11-28

  * bug cygwin 環境で補完が効かない

  * bug

    $ seq2gif -f 0 -b 254 < demo.tty > out/img/demo.gif
    カーソルを先頭に移動した時?? 再現しない。

    stackdump: X1 0 <= 48 <= 49 <= 1, 48 <= 48
      @ /home/murase/prog/ble/ble.sh:-16 (ble-syntax/parse)
      @ /home/murase/prog/ble/ble.sh:4 (_ble_edit_str.update-syntax)
      @ /home/murase/prog/ble/ble.sh:-135 (ble-highlight-layer:syntax/update)
      @ /home/murase/prog/ble/ble.sh:4327 (ble-highlight-layer/update)
      @ /home/murase/prog/ble/ble.sh:4818 (.ble-line-text/update)
      @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
      @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
      @ /home/murase/prog/ble/ble.sh:1001 (.ble-decode-byte:bind/tail)
      @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)
    stackdump: X2 0 <= 0 <= 48 <= 49 <= 1 <= 1
      @ /home/murase/prog/ble/ble.sh:-16 (ble-syntax/parse)
      @ /home/murase/prog/ble/ble.sh:4 (_ble_edit_str.update-syntax)
      @ /home/murase/prog/ble/ble.sh:-135 (ble-highlight-layer:syntax/update)
      @ /home/murase/prog/ble/ble.sh:4327 (ble-highlight-layer/update)
      @ /home/murase/prog/ble/ble.sh:4818 (.ble-line-text/update)
      @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
      @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
      @ /home/murase/prog/ble/ble.sh:1001 (.ble-decode-byte:bind/tail)
      @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)

2015-11-25

  * complete: bug 単語と単語の間で補完が効かない。

2015-11-23

  * プログラム補完: 末尾空白の問題点

    現在 git 補完関数に合わせる形で勝手に末尾の空白を除去している。
    しかしこれで良いのか? これだと空白で終わるファイル名などがあった場合に問題になる。
    (その様なファイル名は滅多にないとは思われるが…。)

  * ble-detach 後の stty sane

    現在はユーザに stty sane を実行して貰っている。もっと綺麗な方法はないか?

2015-11-21

  * 公開までに追加であった方が良いかも知れない物

    + release の登録

    + 拡張性の提供 (拡張の仕方の説明)
      + theme の枠組を整える事 (setting files の置き場?)
        ble-color-list
      + 文字コード拡張 (Unicode との mapping)
      + 端末制御コード拡張
        tput からもっと積極的に読み込むべきなのでは?
        cmap/default.sh に加えて cmap/tput.sh 的な物も?
        > minimal.sh, xterm.sh, rosaterm.sh の整理。

    + 同じ場所で complete (TAB) を連続で呼び出した時にカウントを行うべき
      + peco や sentaku などを起動する時の基準に使用できる。

    + vbell の色
      + キーボード入力内容を全部 vbell で表示する方法?


    + マウス対応
    + RPS1

    + vi bind (これは bind -p で調べれば大丈夫の筈?)

      →bind -p して見たがどうも vi には vi の完全に異なるコマンド体系がある様である。
        単純な移動コマンドぐらいならば対応できるが、それ以外の物についてはどの様な操作なのか
        よく理解していないので憶測で実装するのは難しい。

    + 簡単なキーボードハンドラのサンプル (テトリスとか? 或いは sentaku 再実装とか)

      サンプルとしては、端末の出力画面に現れる物よりは、
      画面を altscreen で完全に切り替える物の方が実装しやすいと思われる。
      それでいて、read -t 0 などを有効に使えるとなるとテトリスなどになるだろうか。

  * bug: 複数行編集でカーソルが一番上にない場合 vbell で編集内容が消される。

    元々 vbell を実装した時は複数行になる事を想定していなかった (複数行にできなかった)。
    現在は複数行に対応したので特別の配慮が必要である。
    (ble-edit.sh から値を引っ張ってくる必要があるので interface を決めておく必要はあるが。)

2015-11-18

  * bleopt コマンド: onchange

    変数の値が変わった時に onchange イベントを起こす仕組みを整えても良い。
    これは変数の内容変更にともなって処理が必要な変数が出てきてから考える。

  * PROMPT_COMMAND を一番外側の環境で実行する様に変更する。

    現在は .ble-line-prompt/update の中で直接実行している。

    また、stty 等を正しく設定して呼び出すようにする?

      参考の為: 現在 ble-bind -cf による登録では、
      function .ble-edit.bind.command を通して .ble-edit.accept-line.add
      でコマンドを登録し一番最後に外側でコマンドを実行する。
      このコマンドによる出力はプロンプトの次の行に表示される。
      またコマンド終了後には改めてプロンプトが表示される。

      一方で ble-bind -xf proc に関してはそもそも未実装の状態になっていた。
      このコマンドではプロンプトの次の行に行ったり、プロンプトを消したり、
      或いはプロンプトを再描画したりなどと言った事は不要である。
      (勝手な出力をしないという前提・表示が乱れた場合 proc の方が悪いという事にする)

  * complete: 存在しない変数名で補完しようとすると \ が挿入される。
    ここは何も実行しないで欲しい所である。

  * histexpand: shopt -s histverify histreedit 対応

2015-11-06

  * isearch-forward/backward で現在の一致範囲をハイライトする。

  * まったく同じ nest 状態になると思われるのに解析中断が起こらない

    ☆これは表面上は何の問題も起きない。多少無駄な処理をするだけである。
      従ってそんなに対処に緊急を要しない。

      | function ble-syntax/parse/nest-equals {
      |   local parent_inest="$1"
      |   while :; do
      |     ((parent_inest<i1)) && return 0 # 変更していない範囲 または -1
    -->     ((parent_inest<i2)) && return 1 # 変更によって消えた範囲
      |
      | local _onest="${_tail_syntax_nest[parent_inest-i2]}"
      | local _nnest="${_ble_syntax_nest[parent_inest]}"
      | [[ $_onest != $_nnest ]] && return 1
    変更によって消えた領域を指している場合は、
    既に消えた領域のデータを捨てているので nest の判定を行う事ができない。
    そんな訳で解析中断はできないと判定されてしまうのである。

    ここで解析中断を出来るようにする為には消えた領域のデータも取って置いて、
    その上で全く同じ解析結果になったら解析中断を行う、という事になろう。
    以降の解析の動作に違いがなければ良いのだから
    過去の nest の状態だけが一致していれば解析中断には充分である。
    これは別項目として独立させて残す事にする。

    ※問題は解析領域拡大によって i1 が後退する事によって
      変化の無かった部分についても解析結果が消去されてしまう事にある。

2015-08-20

  * エラーがある時にはコマンドを実行できない様にする

    一番明らかな物は一番初めのコマンドが見付からない場合である。
    また、文法構造にエラーがある場合も含まれる。
    文法構造にエラーがある場合は ATTR_ERR が指定されている筈である。
    然し乍らそれ以外にはエラーを得る情報が無いとも言える。
    エラーがある時のコマンド実行について考える前に、
    先ずはエラーの処理について再考しておいた方が良いような気がする。

  * エラー検出・表示の管理について

    現状

    現在エラーは様々な方法で使用者に対して提示している。
    解析の途中状態で既にエラーと分かる物については
    _ble_syntax_attr に ATTR_ERR を設定している。
    これは _ble_highlight_layer_syntax1_table を経由して表示の着色に反映される。
    もう一つのエラーの種類は入力したコマンドラインの末端で入れ子が閉じていない物である。
    これは一番最後の文字と対応する入れ子の開始点の色を変更する事によって提示する。
    この着色は解析点より前に対して行われるので部分更新の対象とする事は難しい。
    従って _ble_highlight_layer_syntax3_table を介して、毎回全消去・再計算を実行している。

    以下に改善したい箇所について列挙する。

    - この様に複数の方法を用いてエラーを提示しているのは少し醜い。
      もう少し統一した枠組を作っても良いのではないかという気がする。

    - ATTR_ERR を用いて設定したエラーは、
      後の処理で追加される単語毎の着色によって上書きされてしまう。
      つまり、折角エラー通知の為に着色を設定していても使用者に見えない事がある。
      別の場所にエラーを登録しても良いのではないかという気がする。

    - 各エラー項目に対して何が問題なのか・何のエラーなのかのメッセージを設定したい。
      これらのメッセージも枠組の中で管理して、カーソルの位置に応じて表示できる様にしたい。

    もう少し現状について調べて実装の方法について考える。
    先ずエラー情報を記録する為の配列の形式について。
    既存のエラー着色に使っている配列 _ble_highlight_layer_syntax3_table が気になる。
    これを拡張する形で実装する事はできないだろうか。。
    →この配列は部分更新できないような情報を保持するのに使っている。
      部分更新できない様な着色であっても今回の実装によって
      よりましな方法に変更できるのではないか、という気もするが、
      それは今回の実装が終わってから考えれば良い事である。
      (初めからその様な物にも対応できる様に今回の実装を設計するという事も出来るが
      複雑になるので、取り敢えずは何も考えずに実装する事を目指す。)

    つまり、_ble_highlight_layer_syntax3_table は non local な着色の為に使うとして残し、
    それとは別にエラーを管理する為の配列を作成する。

    部分更新の際の効率を考えると _ble_syntax_attr と同様に、
    編集文字列中の位置を配列のインデックスとする方法が良さそうに思われる。
    然し一方で、エラーの数はそんなに沢山になるとは考えがたい (sparse) なので、
    リストにして管理するという方針も考えられる。どちらの方が良いだろうか。
    リストにしている場合、"エラー設置点 エラー開始点 エラー終了点 メッセージ" というデータ形式になるだろうか。
    shift や解析中断後の再開に際してはエラー設置点を用いた filtering を行う。
    % このエラー情報の内容は解析の動作に全く影響を与えないし、
    % 解析が同じように進めば全く同じエラー情報を生成すると期待できるので、
    % 解析中断の判断基準に含める必要はないと考えられる。
    →本当だろうか。エラー開始点・終了点などの情報は解析状態が同じになっても異なる値になりうるのでは?
      特に、現在 _ble_highlight_layer_syntax3_table で管理している物はその最たる例である。
      ここで、エラー開始点・終了点が正しく設定される為には次の条件が必要である。

      エラー設置点を p1 とする。ble-syntax/parse の 1 step で i=i1 から
      i=i2 まで進む (但し i1 <= p1 < i2) 時、エラー開始点 p2, 終了点 p3 は、
      i1 <= p2 < p3 < i2 を満たす。

      この条件が揃っている時のみに現状の解析中断条件で部分更新安全である。
      因みに p2, p3 を設置点からの相対位置で記録しておけば shift の操作が必要なくなるのでその様にするべきである。


2015-08-16

  * 入れ子構造を考慮に入れた効率的な単語着色

    現状: 新規生成単語及び消滅単語の範囲 (range1) に関して再度単語の着色を実行する。

    x 但し、着色は "消滅単語の存在していた範囲" 及び "新規生成単語登録位置の範囲"
      に登録されている単語及びその子孫だけになっている。
      本来は、range1 に被さっている全ての単語について処理を実行するべきである。

    - 考慮に入れるべき事として、将来的に解析を途中で停止した場合でもそれなりに動くような方法がよい。
      しかしながら未だ解析を終えていない部分については結局どうしようもないから、
      解析が完了している部分文字列について木構造を作成して処理する事になるだろう。
      結局、現在 shift を実行するのに用いているのと同じ事をする事になる。
      (そしてそれは tree-enumerate/.initialize で実装されているので余り気にする事はない。)

    方法

    a 一つの方法は tree-enumerate を使用して末端から順に単語の範囲をチェックしていく方法である。
      つまり、現状の shift の実装と同じになっている。

    b もう一つの方法は、先に単語の木構造の情報だけ構築してから、
      range1 に対応するノードを列挙して構築する方法である。
      木構造として親ノードの位置・子ノードの配列を保持していれば、
      指定した範囲に対応するノードの範囲を効率的に計算する事が出来る。

      ただし、木構造の情報の構築自体にどれだけのコストがかかるかについて考える必要がある。
      木構造は後ろから掘り出すようにして実行する為、
      更新範囲の beg から文字列の末端 iN 迄を完全に構築し直す必要がある。
      部分更新するというのが難しいと思われる。

      しかし、部分更新は全くできないのでは等と考えていたが、
      考えてみると意外と部分更新も出来るのではないかという気になってくる。
      更新範囲に含まれていないノードの内部構造に関しては実は更新の対象ではない。
      また、更新範囲より前にあるノードの内部構造についても同様である。
      但し、親ノードの位置は、更新範囲より前にあるノードであっても更新する必要がある。

    c 或いは、parse の過程でより分かり易い木構造データも同時に構築してしまうという手もある。

      x parse の内部状態を増やせば増やす程、解析中断が難しくなるが
        最終的に構造を再構築するのであれば結局中断してもしなくても同じかも知れない…?
        しかしながら木構造を考えずに parse した後、木構造に対する更新を行った方が処理量は少なくなるはずである。
        というのも木構造を考えながら parse する事にすると、
        更新の必要のない文法的処理も木構造の構築と同時に実行してしまうからである。
        それよりは、文法的処理で必要最低限の所を parse で処理して、
        木構造の構築について必要最低限の所を後の処理で実行する、という形の方が良さそうである。

      o ただ、parse の過程で木構造も一緒に構築するようにした方が、
        データ同士の依存関係が整理されて良いという側面もある。
        parse の後で木構造としてどの範囲を更新するべきかを決定するのは面倒でありバグを生む原因にも成る。
        →parse の後で処理をする際にも何らかの "原則" を決めてその下で実装するなどした方が良いと思う。
        (逆に言えば上手に原則を決める事さえ出来れば、parse で木構造を構築する事の利点はなくなる。)


    入れ子構造の実装後に改善できる箇所
    - tree-enumerate-in-range 及びその呼出元
      現在は愚直に範囲内に設置されている単語識別子を

2015-08-15

  * ble-syntax.sh: CTX_CMDXC, CTX_CMDXF 等に於いて redirect は許可するべきでないのでは?
    更に、CTX_CMDXC においては var=... も許可するべきではない。

    また CTX_CMDX1 についても直前のコマンドによっては redirect は許可するべきでない?
    (while, if, do, then, else, '(', time の直後では redirect も可能な様だ。)

  * ble-syntax.sh: `function ...' において関数名の部分に使用した履歴展開を解釈する?
    履歴展開だけを解釈する新しい文脈が必要になると思われる。

    然し乍ら、履歴展開の結果として複数の単語になる場合などを考えると、
    そもそも一つの単語として読み取って良いのかなど疑問点が残る。

    % 或いは、その場で履歴展開としての妥当性を検証して色をつけてしまうという手もある?
    % →これだと正しく解釈されない。例えば履歴展開には $ が含まれて良いが関数名には $ が含まれないので、
    %   先に関数名としての切り出しを実行すると $ の直前で不正に関数名が中断する事になる。

  * ble-syntax.sh: `function' と入力した時に最後の n の部分にエラーを設定するが、
    command 名としての着色の際に上書きされてしまっている。


2015-08-14

  * 高速化: ble-syntax/parse: より厳密な shift 範囲の特定・省略?
  * 高速化: $(type -t), $(printf), $(jobs) をファイル書き出し・read読み出しに変更する

    $() を read で実行する為の関数 ble/util/assign を作成した。
    cygwin 環境で特に遅くなる原因と思われる部分についてはこれに置き換えた。

  * DECSET 2004 に対応する? (ref http://srad.jp/~doda/journal/506765/)

    bash-4.0 未満では read -t 0 がないので貼付などが行われた時に長く待たされる事になる。
    DECSET 2004 を用いて貼付を検知するなどの対策が必要。

2015-08-11

  * history コマンドで操作を実行したときにそれが ble の履歴情報に反映されない。

    history コマンド自体を上書きするなどするとまたややこしいことになるので、
    ble-history 等のコマンドを用意してそちらを使ってもらうようにした方がよい。

  * complete: コマンドの補完で現在のディレクトリにあるサブディレクトリも候補に入れる。

  * 今後必要になる大きな書換・再実装は2つある:
    1 コマンドライン着色の効率的方法の模索
    > 2 shift の高速化の為の _ble_syntax_word, etc. のデータ構造の変更

2015-06-28

  * complete: HOGE= の直後の編集でファイル名などを補完候補として出して欲しい
  * complete: <bug> HOGE=aa| の状態で TAB を押すと滅茶苦茶沢山のコマンドが表示される
  * complete: 沢山の補完候補が存在する時に表示する内容を絞る

  * color: --prefix=filename の filename 部分
  * color: PATH=filename の filename の部分

    単語に対して部分的な着色をする場合、現在の単語毎の着色ではない方法を考えるべき。

2015-03-06

  * 整理
    - complete の古いコード
    - 着色の古いコード
      これに関しては現在の複雑な実装と昔の簡単な実装の間の着地点を見つけたい。
    - binder-source 周辺

2015-03-04

  * 88colors の時の palette について

    16-79 4x4x4 0,58*v+81
    80-87 gray 46+25*v

2015-03-01

  * ble-edit: ble-bind -xf 対応

  * ble-edit: bind 模倣?

    bind -x や bind の機能を実装し、
    更に bind 関数を上書きしてその動作を模倣するという事?

  * ble-edit: 対応する物がない readline 関数

    > history-expand-line magic-space
    > delete-horizontal-space
    history-search-forward/backward
    yank-nth-arg yank-last-arg insert-last-argument
    shell-expand-line alias-expand-line
    tilde-expand history-and-alias-expand-line
    edit-and-execute-command
    transpose-words upcase-word downcase-word capitalize-word
    kill-whole-line
    yank-pop これはkill-ringを正しく実装する必要がある
    digit-argument universal-argument 入力しやすい様に?
    complete関連
    redo, undo

  * undo の実装について

    どの様な振る舞いにするのがよいかというのが問題である。
    他の shell でどの様に実装されているかについて確認する。

    zsh における undo について

    履歴行に関係なく "表示されている文字列" の redo undo の様に見える。
    つまり、履歴で上へ行ったり下へ行ったりするとそれも含めて undo される。
    これが分かり易いのかどうかは不明。というか分かりにくいと思う。
    また、一旦 accept した後はそれ以前の履歴にはアクセスできない。

    bash における undo について

    bash で試してみるとコマンド履歴の行毎に編集履歴は記録されている様である。
    また、accept した後でも編集が残っている。
    但し、accept した編集行については中身が編集前の状態に戻る。
    (つまり、後で実際に実行されたコマンドを確認するには undo しきらなければならない)
    これも分かり易いのかどうかは分からないが、少なくとも zsh よりは良い様にも思う。

    とはいいつつも accept-line した後も編集が残っているのは良いのか微妙である。

2015-02-27

  * complete
    - 既存の bash complete に対応する。

    - 文脈判定を強化する。他にも色々な箇所で補完を実行する。

    - 引用符の中で補完を実行する方法?
      引用符の途中でも正規な単語として認識できる様にする。
      引用符の中であるという情報が必要。

2015-02-25

  * isearch-forward/backward の動作

    気付いたのだが bash では isearch-forward/backward は各ヒストリ項目に対して一致しているのではなく、
    ヒストリ項目の中にある文字列に対して一致している様だ。
    つまり、複数の一致が一つのコマンドラインの中にあれば、
    その中を C-r C-s で移動していく事になる。
    そればかりか現在編集している文字列の中で一致する物についてもちゃんと移動できる。。

2015-02-24

  * ble-syntax-highlight+* の代替機能の実装と廃止

  * layer の仕組みに対する問題提起

    | 現在の実装では各レイヤーは下のレイヤーが提供した文字配列を弄る事によって動作している。
    | しかし、実の所受け継ぐのは文字配列ではなくて描画属性の配列の方が良いのではないだろうか。
    |
    | o 先ず第一に実装の簡便さがある。
    |
    | o 次に、更新範囲というのは複数のレイヤーで似たような箇所になりがちなのではないかと思う。
    |   属性の配列で渡して置いてから一番最後の所で更新範囲に対して切り貼りをして文字配列を構築した方が良いかも知れない。
    |
    | x ただ、文字配列にするという事の利点も存在する。
    |   region 等の様に大域的に色を一時的に変更する様な物の場合、
    |   文字配列として region の下層にあるレイヤーについて記録を行っておく事は有意である。
    |   選択が解除された時に再び構築し直すというのは時間が掛かる。
    |
    |   但し、その様な動作をする物は限られている様にも思われる。
    |   殆どの場合には纏まった箇所でコンパクトに更新が行われる。
    |
    | x 括弧の対応などの場合、まとめて描画属性から文字列を構築する場合に細かい最適化が出来ない。
    |
    |   複数のレイヤーの描画属性の配列からまとめて文字列を生成する場合、
    |   複数のレイヤーが報告した更新範囲を総合してその範囲で文字列を再生成する事になる。
    |   しかし、括弧の対応など、実際の変更が小規模に渡るにも拘わらず、
    |   離れた二点で実施される色付けの場合には、変更の実体に反して範囲が拡大する。
    |
    |   今迄の様に文字列を各層で構築する方式の場合には、
    |   更新を各層の関数の中で自由に行う事ができるので、
    |   自身の変更の update に関しては最適な方法で更新する事ができる。
    |
    |   とはいいつつも更に上のレイヤーに渡す更新範囲はやはり巨大な物になる為、
    |   上のレイヤーでの合成作業が大域に渡る事は考えておかなければならない。
    |   実のところ合成作業についてはちゃんと実装していない。
    |   region に関しては可能な限り最適な方法になる様に実装したが滅茶苦茶複雑になった。
    |   実際の実装では被覆によって隠される更新などについては考慮に入れなくても良いが、
    |   複雑になりそうだという事に代わりはない。
    |   結局、内部的に描画属性の配列を持って更新に望まなければならないという事態になりそうだ。
    |
    | 何れにしても現在の実装は、今後拡張していく上で非現実的な感じがする。
    | ベースを (下層の情報を含まない) 描画属性の配列を上流に渡す方法に変更した方が良いのではと思う。
    | region 等の実装の際には cache を行う様にする等の工夫をその上で実装する様にしてみたい。
    |
    | また、実装が複雑になるが仕様がない。
    | 取り敢えず現在の所まともに着色を行っている所が syntax だけなので、
    | これを ble-highlight-layer:syntax に対応する上で考えてみる。
    |
    | ble-highlight-layer:syntax の内部で三つの描画属性の配列を用意し、
    | これらの三つの描画属性の配列を総合する事で文字列を構築する様にしてみた。
    | 可もなく不可もない感じの実装である。
    | 少なくとも各層で文字列を構築する様な実装はしたくない。
    | これぐらいが丁度良い実装の複雑さである様に思う。

    将来的には描画属性の配列で対応できる様にする。

2015-02-23

  * bleopt_suppress_bash_output 制限

    - SIGWINCH (ウィンドウサイズ変更) の時に bash の表示する物になってしまう

  * complete

    TAB を打たなくても補完候補がある場合は薄く表示する?

    重くなるといけないので read -t 0 で確認しつつ処理を行うのが良い。

    実際に未だ入力されていない物を上に重ねて表示する場合、また新しい枠組が必要になる気がする。

    a 一つの簡単な方法は「編集文字列を本当に書き換えてしまう」方法である。
      しかし編集文字列を書き換えている状態で別のコマンドが起動されるなどすると
      編集文字列内容に齟齬が生じて面倒な事になる。それを防ぐ為に新しいコマンドが来るたびに
      編集文字列の内容を復元するようにトラップをしかけるのも綺麗でない。
      その他の理由でトラップをしかけたくなった時などに結局齟齬が生じる可能性が残る。

      この方法は現実的でない。

    b もう一つの方法は上に重ねる事のできる「レイヤー」の概念を導入する方法である。

      レイヤーを導入する場合、描画ルーチンが面倒な事になる。

      b.1 既存の描画ルーチンを活かす方向で行くと、
        一旦一番下のレイヤーを描画した後でその上にあるレイヤーの描画をつづけて行えばよい。
        しかしこれだとちらつきが気になる。

      b.2 もう一つの方法は描画を完全に座標指定で行う事にして、
        あるレイヤーを描画する際にはマスクを考慮して描画できる様にする。

        うーん。わざわざ座標指定で描画を行える様にしなくても、
        既存の描画関数の内部を適当に書き換えるだけで行けそうな気もしないでもない。
        要するにマスクされた領域の上にある文字については、文字を出力する代わりに
        位置だけを更新して、最初にマスクされていない領域の文字を書き込もうとした瞬間に、
        その位置へ移動するシーケンスを生成する様にしたらよい。

        ただこの時に問題なのはどの様にしてマスクされた領域を表現するかである。
        領域の上に複雑にレイヤーが存在している場合、領域に沢山の矩形の穴が空いた状態になる。
        この様なマスクがある場合マスクの上にあるかどうかの判定は物凄く重い計算になる。

        やはり描画可能領域は矩形に制限して、上に重なっている別のレイヤーに関しては
        上から重ねて描画してしまうという手を取った方法の方が良いのではないかという気がする。


      b.3 或いは内部に完全に画面のバッファを保存してしまうという手もある。
        そして最後に更新された部分だけ反映させるという方法である。

        o この方法だとサブウィンドウを作成したりする事ができて汎用性が高い。
          何れはこの方法を採らなければならなくなるのではと言う気がする。

        x 特に各座標位置について描画属性などを保存する事になるだろう。
          しかしメモリを食うのではないかなどの懸念も残る。

        x また描画用のシーケンスの生成にも処理時間が掛かりそうな気がする。
          何しろ記録した配列の要素をスキャンしてシーケンスを構築していかなければならないからである。
          或いは現在の編集文字列の記録と同様に配列に描画シーケンスも含めて記録しておいて、
          其処から特定の範囲の要素だけ単純に join して出力できるようにするか。


  * 描画ちらつき: DCH や ICH 等を用いた効率化?

  * bind の上書き

    未だ時期尚早である。先ず、readline の function を一通り実装しなければならない (expand 系が大変)。
    また、bind にある様々なオプションとそれらを組み合わせて使った時の振る舞いについて整理しなければならない。

    一応将来的な実装の為に、既存の bind の呼出に一通り builtin をつけた。

2015-02-21

  * zsh にある機能で気になる物

    menu 補間と言った物もあるようだ。
      選択肢の説明の表示もできる。
      考えつきそうな機能は一通り揃っているという事か。

    /a/b/c 等に対してディレクトリ名の補間も行う
      でも、これはやった後で一意に補完できない事が分かった場合が悲しい。
      TAB を打つ回数が多少減るだけで何が嬉しいのか分からない。
      しかしながら、曖昧一致による補完機能はあった方が便利な気がする。
      ただ、候補を表示するに留め、無断で補完する事はやめる。

2015-02-18
  * エラーメッセージの設定を可能にする

  * 履歴展開の微妙な所

    例えば echo "!a" は !a の部分が履歴展開される。
    しかし echo !a" は !a" の部分が履歴展開される。
    これらの規則は一体どうなっているのだろう。man には大して何も書かれていない。


2015-02-16
  * ble-syntax.sh ToDo

    > 関数定義 function ...
    - ${ ... } 内の文法チェック
    - a=(arr) b=([x]=123 [y]=321) a+=
      aaa=(hoge), 他に aaa+=(hoge) というパターンもある。
      これは declare や local typset readonly 等を文法的に特別扱いしなければ対応できない
    - case構文の中の文法
    - ;; ;& ;;& の後に case のパターンを受ける
    - Here document, Here string
      Here document は次の行から始まるというのが厄介である。
    - [[ 条件式の文法。より正確に
    - time -p
    - extglob

2013-06-10

  * ble-bind キーボードマクロの定義に対応
    + DEL を BS にマップする
    + C-_ を C-BS にマップする
    + C-m を RET にマップする
    + C-i を TAB にマップする
    + M-大文字 を M-S-小文字 にマップする? → これは CapsLock に依存するので止めておく
    + DEL の bind している物を BS から bind する。
    + C-_ の bind している物を C-BS から bind する。

  * sword で quote を正しく処理する?

    これは少なくとも解析器が出来た後に考える。

2013-06-06

  * complete: 入力する側から候補を表示?
  * complete: complete -F に対する対応
  * complete: 空白文字や " や ' などをエスケープしている時も正しく単語分割する
  * complete: コマンド先頭位置の検出 (複合文の途中からコマンドが始まっている場合など)
  * complete: 候補一覧の整列

  * ble-line-info の描画のタイミングを ble-edit-draw.update と同じ時にする?
    それ以外の時に描画したければ、必要に応じてその場で明示的に描画させる。

2013-06-05

  * bashfc
  * RPS1

    zsh で試してみた所、そもそも RPS1 に改行を含めると RPS1 自体表示されない事が分かった。
    改行は含まれていないと仮定して表示してしまっても良いのかも知れない(2015-03-04)。


  * ^U ^V ^W ^? bind 関連
    + 説明書にその事を書いておく。
    + ^U ^V ^W ^? を bind するより良い方法があれば考える
    + bashrc の中でも同様に問題が起こるのか?

    + 一旦 bind '"":"hogehoge"' 等として変換したら受信できる可能性?

2013-06-04

  * vbell .time の置き場所を変更?

  * 説明書:
    + 問題点: 既存の bind を上書きする事
    + 問題点: 既存の trap を上書きする事
    →これらは説明書にその様に書いておけば問題ない

2013-06-01 以前

  * vbell
    + スタイルを指定できる様にする
    + 位置を指定できる様にする
    + メッセージが長い場合に適度に長さを制限する

  * ble-decode
    + [kbd] terminfo からの読み取り (entry 名は tmux が参考になる)
    + ble-bind: -x オプションに対する対応: BLE_LINE, BLE_POINT, 再描画
    * ble-bind: -s オプションで文字入力の羅列を指定できる様にする。

  * 編集文字列の表示
    + スタイル指定文字列
    + color fall backs
    + forward-char
    + goto-char
    + insert-string
    + insert-char

  * デフォルトで bind されている readline 関数の一覧をチェック
  compgen, history コマンドを関数内から自由に利用する事が出来るか

  * 説明書
    + 文字コード decoder の追加方法
    + keysequence を指定する文字列の文法
    + スタイルを指定する文字列の文法

  * 問題点
    + コマンドが完結していない状態で accept-line すると
      既定の動作では続きを入力する事が出来るが、
      eval をすると単にエラーになってしまう。

      →これは寧ろこの様な動作の方が分かりやすいかも知れない。
        取り敢えずそういう仕様と言う事にする。


*******************************************************************************
    ChangeLog
-------------------------------------------------------------------------------

2015-03-03
  * ble-edit.sh, ble-edit.color: discard-line の際に着色
  * ble-edit.sh, ble-core.sh, etc: echo を builtin echo に。
  * ble-edit.sh: bugfix, 複数行で上に行けない
  * ble-edit.sh: bugfix, 複数行なのに空行の accept-line でのずれ量が1行になっている
  * プロンプト再実装
    - ble-edit.sh (ble-edit/draw/trace): escape sequences が含まれている文字列の位置追跡。
    - ble-edit.sh (.ble-line-prompt/update): プロンプトの構築を再実装。$() がある場合なども正しい計算。
  * ble-complete.sh (source/command): shopt -s autocd の時にディレクトリ名も候補として列挙。
  * ble-complete.sh: 補完候補の選択の方法を変更。より近くの開始点の物を優先。

2015-03-01

  * ble-edit.sh: .ble-edit-draw.goto-xy, .ble-edit-draw.put 廃止
  * complete.sh: 関数名に / が入っていると compgen -c で列挙されないので、別に列挙する。

2015-02-28

  * 初期化の最適化
    - ble-decode.sh: ble-decode-kbd 書き直し、ble-bind 書き直し
    - ble-getopt.sh: 多少最適化
    - ble-decode.sh: bash-4.3 でも ESC [ を utf-8 2-byte code で受信する様に変更。
    - ble-decode.sh (.ble-decode-bind/generate-source-to-unbind-default): awk 呼出を一回に統合。
    - ble-decode.sh (.ble-decode-key.bind/unbind): [[ ]] による書き換え、bugfix。
    - ble-decode.sh, bind.sh: bind -x を生成する為のコードを bind.sh に分離。
    - ble-edit.sh, keymap.emacs.sh: keymap 初期化部分の分離、キャッシュ化。
    - ble-edit.sh: history 遅延ロード対応
  * ble-core.sh, ble-color.sh: .ble-shopt-extglob-push/pop/pop-all 廃止
  * ble-edit.sh: bugfix, .ble-line-info.clear で位置がずれる
  * ble-edit.sh: ble-edit/draw/put.il, ble-edit/draw/put.dl
  * ble-color.sh (ble-highlight-layer/update/shift): 長さが変わらない場合でも shift する。
  * ble.pp (include ble-getopt.sh): 現在使っている所がないので取り敢えず外す。
  * ble-syntax.sh (completion-context): 簡単なパラメータ展開に対する対応。

2015-02-27

  * <bug> TAB 等の変更文字があった場合に文字列が表示されなくなる
  * bash-3.0, 3.1 対応
    "<bug> bash-3.1 日本語の色付け・描画が変だ"
    - ble-edit.sh, 他: @bash-3.1 bashbug workaround, ${param//%d/x} などは効かないので %d を '' で囲む。
    - ble-syntax.sh, 他: @bash-3.1 bashbug workaround, x${#arr[n]} はバイト数を返す様なので一旦通常変数に入れて ${#var} とする。
    - *.sh: @bash-3.0: += 演算子の置き換え、配列宣言の修正。
    - term.sh: @bash-3.0: bashbug workaround, declare -p で出力すると誤った物になる。
  * ble-edit.sh (.ble-line-text/update/slice): bugfix, 変更文字がある時にもう存在しないローカル変数を参照していた。
  * ble-core.sh: ble-load, ble-autoload
  * complete.sh:, ble-syntax.sh, ble-edit.sh: 文脈依存補完の実装

2015-02-26

  * ble-syntax.sh: a+=( a=( に対応

2015-02-25

  * ble/term.sh: TERM 依存の部分を分離。キャッシュ化。完全移行ではないが徐々に。
  * ble-decode.sh:
    - <bug> $_ble_base/cache の代わりに $_ble_bash/cache を作成していた
    - <bug> accept-single-line-or-newline が二回目以降常に accept
  * ble-edit.sh:
    - <bug> 複数行の編集時に履歴移動をすると表示が乱れる
    - printf %()T を用いた実装の導入、PS1 \D{...} に対応
    - <bug> 表示の属性の更新がうまく行かない事がある。
    - <bug> 編集文字列の行数が変わった時に info.draw の内容がずれる
  * カーソル移動
    - ble-edit: 複数行編集と項目内でのカーソル移動に対応
    - ble-edit.sh: 複数行コマンドの履歴に対応。
  * ble-syntax.sh: ble-syntax-highlight+syntax を ble-highlight-layer:syntax に書き換え
  * ble-syntax.sh:
    - 関数定義 func() の形式に対応、
    - 条件式 [[ ... ]] と配列初期化子内の文脈に対応。
    - コメントに対応。
    - $[...] の形式に対応 (何故か bash の説明には一切載っていないが使える)。
    - <bug> invalid nest " $()" の先頭に for を挿入した時

2015-02-24

  * ble-edit.sh 出力の部分更新に対応 (描画ちらつき対策)
  * ble-syntax.sh: _ble_syntax_word, _ble_syntax_stat の形式の変更
  * ble-syntax.sh: 今迄行っていた dirty-range 拡大の方法を止めて、単に stat の削除を行う。
  * ble-syntax.sh: 及び上記の変更に伴う数々の bugfix
    - <bug> 文字削除時 invalid nest の assertion に引っかかる。
    - <bug> 編集内容が零文字になった瞬間に改行が起こって表示が消える。
    - <bug> 改行しても先頭がコマンドになっていない
    - <bug> _ble_region_highlight_table で空欄になっている箇所がある。
    - <bug> 単語の属性適用が後ろに続く単語にも続いている。
    - <bug> _ble_syntax_attr の中に "BLE_ATTR_ERR" の文字列が混入している。
    - 残っている dirty 拡大と _ble_syntax_word[] の廃止された形式に対する処理の
      コメントアウトされた部分を削除。dirty 拡大の変更に伴う効率化の確認と、
      shift が遅いという事の ToDo 項目の追加。
  * ble-decode.sh: <bug> $_ble_base/cache の代わりに $_ble_bash/cache を作成していた
  * ble-edit.sh: ble-edit+delete-backward-xword の類の動作を変更。

2015-02-23

  * ble-core.sh: ble-stackdump, ble-assert
  * <bug> update-positions で dend-dbeg が負になると警告が出る
  * <bug> info.draw で特殊文字が改行に跨っている時の座標計算

2015-02-22

  * ble-edit.sh: <bug> .ble-line-info.draw を使った時行がずれる
  * ble-syntax.sh: <bug> for や do に色が着かない?
  * レイヤー化
    - ble-color.sh: レイヤーの仕組み、レイヤ region, adapter, plain + RandomColor
    - ble-edit.sh: レイヤーに対応した表示文字列構築関数。古い構築関数の削除。出力関数の変更。
    - ble-syntax.sh: 多少の変更。

2015-02-21

  * 描画の高速化
    - ble-syntax.sh: 属性値の変更範囲に応じて適用を行い、変更範囲を LAYER_MIN, LAYER_MAX に返す様に。
    - ble-edit.sh: 表示用の文字列の構築部分を書き直して部分更新に対応。
    - ble-syntax.sh: 内容に変化のあった word の範囲も記録する様に変更。
    - ble-syntax.sh (parse): _ble_syntax_attr_umin (属性値の変更範囲),
      _ble_syntax_word_umin (word の変更範囲) の累積に対応する為に、これらについても shift を実行する。

2015-02-20

  * ble-decode.sh: bind 周り
    - bash-4.3 C-@ を utf-8 2-byte code で受信する様に変更
    - bash-3.1 ESC [ を utf-8 2-byte code で受信する様に変更
    - bugfix, \C-\\ \C-_ \C-^ \C-] に bind できなくなっていた。
    - bind の version 分岐について整理。
    - 既存の bind を ESC に関係なく bind -r する。
  * ble-decode.sh: .ble-decode-key 部分一致探索の処理の再実装。変な動作だった。
  * ble-decode.sh: bugfix, 8bit 文字を正しく bind できていない。c2s で8bit文字が符号化されていた。
  * ble-syntax.sh: 履歴展開は $- に H がある時のみ有効に。
  * ble-syntax.sh: bugfix, bash-4.2 のバグの work around。配列を参照する算術式の書き換え。
  * ble-core.sh: c2s を bash の機能だけで実装できたので fallback を replace。
  * ble-core.sh: bash-4.0 で .ble-text.s2c を連想配列でメモ化
  * ble-edit.sh: bugfix, bash-4.0 で ret に予め特定の値が入っていると c2w に失敗する。
  * ble-edit.sh: bugfix, bind -x 直前のプロンプトの取り扱いは bash-4.0 では bash-3 系と同じ。
  * ble-edit.sh (.ble-line-text.construct 周り): lc lg を後で計算する様に変更。一区切り。一旦 commit する。

2015-02-19
  * ble-syntax.sh: 履歴展開に対応。
  * ble-decode.sh: bugfix, bind -X から bind -x を生成するコード。
    bind -X の出力する形式は再利用不可能な形式でエスケープされているのでこれを変換。
  * ble.pp, etc: noattach 引数に対応。ble-attach/ble-detach 関数の定義。detach の bugfix。
  * ble-edit.sh: bug, bleopt_suppress_bash_output= にした時にプロンプトが二重になる

2015-02-18

  * ble.pp, ...: ディレクトリの構成を変更
  * ble-syntax.sh: 文法の対応
    - プロセス置換を単語として扱う様に変更
    - リダイレクトの後の引数に対応
    - リダイレクトの前の fd 部分に対応
  * bash-3.1 対応
    - ble-edit.sh: bash-3.1 で C-d を捕捉できる様に(結構無理のある方法だが)。
    - ble-edit.sh, ble-decode.sh: bugfix, bash-3 でカーソルキーの類が動かない。履歴が読み込まれていない。
    - ble-edis.sh: bash-3.1, bleopt_suppress_bash_output=1 の方が安定して動いているのでこちらで行く。
    - ble-edit.sh: bash-3.1, カーソルキーが効かない。例によって ESC [ ... に関係するコマンドで
      keymap が見付からないエラーになっている。これは ESC [ を CSI (utf-8) に変換してから読み取る事にした。
    - ble-syntax.sh: bash-3.2.48 のバグの work-around, (()) 内で配列要素を参照すると制御が無条件に其処に跳ぶ。

2015-02-17
  * ble-edit.sh (ble-edit/dirty-range): 範囲更新の仕組みを追加。
      _ble_edit_dirty はプロンプト再描画の判定も兼ねているので取り敢えず残す。
  * ble-edit.sh: 変数リーク (グローバル変数の汚染) の修正。line i
  * ble-syntax.sh (ctx-command/check-word-end): 単語終了判定の処理タイミングを変更。
  * ble-syntax.sh: context の追加。CTX_CMDXF CTX_CMDX1 CTX_CMDXV CTX_ARGX0
    より正確な文脈判定・エラー検知。
  * ble-syntax.sh: 他にも多くの修正がある。未だ修正が続きそうなので一旦 commit する。

  * ble-edit.sh (accept-line): bug, - で始まるコマンドを実行できない。
  * ble-color.sh: <bug> bg=black を設定しても反映されない。
    "未設定" と "黒" を区別する様に修正。
  * ble-syntax (ble-syntax-highlight+syntax): 入れ子エラーの色の範囲
  * ble-syntax: m, ;& は ;; ;;& 等と同じ取り扱い
  * ble-syntax, etc: bash-3 正規表現対策。bash-3/4 の正規表現の違いに依存しない書き方に変更。

2015-02-16
  * ble-syntax.sh: bugfix, incremental に更新した時に word の長さが更新されない。
    _ble_syntax_word への格納の際に失敗していた。

2015-02-15
  * ble-synatax.sh: bash の文法に従った incremental な解析と色付け。

2015-02-14
  * ble-edit.sh (.ble-line-info.draw): 表示が遅いので修正。
    ASCII 文字は特別扱いする様に改良。劇的に速くなった。

2015-02-13
  * ble-edit.sh (keymap emacs): 既定の keymap に emacs の名を付与。
  * ble-edit.sh (accept-line.exec): bugfix, C-c で再帰呼び出しのループから抜けられない。
    trap DEBUG を用いて再帰呼び出しから抜けられる様に exec 周りを整理・実装し直し。
  * ble-edit.sh: オプション名の変更、各オプションの整理・説明の追加。
  * ble-edit.sh (.ble-edit/gexec): グローバルな文脈でコマンドを実行する仕組み。
    再帰呼出に対する C-c にも対応。bleopt_exec_type で実行の方法を切り替えられる様に。
    exec が従来の方法で gexec がこの新しい方法。

2015-02-12
  * ble-decode.sh: bugfix, exit 後に stty が壊れているのを修正
    これに伴って ble の detach 機能の実装も行った。
  * ble-decode.sh: bugfix, bash-4.3 で三文字以上のシーケンスが悉く聞かない。
    keymap が見付からないエラーになってしまうので全てのシーケンスについて bind -x する事にした。
  * ble-core.sh: bugfix, builtin printf \U.... の使えない環境で command printf fallback が働かない。
    printf のパスを修正。また ASCII に対しては printf は使わない様に変更。
  * ble-color.sh (ble-syntax-highlight+default):
    追加・修正。また選択範囲の反転を ble-syntax-highlight+region として実装し、それを呼び出す形に。
  * ble.pp: 起動時に interactive モードかどうかのチェックを行う様に。

2015-02-11
  * ble-edit.sh (_ble_edit_io_*): ちらつきを抑える為に stdout/stderr を切り替える事にした。
    ちらつくのは bash の既定の出力によって ble の表示がクリアされ、bash の表示したい物が表示されるから。
    これに対抗して ble は bash の出力の直後に上書き再描画して何とか表示していた。
    bash の既定の出力を抑える為に、exec で出力先を切り替える事にした。
    bash の出力はファイルに書き込まれる様にし向ける。出力先ファイルを逐次確認して、
    エラーが出力されていれば visible-bell で表示する事にした。
    bleopt_suppress_bash_output=1 の時にこの新しい方法を実験的に用いる。
    bleopt_suppress_bash_output= の時は従来のちらつく方法。

2015-02-10
  * ble-edit.sh (accept-line.exec): bash-4.3 で内部からグローバル変数を定義できる様に
    declare 及び typeset を上書きして -g オプションを指定する様に変更。
    また、これに関係する注意点を ble.htm に記述。
  * ble-edit.sh (history): ロードに時間が掛かるので最適化。
  * 全般: bugfix, 文字列分割で GLOBIGNORE='*' を設定していないとパス名展開されて危険
  * ble-color.sh (ble-syntax-highlight+default): より良い色づけ。
  * ble-edit.sh (accept-line.exec): ble-bind -cf で bind されたコマンドの実行コンテキストを変更。
    accept-line で実行されるのと同じコンテキストで実行する。
  * ble-edit.sh (keymap default): C-z M-z を fg に bind。

2015-02-09
  * git repos
  * ble-edit: bugfix, locate-xword マクロが展開されていなかった
  * ble-decode: bash-4.3 に対応する為に色々変更
    - bind 指定の場合分けを整理
    - bugfix, ESC ?, ESC [ ? に対して全て bind
    - bugfix, 場合によって全く bind -r できていない
      →"bind -sp | fgrep" が "バイナリ" という結果になる事がある様だ。
        fgrep に -a を指定する。
    - bugfix, 日本語が入力できない。8bit 文字が認識されない。
      →8bit 文字はエスケープシーケンスで bind に指定する様に変更。

2013-06-12
  * ble-edit: history-beginning, history-end, accept-and-next

2013-06-12
  * ble-edit:
    kill-forward-fword, kill-backward-fword, kill-fword,
    copy-forward-fword, copy-backward-fword, copy-fword,
    delete-forward-fword, delete-backward-fword, delete-fword,
    forward-fword, backward-fword
  * ble-edit: history-expand-line, display-shell-version

2013-06-10
  * ble-edit:
    kill-forward-uword, kill-backward-uword, kill-uword, kill-region-or-uword,
    copy-forward-uword, copy-backward-uword, copy-uword, copy-region-or-uword,
    forward-uword, backward-uword

  * ble-edit:
    delete-forward-uword, delete-backward-uword, delete-uword, delete-region-or-uword,
    delete-forward-sword, delete-backward-sword, delete-sword, delete-region-or-sword,
    delete-forward-cword, delete-backward-cword, delete-cword, delete-region-or-cword

  * ble-edit:
    以下の編集関数を廃止:
      delete-region-or-uword, kill-region-or-uword, copy-region-or-uword,
      delete-region-or-sword, kill-region-or-sword, copy-region-or-sword,
      delete-region-or-cword, kill-region-or-cword, copy-region-or-cword.
    代わりに以下の編集関数を用いる:
      delete-region-or type, kill-region-or type, copy-region-or type.

2013-06-09
  * ble-edit: kill-region, copy-region
  * ble-edit:
    kill-forward-sword, kill-backward-sword, kill-sword, kill-region-or-sword,
    copy-forward-sword, copy-backward-sword, copy-sword, copy-region-or-sword
  * ble-edit:
    kill-forward-cword, kill-backward-cword, kill-cword, kill-region-or-cword,
    copy-forward-cword, copy-backward-cword, copy-cword, copy-region-or-cword
  * ble-edit: forward-sword, backward-sword, forward-cword, backward-cword

2013-06-06
  * ble-edit-bind: 全ての文字・キーが入力可能に。
  * complete: 候補一覧の表示 (簡易版)
  * ble-color.sh: 色付け機能を highlight.sh から移植

2013-06-05
  * ble-edit: history-isearch-backward, history-isearch-forward,
    isearch/self-insert,
    isearch/next, isearch/forward, isearch/backward,
    isearch/exit, isearch/cancel, isearch/default,
    isearch/prev, isearch/accept
  * ble-edit: yank
  * ble-bind -d で今迄に bind した物を表示できる様に。
  * ble-edit: complete, 取り敢えずファイル名補完だけ
  * ble-edit: command-help

2013-06-04
  * ble-edit: discard-line, accept-line
  * ble-edit: history-prev, history-next
  * ble-edit: set-mark, kill-line, kill-backward-line, exchange-point-and-mark
  * ble-edit: clear-screen
  * ble-edit: transpose-chars
  * ble-edit: insert-string

2013-06-03
  * ble-edit: bell, self-insert, redraw-line,
  * ble-edit: delete-char, delete-backward-char, delete-char-or-exit,
    delete-forward-backward-char
  * ble-edit: forward-char, backward-char, end-of-line, beginning-of-line
  * ble-edit: quoted-insert
  * ble.sh: 取り敢えず簡単に文字列を入力できる程度までは完成

2013-06-02
  * ble-getopt.sh: bugfixes
  * ble-getopt.sh: 無事に完了した場合に OPTARGS を unset する様に変更
  * ble-decode-kbd, ble-decode-unkbd

2013-05-31
  * ble-getopt.sh: created
  * ble-decode: 大枠が完成

2013-05-30
  * highlight.sh: 取り敢えず簡単な色付け
  * ble.sh:

    -- 経緯 --
    highlight.sh の方針だと bash が表示する編集中の内容を消す事が出来ないし、
    カーソルの位置も bash が表示する物の場所を指している。
    色を付けて表示した物は、補助的に bash が表示する物の下に並べて表示する
    ぐらいしか方法がない。

    また readline 関数をスクリプトから呼び出す事が出来ないので、
    結局、色付けを更新したいタイミングで READLINE_LINE や READLINE_POINT の動作を
    スクリプトの側で全て模倣して再現しなければならない。
    READLINE_LINE, READLINE_POINT の bash の仕様が変な所為で、日本語など
    のマルチバイトで正しく処理する為に、色々と汚い事をしなければならない。

    以上の事から、文字列の編集などの操作からスクリプトの実行まで
    全部自分で好きな様に実装して bash readline の機能を全て上書きする事にした。
    その為に、スクリプトを新しく書き直す。zle を真似て ble (bash line editor)
    と名付ける。

    -- 方針としては --
    a. read -n 1 を用いて 1 文字ずつ標準入力から文字を取り出してそれを処理していく
    b. bash の bind で全ての文字に ble のバイト受信関数を繋げて、
       バイト列を受信しながら処理する。

    highlight.sh の延長線上で b. の方針にしたが、
    もしかすると a. の方針も可能かも知れない。

2013-05-29
  * highlight.sh: 作成


*******************************************************************************
    実装ログ
-------------------------------------------------------------------------------

2015-12-01

  * bug: isearch/forward incremental にできない。

2015-11-29

  * input_encoding=C full support as 'UTF-8'

  * bug

    選択している状態で history を移動すると座標がずれる。
    特に長いコマンドの一部を選択している時にずれる。
    ずれの量は選択範囲の長さや位置に依存しない。

    どうやら ble-syntax-layer:region が悪い様だ。
    _ble_highlight_layer__list から region を外したら直った。

  * ライセンスファイルの追加

  * ble-bind -xf
    ble-bind -x 未実装状態になっている
    →これは単純に ble-edit+... を実装してそれを ble-bind -c で登録すれば良いだけなのでは?

2015-11-25

  * 公開までに特に必要な物 [2015-03-01]

    > 1 背景が暗い環境での色の設定
    >   これは確認してみたがそんなに問題にならないのではないかという気がした。
    >   何れにしても自由に配色を設定できるようにする仕組みは提供する必要がある。
    >   →解説を加えれば良い。
    > 2 complete の設定の取り込み
    3 bind 等の設定の取り込み
      readline 関数の完全対応
      bind -x は対応しなくて良い
      inputrc は対応しない。簡単に翻訳できるから。
    > 4 正しい PS1 の解釈

    取り敢えず大体の所は終わった。
    readline 関数の完全対応には時間が掛かると思われるので、一旦保留として別項目にする。

2015-11-23

  * magic-space

    特定の文字列がある時にカーソルが末端に移動する。

  * プログラム補完: ディレクトリ名の直後の "/" 挿入

    プログラム補完でディレクトリ名を列挙されると、
    それがディレクトリ名であるにも関わらず直後に " " が挿入されて中のファイルを列挙できなくなる。
    仕方がないのでプログラム補完で生成される候補については action/file で登録する事にする。
    つまり、ディレクトリ名に一致すれば "/" を末尾に挿入するしそれ以外ならば " " を挿入する。

  * complete/compopt -o の対応

    + compopt -o nospace 等の情報を取り出す事ができない?
      これは complete -p の解析時に先ず抽出し、
      更に、プログラム補完時に compopt 関数を上書きすればよい。
      →実装した。動いている様に見える。

    + compopt -o filenames/dirnames/default/bashdefault
      現状だとこれらは全く使われない様だ。
      これは compgen に失敗した時にどの様に動作するかを指定する物であって、
      compgen 自体の動作には影響を与えない様である。

    + compopt -o plusdirs については compgen の方で処理してくれる様なので気にする必要はない。

  * bug: ble-detach による stty 破壊

    ble-detach した後に rm file RET yes RET とすると反応がなくなる。
    改行が正しく伝わっていない? stty で調べてみる。

    ble$ bash-4.0 --norc
    ble$ stty -a
    speed 38400 baud; rows 73; columns 210; line = 0;
    intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = M-^?; eol2 = M-^?; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;
    -parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
    -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl -ixon -ixoff -iuclc -ixany -imaxbel -iutf8
    opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
    isig -icanon iexten echo -echoe -echok -echonl -noflsh -xcase -tostop -echoprt -echoctl -echoke

    ble$ stty -a
    speed 38400 baud; rows 73; columns 210; line = 0;
    intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = M-^?; eol2 = M-^?; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;
    -parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
    -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl -ixon -ixoff -iuclc -ixany -imaxbel -iutf8
    opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
    isig -icanon iexten echo -echoe -echok -echonl -noflsh -xcase -tostop -echoprt -echoctl -echoke

    ble$ ble-detach
    ble$ stty -a
    speed 38400 baud; rows 73; columns 210; line = 0;
    intr = <undef>; quit = <undef>; erase = <undef>; kill = <undef>; eof = ^D; eol = M-^?; eol2 = M-^?; swtch = <undef>; start = ^Q; stop = ^S; susp = <undef>; rprnt = ^R; werase = <undef>; lnext = <undef>;
    flush = ^O; min = 1; time = 0;
    -parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
    -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr -icrnl -ixon -ixoff -iuclc -ixany -imaxbel -iutf8
    opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
    isig -icanon iexten echo -echoe -echok -echonl -noflsh -xcase -tostop -echoprt -echoctl -echoke

    どうも色々な設定が消滅している様子である。
    状態の復元は ble-decode-detach -> .ble-stty.finalize -> stty で実行している筈である。
    やはり bind -x の中で実行した stty の反映には制限が伴うという事か。
    一応最後に stty sane を実行すれば直る。

    取り敢えずの暫定処置として stty sane を ble-detach 後にユーザに実行して貰う事にする。

  * complete -p による補完を動作する様に修正。

    下らないバグだった。extract-command 内で、出力変数の筈の
    comp_words comp_line comp_point comp_cword に対して local を指定したままだった。
    (実装中にテスト用として local 宣言していたのが残っていた。)

  * complete -F 対応

    if complete -p コマンド名 &>/dev/null; then
      IFS=$'\n'
      local arr=$(
        1 ble-getopt $(complete -p コマンド名) で解析
        2 -F, -C オプションに指定されたコマンドを ble の用意した物に置き換え
          ble の関数で COMP_ 変数を用意し、
          その後で -F -C オプションに指定されていたコマンドを呼び出す。
          呼出方などは -F -C の仕様に準じる。
        3 compgen 解析したオプション -- "$COMPV" を呼び出し候補を列挙する
      )
    fi

    既存のシェル関数による補完候補生成 (complete -F) の仕様について確認する。

    | complete -F による補完を実行する際にどの様な変数を設定する事になっていたか、
    | どの様にして補完単語及び補完単語を指定する事になっていたかについても確認する必要がある。
    | それらの仕様によってどの様にコマンドラインの情報を構築するかが変わってくるからである。
    |
    | 基本的に complete -F 呼出元では COMP_ シェル変数を設定すれば良いと考えられる。
    | COMP_* シェル変数には以下のような物がある。
    | - COMP_LINE   コマンドライン全体
    | - COMP_POINT  コマンドライン全体の内の位置
    | - COMP_WORDS  コマンドラインを構成する単語たち
    | - COMP_CWORD  COMP_WORDS 内のどの単語に現在カーソルがあるか
    | - COMP_KEY
    | - COMP_TYPE
    | - COMP_WORDBREAKS ← これはユーザ側が comp の動作を制御する為に使用する変数であって、comp 側で設定する変数ではない。
    |
    | 疑問: 補完関数はどの様にして COMP_WORDS[COMP_CWORD] 内におけるカーソルの位置を知るのか?
    | a 例えばカーソル位置で必ず単語が切断されるのか、
    | b 或いは、COMP_WORDS[COMP_CWORD] にはカーソルよりも前の部分しか格納されないのか、
    | c COMP_WORDS 自体がカーソルよりも前の部分だけしか含まないのか、
    | d それともカーソル位置を知る方法はないのか。
    |
    | →d の様である。COMP_WORDS COMP_CWORD は素直に生成される。
    |   従って単語の途中で TAB を押している可能性もあるので、
    |   シェル関数側では「COMP_WORDS[COMP_CWORD] から始まる単語だけを生成する」
    |   という訳には行かないようである。ちゃんと COMP_LINE, COMP_POINT を用いて、
    |   現在のカーソルの位置が何処にあるのかを確認して候補を列挙する必要がある。
    |
    | 疑問: COMP_POINT の説明が気になる。コマンドの先頭からの offset というのは、
    |   コマンドラインの先頭からの位置とは違うのだろうか。例えば複数のコマンドがコマンドラインに含まれている場合にどうなるか。
    |   特に、複数のコマンドが含まれている場合には、他のシェル変数 COMP_CWORD, COMP_WORDS, COMP_LINE 等もどうなるか気になる。
    |
    | →何と! ちゃんとコマンドライン中の、現在のコマンドに対応する部分を切り出して
    |   COMP_LINE, COMP_WORDS, COMP_CWORD を設定してくれる様だ。
    |   COMP_LINE が現在のコマンドラインだという説明が誤っていたという事になる。
    |
    |   所で $(echo $(echo $(...)) 等としてみたが、... の場所に書かれているコマンドについては
    |   complete で設定された補完は実行されないようである。
    |   一番外側のコマンドについて complete が呼び出されるだけである。
    |   一番外側のコマンドについての補完では $(...) はちゃんとひとまとまりとして
    |   (途中の空白で単語分割されたりせずに) 扱われる様である。
    |
    | 疑問: compgen は COMP_* に対して透過的か?
    |   つまり、先ず compgen -F でシェル関数は呼び出されるのか? という事と、更に、
    |   COMP_* だけ自分で適当に設定すれば compgen -F を介して呼び出される関数は期待通りに動くのか?
    |
    | →試してみた所、透過的ではなかった。関数内で見ると COMP_LINE= COMP_POINT=0 COMP_CWORD=-1 の状態になる。
    |   そればかりか、関数呼出元の変数の内容も変更されてしまう様である。
    |   もし compgen を利用するとなると -F の内容は一旦関数でくるんで実行する事になるだろう。
    |
    | 従来の bash 向けの補完関数の能力を最大限に引き出す為には ble 側で、
    | 現在のコマンドの部分を切り出して仮想的に再現した COMP_LINE, COMP_POINT を用意する必要がある。

    結論 (origiinal complete の仕様)

    (1) COMP_LINE, COMP_POINT, COMP_WORDS, COMP_CWORD は現在のカーソル位置にあるコマンドから作られる。
    (2) COMP_WORDS, COMP_CWORD はカーソルが現在の単語の中のどの位置にあるかは教えてくれない。
    (3) compgen -F を実行すると COMP_* の内容がクリアされてしまう。

    結論 (方針)

    (1) 基本的には complete -p の結果を元に compgen を用いて候補の生成を行う。
    (2) complete -F のシェル関数は COMP_* を設定する関数を一旦挟んでから呼び出す様に介入する。
    (3) 補完対象は現在カーソルがある位置のコマンド全体を特定して決める。
      そこから仮想 COMP_LINE COMP_POINT を構築する。

    先ずはコマンド全体を抽出する所から始まる。

    | [コマンド全体を抽出する手法の選択]
    |
    | というよりそもそも現在の実装で単語のどの様に抽出していたか?
    | →ble-edit+complete 関数から ble-syntax/completion-context 関数を呼び出している。
    |   更にそこから ble-syntax/completion-context/check-prefix 関数を呼び出している。
    |   この中で現在位置が属している単語の切り出しを行っている筈である。
    |   実際に見てみると現在位置から先頭に向かって順に _ble_syntax_stat を見ていって、
    |   現在位置より前にある最後の解析再開点の情報を読む。
    |   解析再開点には現在の解析における単語開始位置などの情報が格納されている。
    |   この情報を利用すれば確かに現在位置にある単語の情報を抽出する事ができる。
    |
    | では更に現在位置の属している単語だけではなくコマンドまで抽出するにはどうしたら良いか。
    | 取り敢えず現在の単語とそれより前にある単語を順に辿って行って、
    | 初めにコマンド単語に当たったら其処で停止するという方法を取れば現在のコマンドを抽出できる。
    | その過程でコマンド・最初の引数から現在の引数までを取得する事は可能である。
    | しかし、以降の単語を抽出するにはどの様にしたら良いのだろうか。
    | 一文字ずつ進んで確かめていく方法だとそのコマンドがとても長いコマンドであった場合に時間が掛かる。
    | すると木構造を辿るしかないのだろうか。現在の実装だと中身から木構造を根本に辿る方法は提供されない。
    | ここで二つの選択肢がある。
    |
    | a tree-enumerate を利用して根本から順に辿っていく方法
    |
    |   現状 ble_debug=1 としてデバグ用情報を表示している時でもそんなに重くは無いようだから、
    |   根本から情報を辿る方式でもそんなに問題は無いように思われる。
    |
    | b tree-enumerate の情報をキャッシュして葉から根本の方向へ辿る事のできるデータ構造を構築する方法
    |
    |   % しかしながら、今後色付けなどの更新の方の需要から、
    |   % 葉から根本の方向へ辿る事のできるデータ構造を構築するかもしれない。
    |   % もしその様な仕組みが整うのだとしたら初めからその事を意識した実装にする必要がある。
    |   % 或いはもうこの complete の実装の為にその仕組みの大枠を作ってしまう方が良いかも知れない。
    |   %
    |   % 例えば葉から根本の方向へ辿る事のできるデータ構造を取り敢えず作り、
    |   % その更新は愚直に全体に対して行う事にする。
    |   % 部分更新などの細かい最適化の可能性については後で考える事にする。
    |   %
    |   % しかし、昔の考察だと部分更新は(整合性を保つようにするのが)かなり難しいと思われる。
    |   % そうすると結局最終的にも完全に全体を毎回再構築する事になるかもしれない。
    |   % それだと結局キャッシュする事の意味も余りないという事になる。
    |   % 色付けの更新の際にもその様な調子であれば結局この仕組みは遺棄される事になる。
    |   % それならば無駄なデータ構造を作らない方が良いとも考えられる。
    |   %
    |   % 結局の所具体的な需要がはっきりしないうちに仕組みを中途半端に揃えても、
    |   % 結局想定していた需要に対しては利用できない・実現不可能という事になって、
    |   % 無駄になるかもしれない。それならば今の段階では余り具体的な行動は動かさない方が良い様に思われる。
    |
    |   色付け更新の方から来る需要にも対応して入れ子構造のデータを構築するのは後回しにする。
    |
    |   そもそもその様な入れ子構造のデータを管理して色付けを効率化できるか不明である事、
    |   "complete で必要としているのは現在のコマンドに於ける最後の引数の位置" という単純な物であるから、
    |   その様な入れ子構造のデータを実装してからでも対応は難しくない事からである。
    |
    | 結局、「最後の引数の位置を特定する」機能を実装して、更に其処からコマンドを抽出するという事にする。
    | この最後の引数の位置は a/b のどちらでも実装できるが取り敢えずの所は a による実装で進める。
    |
    | 現在の単語抽出の枠組を流用しようかと思ったが、どうも現在の実装は不完全の様な気がする。
    | 現在の位置が "～" で囲まれた場所だったりした時に補完が働かない。
    | 一方で現在の位置が ${～} で囲まれた場所だった場合は補完が働かなくて正解なので
    | やはり現状の実装の様にする必要もあるかも知れない。
    | どの様な時にコマンド単語としての補完を実行して、どの様な時にしないのかをはっきりとさせておく必要がある。
    |
    | もう少し体系的な取り扱いをしたいが、これは現状の実装でも同じ様に体系的な扱いをしたいので、
    | 別に新しく作るという事はせずに、現在の枠組の延長としてコマンド抽出を実装し、
    | もし体系的な取り扱いをしたければ現状の実装の部分を拡張する方針で行く。

    結論
    (1) コマンドの抽出部分はモジュール性が高く簡単に再実装できるので、
      現状の枠組 (tree-enumerate) による抽出コードを取り敢えず書いて使う。
    (2) もし今後最適化の機会があれば再度書き直す。

    先に補完対象 (file, command, argument, etc.) を列挙し、
    その後で argument による補完候補列挙が必要になった時にコマンドの抽出を行う。

    | [コマンド部分の抽出の実装]
    |
    | コマンドの抽出はまた別の関数として実装する事にする。
    | 取り敢えず入れ子構造を走るプログラムを書いてみる事にする。
    |
    | そのノードが現在地を含む一番小さな word である条件は?
    |
    | 1.そのノードが word であるという事。
    |
    |   nest による構造ではなくて word であるという意味である。
    |   これは wtype が整数 (CTX_*) か文字列化で判定できる筈。
    |
    |   →本当か? nest で整数を使っている箇所はないのか?
    |     各場所の nest-push 調べてみた所、
    |     数字をしている箇所は存在しないようである。
    |     一箇所だけ何も指定していない場所があるが、
    |     nest-push 関数の中を見ると何も指定しない場合は type は "none" になる様である。
    |   →或いは、nest による node 登録は別の方法で区別できるようになっていたかも知れないのでそれも確認する。
    |     調べてみたが ntype をそのまま tree-append に渡しているので、
    |     区別する為にはやはり ntype, wtype を使用する必要がある。
    |     現在は ntype の値は使用していない様に思われるので、
    |     実は tree-append 時に type を "n$ntype" にしてしまえば良いのではないだろうか?
    |   →また既に ${node[0]} =~ ^[0-9]+$ で判定を行っている箇所を発見した。
    |
    |   保険の為 nest の場合は tree-append 時に n$ntype とする事にした。
    |
    | 2. 内側に word を含まない事
    |
    |   これは先に tree-enumerate-children して内部の構造を調べてから自分の処理を実行するという風にすれば良い。
    |   自分が word で内部に word を含まないと判定できれば isword=1 を設定する事にすれば良い。
    |   内部に word を含まないという事は isword= である事によって確認できる。
    |
    | > 現在のカーソル位置に未だ単語が出来ていない場合はどうするのか?
    | > つまり単語を其処に入力しようとしているが未だ 1 文字も入力していない状態の場合である。
    | > この様な場合を検出する為には単語ではなくて寧ろコマンドの context で検出するべきなのではという気がする。
    | >
    | > 或いは、現在地を含む単語によって検出するのではなくて、現在地より前にある単語を用いて検出するか?
    | > 現在地より前にある単語でかつ親ノードの内側に現在地を含む物が見付かれば良い。
    | > これについては後で対策する。-> Done.
    |
    | コマンドに属する単語の抽出は大体完了した様子である。
    | 更に comp_line や comp_point comp_cword にも対応する必要がある。
    | →対応した。

    取り敢えず実装したので commit する事にする。
    何故か動いていないが後でデバグする。

2015-11-19

  * bleopt コマンド

  * PROMPT_COMMAND

    普通の bash (ble のない bash) では、
    bind -x によって設定したコマンドを実行後に prompt を再描画するが、
    その時には PROMPT_COMMAND の中身は実行されない様だ。
    あくまで通常コマンドを実行した後にプロンプトの内容を
    再計算する時にコマンドが実行される様である。

    つまり PROMPT_COMMAND はプロンプトを計算する際に実行すれば良い。
    プロンプトの計算は .ble-line-prompt/update の中で、
    _ble_edit_LINENO と _ble_line_prompt[0] (前回のプロンプトの計算をした時の LINENO) が
    不一致だった時に実行される。

    PROMPT_COMMAND の内容を何処で実行するかは問題になる。
    関数の内側で実行すると declare した変数が見えないし、
    また関数の内側で定義された変数に干渉する事ができてしまう。

    一番外側で実行しようと思うと色々面倒なことになる気がするので
    取り敢えずは .ble-line-prompt/update の中で
    eval "$PROMPT_COMMAND" を実行する事にする。

  * histexpand: "～" 中の histexpand, extglob の際の histexpand 開始

    > - 文字列 "～" 中の history-expansion は " を含まない。
    > - '!(' not histexpansion when shopt -s extglob 対応

  * histexpand: histchars 対応

    histchars が設定されている時の正規表現の修正。
    > - _ble_syntax_bashc (旧 _BLE_SYNTAX_CSPECIAL)
    > - _ble_syntax_rex_simple_word
    > - _ble_syntax_rex_simple_word_element

2015-11-16

  * bug: 解析エラー

    解析のバグがようやく直ったと思っていたらまたエラーになった。
    今度は以下の様な状況でエラーが起こる:

    1. echo "${a[*]}" と入力する。
    2. echo ""${a[*]}"
    3. echo ""${a[*]}"" ←これでエラーになる。更に続けて何回かエラーが出る。

    しかもエラー状態のまま色々操作しているとついに CPU 100% でハングする。

    | [murase@padparadscha 0 ~]$ ""${a[*]}"
    | A?
    |  9*a    000 '"'      stat=(1 w=- n=- t=-1:-1)
    |  9*a    001 '"' ||
    | 14*a    002 '$' |||  nest=(2 w=2:0- n=- t=-1:-1) stat=(2 w=2:0- n=- t=-1:-1)
    |  |*a    003 '{' |||
    |  7*a    004 'a' |||
    |  8*a    005 '[' |||| nest=(14 w=- n='v[':2- t=-1:-1)
    |  8 a    006 '*' |||| stat=(8 w=- n=@5 t=-1:-1)
    |  8 a    007 ']' |||+ word=v[:5-8 stat=(8 w=- n=@5 t=-1:-1)
    | 14 a  s 008 '}' ||+  word=${:2-9>@7 stat=(14 w=- n=@2 t=0:-1)
    |  9 a  s 009 '"' ++   word=2:1-10>@9 word=none:1-10>@8 stat=(5 w=- n=@1 t=0:-1)

    何が起こっているかはすぐに分かった。一つ目の " を挿入した時に、
    解析が ${a[ までで中断している。本来は入れ子の構造が異なるので中断してはならない筈である。
    さて最近の修正の所為で中断されなくなったのか、それとも昔からあったバグなのか。

    先ず初めの可能性は更新された領域が誤った解析結果になっていないかという事である。
    上の状態で言えば 000, 002, 005 に設置されている情報に当たる。
    これはなさそうであるが念のため確認しておく。
    →挿入をせずに初めから順番に入力していった場合 (エラーは起こらない) と比較する。
      000, 002, 005 は完全に一致している。
      更にいうならば 006 に設置されている stat も一致している。

    000, 002, 005 が一致しているのは正しく解析が行われているという事なのでOKである。
    ところが 006 も一致しているというのは何かおかしい。
    これだけの情報だと確かにこの場所で解析が中断されてしまう。

    何故前回の解析で全く同じ stat が再現されているのだろうか??
    →いや局所的に見れば stat が一致するのは不思議な事ではない。
    たとえ全く同じ stat になったとしてもその参照先の nest が異なるのでここで中断はないはずなのだ。
    念のため直前の nest の状態についても調べておく:

    | [murase@padparadscha 0 ~]$ "${a[*]}"
    | A?
    |  9 a    000 '"' ||   nest=(2 w=2:0- n=- t=-1:-1) stat=(1 w=- n=- t=-1:-1)
    | 14 a    001 '$' |||  nest=(5 w=- n='${':0- t=-1:-1) stat=(5 w=- n=@0 t=-1:-1)
    |  | a    002 '{' |||
    |  7 a    003 'a' |||
    |  8 a    004 '[' |||| nest=(14 w=- n='v[':1- t=-1:-1)
    |  8 a    005 '*' |||| stat=(8 w=- n=@4 t=-1:-1)
    |  8 a    006 ']' |||+ word=v[:4-7 stat=(8 w=- n=@4 t=-1:-1)
    | 14*a    007 '}' ||+  word=${:1-8>@6 stat=(14 w=- n=@1 t=0:-1)
    |  9*a    008 '"' ++   word=2:0-9>@8 word=none:0-9>@7 stat=(5 w=- n=@0 t=0:-1)

    やはり "nest" が違うようだ。一つ上の nest @ 004/005 は一致している。
    更にもう一つ上の nest @ 001/002 は内容が異なる。
    '"' 挿入前は更にもう一つ上の nest @ 000 を参照しているのに対して、
    '"' 挿入後はもう一つ上の nest は - となっていて無効になっている。

    原因として考えられるのは:

    a. nest を遡った比較に失敗している?
    c. nest を遡って比較する為のデータを誤って参照している?
      またはデータを移動する時に失敗して新しいデータが混入している?
    b. shift に失敗している? (shift の際にデータが化けている?)

    一つずつ確かめていくしかない。確認の簡単そうな物&怪しそうな物から順に。
    先ずは a を疑う。function ble-syntax/parse/nest-equals の制御パスを調べる。
    →おかしい。ループが終わるはずのない場所で終わっている…。
      変だ…と思ったらこれはデバグ用コードの return が悪さをしている??
    →ああ、これだ。bash の && と || の優先順位は同じで左結合である。

    試してみた所、
    * [[ ～ ]] の && と || は期待通りの優先順位である。
      [[ a || '' && '' ]]         -> 0
      [[ ( a || '' ) && '' ]]     -> 1
    * (( ～ )) の && と || の優先順位も期待通りである。
      ((1||0&&0))                 -> 0
      (((1||0)&&0))               -> 1
    * command || command && command の優先順位は注意しなければならない。
      true || false && false      -> 1
      true || { false && false; } -> 0

    一応他にも同じ間違いをしている箇所がないか以下のコマンドで調べる:

    $ grc '\&\&' | grep -E '\|\|' | grep --color -E '\&\&|\|\|'

    他には同じ間違いをおかしている箇所は無いようである。
    元々コマンドを三つ以上 && や || で繋ぐ場合が少ない上に、
    使っている場合でも先に && があってその後に || があるパターンばかりの様である。
    左結合なので、この場合は期待通りに && が内側にあると解釈してくれる。

    (以前同じ様な事で嵌って修正を行ったような気がするが、
    その時に && と || を入れ替えたのだったか…。余り覚えていないが… 恐らく、
    A || B && C となっているのを ! A && B && C にしたのだろう。)

    何れにしても今後は && と || の優先順位に騙されないように注意深く実装を行う。

2015-11-08

  * 補完候補列挙に時間がかかっている時に入力があった場合、中止する?

    そもそも補完候補列挙のどの部分に時間がかかっているのか調べる必要がある。
    列挙・フィルタ部分なのか、それとも描画レイアウト決定部分なのか、描画部分なのか。

    特に時間が掛かるのは何も入力されていない状態で TAB を押した時である。
    complete がどの様な手順で処理されているかについて初めに調べる。
    ble-edit+complete (ble-edit.sh ble-autoload)
    -> ble-edit+complete (complete.sh)
        この関数内で殆ど分岐の処理をしている。
        先ず初めに候補を列挙して (ble-complete/source/command)、
        候補をスキャンして共通部分を計算する。
        候補が複数あったら描画を実行する。
    一番時間が掛かっているのは候補の列挙であり、
    そして次に時間が掛かっているのは共通部分の絞り込みである。
    今迄描画に時間が掛かっているのかと思っていたが、
    描画は本当に一瞬で終わっている。

    もっと ble-complete/source/command を詳しく見てみると、
    どうやら各候補についての情報を生成する所 ble-complete/yield-candidate で時間が掛かっている様だ。
    うーんこれを最適化するのは難しい…と思ったが、
    この部分はシェルによるループになっているので read -t 0 をチェックして中断するのは容易である。

    read -t 0 の performance をチェックする:

    > | $ time for ((i=0;i<100000;i++)); do read -t 0 && echo "$i"; done
    > |
    > | real    0m2.139s
    > | user    0m1.998s
    > | sys     0m0.139s
    > | [ble: exit 1]
    > | $ time for ((i=0;i<100000;i++)); do ((i%10==0)) && read -t 0 && echo "$i"; done
    > |
    > | real    0m1.673s
    > | user    0m1.664s
    > | sys     0m0.009s
    >
    > read -t 0 の呼出回数を 1/10 にしても対して変わらない様だ。
    > つまりループのコストか、或いは算術式による i%10==0 の実行の方も同じ位の実行コストがあるという事である。
    > これならば下手に read -t 0 の判定を間引く必要もないだろう。
    >
    > | $ function ble-util/check-input { IFS= read -t 0 -n 1; }
    > | $ time for ((i=0;i<100000;i++)); do ble-util/check-input && echo "$i"; done
    > |
    > | real    0m9.482s
    > | user    0m9.260s
    > | sys     0m0.213s
    > |
    > | $ function ble-util/check-input { IFS= LANG=C read -t 0 -s -r -d '' -n 1; }
    > | $ time for ((i=0;i<100000;i++)); do ble-util/check-input && echo "$i"; done
    > |
    > | real    0m16.039s
    > | user    0m15.809s
    > | sys     0m0.215s
    > |
    > | $ function ble-util/check-input { IFS= LANG=C read -t 0; }
    > | $ time for ((i=0;i<100000;i++)); do ble-util/check-input && echo "$i" && break; done
    > |
    > | real    0m11.199s
    > | user    0m10.965s
    > | sys     0m0.226s
    > |
    > | $ function ble-util/check-input { read -t 0; }
    > | $ time for ((i=0;i<100000;i++)); do ble-util/check-input && echo "$i"; done
    > |
    > | real    0m3.687s
    > | user    0m3.518s
    > | sys     0m0.166s
    > |
    > |
    > | $ IFS= LANG=C; time !!
    > |
    > | real    0m3.219s
    > | user    0m3.048s
    > | sys     0m0.168s
    >
    > 分かった事は read -t 0 の引数を増やすとそれだけ処理時間が増えるという事、
    > それ以上に IFS= LANG=C によって変数を書き換えるのに時間が掛かるという事。
    > 所で read -t 0 の引数を削除しても振る舞いには影響がないように見える。
    > 唯単に速度が遅くなるだけなのでループ中断の判定の歳には引数は無駄に指定しない事にする。
    >
    > | $ time for ((i=0;i<100000;i++)); do ((_ble_bash>=40000)) && read -t 0 && echo "$i"; done
    > |
    > | real    0m2.909s
    > | user    0m2.775s
    > | sys     0m0.131s
    > |
    > | $ time for ((i=0;i<100000;i++)); do ((check)) && read -t 0 && echo "$i"; done
    > |
    > | real    0m2.712s
    > | user    0m2.646s
    > | sys     0m0.064s
    > |
    > | $ check=1
    > | $ time for ((i=0;i<100000;i++)); do [[ $check ]] && read -t 0 && echo "$i"; done
    > |
    > | real    0m2.614s
    > | user    0m2.419s
    > | sys     0m0.193s
    >
    > 更に、関数呼出はそれほどには重くはないが多少時間は掛かるという事。
    > それでも算術式展開と殆ど同じである。一番早いのは [[ ]] による長さ判定である。
    > 関数呼出が絡むのであれば算術式 ((i%100==0)) でも挟んだ方が結局の所は有効なのかも知れない。
    >
    > | $ time for ((i=0;i<100000;i++)); do ((i%100==0)) && IFS= LANG=C ble-util/check-input && echo "$i"; done
    > |
    > | real    0m1.681s
    > | user    0m1.679s
    > | sys     0m0.001s
    > |
    > | $ time for ((i=0;i<100000;i++)); do ((i%10==0)) && IFS= LANG=C ble-util/check-input && echo "$i"; done
    > |
    > | real    0m2.475s
    > | user    0m2.458s
    > | sys     0m0.014s
    > |
    > | $ time for ((i=0;i<100000;i++)); do false && IFS= LANG=C ble-util/check-input && echo "$i"; done
    > |
    > | real    0m1.586s
    > | user    0m1.585s
    > | sys     0m0.000s
    > |
    > | $ time for ((i=0;i<100000;i++)); do :; done
    > |
    > | real    0m1.399s
    > | user    0m1.398s
    > | sys     0m0.000s
    >
    > そもそもループのコストが一番大きくて、算術式や [[ ]] による判定は殆どノーコストな様だ。
    > read -t 0 による判定は 10 に 1 でも良いかも知れない。

    read -t 0 の performance は大体分かったので適当に complete.sh に中断を実装した。
    関数 ble/util/is-stdin-ready (ble-core.sh) に実装して、それをループ内で間引きつつ呼び出す事にする。

    今の所は使い勝手はそんなに問題ない。誤って TAB を押しても固まるという事は無い。

    ただし、初めのコマンドを compgen で列挙する phase は環境によって滅茶苦茶時間が掛かるかも知れない。
    以下に速度を計測してみる事にする。

    | @gauge Cygwin (Intel(R) Core(TM)2 CPU 6300 @ 1.86GHz)
    |
    | $ time compgen -A command '' > /dev/null
    |
    | real    0m24.248s
    | user    0m0.953s
    | sys     0m5.875s
    |
    | $ time compgen -A command '' > /dev/null
    |
    | real    0m6.578s
    | user    0m1.063s
    | sys     0m5.375s
    |
    | $ time compgen -A command '' | wc
    |    6472    6494   65984
    |
    | real    0m6.734s
    | user    0m1.296s
    | sys     0m5.420s
    |
    | @padparadscha GNU/Linux (Intel(R) Core(TM) Duo CPU T2300 @ 1.66GHz)
    |
    | $ time compgen -A command '' | wc
    |    5274    5274   68019
    |
    | real    0m0.119s
    | user    0m0.038s
    | sys     0m0.092s
    |
    | @hankel GNU/Linux (Intel(R) Core(TM) i7-2600 CPU @ 3.40GHz)
    |
    | $ time compgen -A command '' | wc
    |    4112    4112   57267
    |
    | real    0m0.051s
    | user    0m0.019s
    | sys     0m0.038s
    |
    | @laguerre GNU/Linux (Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz)
    |
    | $ time compgen -A command '' | wc
    |    7639    7639   87603
    |
    | real    0m0.094s
    | user    0m0.021s
    | sys     0m0.079s

    やはり cygwin では桁違いの遅さである。
    cygwin では command prefix が空の時は何も列挙しないなどの対策が必要かも知れない。
    →しかしながらこれは ble.sh を使っていなくても同じ事である。
      遅いのが嫌であれば shopt -s no_empty_cmd_completion を設定している筈なのだから、
      この設定を参照して補完の有効・無効を切り替えるべきである。

2015-11-07

  * M-\ delete-horizontal-space

2015-11-06

  * <bug> 編集中に偶にエラーが起こる。起こる条件は不明 [提起: 2015-09-24]

    [状況確認]

    起こった時のメッセージを記録する。
    "${i}" → "${i" → "${i))" → "$((i))" とする過程で起きた。
    詳細: &kbd{'echo "${i}"' left left DEL "))" left left left DEL}: これで起こる。
    入れ子の境界を backspace で消した時に起きた?
    或いは別の入れ子の終了を挿入した時?

    assertion failure: [[ ${_ble_syntax_nest[inest]} ]]
    ble-syntax/tree-enumerate/.initialize/FATAL1
      @ /home/murase/prog/ble/ble.sh:7397 (ble-assert)
      @ /home/murase/prog/ble/ble.sh:2 (ble-syntax/tree-enumerate/.initialize)
      @ /home/murase/prog/ble/ble.sh:22 (ble-syntax/tree-enumerate)
      @ /home/murase/prog/ble/ble.sh:236 (ble-syntax/parse/shift)
      @ /home/murase/prog/ble/ble.sh:-16 (ble-syntax/parse)
      @ /home/murase/prog/ble/ble.sh:4 (_ble_edit_str.update-syntax)
      @ /home/murase/prog/ble/ble.sh:2479 (ble-highlight-layer:syntax/update)
      @ /home/murase/prog/ble/ble.sh:4223 (ble-highlight-layer/update)
      @ /home/murase/prog/ble/ble.sh:4762 (.ble-line-text/update)
      @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update)
      @ /home/murase/prog/ble/ble.sh:1 (.ble-edit-draw.update-adjusted)
      @ /home/murase/prog/ble/ble.sh:975 (.ble-decode-byte:bind/tail)
      @ /home/murase/prog/ble/ble.sh:1 (ble-decode-byte:bind)

    異常状態
    [murase@padparadscha 0 ~]$ echo "${i))"
    A?
     2 aw   000 'e' | stat=(1 w=- n=- t=-1:-1)
     | aw   001 'c' |
     | aw   002 'h' |
     | aw   003 'o' + word=2:0-4
     3 a    004 ' '
     9 a e  005 '"'   nest=(4 w=4:5- n=- t=-1:1) stat=(3 w=- n=- t=1:-1)
    14 a e  006 '$'   nest=(5 w=- n='${':5- t=-1:-1) stat=(5 w=- n=@5 t=-1:-1)
     | a e  007 '{'
     7 a    008 'i'
    15 a    009 ')'   stat=(14 w=- n=@6 t=-1:-1)
     | a    010 ')'
     6 a es 011 '"'   nest=(15 w=- n='none':7- t=-1:-1) stat=(15 w=- n=@6 t=-1:-1)
    \_ '"' (← ※エラーの結果としてこうなっている。原因ではない。)

    正常状態
    [murase@padparadscha 0 ~]$ echo "${i))"
    A?
     2 aw   000 'e' | stat=(1 w=- n=- t=-1:-1)
     | aw   001 'c' |
     | aw   002 'h' |
     | aw   003 'o' + word=2:0-4
     3 a    004 ' '
     9 a e  005 '"'   nest=(4 w=4:5- n=- t=-1:1) stat=(3 w=- n=- t=1:-1)
    14 a e  006 '$'   nest=(5 w=- n='${':5- t=-1:-1) stat=(5 w=- n=@5 t=-1:-1)
     | a e  007 '{'
     7 a    008 'i'
    15*a    009 ')'   stat=(14 w=- n=@6 t=-1:-1)
     |*a    010 ')'
     6*a e  011 '"'   nest=(15 w=- n='none':6- t=-1:-1) stat=(15 w=- n=@6 t=-1:-1)
    \_ 'echo'
    \_ '"${i))"'
        \_ '"${i))"'
            \_ '${i))"'
                \_ '"'

    011 文字目の nest の値に誤りがある。正しく shift されていない?
    どうやら "${i)" から "${i))" にした時にずれる様だ。
    更に色々調べていると "${i " から "${i a" にしても問題になる。
    "${i" を "${iaa" としても問題は起こらない。

    [原因特定]

    違いを見てみると最後の " の部分についても再更新を行っているかどうかに依存している様である。
    何も問題が生じない時には最後の " についても再更新が行われている。
    しかし問題が起こる場合には最後の " についての再更新が行われず、
    そこで状態が一致したと解釈されて解析が終了してしまう。

    最後の " について shift が実行されていないという事から見ると、
    本来は最後の " に関しては必ず再更新を行うという想定なのだろう。
    それが何かの具合で " の位置で状態 (stat) が一致すればそこで中断可能という事になっている。
    (或いは、逆で、状態が一致すればそこで中断可能の筈なのに、shift が省略されているのかもしれない。)

    最後の " (つまり、挿入部分の直後の文字) について状態が一致した時に
    そこで中断可能とするべきなのかどうなのかについて再度考察する必要がある。
    以前に、再開を可能とする為の条件についてまとめた様な気がするのでそれを参照する。
    →"[memo] の解析の際の原則" に書いたものだったはず。
      ここには解析データ配列に対する操作の原則を書いている。
      この原則から中断が可能かどうかについて導出ができるはず。
    →この原則が厳密に守られているのであれば解析は中断可能な気がする。
      % いや。解析データに関しては問題はないが、編集文字列本体に関してはどうだろうか。
      % 解析の際にどこに解析再開点を設置するかを決定するために、解析点よりも先の文字を使用している。
      % →でも一旦解析状態 stat (及び nest 構造) が同じになって、その点以降の文字列が同じであれば
      % 解析の結果は完全に同じになるほかはない。従ってその場所で解析の中断が可能なはずである。
      やはり解析は挿入範囲の直後で中断可能である。

    % もう一つの疑問点は "${i" を "${iaa" とする過程で、何故解析の中断が行われないのかという点である。
    % stat は一致する筈のように思われるし、解析中断可能範囲は "${i a" とする時と同じはずである。
    % % →本当に stat は一致するのだろうか。もしその位置の stat も shift をしないのだとすれば
    % % 解析状態 stat は一致しないのでそこで解析が中断する事は無い。
    % % でも、そうすると今度は "${i a" の時に何故解析状態が一致してしまうのかという話になる。
    % % うーん。謎だ。というか確認してみた所 stat はちゃんと shift されている様である。
    % stat はやはり shift されている。従って一致しても良いように思われる。
    %
    % とすると残るのは解析中断範囲の計算方法の問題だろうか。。
    % (つまり、挿入範囲直後の文字を含んだり含まなかったりまちまちになっている可能性?)
    % →実際に調べてみると解析中断範囲 (-i1 i2-)は問題が出ている時も出ていない時も、
    % 挿入範囲直後の文字の位置に i2 がある。つまり、解析中断範囲の指定によると解析中断可能の筈である。
    % それが中断不可能と判定される理由は何であろうか…。
    % % 唯一の違いは '${' から解析を再開しているかその中身から解析を再開しているかに依存すると思われた。
    % % しかし、中身から解析を再開した場合でも問題が起きない場合には起きない様だ。
    % % →気のせい??→どうやら ble_debug を入れている時と入れていない時でエラーが出るタイミングが違うようだ。
    % %   ble_debug を入れている時の方が即座にエラーを検知していると思われる。今後その仮定の下で調べる。
    % やはり '${' から解析を再開しているかどうかである。
    % '${' から解析を再開する場合、それに対応する nest
    % への参照を含む stat が全て削除されてしまうのが中断が起こらない原因と思われる。
    % さて、ここで改めて考えるに '${' から再解析をして再び全く同じ状態になった場合、
    % 新しく作成される nest は元々あった nest とは違うインスタンスではあるが、
    % やはりそれより後の解析状態は同じになるのではないだろうか。
    % そうだとすると nest が新しく作成された物であったとしても、
    % そこで中断して良いはずなのではないだろうか。
    % →取り敢えずは挿入範囲で削除された要素に対する参照が復元された場合でも中断可能として考える事にする★
    %
    % もし「新しい nest インスタンスであっても同じ状態になれば中断可能」とするならば
    % shift の部分を弄ってその nest に対する参照がある stat/nest etc. を削除しない様に修正する。
    % (削除する代わりに適当なshiftを実行する。特に、内容が変わらないという仮定の下での shift で良かろう。)
    %
    % % - 挿入範囲にあって削除される単語・ネストを参照する解析要素でも削除せず
    % %   適当な shift を実行する事にする。
    % →確認してみた所初めからその様になっている様である。おかしい
    →解析の中断が終わらないのは nest の shift 自体にバグがあって nest が変な状態になっていたからであった?
      でも変である。解析の中断の判定は stat 及び stat の参照している nest だけしか参照しない。
      現在の位置に設定されている nest は解析を続行する事によって設定されるはずの物だから、
      解析の中断の判定には使わないはずだし実際に確認してみた所そうなっている様に見える。

    未だ残っている問題というか、確認していない事項は shift 対象の範囲である。
    なぜ nest の情報が shift の対象になっていないのだろうか。
    nest の格納方法について再度確認を行う。別に特別な格納の方法はしていない様だ。
    原則に則った格納方法になっている。

    各項目の shift 方法の判定についても確認してみたが問題ないようである。
    と思ったらバグを発見した。klen = nest[k] の値を見て nest[k] の shift 方法を判定するべき所を、
    nest[1] を見て nest[k] の shift 方法を判定していたようだ。
    →修正した。これで当初のエラーは発生しなくなった。

    ToDo: 残る事はこの修正によって解析の中断がちゃんと起こる事を確認する事である。
    →おかしい。やはり解析の中断は起こっていない。
      確認してみたが stat の状態は同じ様である。という事は nest か。
      やはりそうだった nest の判定で棄却されている。ではどの様に?
    原因が分かったこれは別項目として独立させる (2015-11-06)。

2015-08-25

  * ble-edit.sh (function .ble-edit/history/generate-source-to-load-history): bash-3.0,
    history が load されているか確認する時 history '!1' でエラーメッセージが表示される。

  * ble-edit.sh: PS1 の中に含まれる ! が \! に化ける。

    → eval 'a="!m"' となっていても特に履歴展開は起こらない様だ。
    また、PS1 中の ` は特別な意味を持つのでエスケープしない。

  * ble-edit.sh: PS1 の \w の $HOME を ~ に置換する部分で、
    或るユーザ名が自分のユーザ名を先頭に含んでいる場合、
    そのユーザのホームディレクトリが部分的に ~ に置換されてしまう。

2015-08-19

  * <bug> bash-3.0 で上 (prev-history) をすると今迄に実行したコマンドの履歴が消える。

    bash-3.0 で消える。bash-3.1 ではちゃんと期待通りの動作になっている。

    そもそも history に登録されていないという可能性もある??
    →しかし一回履歴を見てから実行したコマンドについてはちゃんと履歴に残っている様である。
      でも、それは history コマンドから拾った事に依る物ではなくて、
      自前で記録しているからに過ぎないのでは?

    実際に history コマンドでどの様な物が登録されているかを確認してみればよい。
    と思って確認してみた所最近拾ったコマンドですら登録されていない。
    というか、history に項目を登録するたびに実際には
    history の末端の項目が削除されて行っている様である。
    これは history コマンドの呼出周辺に問題がありそうである。

    少し触ってみて分かった事。
    bash-3.0 では history -s -- で登録したコマンドは末尾に追加されるのではなくて、
    一番最近のコマンドを置き換える形で実行される様である。この動作は bash-3.1 の時と異なる。
    history -s 'echo hello' としても同じであった。
    しかしこれだけならば何故コマンドを実行する度に数が減るのかを説明できない。

    もう少し試してみる。bind -x に history ... を指定したらどうなるだろうか。

      bind -x '"\C-t":history -s echo "$RANDOM"; echo ok'

    として C-t を何回か押してみたが history が寧ろ減少するという状況は再現しない。

    他に history に対して操作をしている箇所と言えば history -p ... のみである。
    それとも history -p を実行する度に history の中身が減少するのだろうか。。。

      bind -x '"\C-t":history -p "echo $RANDOM"; echo ok'

    →何とこれだった! bash-3.0 では history -p する度に history の中身が減少するのだ。
    しかも一回 history -p する度に 2 個ずつ項目が削除される様だ。

    a history -sp としてやってみると何も問題は起こらないようだ。
      しかしこれだと評価結果が出力されないので history から読み出す必要がある。
      更に問題なのは history -sp を用いるとそれまでに history の一番上にあった項目が置換されてしまうという事である。
      これに対応する為には一番上にあった項目を一旦別の変数に覚えておいて、
      history -sp ...; history 1; の後に再度覚えて置いた項目を history -s で設定する必要がある。
      しかも history 1 で出力される内容は行番号 (と変更があれば * も) なので、自分で解析して正しい履歴内容にする必要がある。
    b 上の方法は大変に面倒である。面倒な事をするぐらいならば、
      実は (history -p ...) の様に subshell の中で history -p を実行してしまうのが一番楽である。
      subshell 内での履歴リストに対する変更は親シェルには影響がないので。
      fork のコストはあるものの、どうせ古い bash の対応であるのでこれで良いだろう。

    しかし、history -p で履歴が削除されるのを防ぐ事が出来たとしても問題は依然として残る。
    実際にコマンドを履歴に登録する history -s が使えない事である。
    history -s を用いても最近の項目が置換されるばかりで新しい項目としての登録が出来ない。
    これは、複数回のコマンドを実行しても一番最近の一つのコマンドの履歴しか保持できないという事を意味する。
    これに対処する為には、bash の history に頼らずに初めから全て ble.sh の側で処理してしまうしかない?

    →結局 history -s には頼らずに全部 ble 内で処理することにした。
    起動時に既に .bash_history を読み込んでしまい、
    そして、history -s には頼らずに直接 .bash_history に append を行う。

2015-08-18

  * <bug> bash-3.0 で less <<< と入力した時点で assertion failure が出る

    更に echo $(echo) と入力しただけでも assertion failure になる。

    - FATAL1 が出て無限ループになる → 無限ループになっていたのは
      ble-assert || break による停止が働いていなかった為。
      ble-assert の実装を新しくして上記の使い方が出来る様にしたつもりで居たが、
      実際には古い ble-assert が使われていた為。

    - さて assertion-failure になるのは children で参照した先が空欄である為。
      print-status で構築されている木の形を見てみようとしたが何か出力が変である。
      と思ったら local arr=() の形を使っていた為に bash-3.0 で arr='(...)' が代入されていた。
      これを local -a arr; arr=() の形に修正したらすぐに print-status は直った。

    さて漸く print-status による出力を確認してみる。しかし assertion failure になる直前の形に問題はない。
    (正しく動いている bash-4.3 の出力と全く同じ物が出力されている。)
    逆に assertion-failure 直後の print-status の状態を確認してみると一箇所だけ間違っている。

    | --- a.txt       2015-08-18 23:27:44.399485443 +0900
    | +++ b.txt       2015-08-18 23:28:20.860151961 +0900
    | @@ -11,7 +11,7 @@
    |   | aw   008 'c' |||
    |   | aw   009 'h' |||
    |   | aw   010 'o' ||+ word=2:7-11
    | -14 a    011 ')' ++  word=4:@3>5-12>@11 word=$(:5-12>@10 stat=(3 w=- n=@5 t=0:-1)
    | +14 a    011 ')' ++  word=4:@3>5-12>@11 word=$(:@4>5-12>@10 stat=(3 w=- n=@5 t=0:6)
    |  \_ 'echo'
    |  \_ '$(echo)'
    |      \_ '$(echo)'

    何故か存在しない単語を親単語としている様である ("@4>" の部分)。
    しかしこれは寧ろ ble-assert による中断で shift に失敗しているという事の様な気もする。
    しかしそもそも ble-assert が発生するのは存在しないノードへの参照がある為であり、これがその原因とも解釈できる。
    もう少し動作を見て判断する必要がある。

    全体を探す前に念のため local arr=() の形式の誤りをしていないか確認を行っておく。
    他に2箇所その様な問題のある記述をしている箇所が見付かった。それを修正する。
    それを修正したら今迄出ていた assertion failure も出なくなった。
    echo $(echo) をしても何も起こらないし、また、cat <<< hello 等としても何も起こらない。良かった。

2015-08-16

  * [2015-02-21] <bug>

    word の属性が解除されてもそれが表示に反映されない。
    これはレイヤーの機能を使って実装した方が良いだろう。

    付記: 以下の問題もこの問題によるものだった。

    % * color: <bug> \ arg → \rm arg という編集をすると間の空白が構文再計算の対象から抜ける??
    %   →問題点は構文解析部分ではなくて単語に対する着色を削除する部分にある。
    %     構文解析や属性・単語の更新範囲の計算には問題がない事が分かった。
    %

    % echo file とした後 echo を C-d で消すとその直後の空白がエラー状態になる。
    % そのまま新しいコマンドを入力してもエラーの儘?
    % →再現しない?

    そればかりか…。前に存在していた word が消えた時 (word 以外の意味になった時)
    にそれを検知する術がない…。前回の word 配列を覚えておいてそれと比較する必要がある?
    二つの方向性がある。

    a parse で消えた word についての情報も提供する

      実は消滅した単語というのは、(1) DMIN DMAX0 の間にあったものと
      (2) _tail_syntax_word で使われなかった部分の2種類しかないのでは?
      代入する事によって上書きして消している word は存在しない。
      常にまっさらな所を i が走り、その i の箇所で word に代入しているから。

      (1) はどうせ削除されるから関係なさそうとも思ったが、
      DMIN DMAX0 の間にあった単語に関しても蔑ろにはできない。
      というのも DMIN DMAX0 の間に終端があって開始点は
      それよりも前にあるかも知れず、これらの単語が消える可能性もあるから。

      さて、parse の側でこれらの消滅について通知する事も出来るが、
      これは parse のするべき事なのかというと疑問である。
      もう少し別の方法…補足的情報を外部で取得する事によって、
      外部で消滅した単語の情報を取得する方法はないだろうか。

      (1) に関しては外部で既に計算する事が可能である。
      (2) に関しては…外部で計算前の _word のコピーを持っていれば、
      最後に処理した i さえ分かれば分かる。
      そして (将来的に変わるかも知れないが) _ble_syntax_attr_uend がそれに対応する。

    |
    | b 或いは、呼出側で前回の _word の内容を覚えて置いて消えた物がないか確認する。
    |
    |   これだと比較する為には呼出側で覚えて置いた物について shift したりしなければならない。
    |   というか覚えて置いたとしても同一性を確認するのは骨である。
    |   範囲と種類が同じであったとしても内容が同じとは限らないし、
    |   内容までも覚えておくのは面倒である。
    |   それに内容が完全に一致したとしても本当に同一と言えるのか??? (同一として良い気がするが)
    |
    | c 更に別の方法としては呼出側で単語と描画属性の組を覚えておくというのもある。
    |   (これは独立したレイヤーとして扱うという事に近い)。
    |
    |   これを用いて毎回全ての単語に対して属性の適用を行う。
    |   但し、単語の描画属性が何になるかだとか引数の解析だとかは省略する。
    |
    |   然し乍らこれは結構なコストである。属性の適用についてキャッシュしていないから。
    |   それに消滅する単語に対する処理は結局考えなければならないので変わりない。


    改めて考え直す。parse 呼出元で呼出前の _ble_syntax_tree を保持しておいて、
    消滅した単語を検知するというのは面倒である。もっと良い方法がないか。

    呼出元で呼出前の状態を保持する場合にしなければならないのは以下の事である。
    1. 先ず初めに、parse による更新範囲を取得する。
    2. 1 で得た更新範囲に登録されている単語を列挙し、
      その単語が存在していた範囲を特定する。更新による shift に注意する事。
    3. 2 で得た範囲に含まれる文字について着色を再計算する。

    実際には消滅した単語の更新範囲 (上記 2.) さえ分かればよいのだから、
    それを parse の中で計算してしまうと言う手もない事はない。

    また、3. を実行するという事は、任意に与えられた範囲に対して
    入れ子構造を考慮に入れた着色を実行するという事になる。

    これは何れ対応しなければならなかったので難点とはならない。

    ∵現状では新規生成された単語の範囲内のみで入れ子構造を考えていたが、
      実はこの実装は不十分である。新規生成された単語に着色が為されない場合、
      本来その親節の着色を適用するべきであるが、現在の入れ子構造の処理方法だと、
      任意に与えられた単語の親を取得する事が困難である。
      仕様がないので現状では着色無し、という事にしている。
      更に、単語と単語の間の空隙に関しても親節の着色を適用すべき所であるが、
      % これについては現在の実装では何もしていない (前回の状態が残る)。
      これについては着色の更新範囲内に入った場合には属性を完全に削除する様に変更した。

    つまり、色々な小細工を考えても仕方がない。現状で既に問題があるのだから、
    入れ子構造を用いた再着色の実装は必須である。

    「任意に与えられた範囲に対して入れ子構造を考慮に入れた着色を実行する」のは結構骨である。
    後ろから入れ子構造を辿っていかなければ完全な木を構築する事が出来ないからである。
    実は、似た操作を shift の時にも行っている。一回木の構造 (というか親節へのポインタ) を生成してしまえば
    後はそれを使い回せばよいので、木の構造を何処かにキャッシュする仕組みがあると良いだろう。

    % 1 取り敢えず消滅単語の範囲を計算するコードを書く。
    % 1.1 更新によって消滅する部分については、parse 呼出前に確認する。
    % 1.2 再解析によって捨てられる部分に関しては、何とか parse から結果を借りる方法を考える。
    %   適当なフラグに従って tail_* に対して local を宣言しないようにすれば良いだけでは?

    parse をできるだけ弄らないように実装しようとしていたがどうも困難な様なので
    結局 parse 内に消滅単語呼出の追跡の為の関数呼出を書き込む事にした。
    取り敢えず実装した。以下の変数に範囲を記録する:
      _ble_syntax_vanishing_word_umin _ble_syntax_vanishing_word_umax

    2 入れ子構造に対して計算を実行するコードを書く

    現状で十分動いているので、一旦切る事にする。
    効率が悪くなったら再度考え直す。

  * color: <bug> echo hello world と入力してから echo を消去すると、
    hello に適用されるはずの色が "hello world" 全体に適用されてしまう。
    内部の _ble_highlight_layer_syntax?_table 系統の配列の内容は正しい物になっているが、
    _ble_highlight_layer_syntax_buff の内容はずれている。

    ble-syntax.sh (ble-highlight-layer:syntax/update-attribute-table) の実装で、
    _ble_syntax_attr_uend とするべき所 _ble_syntax_attr_umax としている部分を見つけた。
    取り敢えずこれを修正する→直った。。。原因を探索することなく、案外呆気なく直った。

  * <BUG> 表示されている文字列と内容の文字列がずれている。

    まとめ: これは ble-edit/dirty-range/update 実装中の2種のタイプミスによる物だった。
      今迄影響が出ていなかった(影響に気付かなかった)のが不思議な位に致命的なバグであった。

    C-d を連続で入力した時などに発生している。
    どうも描画用の配列に対する shift が正しく処理されていない様に見える。
    _ble_highlight_layer_syntax_buff の内容を見てみたが変な事はないようだ。
    →異常がないように見えた物のよく見たらちゃんと shift できていない様だ。
      実際の文字数よりも長い配列になってしまっている。

    もう少し詳しく見てみる事にする。これらの *_buff 配列は、
      function ble-highlight-layer/update/shift
    を呼び出す事によって shift している。そしてこの関数では DMIN, DMAX, DMAX0
    を用いて shift を実行している。一方で、ble-syntax/parse ではどの様に
    shift を行っていただろうか (もしかするとこれ自体も間違いを含んでいるかもしれない)。
      ble-syntax/parse text beg end end0
    の引数を参照している様だ。そしてこの関数は ble-edit.sh (_ble_edit_str.update-syntax)
    から参照されている。ここでは _ble_edit_dirty_syntax_* に格納されている情報を渡している様だ。

    一方で *_buff の shift に用いている DMIN, DMAX, DMAX0 の出所は何処だろうか。
      ble-highlight-layer/update
    において DMIN, DMAX, DMAX0 が設定されている。この関数では配列 BLELINE_RANGE_UPDATE に
    格納された情報をそのままコピーしている。配列 BLELINE_RANGE_UPDATE は、
      ble-edit.sh (.ble-edit-draw.update)
    関数で、_ble_edit_dirty_draw_* から読み出している。これらの、
    _ble_edit_dirty_draw_*, 及び _ble_edit_dirty_syntax_* の更新は、
      ble-edit.sh (_ble_edit_str/update-dirty-range)
    にて実行されている。同時に実行されているので両者の内容に変化が生じるとは思えない。

    という事は syntax の方も不当な shift/解析になっている可能性もある。
    但し、元の文字列を参照して解析を行っているので目立った問題が見えていないと言うだけと思われる。
    これについてもチェックする。ble-assert を試しに埋め込んで見る。
    やはり _ble_edit_dirty_draw_*, 及び _ble_edit_dirty_syntax_* の内容は常に同じになっている。

    すると問題点は dirty 領域の合成自体にあると思われる。試しに、

      $ ble-edit/dirty-range/clear --prefix=hello
      $ echo $hellobeg:$helloend:$helloend0
      -1:-1:-1
      $ ble-edit/dirty-range/update --prefix=hello 2 2 3
      $ echo $hellobeg:$helloend:$helloend0
      2:2:3
      $ ble-edit/dirty-range/update --prefix=hello 2 2 3
      $ echo $hellobeg:$helloend:$helloend0
      2:2:2

    もうこれだけで間違った合成になっている。全然駄目だ。ble-edit/dirty-range/update の実装を見直す。
    ちょっと見ても分からないので過去のログを見る事にする。ble-edit/dirty-range/update の実装の詳細については、
    2015-02-16 の実装ログに記録が残っていた。論理についてよく見てみたが誤りは内容に思われる。
    結局、結果の式に値を代入しても正しい結果になると言う事を確認した。
    再度、コードの方を見てみると…何と変数名を間違えている。delta とするべき所が del になっていた。

    直した。然し良く分からないのは、このミスだけだったら最終的な結果は 2:2:2 ではなくて、
    2:2:3 という謝り方をしていた筈なのではないかという事である。
    2:2:2 になるという事は未だ別の箇所で何かミスをしているという事ではないだろうか。。
    取り敢えず再度実行してみる…。

      -1:-1:-1
      2:2:3
      2:2:3

    今度は 2:2:3 がもう一度表示されるという結果になった。本当は 2:2:4 になるべきだ。
    手で計算しても 2:2:4 になる気がする。再度数式を追って何で 2:2:4 にならないのか確認する。
    と思ったら…endA0 読み出しの時点で beg を読み出していた…。

      -1:-1:-1
      2:2:3
      2:2:4

    今度は正しい合成になっている。

  * eval は builtin eval に書き換え。test は [[ ]] に書き換え。
    builtin の上書きを阻止。他にも複数のコマンドの上書きを阻止する。

  * <bug> コマンドを編集中にカーソルの位置がずれて表示されている文字列と内部の文字列に齟齬が生じる。

    これはどうやら read -t 0 で読み取ったキーシーケンスが不当に解釈されて、
    結果として不正な文字が編集文字列に挿入されるためのようである。
    どの様な文字が挿入されているかを調べてから対策を考える事にする。

    1 本来は不正な文字が挿入されたとしても正しく表示されるべきである。
      →不正な文字 (というか 0x80-0x9F) が挿入された時に M-^? と表示される様に変更を行った。
      (元の bash readline ではこれに対する対策は行っていない。従って表示がずれる。)

    2 また、不正な文字が挿入される過程についても調べる。

      挿入されている文字を確認した所 "M-^[" であった。
      つまりこれは ESC [ を受け取る為にこれを CSI の utf-8 表現に変換しているのが原因である。
      変換の際に bind '"\e[":"\xC0\x9B["' としているが、この "\xC0\x9B[" という列は
      bind を通じてしか読み取る事ができず read で読み取れる文字とは別である。
      bind で 1 byte 目を受け取った時点で read を実行すると 2 byte 目ではなく、
      "\e[" の更に次に来た文字を読み取ってしまう。
      "\e[" の 2/3 byte 目は全ての read が実行された後にようやく処理される事になる。
      つまり受信される文字の順序が変化してしまうのである。

      (実際に確かめてみた所、その通りだった。しかし、この場合だけでなく複数の文字に対して
      bind -x または bind している物の場合に同様の問題が発生しうる?
      →複数文字から1コマンドへのmappingの際には問題にならない。複数文字が来て初めて
      コマンドが実行される為、複数文字の順序が交換されたりする事はない。)

      解決方法は色々考え得る。

      | a read -t 0 を使う以外の方法を考える。
      |
      |   bind -s と相性の良い読み取り手段が有れば良い。
      |   例えば、bind -s で待機されている文字をコマンドから取り出す方法が有れば良い…
      |   がそのような方法があるとは思えない。
      |   或いは、bind を用いて次の文字を直ぐに受信できるかどうかを判定する方法さえあればよい?
      |
      | a' read -t 0 で次の文字が来ていれば再描画を行わずに bind を抜ける
      |
      |   実は read -t 0 を用いて次の文字がすぐに来る事が確認できれば、
      |   表示を省略して bind を抜けても良いのではないだろうか。
      |   再描画は次の文字を処理する為の bind で実行されるであろう。
      |
      |   問題は accept-line の処理中に、
      |   再描画が完全に終わっている事を前提として処理が行われているかも知れないという事である。
      |   (exec:exec の場合にはそうではなかったのでちゃんと再描画していたはずだが、
      |   exec:gexec の場合にどうなっているかは調べないと分からない。)
      |   →どうも exec:gexec の場合には
      |
      |     ".ble-edit+accept-line/process+$bleopt_exec_type" && return 0
      |
      |   によって bind を取り敢えず抜けてから exec:gexec の設定した trap の内部で
      |   再描画処理を実行するので、再描画を省略しても問題はない。というか、
      |   元々 bind 内部では再描画されない。
      |
      |
      | b "ESC [" を受け取る別の方法を考える。
      |
      |   bind '"\e[":"\C0\9B["' が悪い、という事ならば別の方法で受け取る方法を考えればよい。
      |   しかしこれは可成り苦しんだ事なので他に解決方法を見つけるのは難しい。
      |
      | c utf-8 decoder の内部状態を見て bind-s の処理中かどうかを確認し、
      |   bind-s の処理中であれば read -t 0 で次の文字を読み取るのを抑制する。
      |
      |   例えば現状だと "\e[":"\xC0\x9B[" としているが、代わりに
      |   "\e":"\xC0\9B" という事にすれば、最後の文字として \xC0 が来た場合には、
      |   次の read -t 0 を抑制するという風にするだけで問題は発生しなくなる。
      |
      |   実は内部状態を見なくても、その :bind の中で最後に処理された byte が
      |   C0 かどうかだけ見れば良いのではないかという気がする。
      |   但し "\e[" の代わりに "\e" に対して bind を行った場合。
      |
      |   % x しかし \xC0 で始まる文字は結構ある (u80-u7FF) ので、
      |   %   それらの文字の read -t 0 ができなくなるという問題点がある。
      |   % と思ったが、\xC0 は u80-u7FF では決して使われないのでこれは気にする事は無い。
      |   % \xC0 はいわば非正規化表現でしか使われないのでそれ程気にしなくても良い。
      |
      |   x この方法だと実際に次の文字が来ているのに、
      |     \e[ の回数 (bind-s を介した読み取りの回数) だけ
      |     再描画処理が実行されてしまうという問題もある。
      |
      |     というか、実は "\e[" の組合せだと utf-8 の内部状態を見ても bind -s の処理途中なのか
      |     どうなのかという事を判定できない (utf-8 decoder を弄れば出来ない事もないが) ので、
      |     "\e" に bind -s するのが現実的となる。しかし、そうすると "\e" を含むシーケンスは全て
      |     read -t 0 の抑制の対象になってしまい、入力の高速化には繋がらない。
      |
      |     とも思ったが "\e" の読み取り過程では実際のキー入力は発生せず、
      |     ble-decode-key または ble-decode-byte の内部状態を変更するだけで、
      |     再描画も何も処理されないので、read -t 0 で急いで読み取らなくても問題ないのでは?
      |     という気もする。とも思ったが、確かに byte 毎の処理は実行されないが、
      |     例えば矢印キーによる移動などを考えると key 毎の矢印キーの移動・更新は実行される事になる。
      |     その過程で syntax も更新されるだろう。key 毎に syntax を更新するという事なので、
      |     やはり入力には従来通りの時間が掛かってしまうと言う事と思って良い。
      |
      | c' utf-8 で来るはずのない byte \xFF を用いるという手もある。
      |
      |   % c において、多くの文字で read -t 0 ができないのを防ぐ為に、
      |   % →この問題は気にしなくても良いという事が分かった。
      |   % つまり、この方法は c と比べて何らの利点もない。
      |
      |   "\e":"\xFF\9B" 等としておいて byte \xFF が来たら次の文字では read -t 0 をしないという具合に。
      |   x この方法を用いる場合 utf-8 decoder に手を加える必要がある。
      |     或いは、ble-decode-byte:bind 側で \xFF のみを特別扱いして
      |     ble-decode-byte に実際には文字が渡らない様にするなどの対処が必要である。
      |   x この方法は utf-8 以外の文字符号化方式では使えない。
      |     或いは文字符号化方式毎に調整が必要である。
      |   x 更に、c でもう一つ問題だった \e[ の入力の際に処理を抑制できない
      |     という問題も解決されていない。
      |
      |   この方法は可成り実装が面倒なのと場当たり的なので、余り考えたくない。

      → a' の方針で行く事にした。簡単な実装だがちゃんと動いている様だ。

  * read -t 0 を用いて貼付などの際に入力をまとめて処理するという事。

    実は read の timeout を 0 にして呼び出せば、これまでに入力されたバイトを全て読み出せるのでは?
    →意外と簡単に実装できた? と思ったが色々と問題がある様だ。

    1. bash-4.0 未満では文字を既に入力していても何故か read -t 0 に失敗する。

      (何も入力がない時には単に失敗するだけなので、bash-4.0 未満では単に動作しないだけである。)

      bind -x 内部で実行している為に環境が違って read -t 0 が動作しないのかとも思ったが、
      実際に通常のスクリプト (test/readbyte.sh) として実行してみてもやはり動作しない。

      改めてマニュアルを見てみると read -t 0 について言及があるのは bash-4.0 以降の様だ。


    2. 日本語の文字を入力した時に変な事になる。

      bind -x で受信しているのはバイトである。一方で read で受信できるのは、
      bash-4.0 以降では文字である。日本語を入力すると、日本語の 1 byte 目は bind で受信され、
      2 byte 目以降は read で読み取る事になる。この時に、

      - read で読み取られた不完全なバイトをどの様に処理するか
      - byte 単位で読み取られた文字と文字単位で読み取られた文字をどの様に区別するか
      - 現状不完全な byte の内容取り出しに失敗している (printf %d '文字 は常に 0 を返す様だ)。
        →否、負の数を返してる様だ?

      が問題になる、解決の方法としては、

      a byte/char を区別する方法を考える。

        byte の場合、read の結果に不完全な文字が入っているという事なので、
        原理的に区別はできる筈だが…。また、区別できたとして、
        不完全な byte の内容を取得できる必要がある。

      b read でバイト単位で読み取る方法を考える。

        試しに LANG=C を read につけて読み取るなどしてみたが効果は無かった。

        →どうやら LANG=C をつければちゃんと byte 単位で読み取られる様だ。
        しかし、その直後の s2c で LANG=C を付けていなかった為に
        変な結果になっていたという事の様だ。

2015-08-15

  * ble-syntax.sh: `function ...' 対応

    先ず関数名に使用する事の出来る文字について確認しておく必要がある。

    使える物: [][:%=~^{}@+-*:,.?/_]
    使えない物: [	 "$&'();<>\`|]
    条件付き:
      !    shopt -H して置かないと履歴展開されてしまう。
      #    単語の先頭には使えない (コメントになる)
      \001 使えるが実際に定義される関数名は何故か \001\001 になる。
      \177 使えるが実際に定義される関数名は何故か \001\177 になる。

    $'[^#\t\n "$&\'();<>\\`|][^\t\n "$&\'();<>\\`|]*'

  * ble-syntax.sh: `hoge ()', `function hoge ()' 直後のコマンドに制限をかける。


2015-08-14

  * ble-syntax/parse/shift.impl2: <bug>: echo $(echo hello) hello で1つ目のhelloをBSで削除すると無限ループになる。

    取り敢えず今は、古い実装を使う事にする。

    ble-syntax/tree-enumerate ble-syntax/parse/shift.impl2/.proc1

    の内部で無限ループになっている様である。
    どうやら一箇所に複数の節が登録されている時に
    一番外側の節に出会った時に一気に shift を実行してから、
    内側の節に対する処理を続けるという形にしていた為に不整合を生じていたようだ。
    一気に shift をするのではなく自分に対応している所だけ shift をする様に変更したら問題は発生しなくなった。
    取り敢えず、これで一旦解決とする。


  * [2015-03-08] <bug> $() を閉じると中身に色が着かない。

    $( だけ書いて中身を記述している時は正しく着色されている。
    $( の中の引数も、コマンド名についても同様に着色の対象になっていない様だ。
    ( ) の中については正しく処理されている様に見える。

    原因は分かった。$() 全体が一つの単語となっている為に
    $() 全体としての着色が施され、内部にある個々の単語の着色が消されているという事だ。
    これをどの様に処理するのが良いかは考える必要がある。
    例えば zdepth 的な物を使って被覆されない様にするとか?
    しかし、それだと単語が消滅した時に困る。
    より上の階層にある単語の色を使いたいが
    その情報は失われているので単語の色を再計算しなければならない。

    一応適用順序を範囲の広い物が先に行われる様に修正したが、
    それでも部分更新に際しては完全ではない。
    やはり部分更新と単語毎の着色は親和性が低いのだろうか。

    これに完全に対応する為には現在存在している全ての単語について
    どの様に着色をしているかの情報を保持する必要がある。
    その為には必然的に単語の生死を完全に追跡する必要がある。

    実は単語の生死を追跡するのは簡単なのではないか?
    単語の生成に関してはわざわざ述べる迄もない。
    単語の消滅に関しても beg-end0 に存在していた単語と、
    shift 後に j2-i に存在していた単語が消滅する単語と分かっている。

    ただし、問題は単語が消滅した事が分かったとしてどの様に着色を修正するのかという事である。
    親単語が変更された時に全ての子単語について再度着色をするのは大変であるが、
    各単語の着色については _ble_syntax_tree に記録してしまうという手もある。

    入れ子構造が変化した時の着色の変化をどの様に適用するかについて二通りの方法を考え得る。

    a 着色の変化を考慮に入れるべき範囲を先に計算し、その範囲内の各点について色を計算する。
      この方法を用いるとどの部分を再度着色し直さなければならないのかという事を計算しやすい。
      一方で、各点がどの色になるのかという計算が難しい。
      愚直にやると各点についてその点に存在する word を列挙しなければならず現実的でない。

      実は末端から順番に着色を進めていけばそんなに複雑な操作をしなくても着色ができるのでは?

    b 生成・変更のあった各単語について着色を実行する。

      単語に overlap がある場合に複数回着色されて非効率に思われるかもしれないが、
      親単語から順に着色を実行する様にすれば他の単語の事は考えずに自然に着色が出来る。
      問題点は親単語の一部でも変更があると、その親単語に含まれる全ての子要素について再度着色を実行する必要が生じることである。

      特にこの問題はトップレベルの単語が消滅した場合にも拡張される。
      トップレベルの単語が消滅した場合、その部分の着色は解除されて既定の色になるべきである。
      しかし、単語に対して着色を実行するだけで、既定の色を適用するという操作をしなければそこに色が残ってしまう。
      結局トップレベルの文脈で既定の色を適用するという操作が必要になるのである。
      しかし、トップレベルで既定の色を適用すると全ての単語について再度着色を実行しなければならなくなる。

    c もっと効率的な実装はないだろうか?

      例えば CG で複数の物体が重なり合っている場合にどの様に処理を行うか?
      CG の場合には毎回全てのオブジェクトを描画し直すという事をする気がする。
      その場合には z-depth を用いてどのオブジェクトが前に来るかの判断を行う。

      今回の場合には単語の入れ子構造の情報を持っているので z-depth を考える必要はなくて、
      単純に親のノードから順に着色を実行していけばよいだけの事である。
      従って z-depth だとかの手法は今回の場合には訳に立たない。

      今回特に考えたいのは "部分更新" である。
      部分更新の対象は、生成された単語に対する着色、消滅した単語についての着色解除を含む。
      更に、コマンドに応じた着色を行っている際には、単語自体に変化が無くても着色が変化する事もあるだろう。
      これらを効率的に処理するにはどうしたら良いだろうか。
      特に最終的に "その点の配色" を格納した配列を更新・取得できればそれで良い。

      % 例えば単語の depth 毎に配列を用意してそこに値を記録するという方式は?
      % →単語のレベルがまとめて上がったり下がったりする時に大移動が起こる。非効率である。
      %   更に、depth が深くなれば成る程より遅くなる。

      % 各点についてそこに存在する単語へのリスト構造を保持する方式は?
      % この様にすれば或る単語が削除された時に、その位置に次に存在する色を直ぐに取り出す事ができる。
      % →リストを管理するのが大変である。
      %   単語の生成・消滅に際してリストへの登録・解除を行う必要がある。
      %   単語自体はその範囲情報を伴っているので、どの範囲に登録・解除をするべきかという情報を追加で持つ必要はない。
      %   逆にリストの各項目がどの単語に対応しているかという情報が必要である。
      %   shift が起こった場合などには更に面倒な事になる。
      %   余り考えたくない方法である。単語が削除された時にその下にある色を取得する方法としては大袈裟すぎる。

    色々考えたが a の方法が現実的な気がする。もう少し案を具体化する。

    先ず、単語自体の着色と結果の着色は独立に扱う。

    単語自体の着色情報は _ble_syntax_tree に補足情報として追加する事にする。

    > 1 _ble_syntax_tree に色情報を記録できる様にする。
    > 1.1 4と即値で指定している所を修正する。
    > 1.2 _ble_syntax_tree の幅を5に増やす。未設定の状態では - を置く。
    >   終端していない単語の場合には - の代わりに -- を置く事にした。
    > 1.3 長さや内容の変化した node についての色も - に戻す。
    >   _ble_syntax_word_umin 等に登録を行う。
    >
    > 2 更新された単語について色情報を再計算する。
    >   同時に色情報の変化のあった範囲を記録する。
    >
    > 3 色の変化のあった範囲に関して色配列を更新する。

    取り敢えず実装した。$() の中も期待通りに着色されている。
    一旦此処でこの項目は解決とする。

    削除して消滅した単語について着色が除去されない、
    速度について検証していない、等の問題点はあるが、
    これらは後で問題になってから考えればよい。

  * leak variables

    > cs ps1out                             # local 宣言忘れ
    > rex=$'^([ \t]*)(\\([ \t]*(\\))?)?'    # local rex 宣言忘れ
    > rmax=-1 rmin=-1                       # local rmax rmin 宣言忘れ
    > type='$('                             # parse/nest-type -v type 前に local type 忘れ
    > tchild=11 tprev=-1 wbegin=-1 wtype=-1 # parse/nest-pop を parse の外側で呼び出していたのが原因

    現在 g が leak している事が分かっているが、使用箇所が分散している為に見つけるのが面倒。
    → g も処理した。

  * ble-syntax/parse: shift チェックのループが遅い。

    [現状]

    % これはどんなに後ろの方であっても挿入位置に wbegin や inest の参照があるかもしれない
    % という可能性が否定できない所に問題点がある。取り敢えず、この可能性があるかないか
    % 判定する簡便な方法について考えてみる。
    %
    % 1 削除領域内に word 開始点や nest 開始点がなければこのチェックは免れられる。
    % 2 word 終了点や nest 終了点は一つの開始点に対して一つまでしかない

    と思ったが、stat の有効性のチェックは上記の様に工夫すれば省略を考えられるが、
    shift に関しては結局全てチェックしなければならないので意味がない様に思う。
    ただ、stat や word を相対位置で覚えておくようにすれば、
    編集領域に跨る word や nest 以外についての shift をしなくても済む様になる。

    % どの様にすればスキップを行う事ができるだろうか。
    % 先ずは stat から考えてみる事にする。
    % inest の可能性について。
    %
    % 1 編集領域の終了点でトップレベルならば中で始まった inest が外で閉じる事は無い
    %
    %   編集領域の前と後で nest level が同じ場合、新しい inest が中で始まっている可能性はあるだろうか。
    %   と思ったが、ある。xxxx の中で一旦括弧が閉じて再び括弧が始まる可能性などを考えなければならない。
    %   但し、xxxx が top の nest level にある場合には中で括弧が閉じる事は出来ないので inest が中にあるとは考えにくい。
    %   (ただ、inest の境界などで何が起こるかは慎重に考えなければならない。)
    %
    %   まとめ: 編集領域の開始点と終了点でトップレベルならば中で始まった inest が外で閉じる事はない
    %   と思ったが、別に開始点はトップレベルでなくても関係ない。終了点でトップレベルならば関係ないのだ。
    %
    % 2 編集領域の終了点での inest が編集領域の開始点よりも前を指しているのならば、
    %   中で始まった nest が外で閉じる事はない。
    %
    %   というかつまり編集領域の終了点で inest が編集領域の内部を指していなければ OK という事である。
    %
    % 3 編集領域の終了点から順に見ていって、一度でも inest が編集領域よりも前を指したならば、
    %   それ以降に編集領域の内部を指す inest が現れる事はない。
    %
    % 3 は 1,2 の一般化になっているので 3 だけチェックすれば OK である。
    % もっと条件を課す事が出来ないかとも考えたが、長いネスト領域の開始点を編集した時に
    % 多少処理に時間が掛かるという事は不自然な事ではない。
    % 長さ(相対位置)を補正するのに時間が掛かっているのだなという事は想像できるだろう。
    %
    % 次に stat に格納されている wbegin について。基本的に wbegin についても同じである。
    % wbegin は通常 inest よりも更に下の構造である。つまり inest < wbegin の筈である。
    % この事が使えるかは分からない。
    % 少なくとも言える事は wbegin も inest と同じ様な判定方法ができるという事である。
    % ここで更に考えたいのは inest と wbegin を組み合わせてより効率的に中断をできないかという事。
    % もう少し考える inest < wbegin であるのならば、
    % wbegin < dbeg になった時には inest も wbegin も更新を中断して良い。
    % しかし inest < dbeg となった段階では未だ wbegin が dbeg より手前にあるかもしれない。
    % でも少なくとも word は同じネストレベルの中で構造は作らないはずだから、
    % 一旦 dend0 < wbegin となったならばそのネストレベルでは二度と wbegin が編集領域内に現れる事は無いだろう。
    % 但し、一つネストレベルを抜けた時にまた wbegin が編集領域内に現れる可能性はある。
    % 一つネストレベルを抜けた時にまた wbegin が現れない為の条件は何か?
    % これは何とも言えない。抜けたネストレベルの inest が編集領域内にある限りは
    % 常に wbegin が編集領域内に新しく現れる可能性を排除できない。
    % 逆に inest < dbeg なネストを抜けたら OK という事になる。
    %
    % wbegin も考慮に入れた時の中断の条件を更新する:
    %
    % 4 編集領域の終了点から順に見ていって始めに以下の条件を満たした時に中断できる
    %   inest < dbeg かつ ( wbeg < dbeg または dend0 < wbeg )
    %   この時に inest が再び編集領域内部に現れる事は無いし、
    %   また wbeg も編集領域内部に現れる事は無い
    %
    %   仮定: word は或るネストレベルの中で構造を作る事はない
    %     (これは現在の解析の仕組み上保証されている様に思うので特別に意識する必要はない)

    此処まで書いて気付いたが、上は編集領域内に inest や wbegin がない事の条件であって、
    inest や wbegin の相対位置を補正しなくても良い条件ではない。
    相対位置で記録した場合に inest や wbegin の補正が必要になるのは、
    編集領域の長さが変化し、かつ、inest や wbegin が編集領域よりも前を参照している場合である。

    一方で編集領域の長さが変化しなかった場合でも、
    word の invalidate が必要になるのでループを回す必要は残る。
    いっその事 word の invalidate は別のループで処理した方が良いのかも知れない。
    word の invalidate に関しては上記の方法でループを回すのを中断して問題ない。

    思うに、尻からで良いからネストの構造を掘り出す事ができる様なデータを記録するべきだという気がする。
    特に、直前のネスト構造ノードへの nest の offset を保持する様な。
    全ての点について一々ネストノードだとか stat だとかが設定されているかどうかをチェックするのは大変である。
    考えなければならないのはその様なデータ構造自身も shift の対象としなければならない事、
    それから文脈値 (stat) が同じになった時に解析の中断をしてデータ構造が壊れないかどうか考える事。

    少し考えてみる。その様な掘り出すのに必要なデータは何かというと…。
    先ず、途中から解析を再開できる様にする為にはその点よりも後の情報を含んでいる様なデータは保持できない。
    従って、必然的にノードはデータ構造の末尾に置く事になる。
    1 兄(末尾)のoffset 2 親(先頭)のoffset 3 末子(末尾)のoffset である。
    親の offset に関しては兄を辿っていけば早晩に辿り着くので記録しなくても良い。
    というか、親の offset は stat の inest に記録されているのでわざわざ此処で記録する必要はないし、
    そもそも親の末尾の offset さえ知っていれば問題なく、
    これは掘り出す過程で知っているはずなので各ノードのデータに含める事は考えない。

    更に良く考えてみたら自身の情報についても格納しなければならない。自身の先頭の offset も含める。
    データの内容について改める。
      data="${自身の先頭のoffset} ${兄(末尾)のoffset} ${末子(末尾)のoffset(子がなければ -1)}"

    [2015-08-11] 取り敢えず _ble_syntax_* に含まれるポインタを offset (長さ) で表現する様に書き換えた。

    [2015-08-13] _ble_syntax_tree (旧 _ble_syntax_word): 入れ子構造を記録する様に変更

    入れ子構造の情報を利用して shift を実行するコードを書いてみた。
    しかしそれ程高速化はしていないようである。もっと積極的に shift の skip を行うべきか?
    しかし、取り敢えずはこれで良いという事にする。

  * [2015-08-13] _ble_syntax_tree (旧 _ble_syntax_word): 入れ子構造を記録する様に変更

    shift の際に入れ子構造を考慮に入れたスキップをする為に、
    入れ子構造を記録・構築する様に改良を行う。

    % 整理2015-08-12
    %
    % 改めて _ble_syntax_* の形式についてまとめる:
    %
    % | _ble_syntax_text    解析結果の対象の文字列を記録
    % | _ble_syntax_stat[]  文字 #i を解釈する直前の解析状態
    % |   ctx     現在の解析の文脈
    % |   wlen    現在のシェル単語の継続長さ
    % |   wtype   現在のシェル単語の種類
    % |   nlen    現在の入れ子段階の継続長さ
    % | _ble_syntax_nest[]  入れ子の情報
    % |   ctx     入れ子を抜けた時の復帰状態
    % |   wlen    同上
    % |   wtype   同上
    % |   nlen    同上
    % |   type    入れ子の種類を表す文字列
    % | _ble_syntax_word[]  境界 #(i+1) で終わる単語の情報を記録
    % |                     (つまり単語の最後の文字の位置に記録されると思えば良い)
    % |   wtype   シェル単語の種類
    % |   wlen    シェル単語の長さ
    % |
    % |   ※境界#(i+1) (または境界#i が word[i-1] に対応する) の様に1つずらして格納しているのは、
    % |     部分更新の際の配列の切り貼りを他の配列と同様に行える様にする為である。
    % |     基本的に配列の切り貼りは、添字 data[i] に対応している情報はその境界の右にある文字に附属していると見做して実施される。
    % |     従って単語の情報は単語を構成する最後の文字、つまり添字 i-1、に附属しなければならない。

    [計画]

    - 入れ子構造を利用して効率的に shift を実行するためには、
      入れ子構造の情報を残して置かなければならない。
      現状の実装では入れ子構造の情報の一部は _ble_syntax_nest 等に残存しているが、
      解析終了後に再び構造を調べるのに十分な情報は記録されていない。

    - 入れ子構造を構築するに当って、word に関する入れ子構造の管理は不要である。
      というのも、word が入れ子になっている場合には
      必ず nest を通して入れ子になっているはずだからである。

      ただし、word を効率的に列挙して処理を実行するためには
      "前のword" に対するポインタを word 情報に含めておくのが良い。
      →しかしそうすると prev_word ポインタについても
        shift を考えなければならないという面倒な事に…。

      nest に関しては自分の親、自分の兄、自分の末子に対するポインタを保持する。

    - どこにどの様な形式で情報を格納しておくかというのも考える必要がある。
      既存の _ble_syntax_* のどこかに入れ子構造を記録するという形にするという手と、
      新しく _ble_syntax_tree などの配列を作成してそこに記録するという二種類の方法がある。

      既存の _ble_syntax_* のどこかに記録するとしたら _ble_syntax_word が適切であろう。
      ちょうど _ble_syntax_word は解析の動作自体に影響は与えず「出力」としての効果を持つ。
      また、word と nest の入れ子構造を統合して統一的に記述できる可能性がある。
      この変更にあたって _ble_syntax_word の中身の形式を大幅に変更してしまっても良い。

      新しく _ble_syntax_tree などの配列を作成して管理する事にすると、
      x 切り貼りをしなければならない配列が増える。
        元々 sparse な配列なので無駄に切り貼りの作業を増やしても損した気分になる。
      x word/nest の両方について入れ子構造を辿るのも面倒かも。

      _ble_syntax_word を改造して形式を一新する方向で考える。
      まず、現在 _ble_syntax_word が使用されている箇所について確認を行う。
      - 単語の登録・shift
      - 色付け (syntax/update-word-table)
      - debug 用コード (print-status など)
      現在の形式は "wtype wlen" である。此処にどの様な情報を付加するべきか?
      - word と nest は同じ箇所で終了する可能性がある。
        したがって両方登録できる様にするべきである。
        同じ箇所で終了する場合、word の内部に nest があるという構造になっている。
      - word の親と nest の親は必然的に同じである。
      - word の親はなしまたは nest である。nest の親はなしまたは word である。
        word が word の親になっていたり nest が nest の親になっている事はない。

      a 案 "wtype wlen parent prev child ..." というのはどうだろうか。
        [[ $wtype == ^[0-9]+$ ]] の時に word でありそれ以外の時に nest である。
        child > 0 の時は末子はその offset の位置に存在する。
        child == 0 の時は末子は同じ位置で終了し ... に末子の情報が記録される。
        既に登録されている場合には "wtype wlen parent prev 0 既存内容" などとすれば良い。

        % ? 疑問点: 前回の解析までに存在していた内容を消去しなくても良いのか?
        %   前回の内容はいつ消去されるのだろうか。
        %   何処かで削除を実施しないと、前回の解析の結果が混ざってしまう。
        % - これは今迄の実装でも注意しなければならなかったはずだ。
        %   前回の解析で単語の終端だった部分が新しい解析で単語の途中になった場合、
        %   前回の解析で生成された単語が消去される機会が失われてしまう。
        % →前回の解析で存在していた内容を気にする必要はない。
        %   これらは配列の切り貼りの時点で削除され _tail_syntax_word に移動される。
        %   途中で解析状態が同一になった時にのみ _tail_syntax_word から再度コピーされる。
        %   つまり、解析する時には _ble_syntax_word は空文字列になっているので
        %   前回の内容の残存については気にしなくて良い。

        この方法ならば同じ位置で複数のレベルの word が終端する場合にも対応できる。
        今現在ではそのような単語の区切り方は存在し得ないが、柔軟な構造にしておいた方が見通しが良いだろう。

        ? nest-push の type として [0-9]+ の様な物が存在していると word と区別が付かない。
          そのような物が存在していないことを確認する必要がある。
          → grc --exclude=out nest-push で確認した。その様なものは今のところない。OK

    [実装]

    上記 a 案で行くことにする。

    1 先ず初めに word に登録する関数を準備する。これで word を登録する様に変更する。動作を確認する。
    2 word に別の情報も登録できる様に word 読み取り部分の変更を行う
    3 nest 情報も pop 時に登録する様に変更する。print-status の改良

    4 兄情報・子情報も登録する。入れ子になっている部分も shift する

    > (a) 兄情報・子情報をその場で計算して登録するという可能性?
    >
    >   兄情報・子情報も登録するためには stat に兄情報・子情報を記録する必要がある?
    >   もし兄情報・子情報をその場で計算して求めることができるのであれば、
    >   わざわざ現在の解析状態に含める必要はないのではないかということ。
    >
    >   ? stat に記録を行わなくても _ble_syntax_word, _ble_syntax_nest 等を用いて
    >     兄情報・子情報を構築することは可能だろうか?
    >
    >     兄は max { 終端 | 親の開始位置 < 終端 <= 自身の開始位置 } の筈である。
    >     また、子は max { 終端 | 自身の開始位置 <= 終端 <= 自身の終端位置 } の筈である。
    >     親の開始位置は、
    >       wbegin が設定されている場合は wbegin が、
    >       inest が設定されている場合は inest が、
    >       それ以外ならば初期位置 0 が該当する。
    >     自身の開始位置・終端位置は知っている。
    >
    >     これらの情報を用いれば兄情報・子情報を必要になった時に構築する事は可能である。
    >
    >   ? 解析時は兄情報・子情報はローカル変数に保持しながら解析して、
    >     ただし、stat から復元する時には兄情報・子情報を再構築するという方法はどうか?
    >     nest-pop の際にも同様に構築する必要が生じるのでは?
    >     これだとコストがかかってしまうので、nest-push の際にまとめて兄情報・子情報も push して良い。
    >     しかし、その様にするのであれば stat にも同様に保存してしまえば良いのではという事になる。
    >     但し面倒なのは、兄情報・子情報を stat/nest に記録する様にしてしまうと、
    >     兄情報・子情報に対する shift も実装しなければならないという事である。
    >
    >   取り敢えずの方針としては、shift の実装が面倒なので兄情報・子情報は stat/nest には含めない。
    >   代わりに word に登録する際に毎回自分で兄情報・子情報を計算する、という事にする。
    >
    >   問題点
    >
    >   ? 兄情報・子情報は shift だけで良いのか?
    >     stat に登録していない為に兄情報・子情報がずれていても
    >     解析状態が同じになったと判定されてしまう可能性がある。
    >
    >     →削除された領域にあるノードを参照している stat は削除すればよい。
    >       stat で現在参照しているのは wbegin, inest である。
    >
    >     % 但しチェックする範囲が広がるのが難点かも知れない。
    >     % →stat に兄情報・子情報を記録する場合でも stat の更新範囲が広くなるので
    >     %   結局どのようにしても同程度チェックする範囲が広がる。気にしなくて良い。
    >
    >     →削除された領域にあるノードを参照している弟ノードはどうするのか?
    >       それも削除すると更にその弟も再構築の対象になり…を繰り返して結局すべて解析し直す事になる?
    >       更に、削除された領域にあるノードでなくても、
    >       解析状態が一致しないことによって再解析が行われて失われる word も存在している。
    >       それらを兄情報・子情報として参照しているノードはどの様に取り扱うべきか。
    >
    >     結局 _ble_syntax_* に記録された昔の情報を参照して構築する方式だと、
    >     部分更新した際に不整合が生じてしまう。
    >     昔の情報を参照して構築した部分をすべて再計算しなければならなくなるが、
    >     どの部分がどの部分の昔の情報まで使って構築したかの情報がないので、
    >     すべて再計算しなければならなくなる。
    >     (一応各ノードを調べれば再計算が必要かどうかを得ることができるが、
    >     いずれにしてもすべてのノードについてそのチェックを実行しなければならない。)
    >
    >     因みに _ble_syntax_nest に関しては過去の情報を使用して解析が実行されるが、
    >     解析状態一致の確認の際にはちゃんと _ble_syntax_nest の一致まで確認されている。
    >
    > (b) 兄情報・子情報に対応する情報も stat に含めて計算を実行する
    >
    >   word/nest が混合しているのでどの様に取り扱うかが微妙である。
    >   兄にしろ子にしろ (ある条件を満たすノードで) 最後に登録したノードへのポインタになる。
    >
    >   何れにしても wbegin/inest 設置の瞬間に兄・子の情報も更新する必要があるような気がする。
    >   inest 設置の瞬間の処理については nest-push で行えば良い。
    >   wbegin 設置については新しく wbegin 設置用の関数を置くことにするか?
    >   先ず初めに wbegin 設置位置について確認を行う。
    >   →主に3箇所の wbegin 設置箇所があったので新しく関数を用意してそれに置き換えた。
    >
    >   更に解析状態を表す tprev, tchild という変数を追加した。
    >   tchild は現在の level で一番最後に設置された節の位置を表す。
    >   tprev は一つ上の level で一番最後に設置された節の位置を表す。
    >   child/prev というのは現在の節からの視点であって、
    >   現在の位置に新しく設置する節からの視点ではないことに注意する。
    >
    >   ? stat に tprev/tchild を記録する必要は実はないのではないか?
    >     というのも解析再開時に状態を復元する際は、
    >     過去のデータ配列の内容を参照して良いはずだから、
    >     わざわざ記録しなくても計算で tprev/tchild を再構築できるからである。
    >
    >     →やはり記録する必要はある。stat には2つの役割がある。
    >       一つは解析再開時に解析途中の状態を復元する役割であり、
    >       もう一つは解析状態が一致したかどうかを判定して、
    >       解析を中断するための参照状態となる役割である。
    >
    >     前者の役割を果たす為には tprev/tchild は再構築できるので不要であるが、
    >     後者の役割を果たす為には参照用の tprev/tchild を保持している必要がある。
    >     (後者の場合でも、一応 "古いデータ配列を全て覚えておいて、かつ解析状態の比較の際に
    >     毎回古いデータ配列から tprev/tchild を再構築して一致するか確かめる" という力技もあるが、
    >     それはさすがに遅くなるのでやはり記録をする。)
    >
    >     結論: stat に tprev/tchild も記録する。
    >
    >   ? nest に tchild を記録する必要は実はないのでは?
    >     nest は pop した時に状態を復元するためにある。
    >     ところで pop した時に新しい節が作成されて tchild は上書きされて消える。
    >     どうせ直後に上書きされて消えるのであれば記録する意味は無いのでは?
    >
    >     解析状態の一致の際にもチェックする必要はないように思われる。
    >     というのも結局使われない情報であるため、
    >     もしチェックをせずに違いを看過したとしても最終的な結果には何の違いも出ないからである。
    >
    >     % また記録するとその分また shift のコストが上がるという事を意味する。
    >     % 取り敢えず nest には tchild を記録しない方針で行くことにする。
    >
    >     実は nest の tchild は必要のようだ。
    >     nest の下に word を構築する際、word に入って word から抜けた時に tprev を復元しなければならない。
    >     それが実は nest-push した時の tchild に対応している。
    >
    >   ? word-pop 後の tprev について現在のデータ形式で自然に再構築できるか?
    >
    >     word-pop 後は nest の level (または top level) に必ずいる。
    >     というのも word の下に word は直接来ないからである。
    >     word-pop 後の tprev は何を意味するかというと、現在の nest-level の前の nest-level である。
    >     これは nest-push する直前の tchild を意味する。
    >
    > 取り敢えず (a) で実装したが (b) に方針転換する事にする。

    4.1 word-pop の際の tprev の再構築?
    4.2 ble_syntax_stat の形式変更
    4.3 check
    4.4 新しく追加した項目の shift

    > shift は再度整理して書き直す事にする。
    >
    >   不可解な実装になっている部分についても再考察を行う。
    >
    >   ? stat 無効化に於いて wbegin/inest の判定範囲が
    >     更新領域 beg-end0 ではなく再計算領域 i1-j2 になっているが、
    >     無効化は更新領域に被る時にだけ行えば問題ないのでは?
    >
    >     或いは実は原則を破っている箇所があった為にこの様になっていた?
    >     例えば var[]= の部分に関しては、元々原則を破った実装になっていた。
    >     (現在は、この部分に関しては保留中である。
    >     最終的には word 着色で var[] としての着色を上書きしてしまうなどすれば良い。)
    >
    >   ? stat の shift に於ける無効化チェックは必要なのだろうか?
    >
    >     原則さえ守っていれば stat/nest の解析状態チェックだけでOKなのでは?
    >
    >     元々この様にした理由は、無効化がないと不正確な stat が残ってしまうという事である。
    >     % この不正確な stat の状態で解析を続行しても続きのデータを再現できない可能性がある。
    >     % つまり、この事により予期しない解析中断が生じる可能性がある。従って無効化は必要である。
    >
    >     →本当だろうか? 不正確な stat (その様な stat が生成される機会はなかった) としても
    >     stat が一致している以上は後続のデータも全く同様の物が生成されるのではないだろうか?
    >     つまり、stat を無効化するかどうかの判定は「前回の解析の shift だけで同じ stat が生成されるかどうか」
    >     ではなく、もっと許容的な「後続のデータを再現することができる stat」という条件にするべきという事である。
    >
    >     逆に stat が壊れた状態になったとしても、
    >     後続のデータと整合する様に修正する事ができれば無効化する必要はないという事になる。
    >     stat の wbegin/inest が指し示している部分が消滅した時の wbegin の変更の仕方を一つ決めればよい。

    5 check: チェックの為に print-status に構文木の結果を表示する。

    5.1 未だ終端していない入れ子構造についても正しく処理する必要がある。

    > 例えば shift を計算する範囲を決定する際に愁嘆していない入れ子構造の部分を跳ばす事はできない。
    > 終端していない入れ子構造についてどの様に処理を実行するべきかは、print-status の実装で試せばよい。
    > 他の shift 等に対しても同様の処理を実行する際には print-status の実装を真似すれば良い。
    >
    > 一つの方法は無理矢理終端させた時のデータ配列を作成して、
    > その配列に対して処理を実行する方法である。
    > この様にすればデータ配列の形式に従ってそのまま処理を実行する事が出来る。
    > 終端していない節と終端した節 (データ配列に格納された節) が混合したままだと、
    > それに対する処理を上手に書くのが面倒なように思われる。
    >
    > 何れにしても print-status の実装を終端していない節に対応する過程で再考察を行う。
    >
    > 何だか良く分からなくなったので、結局終端していない入れ子構造についての情報を変数 tree に集計した後で、
    > ("${_ble_syntax_tree[@]}" "$tree") に対して処理を実行するという形にする事にした。
    > 関数 ble-syntax/tree-enumerate proc, ble-syntax/tree-enumerate-children proc を使う。
    > proc には各節を処理する関数名を指定する。
    > これを用いて print-status も実装した。多分動作している。

2015-08-11

  * _ble_syntax_* の単語・入れ子開始位置の記録方法を変更 (絶対位置 wbegin → 相対位置 wlen)
    記録点からの負のoffset(単語長・入れ子継続長)で指定する事にした。

    % 整理2015-08-11
    %
    % 何やらよく分からなくなってきたので改めて現在の状況についてまとめることにする。
    % まず、現在の _ble_syntax_* のデータは以下のような形式になっている。
    %
    % _ble_syntax_text    解析結果の対象の文字列を記録
    % _ble_syntax_stat[]  文字 #i を解釈する直前の解析状態
    %   ctx     現在の解析の文脈
    %   wbegin* 現在のシェル単語の開始位置
    %   wtype   現在のシェル単語の種類
    %   inest*  現在の入れ子の開始点
    % _ble_syntax_nest[]  入れ子の情報
    %   ctx     入れ子を抜けた時の復帰状態
    %   wbegin* 同上
    %   wtype   同上
    %   inest*  同上
    %   type    入れ子の種類を表す文字列
    % _ble_syntax_word[]  境界 #(i+1) で終わる単語の情報を記録
    %                     (つまり単語の最後の文字の位置に記録されると思えば良い)
    %   wtype   シェル単語の種類
    %   wbegin* シェル単語の開始位置
    %
    %   ※境界#(i+1) (または境界#i が word[i-1] に対応する) の様に1つずらして格納しているのは、
    %     部分更新の際の配列の切り貼りを他の配列と同様に行える様にする為である。
    %     基本的に配列の切り貼りは、添字 data[i] に対応している情報はその境界の右にある文字に附属していると見做して実施される。
    %     従って単語の情報は単語を構成する最後の文字、つまり添字 i-1、に附属しなければならない。
    %
    % shift の対象となるのは * で示した項目である。
    % 現在、内部構造を表現する情報に nest と word の2種類がある。
    %
    % A word&nest を統合する可能性について:
    %
    %   word と nest を別々に管理していることによって、
    %   shift 対象の管理がより面倒になっている様に思われる。
    %   nest は解析のために必要な入れ子の情報であり、
    %   word は解析には必要がないが解析の結果として呼び出し元に提供する情報である。
    %   どちらも似た様な入れ子構造を構築することには変わりないが使い方が多少異なる。
    %
    %   x どちらも同じ位置で二段階の入れ子を作ったり抜けたりする事はない、
    %     という前提で実装されている気がする。
    %     統合するとしたらこの前提が成立しなくなるので注意する必要がある。
    %     例えば echo $(command),$(command) となっている場合、
    %     echo の第一引数の単語は、開始点で2段階の入れ子を作成し、
    %     また、最終点で2段階の入れ子を抜ける事になっている。
    %     (ところで、単語と解析の入れ子が交錯する様な事態は起こらないので、
    %     多段階の入れ子作成・解除にさえ対応すればそれで問題はなくなる。)
    %
    %   x word/nest は微妙に異なる構造の構築になっている気がする。
    %     word は word の終了時にその性質が決定され、末端に情報を格納する。
    %     word が開始した時点では word 情報は確定していないので、
    %     配列には記録せずにむしろ解析状態 stat に現在の word を直接記録している。
    %     一方で nest は入れ子が開始した時点で、
    %     それがどの様な入れ子なのかが確定するので、開始点に全ての情報を格納できる。
    %
    %   x 何より完全に解析部分を再実装することになりそうなので統合したくない。
    %     現在の実装では、解析の制御に最低限必要な部分を nest に格納している形になっていて、
    %     解析の制御に関係のない word の部分は分離している、という体である。
    %     Shift 時の複雑さには目を瞑ってこのままで良い気がする。
    %
    %   →上記の色々な理由から word&nest の統合は取りあえず断念する
    %
    % shift 時は単純に該当する項目の補正を行うだけではなく、
    % 無効になった word, nest を参照している stat を削除するという事もする。
    %
    % B 単語の開始位置を offset で管理している場合:
    %
    %   単語が完全に更新領域の外側にある時は書き換えの必要性はない。
    %   単語の開始点が更新領域に含まれている場合、
    %     単語は消滅する。この単語を参照している stat (解析状態) も同時に削除しなければならない。
    %     削除しておかないと、再解析の結果として偶々同じ stat になった時に解析が停止してしまう。
    %     # 或いは、解析が停止するのならばそれで良いのではないだろうか?
    %     # 全く同じ状態になったのであれば以後の計算をしても同じ結果になるはず。
    %     # もし同じ結果にならないのであれば shift/状態復元 に失敗しているという事だから、
    %     # そちらを修正するべきということである。
    %     # これは shift を正しく実行できないのだとしたら削除するべきということでもある。
    %     # 今、単語の開始位置の表現を変更した為に、前と状況が変わっているかもしれない。
    %     # この辺りの stat を削除するかしないかについては再度慎重に検討するべきである。
    %     この単語を参照している nest は、使用されることがないので放置で良い。
    %     何故ならば解析再開点は nest が記録された位置よりも前になり、
    %     また…(本当か???)
    %   単語の内部に更新領域が含まれている場合
    %     その単語の長さの修正を行う。
    %   単語の終端だけが更新領域に含まれている場合
    %     単語は word には記録されていない。
    %     stat にある相対位置だけ修正を行えば問題ない。
    %
    %   →考えるのが面倒になったので実際に実装してしまう事にした。意外と簡単に済んだ。
    %     _ble_syntax_{stat,word,nest} に対して内容の形式を変更した。
    %     先ず単語の終端が更新領域よりも後にある場合にしか単語の shift は必要ない。
    %     (というのも、単語の終端が更新領域よりも前にある場合は勿論 shift は不要だし、
    %     単語の終端が更新領域の内部にある場合は単語自体が無効になるからである。)
    %     そして更に単語の長さが変更になるのは単語の開始が更新領域よりも前にある場合である。
    %     (というのも、単語の開始が更新領域の内部にある場合には単語自体が消滅するからである。)

  * <bug> 履歴が正しく初期化されない

    何かコマンドを実行した後に history-prev を実行すると、
    直前に実行されたコマンドが表示されず、少し昔のコマンドが表示される。
    幾つか遡っていくと直前に実行されたコマンドが表示される。

    history で表示されるコマンドは正しいコマンド順になっている。
    また、遡っていって直前に実行されたコマンドに行き着けば、
    それより前は正しいコマンド順になっている様である。
    余分コマンド (直前に実行したコマンドと履歴リストの末端の間にあるコマンド)
    に対応した抜けがある訳でもなく、余分コマンドと同じコマンドが幾つか繰り返している。
    どうやらコマンド順が変になっているのではなくて、
    履歴のリストの末端に余分にコマンドが追加されているという事のようだ。

    どうやら .bash_history に空行があると駄目な様だ。
    .bash_history の空行は初期化の際に読み取られないので行番号がずれる。
    行番号がずれていると history -n で追加読み取りした部分がずれる。
    →.bash_history の空行を削除したら問題は発生しなくなった。

    と思ったが、それでも ble.sh を起動してからコマンドが追加されたりして、
    その後で初めて履歴を使う、という事をするとまた履歴が末尾に追加されて分かりにくい。

    % 無条件で履歴を読み取るのではなくて、履歴エントリが空の時にだけ読み取る様に変更するべきでは?
    % →履歴エントリが空の時にだけ読み取る様にすると、
    %   一回でもコマンドを実行すると過去の履歴が辿れなくなる。
    %   履歴の初期化をせずにコマンドを実行したときの履歴の処理はどうしているのか。

    再度履歴情報の取り扱いについて整理する:

      履歴情報は2段階ある。shell が持っている history 情報と、
      ble で取り扱えるようにシェル変数に格納した履歴情報である。
      ble の履歴情報の初期化には時間がかかるのでできるだけ遅延したい。
      bashrc 処理時には shell の history にまだ履歴が読み込まれていない。
      bashrc の処理が終了して対話状態になった時には shell の history は初期化されている。
      しかし、ble の履歴情報はまだ初期化されていない状態である。
      ble でコマンドを実行したときには shell の history に情報を追加する。
      ble の history 情報が既に初期化されていればそちらの更新も行う。

    結局、shell の history が空の時にだけ読み取る様に変更することにした。

2015-08-09

  * complete: <bug> リダイレクトのファイル名でファイル名補完が効かない。
    →対応した。
  * complete: <bug> .# で始まるファイルを扱うために .\# などとして tab をしても補完が効かない。
    →再現しない。再度改めて試してみたが、補完は問題なく動いている様である。

  * complete に関連する過去の修正
    - 変数= の補間でファイル名を取り扱える様にする
    - > の直後のファイル名の補間が働かないのを修正
    - (command) ディレクトリ名の直後に / を挿入する

2015-04-25
  * complete: 補間挿入: 既に直後に '/' または ' ' がある場合にはこれらの文字を挿入せずに次に文字を進める。
  * complete: option hoge=, hoge: の続きにファイル名を指定できる様にする

2015-03-22

  * ble-decode.sh: bugfix, bash-4.1 でも ESC * に登録しないと駄目

    一回でも ESC z 等を bind -x で登録して解除すれば OK になる。
    しかし、一回も bind -x をしていない状態だと
    ESC 単体で登録しても何も起こらない。
    どの bash の version でも ESC * に対して張る事にする。

    今度は ESC [ を捕まえられなくなった。
    bash_execute_unix_command: cannot find keymap for command のエラーになる。
    bash-4.3 と同じ症状である。結局 bash-4.3 と同様に ESC [ を変換する事にする。

2015-03-11

  * ble-syntax.sh: <bug> 単語の先頭に空白を挿入すると空白が単語の一部とされる

    % 単語の先頭に文字列を挿入した時に単語情報 _ble_syntax_word が更新されない。
    % 結果として単語の先頭位置が更新されず、空白も単語の一部と解釈される。
    %
    % 本来であれば wbegin の位置が変化しているのだから _ble_syntax_stat が一致せず、
    % 単語の終端まで行って漸く _ble_syntax_stat が一致する筈である。
    % 単語の終端まで行くのであるから word の情報も再設定されるはずという算段である。

    これは単に単語の shift が実行されていない事が原因であった。
    元々は、単語の登録は必ず stat の設定を行った箇所でしか起こらないと決めていた。
    従って shift 判定の時は stat に値が設定されている時にだけ単語の shift の確認を行っていた。
    所が、shift の判定を stat に値が設定されているかどうかに拘わらず実行する様にしたら、問題が発生しなくなった。
    これはつまり stat の設定が行われた箇所とは異なる場所で word が設定されているという事を意味する。

    - よく考えてみれば for の直後などでも空白を飛ばしているので for に対する word の箇所では stat が起きない。
      つまり、この場合にも stat が設定されている事を前提とした word の shift は動かない事になる。
      と思ったが改めてみてみると for の直後には stat が設定されている。
      改めて考えてみれば for の直後の状態は CTX_CMDXF で表現する様に変更したのであった。

    - 問題の発生していた例 "echo hello" の場合には word の位置に必ず stat が設定される様に思ったが、
      これで問題が起きていたという事は echo の終端位置に stat が設定されていないという事を意味する。
      実際に echo hello を解析した後に stat の内容を吐き出してみたが、stat が設定されているのは、
      (echo の直前、hello の直前、終端) の三箇所だけになっている。
      改めて ctx-command/check-wrod-end を見てみると、
      関数定義に対応した時にコマンドの後の空白を読みとばす様に変更したのであった。

  * <bug> i-word[1]: substring expression < 0

    time : $(echo | echo | echo) を time : $(: | : | :) に書き換えている最中に
    bash-4.0: i-word[1]: substring expression < 0 というエラーが出た。
    bash-4.0 と bash-4.1 で再現したが、再度起こそうとしても起きない。
    起きる条件が良く分からない。

    エラーメッセージに現れる式は ble-syntax.sh の
    ble-highlight-layer:syntax/update-word-table
    にしか現れない式である。wbegin の shift に失敗しているのだろうか。

    再び起こった。今度はもう少し違ったパターンだが共通点はある。
    $() の中で | の直後の単語の一部を削除している時に起こったというのが共通点である。
    しかし似たような編集を再度実行しても問題が再現しないようである点も同様である。

    多少 shift の部分に手を加えた。これで解決したかは分からない。

    追記:

    "単語の先頭に空白を挿入した時に空白が単語の一部になる" バグの修正の際に、
    word は必ずしも stat の設定された場所だけに設定される訳ではない、
    という事が判明しそれに対する修正を行った。
    この修正の前は shift するべきなのに shift されていない単語があった事になる。
    この substring expression < 0 の問題もこれに関連していた可能性が高い。
    再度 $() 等を入力して色々してみても問題は再現しないようなので、
    取り敢えずこの bug に関しても解決したと解釈する事にする。
    実際には解決されていないとしても、再び問題が発生した時に考える事にする。

2015-03-08

  * cygwin 上で prompt の色がついていない。

    _ble_line_prompt の内容を覗いてみると、
    何と ps1out に CSI 99s や CSI 99u が残っている。
    また、\e[32m も本来ならば \e[0;32m 等に翻訳されている筈なのにそれがない。
    要するに ps1esc がそのまま出力されている様に見える。
    出力幅が22桁余分である事から CSI sequence を認識していない様に思われる。
    先頭の CSI の部分だけ無視して残りを普通に出力している。

    試しに以下を cygwin 上で実行してみた所、失敗する。(linux の上では成功する。)
    rex_csi=$'^\e\\[[ -?]*[@-~]' && [[ $'\e[99s' =~ $rex_csi ]] && echo hello
    何故だろう。locale の問題かも知れない。と思って LANG=C としたら成功した…。
    更にプロンプトにも色が着くようになった…。

    然し、LANG=C にしていると今度は日本語があった場合の動作が怪しいのではという気がする。
    →実際に日本語を入力してみると大変な事になる。なので一時的にだけ LANG=C にしたい。
    実装した。テストは未だしていない。→テストした動くようになった。

  * <bug> bash-4.1 以下でカーソルの表示位置がずれている。
    現在のカーソル位置の追跡自体は誤っていない様に思われる。
    という事は、移動先の cx cy の算出を誤っているという事か?

    bash-4.1, 4.0, 3.2 で起きる。bash-3.0, 3.1, 4.2, 4.3 では起きない。
    調べてみると getxy.cur の返す値が変である。
    変な値を返している時に _ble_line_text_cache_pos の中身を確認したが問題ない。
    と思ったら ((_eoc[2]&&(_pos[0]=0,_pos[1]++))) が駄目であった。
    bash のバグで条件分岐内で配列要素を参照できないのであった
    (参照するとその branch が必ず実行される)。

  * <bug> bash-4.2, 4.0, 3.2, 不完全な編集内容に対してエラーが出る。

    i=${ で駄目。
    bash-4.3 では起きない。bash-4.1 でも何故か起きない?

    どうも正規表現が正しく動いていない様な気がする。
    →これは正規表現中の "'" を無駄に多く escape していたのが原因であった。
    '[^']*' で済む所を \'[^\']*\' としていた事による。
    然し \' になっていた時の解釈が謎である。例えば以下が一致する。

    rex="^([^\$]|\\'[^\\']*\\')+\$" && [[ 'i$' =~ $rex ]] && echo hello

    上で 'i$' を '$' にすると一致しない(正常)。
    上をこれ以上単純化する事は出来なかった。

    何だか良く分からないが \' を ' に修正したら問題は起きなくなったのでこれで解決とする。

  * <bug> bash-4.0, 4.1 でプロンプトが表示されない
    これは declare DRAW_BUFF としただけの時に、
    ${#DRAW_BUFF[*]} が 1 になっている事が原因であった。

  * <bug> bash-4.1 以下でプロンプトの色が着かない。。
    何と、_ret="${specs[++i]%%:*}" を実行すると i が 2 増える…。
    つまり配列の添字を複数回評価しているという事になる。

    色々試してみた。
    i=1; _ret="${a[++i]%%:*}"
    - a が配列でない場合には起こらない。
    - %%:* がない場合には起こらない。
    - %%:* の代わりに #a 等でも起こる。${a{++i]#a} では起こらない。

2015-03-07

  * ble-decode.sh: CSI Function Key Sequence を特別扱いする? (2015-02-28)

    現在の登録作業は些か無駄な事をしている様な気がする。
    ble-bind の出力も exaustive になっているし、
    テーブルも巨大な物になっていて declare や set の時に見苦しい。

    - .ble-decode-char 再実装した。
    - それに伴って .ble-decode-char/csi/* も追加し、
      CSI シーケンスを特別に読み取る様に変更した。
    - また、cmap/default.sh も大幅に変更した。
    - 修飾の機能は sendkey の方で一括で行う様に変更する。
      C-x @ S 等に対して ESC と同様の修飾の機能を与える。

2015-03-06

  * ToDoの整理

    > 2015-02-17
    > * for 等の末端が赤くならない
    >   →コマンドとしての着色によってエラー色が上書きされていた。
    >   着色の "レイヤー" に対応できる様にしたい。その後で再度考える。

    これは改めて確認してみた所、赤くなっている。
    単語の色付けよりも後にエラーの着色を行っている為であろう。
    エラーに関しては又後で仕組みを整えるつもりであるが、
    特にこの問題に関しては解決済という事にする。

    > 2013-06-10
    > * <lbug> complete: ~ で始まるパス名の場合、
    >   ディレクトリ名の末端に / を追加したり、
    >   ファイル名の末端に SP を追加したりする機能が機能しない。
    >   これは test -e "$hoge" としてファイル名がどうかを判定している時に、
    >   hoge の中に含まれている ~ が展開されない為である。
    >   同様に ~user で始まる形式のパスについても期待通りに働かない。

    これは新しい complete の仕組みの元では問題なく動作している。
    単語を eval で評価してから候補を生成している事により見た目の表現には関係なく動作する。

  * overwrite-mode に対応

    | 2013-06-06
    | * overwrite mode
    |   + 開始時は insert
    |   + self-insert, delete-backward-char で対応するだけで OK
    |   + 現在のカーソル位置を反転して表示する

    ble-edit+overwrite-mode 実装、self-insert, delete-backward-char の対応。テスト。
    test (overwrite-mode): OK, accept-line 後のリセットOK
    test (self-insert): 半角を半角で上書き、全角を半角で上書き、半角を全角で上書き、全角で全角を上書き。
    test (self-insert): 行末での半角挿入、行末での全角挿入、改行の挿入
    test (delete-backward-char): 編集文字列終端での削除、文字列中途での削除、行末での削除、行頭での削除

    TAB や改行が関係する場合の emacs の動作について調べる。
    - 改行とタブを挿入する場合は次にある文字を削除する事はしない様だ
    - 改行を上書きする事は無い。タブを上書きする時はタブの終端に達する場合にはタブを削除する。
      終端に達しない場合にはタブをそのまま保持する。
      面倒なので ble では取り敢えずはタブを常に保持する事にする。

    →xterm の場合は元からカーソル位置を反転して表示する様になっている。
      この状態でカーソル位置の属性を反転させると二重に反転して、カーソルが見えなくなってしまう。
      カーソル位置の別の表現方法を考える必要がある。
      或いはカーソルの大きさを制御するシーケンスを出す? カーソルを隠すシーケンスを出しても良い。
      $'\e[?25l' $'\e[?25h' を発射してカーソルを隠す。

    カーソルの反転は layer で行うか、それとも描画部分に対して完全にハードコードするか。
    ハードコードする前回書き込んだカーソル位置の情報を再び回復しなければならない。
    別に layer として実装した時と比べて実装が楽になる訳でも無い様に思われる。
    layer として実装した。無駄に複雑になったように思うが取り敢えずテスト。
    - insert を toggle しても即座に反映されてない
      →これは .ble-line-draw.update の更新判定に登録するのを忘れていただけ。
    - 前の文字の反転が解除されない
      前回の buffer の内容を流用しているのが行けないのかと思ったが、
      どうやら PREV_UMIN PREV_UMAX の方の問題の様である。
      とも思ったがそうでもない。どうも変な動きをすると思ったら、
      そもそも上のレイヤーでの更新に失敗している様だ。/update/getg を弄った事が原因だろうか。
      確認してみると ble-highlight-layer:syntax/update で
      ble-highlight-layer/update/getg を呼び出すべき所で、
      ble-highlight-layer/getg を呼び出していた。つまり layer:syntax 側でのバグであった。

      ble-highlight-layer/update/getg を呼び出す様に変更してみた物の、それでも何か変だ。
      良く考えたら /update/getg でも駄目だ。自分自身を含めないと行けない。
      ble-highlight-layer:syntax/getg を呼び出して空だったら ble-highlight-layer/update/getg を呼び出す様に変更した。
    - bugfix: PREV_UMAX の計算
      insert mode の時に途中を編集するとカーソルの位置が狂う。
      C-u を押した時のカーソルの位置が変。
      C-u 等、overwrite と関係なく見える物でも起こっているので、別の箇所のバグかと思いきや、
      layer:overwrite_mode を外すと上記の現象は起こらなくなる。
      色々試した結果 oindex の shift を間違っている所為で PREV_UMAX が変に大きな値になり、
      その所為で座標位置が 0 0 にあると勘違いされてずれるという事が分かった。

2015-03-05

  * ble-edit.sh (ble-edit/draw/trace): 描画属性も詳しく。

    描画属性の追跡も実装した。
    これに伴って、プロンプトの最後の文字の属性も(限定的ではあるが)取得できる様になった。

    | 2015-02-23
    | * bleopt_suppress_bash_output 制限
    |   - プロンプト最後の文字の SGR が消える。これに対応するにはプロンプト中の SGR を解析しなければならず大変。

    完璧な対応という訳ではないが、これで上の問題は解決された。

2015-03-04

  * 修正: 環境での行末での動作

    編集の行が減った時に削除される行が間違っている気がする。
    長い行を編集してその行が短くなった時の動作に問題がある。
    というか行が減った後のカーソルの表示位置が変だ。
    内部的なカーソルの位置(挿入位置)は正しいようだ。

    どうも丁度ぴったり columns に収まる時の座標計算の問題?
    →カーソルを動かしてみると座標計算自体は問題ないようだ。
    やはり前の行の最後の位置にいるにも拘わらず次の行の先頭にいると勘違いしている様に見える。
    問題は何故前の行の最後の位置に移動してしまうのかという事である。

    % 分かったような気がする。座標計算と部分更新に問題がある。問題点は結構複雑な気がする。
    % 現在、update-positions で計算されるのは「次の文字が表示される位置」という事になっている。
    % これは指定した位置へカーソルを移動させるのに使う。カーソルの移動先は、
    % そこに存在する文字の先頭にあるべきである。
    %
    % 一方で、部分更新をした後にカーソルが存在している位置、というのは xenl cap のある端末では
    % 実は次の文字が表示される位置とは異なっている。
    % 行末の文字を出力した時にカーソルはその行の末端に留まっている。
    % 所が、update-position に格納されているのは、次の文字の開始位置である次の行の先頭である。
    % この時に勘違いが起こる。これを解決するには update-positions に格納されている情報の意味を考え直すか、
    % 或いは、update-position とは独立に文字を出力し終わった後の位置の情報も管理するという事である。
    % 後者は余り考えたくない。殆どの場合で文字出力後の位置と次の文字の開始位置は同じである。
    %
    % どの様な場合にずれが生じるかというと、
    % 1 行末=次の行頭
    % 2 行末近くに wide 文字が存在して入りきらずに次の行へ送られている場合
    %   現在の計算だと次の表へ送られる場合は先頭に行末を埋める padding をつける事になっている。
    %   例えば " あ" 等としている。この時カーソルの位置は "あ" の位置ではなく行末の空白の位置になっている。
    %   これはどちらに表示するべきか改めて考えた方が良いかも知れない。この状態で例えば "a" 等と入力すると
    %   行末に文字が挿入される事になる。カーソルは依然として "あ" の位置ではなくて行末にあるべきなのかもしれない。
    %   しかしながら、例えば↑キーで更に次の行の行頭から移動してきた時に、カーソルが二つ上の行の行末に来るのは変である。
    %   そういう意味から言うとあの先頭にやはり文字を置くべきなのかも知れない。
    %
    % 少なくとも三種類の位置が存在する
    % - 部分更新出力後の位置:
    %   これは部分更新をした後の座標計算に必要である。
    % - 部分更新開始の位置:
    %   これはカーソルの表示位置とは異なる。例えば行末の " あ" の場合には、
    %   カーソルの表示位置は "あ" の直前に来るが、
    %   部分更新の開始位置は " " の直前になければならない。
    %   しかし出力後の位置とも限らない。例えば出力後に行末にカーソルがある場合、
    %   そこから部分更新の出力を開始しようと思っても、そもそも其処にカーソルを移動させる手段がない。
    %   (xenl の厄介な所は文字を出力した時にだけ行末にカーソルが来る可能性があるという所である。)
    %   そこ場合は移動先を次の行頭に変更しなければならない。
    % - カーソルの表示位置:
    %   これは次に来る文字が何かに依存する。
    %   positions の部分更新なども考えるとこれは記録せず、出力後の位置から計算する方が良い。
    %   例えば次に改行が来るのであれば行末だし(でも行末にカーソルを移動させる方法はない■)、
    %   それ以外の文字が来るのであれば次の行頭である。
    %
    % どの箇所で getxy が呼ばれているかについて確認する
    % 意外と呼び出している場所は少ない様である。
    % (改めて考えてみればそんな物だろう、というのは
    % 元々は update-positions は x y endx endy cx cy 等のシェル変数を通して
    % 直接計算した値を返していたからである。つまり、結果は呼出元の関数でしか使っていなかったという事である。)
    %
    % - 先ず、カーソル位置へ移動する時の cx cy と、
    %   bleopt_suppress_bash_output= の時にその左の文字 lc を取得する時。
    % - 後、描画領域を確保する為の begx begy endx endy
    % - それから部分更新の為の umin umax → uminx uminy umaxx umaxy
    % - また、矢印キーによる移動の際の移動先の計算
    %
    % 取り敢えず、_ble_line_text_cache_pos に格納するのは
    % その文字の開始位置ではなくて、前の文字の終了位置という事にする。
    % その文字の開始位置は前の文字の終了位置から計算する事が出来る。

    + bugfix: ascii printable characters の行末で \n を付加した時 ichg に登録していなかった。
      と思って update/postion を変更しようとしたら新しい事実が発覚した…。
      そもそも xenl の場合、行末に来た文字の末尾には \n を付けて、
      文字を出力した際に必ず次の行頭に進むように調整をしていた。
      しかしながら、ASCII 文字が連なっている場合の最適化として
      位置を設定しているループの部分で、「変更文字」ichg のマークをつけていなかった。
      これの所為で実際の出力には \n が反映されておらず期待した位置とは異なる位置に
      文字が出力されるという事態になっていた。

      取り敢えずこれで問題点の一つは解決される事になる。
      そしてまた、上の考察で区別しなければならないとしていた部分更新後のカーソル位置と、
      部分更新開始時のカーソルの位置の違いがなくなった。
      更に、行末にカーソルが来ない事を保証しているので、
      部分更新開始時の位置として行末が来た場合に其処にカーソルを移動できないという問題にも引っかからない。
      (結局、\n を末尾に追加するというのは特に重い処理でもなく、
      また実装も面倒ではなく、そもそも実装されていたというのが考察の上での穴であった。)

    上記の部分を修正してテストしてみた所、表示がずれるという問題は解消された。
    しかし問題(といえるかどうかは分からないが)は未だ残っている。
    行末に入りきらなかった wide character の先頭に移動した時のカーソルの表示位置である。

    + bugfix: _ble_util_string_prototype の長さ指定に 0 を指定していた
      試してみたらかなり微妙な事になっている…。空白が挿入されていない! と思ったら
      x=cols を設定した後に空白を挿入していた。修正した。このバグはこの前全く同じ物を潰したような気がするが…。
      →検索してみたら結構色々な所に似たようなコードがある様だ。(余り良い事とは言えない…)

      また、これに伴って意図的に terminal の幅を縮めた時の折返しの処理も正しくされる様に、
      xenl の時に (本当の端末の端にいる時には敢えて付加しなくても良かった) \n を付加する様に変更した。

      更に、^? や ^A 等の特殊な制御文字の場合についても追い出しを実行する事にする。
      (bash の readline ではこれらの特殊文字の表現に関してはわざわざ追い出しはしないようだが。)

      また、行末付近での tab の取り扱いについても変更を行った。
      特に一番右端にいる場合には " " + 改行を入れる。
      (所で ble-edit/draw/trace の方の tab の取り扱いも同様の問題があるのでは、
      と思って確認してみた所こちらについてはちゃんと実装されていた…。)

    先ず _ble_line_text_cache_pos の形式を変更した。今迄は "x y" だったが、
    更に、入りきらない文字が追い出しされたかどうかを判定する為に "x y wrapping" とした。
    wrapping=0 が通常の文字 (出力開始位置とカーソルの位置が同じ) で、
    wrapping=1 が行頭に押し出された文字 (出力開始位置は前の行の最後、
    カーソルの表示位置は行頭) を表す物とする。
    カーソルの位置を取得する場合には wrapping を見て、((x=0,y++)) 等とする。

    更に、出力位置の制御に用いる getxy とは別に
    カーソルの表示位置を制御する getxy.cur を用意した。
    カーソル移動などの際に参照するのは専ら getxy.cur である。
    また get-index-at 関数も getxy.cur を参照する様に変更した。

    テスト: と、実装してからテストしてみたがずれている…。
    % 改めてみてみると wrapping の格納位置がずれている。
    その文字が wrapping の対象となるかどうかは、その文字を処理してからでないと分からない。
    従って、その文字の終端の境界に wrapping の情報を格納する現在の実装は正しい物である。
    寧ろ、参照する時に「現在の文字の位置」ではなく「次の文字の位置」の wrapping を参照するべきである。
    →この修正で自然な動作をする様になった。

  * ble-edit.sh: プロンプト内の job count 等の情報が更新されない。
    →新実装で取得したデータのキャッシュを local に設定するのを忘れていた。

  * ble-decode.sh (stty): -icanon の設定。

    何故か bless を起動してその儘抜けると入力しても反応しなくなる
    →無限ループに陥っているのかと思ったらそうではない様だ。
    →どうも入力が buffering されている様で C-d を押した時に初めて入力が読み取られ、
      それまでに入力した内容が一気に書き込まれていく。
    →stty で bless 前後を比較してみると stty -icanon が stty icanon に変わっている。
      stty -icanon を設定し直したら正常に表示される様になった。
      stty.enter で -icanon も設定する事にする。

2015-03-03

  * ble-edit.sh: prompt 再実装

    | 2013-06-06
    | * <bug> PS1 に $() などが含まれているとプロンプト位置を正確に計算する事が出来ない。
    |   _ps1txt の方を eval してから再度位置の計算をする?
    |   →それだと _ps1txt, _ps1esc の両方について $() の展開をしなければならない。
    |     つまり、$() が2回実行される。これは意図しない動作になるかもしれない。
    |
    |   例えば \[ ... \] を [ - ] などに変換して出力し、
    |   その後で [ ... ] を除いた物を用いて位置の計算をする?

    この問題が未だ解決されていなかったので。
    bash の PS1 に対する振る舞いも確認して再実装した。
    bash 内部では先に \? の部分だけ展開して、
    その後で "" に全体を入れて eval している様な振る舞いをする様だった。
    それに従って再実装を行った。幅の計算は eval の後に行う事にした。
    \? の解決と幅の計算を独立させた事により、実装は却ってすっきりとした物になった。

    | 2015-02-23
    |
    | * <最適化> プロンプト構築
    |
    |   改行を押し続けた時の反応が遅い
    |   プロンプトの更新を停止すると動きが速くなる。
    |   これはプロンプトの生成に時間が掛かっているという事。
    |   見てみるに高速化できる余地はそんなに無い様な気がする。
    |   jobcount を実行するのに subshell 実行が必要なのは気にはなるが。

    新実装に移行した後に再度確認してみたが、それ程気にならないのでこの問題は破棄する。
    新実装になった事で速くなったのかも知れないし、
    あるいは変わっていないが気分の問題で気にならなくなっただけかも知れないが。


  * ble-edit.sh, ble-edit.color: discard-line の際に着色

    | 2013-06-02
    | * ble-edit+discard-line: 灰色にする

  * ble-edit.sh: bugfix, 複数行で上に行けない
    →_ble_line_begx _ble_line_begy に編集内容の開始点を格納する様に変更。

  * ble-edit.sh: bugfix, 複数行なのに空行の accept-line でのずれ量が1行になっている
    →行を更新した後に _ble_line_x=0 _ble_line_y=0 を設定する必要。

2015-02-28

  * <bug> 履歴項目を移動中色が更新されない例を発見

    "[[ ; == \; ]]" から "arr=(a b<a c)" に移動した時、初めの 2 文字の色がそのままだ。
    これは良く考えたら word による着色を消していない事と関係がある。
    特に上の二つの文字列は長さが一致しているので、shift を呼び出しても
    shift の実行が省略される為に中身がクリアされない。
    これは word 着色のバグ解決の時に解決されるはず。

    長さが一致していても shift を実行する事にする。
    shift によって途中の編集部分がクリアされる方が動作として自然だからである。
    或いは、途中の編集部分に何が入っているか未定義、という事にしていると、
    一々使う側でクリアしなければならないからである。
    編集部分で前の属性などを保持するのは不自然であるし、
    使う側でクリアするよりは shift の内部で行っている様な繋ぎ替えの方がコストが小さい。

    →結局 shift 長さが変わらない場合でも shift を実行するように変更した。

  * 初期化最適化: ble-bind が遅い

    どうも ble-bind の遅さが、後続の bashrc をも遅くしている様である。
    手軽に ble-bind を呼び出す事ができないのは致命的なので performance の悪さについて調べる。
    どうも調べてみると ble-getopt が遅い様に思われる。
    手で解析を書いて試してみる…(面倒だ。似たようなコードを何度も書かなければならない。
    確かに ble-getopt の様な仕組みを作りたくなる物である。)

    ble-bind を ble-getopt なしで書き直してみる。
    今回は ~/.mwg/bashrc にある 7 つの binding について試してみる。
    1 ble-bind (old, using ble-getopt) 122ms - 100ms = 22ms
    2 ble-bind (new) 87ms - 78ms = 9ms
    新実装の方が半分以下の時間で実行できる様になった。
    これで現在 87ms で bashrc がロードされる様になった。

    所で ble-bind が全体でどれぐらいの割合を占めているかについても概算しておく。
    ble-bind が 9/22 の速さで実行できる事によって全体で 122 - 87 = 35ms 短縮している。
    (ble-bind old 時間) * 13/22 = 35ms なのだから、(ble-bind old 時間) = 59ms という事になる。
    実に半分を ble-bind が占めていた事になる。残りの 63ms が他の処理である。
    現在は全体で 87ms に迄減った。63ms (他) + 24ms (ble-bind) という形である。

    また、新しい実装についてより分かり易く実装できないかと、各オプションを関数に分けてみた。
    結果、94ms - 83ms = 11ms であった。それ程遅くはなっていない。
    他のコマンドのオプションを作る時にはこれを参考にしても良いだろう。

    さてこれで ble-bind の速度は割合改善したがそれでも定数倍である。
    本当はもっと速くなって欲しい。改めて現在時間の掛かっている部分の特定をする。
    引数の解析部分を飛ばして直接呼び出して速度を確認すると、
    83ms - 76ms = 7ms であった。という事は引数の解析は 2ms しか費やしていない。
    今度は実際の登録部分について最適化を試みるべきであろう。

    特に気になっているのは ble-decode-kbd の部分である。
    試しに ble-decode-kbd を再実装してみたがそんなに時間は変わらない。
    全体で 83ms である。元々 85ms であったから 2ms しか変わっていない。
    特にテストに使っている部分 (7ms) に限って言えば大体 2/3ms 程度しか速くなっていないという事。
    別の部分で時間が掛かっているという事だろうか。
    試しに ble-decode-kbd 単体の速度を測ってみる事にする。
    | time for ((i=0;i<1000;i++)); do ble-decode-kbd C-,; done → 292ms
    | time for ((i=0;i<1000;i++)); do ble-decode-kbd M-down; done → 295ms
    | 7 * 0.294ms = 2ms なので、全体の内 2/7 がこの ble-decode-kbd であると分かる。
    バグがあった。修正したらかなり変わった。
    | time for ((i=0;i<1000;i++)); do ble-decode-kbd C-,; done → 230ms
    | time for ((i=0;i<1000;i++)); do ble-decode-kbd M-down; done → 375ms
    正規表現によるマッチは結構重い??
    →正規表現ではなく ${key//[...]/} を用いて試したら 375 → 257ms 迄速くなった。
      所で、長さが 1 である事を確かめるならば、
      算術式で長さを求めてから比較するよりは glob の pattern で一致させた方が速い様だ。
    所で、旧実装を削除する前に改めて速度を測っておく。
    →C-, に対しては 346ms,  M-down に対しては 670ms である。
      全体の内 3.070ms / 7ms である。またこの事からこれ以外の部分に 4ms かかるという事が分かる。
    | time for ((i=0;i<1000;i++)); do ble-decode-kbd C-,; done → 231ms
    | time for ((i=0;i<1000;i++)); do ble-decode-kbd M-down; done → 257ms
    | → bashrc の 7 bindings に対し大体 1.667ms / (4+1.6)ms。大体 5/17 を占める。

    その他の部分で怪しいのは .ble-decode-key.bind である。
    押されるキーの数×2 の eval を実行している。
    しかしこれはどうしようもないので取り敢えず諦める。

  * ble-edit.sh: bugfix, .ble-line-info.clear で位置がずれる

    描画後の座標値の設定時に存在しない変数 x y を参照していた。これらは 0 であるべき。

  * 初期化の最適化

    現在の初期化のボトルネックは圧倒的に history である (2015-02-09)
    →.ble-edit.history-load を多少最適化した。読み取り時間が約半分になった。
      それでも未だ全体の半分が history 読み取りである
      (しかし history を 16k も溜めている場合は少ないから、実際は無視できるかも)。

    | 改めて初期化の時間を調べる:
    | 多少なりとも時間が掛かっているのは以下の phase
    | - ble-core.sh                     58ms
    | - ble-edit.sh                    629ms (554ms が history, 75ms が他)
    | - ble-decode-bind.cmap            52ms
    | - ble-decode-bind                105ms
    | - .ble-edit.default-key-bindings 229ms
    | - .ble-edit-draw.redraw           35ms
    |
    | default-key-bindings を見るに ble-bind に平均 229/75 ms かかっている様だ。
    | これを考えると ble-edit.sh の中の 33ms も ble-bind の遅さに起因する。

    改めて初期化の時間を計る (2015-02-28)
    前回から、初期化と attach の分離、history 遅延ロードの実装など、
    初期化の順序・構成が変化した。

    1 ファイルの読込                 |  39ms
    2 ble-initialize
      ble-decode-initialize          |  53ms
      .ble-edit.default-key-bindings | 309ms -> 4ms
      ble-edit-initialize            |   4ms
    3 ble-attach
      ble-decode-attach              | 201ms -> 55ms
      ble-edit-attach                |   0ms
      .ble-edit-draw.redraw          |  36ms

    ble-decode-initialize は ble-decode-bind.cmap の現在の名前と思って良い。
    これのロード時間は大して変わっていない。
    この部分は基本的にファイルにキャッシュした配列を読み取っているだけである。
    しかしその容量が大きい為にこれだけの時間が掛かっている。
    CSI Funtion Key が大半を占めているので、これらを特別扱いする様にすれば多少は解消するかも。

    .ble-edit.default-key-bindings は前回よりも大幅に増えている。
    これは多少の bindings の追加を行った事もあるが、
    keymap isearch などの初期化を .default-key-bindings に統合した事もある。
    →これもファイルに dump を出力する様にした。これは 4ms と嘘のように軽くなった。
      ble-bind 自体に問題があるのかもしれない…。

    ble-decode-attach は前回に比べて大幅に増えている。
    これは bash-4.3 で ESC [ ... に bind する為に、
    全ての可能性に対して bind を実行している為であろう。
    (しかしそれでも元々 100ms 程度かかっていたのでここを直しても劇的に速くなるという事はない)。
    更に詳しく調べる。既存の bind の保存と削除は 31ms で済んでいる。
    全組合せに対する bind は 77ms 掛かっている。メインの bind に 91ms かかっている。
    実はこの部分をこそ最適化するべきなのかも知れない。
    →既存の bind の保存と削除の部分は awk の呼出が2回に渡っているのを1回にくっつけた。
      この部分は時間を計測してみたが 31ms の儘で変化しなかった。
    →結局全組合せに対する bind はしないで代わりに ESC [ を utf-8 で翻訳する方向にした。
    →また、メインの bind はコマンドを生成するのに時間が掛かっている様に思われたので、
      先にコマンドを生成してファイルにキャッシュする様に変更した。
      その為に新しく bind のコマンドを生成する為のファイル ble/bind.sh を作成した。
    結果として元々の 201ms から 55ms に迄ロード時間を減らす事ができた。

    これで一通り重い場所は解決したように思うので解決とする。

  * ble-decode.sh (.ble-decode-bind/generate-source-to-unbind-default): awk 呼出を一回に統合。

    | * 既に bind -x してある物を削除するという事?
    |   bash-4.3 では bind -X が実装されたので bind -x した物を列挙できる。
    |   (但し、bind -r しても bind -X のリストには残ってしまう様だ @bash-4.3.33
    |   リストには残っているが実際には削除されている。)

    同時に上記の項目 (2015-02-09) も実装した。

  * ble-core.sh, ble-color.sh: .ble-shopt-extglob-push/pop/pop-all 廃止

    ble-color.sh で、extglob を使った部分のコードの管理が
    好い加減面倒なので正規表現による実装に切り替えた。
    (そもそもこの部分は現在は使われていない部分ではあるが。)

    さて、.ble-shopt-extglob-push/pop/pop-all 関数は
    この部分でしか使われていなかったので削除してしまう事にする。
    別にそう大した実装でもないので。

  * history 遅延ロードについて

    これから本格的に常用する為にはできるだけ速くロードできる様にしたい。
    特にボトルネックになっているのは history である。
    history の遅延ロードの可能性について考える。

    現在の実装では history がロードされている事を前提にして書かれているので、
    できるだけ history の項目に触る前に history がロードされる事を
    保証する様に書き換えなければならない。
    特に history の interface を絞る事によって移行しやすくする事を考える。

    現在の所どの様な場所で history が参照されているかを確認する。
    先ず現在の history 項目の数を幾つかの場所で参照している。
    実はこれは HISTCMD 変数を用いて参照する事ができるのではないか?

    HISTCMD は代入してもその効果がなくずっと history に登録されている項目の数を指している様に見える。
    と思って実際に ble.sh を起動して確認してみると常に 1 という値になっている。これは困った。
    しかし何故明示的に unset している訳でもないのに HISTCMD=1 なのだろうか。
    これは rcfile で読み取っている事にも関係しているのだろうか。。
    →判明した bind -x の内部で HISTCMD を参照すると 0 になっていると言う事の様だ。

    という事は HISTCMD を参照する事によって history 項目の数を取得するというのはできないという事だ。
    別の方法を考える…。どうやら count=($(history 1)) で取得した値が、
    実際に history からロードした時のエントリの個数と一致する様である。
    という事は count=($(history 1)) を必要になった時に一回呼び出して、
    後はそれを maintain (increment するなど) すれば問題ないという事になる。

    更に history-add の時にもロードを遅延させる事は出来ないかと考える。
    その為に history -s の動作について確認しておく。
    - history -s を使っても HISTCONTROL は考慮に入れられる様だ
      従って、ble.sh の側で HISTCONTROL の処理をしなくても済む。
      逆に現在の history 項目の数は分からなくなる。
      history が追加されたのかされていないのか分からないから。
      返却値も確かめてみたが、重複によって登録されなかった場合でも 0 (正常終了) する様である。

    対応できそうなので遅延ロードに対応する事にした。実際の修正は意外と小規模で済んだ。
    未だ、何処かに取りこぼしがあるかも知れないがそれは問題になってから対処する事にする。

2015-02-27

  * <bug> bash-3.0, bash-3.1

    何故かパス名展開がされない: echo * としても * がそのまま表示される。
    echo $- としても f はついていない。
    何故か分からないが unset GLOBIGNORE したら直った。
    (GLOBIGNORE には何も設定されていない様に見えるのに)

    →ble-decode-kbd の local GLOBIGNORE を削除したら直った。

  * bash-3.0 対応

    bash-3.0 では += 演算子が使えない。また、${#param} が文字数ではない。

    これらの事から対応を諦めていたが、
    += 演算子については調べてみたらそんなに使っていない様だ。

    grc '\+=[("'\'']' --exclude=test --exclude=out --exclude=ble.sh

    term.sh (varnames),
    ble-syntax.sh (completion-context context, _ble_highlight_layer_syntax3_list),
    ble-core.sh (ble-stackdump message),
    ble-decode.sh (.ble-decode/keymap/push, ble-decode-kbd keymods)
    ble-edit.sh (_ble_edit_accept_line, _ble_line_text_cache_ichg, _ble_edit_isearch_arr)

    面倒になったので ble/util/array-push という関数を作って、
    速度に関係なさそうな所ではそれに置き換えた。
    (注意しなければいけないのは、array-push を使う時は、
    配列要素が 0 から順に割り振られている必要があるという事。
    専ら push のみを用いて要素を追加する場合には問題はない。)

    さて bash-4.3 で問題なく動いているか確かめてみると、TAB を打った時に表示がずれる。
    →これはまた別のバグであった。別項目として独立して解決。

    今度は bash-3.0 で起動してみる。すると、沢山のエラーが発生している。
    何より unknown ble edit function と表示されてそもそも関数が登録されていない様だ。
    ble/util/isfunction が悪いのかと思って調べたがちゃんと動いている。
    改めてエラーメッセージと ble-bind を照らし合わせると…そもそも ble-getopt が駄目なのかも。

    →何と…。
      local a=($command)
      上の実行結果が a="($command)" というのと同じになっていた。以下の様に -a を指定する必要がある:
      local -a a=($command)

    さてこの様な使い方をしている所は正直沢山ある。以下で列挙できる。
      grc '(local|declare) [a-zA-Z_][a-zA-Z_0-9]*=\(' --exclude=out --exclude=test --exclude=ble.sh
    特に ble-decode.sh の中にあるのは致命的なので、取り敢えずそれだけは直しておく。
    また ble-core.sh や ble-getopt.sh に関しても起動に致命的な影響を与えるので修正する。

    さてそれでも ble-decode が動いていない様に見える。
    noattach の状態でもエラーが出ているのでそれを手がかりに原因を探る。
    どうも .ble-edit.default-key-bindings の中でエラーになっている。
    しかも其処で死んでいて、続きの初期化が実行されていない??
    この中でやっているのは ble-bind の呼出だけである。
    という事は ble-bind に未だ問題点があるという事だろう。
    何と初回の ble-bind で既に死んでいる。。
    →ble-decode-kbd の中の同様の配列の初期化が悪かった様だ。先程 grep した正規表現では不十分だった。
      grc '(local|declare|readonly|typeset)[^-]* [a-zA-Z_][a-zA-Z_0-9]*=\(' --exclude=out --exclude=test --exclude=ble.sh

    この修正で取り敢えず起動はする様になった。
    しかし、少し弄るだけで簡単に無限ループになる。やはり上記の配列の初期化を全部修正しないと駄目なのだろうか。
    →仕様がないので配列の初期化を全部修正してみたら意外とすんなりと起動した。
      普通に色も着いているし問題は起こっていない様に見える。
      但し、.ble-line-info.draw の表示が少し狂っている様に見える。

      後ファイル名の補完候補を列挙できていない。

    何と…初期化内容に括弧があると local/declare -a に失敗する。
      a="1(2"
      declare -a b=("$a") → エラー
      b=("$a") → これはOK
    local/declare は文法的に特別な処置を受けて折らず唯単に文字列の引数を受け取っているという事だろうか。
    再び大幅な書き換えが必要になりそう…。→結局全部書き換えた。

    改めて bash-4.3 で起動してみると補完候補の表示が狂っている。
    今迄の書き換えで何処かミスしたという事だろう。。
    .ble-line-info.draw を潰すと何も問題はない様なので、
    .ble-line-info.draw の中か関連した所が怪しい。
    そもそも .ble-line-info.draw が表示されている箇所がおかしい。
    .ble-line-info.draw が表示されている箇所に対する相対位置としては最終的なカーソルの位置は正しい。
    という事は何処かで座標計算がずれているという事。

    多分分かった…bash-3.0 の declare で吐き出した term.sh のキャッシュが間違っている。
    →当たりだった…。bash-3.0 は _ble_term_ind (内容は $'\n') について、
    | _ble_term_ind="\
    | "
    という風に出力していて、成る程そういう扱い方もあるのか、等と思っていたが、
    上記のコードは "" となる(改行は消える)。試しにやってみると…やはりそうだ。
    | $ echo "a\
    | $ b"
    | ab
    つまり bash-3.0 の declare -p は信用できないという事である。修正した。

  * <bug> TAB 等の変更文字があった場合に文字列が表示されなくなる

    bash-3.0 対応の時に _ble_line_text_cache_ichg 関係を書き換えテストした時に発見したバグ。
    色々試してみるとこれは今回の変更とは関係ない様に見える。今迄のコードに直しても再現する。
    また、_ble_line_text_cache_ichg の登録を止めるとまた異なるずれ方になるので、
    これは _ble_line_text_cache_ichg の登録に失敗しているのではなく、
    _ble_line_text_cache_ichg を使用している側で失敗しているのではないかと思う。
    →確認してみたが、置き換えに失敗しているという事は無い様だ。
      という事は、座標計算を間違っている可能性の方が高い。
      改めて ichg を設定している側に戻って座標について確認してみる。
      良く分からないので、やはり適用している側に行きそこで _ble_line_text_cache_pos を出力する。
      この部分についても何も問題はない様に見える。
    →もしかして出力している物が間違っている?
      と思ったら空文字列を出力していた…。
      元々 .ble-line-text/update で HIGHLIGHT_BUFF に指定された物を使って出力していて、
      .ble-line-text/update の後で slice によって出力内容を取得する様に変更したのが原因だった。
      変更文字があった場合には HIGHLIGHT_BUFF の示す先をローカル変数 buff に置き換えて
      その場で出力させていた。当然ローカル変数は他の関数 /slice を呼び出した時には
      残っていないので空文字列 (或いは、呼出元で buff が定義されていればその内容) が出力される事になる。
      変更文字があった場合にローカル変数に書き込むのは止めて、グローバルに変数を用意して其処に書き込む事にした。

  * <bug> bash-3.1 日本語の色付け・描画が変だ

    何と日本語が含まれている時の BASH_REMATCH が変だ…。
    一致を試みる際には文字数でカウントして、しかし結果は
    バイトオフセットで切り出しているという具合に見える。

    と思って色々試したらどうも自分で指定している SGR 指定ですら変な事になっている。
    もしかして BASH_REMATCH 等の問題ではなく、単に自分の新しいコードの問題か?
    と思ったが 4.0 4.3 では問題は起きていない。3.2 でも問題は起きていない。
    これはやはり 3.1 固有の問題である様だ。

    よく考えたら SGR 指定で変な事になっているのは、SGR の出力に問題があるというよりは
    その前後に変な文字 (UTF-8 の不完全なシーケンス) がある所為で、
    SGR の先頭の ESC 等が食われてしまっている事による物と推察される。
    さて、描画に用いている文字は基本的に _ble_line_text_cache_cs から来ている。
    そして、_ble_line_text_cache_cs に格納されている文字は
    ${text:i:1} によって取り出した物である。問題があるとすればこの辺りだろうか。

    試しに a='ああ' として見て色々試したが問題がある様には見えない。${a:ofs:len} は勿論の事、
    ${#a} も正しい値を返している。取り敢えずは保留という事にする。
    念のため、最後に新しく実装した.ble-line-text.construct が悪さをしている訳ではない
    事を確かめる為に古い関数に戻して試してみる。やはり古い関数でも同様に変な風になっている。
    従って、新しい実装が悪さをしているという訳ではない。

    →何と ${#BASH_REMATCH[n]} がバイト数になる様だ…。
      以下を実行すると、通常時は正しく日本語の文字数で数えているが、
      BASH_REMATCH の中ではバイト数になっている。

      local text='あいう'
      [[ $text =~ ^.+$ ]]
      echo "#${text} = ${#text}, #${BASH_REMATCH[0]} = ${#BASH_REMATCH[0]}"

      | ${BASH_REMATCH[0]:ofs:len} 等は問題なく動いている様なので謎だ。
      | 別の変数に再代入しても問題は続く。
      | 一旦 ${BASH_REMATCH[0]:0} 等として別の変数に移せば問題ない様だ。
      と思ったら関係ない様だ。

      % if ((_ble_bash>=30200)); then
      %   function ble/util/modify-bash31-rematch {
      %     :
      %   }
      % else
      %   # In bash-3.1, BASH_REMATCH returns corrupted string
      %   # when multibyte characters are matched.
      %   function ble/util/modify-bash31-rematch {
      %     local i iN="${#BASH_REMATCH[*]}"
      %     for((i=0;i<iN;i++)); do
      %       BASH_REMATCH[i]="${BASH_REMATCH[i]:0}"
      %     done
      %   }
      % fi

    →色々試して、漸く問題点が分かった。これは BASH_REMATCH だけの問題ではなく、
      ${#配列[n]} 全般で起こる問題である。この形式で要素の長さを取得すると
      文字数ではなくバイト数が取得される。
      ${#配列} の様にして第一要素の長さを取得する場合は問題にはならない。
      (結構重大な問題だと思うが bash の ChangeLog には fixed された等とは書いていない様だ。
      一応 3.0 → 3.1 で ${#param} の場合にバイト数ではなく文字数を返すように修正された様ではある。)

      取り敢えず以下で問題のありそうな部分を列挙する
      grc '#[a-zA-Z_][a-zA-Z_0-9]*\[[^@*]' --exclude=test --exclude=out --exclude=ble.sh

      一番多いのは ${#BASH_REMATCH[0]} なのでこれは単に ${#BASH_REMATCH} と書き換えれば良い。
      次に多いのは、その場所に一致したかしていないかの判定 ((${#BASH_REMATCH[n]})) である。
      これは [[ ${BASH_REMATCH[n]} ]] 等に書き換えてしまえば問題ない。
      こういった物を除いていったら本当に ${#BASH_REMATCH[n]} を使っている場所は 11 箇所のみであった。
      これならば何とか対応できる。対応した。

      これで着色の問題に関しては解決した。しかし、今度はカーソルの移動の度に C だとか D だとかの、
      カーソルの移動方向に対応した文字が出力される。term.sh のキャッシュの読み取りに失敗しているという事だろうか。
      →分かったような気がする %d の置換に失敗しているのではないか?
      →やはりそうだった
        $ aa=123%d4
        $ echo "${aa//%d/@}"
        $ echo "${aa//'%d'/@}"
        123%d4
        123@4

        下のように %d を '' で括っておけば問題ない様なのでこれで行く事にする。
        しかしそうすると、visible-message も壊れているのでは…。
        以下で問題の有りそうな所を列挙して修正する。修正した。

        grc '//%' --exclude=test --exclude=out --exclude=ble.sh

  * 文脈に応じた complete

    syntax の update はいつ行うか

    | これに対応する為には描画時以外にも syntax の update を実行できる様にしなければならない。
    | その為には
    | 1. ble-syntax/parse を独立に実行できる様にする
    | 2. update-positions や描画なども含めて文脈補完時に実行する
    | 3. 実は ble-syntax/parse は up to date になっている筈?
    |
    | もし 2. の描画が無駄にならないのであれば実装でしても良いが、
    | 補完時には確定部分を挿入するので再度後で解析し直しが必要になる。
    | 3. は補完関数を直接 bind している時には正しいが、
    | 実際には内容を変更してから補完を呼び出すという使い方をシェル関数でするかもしれない。
    |
    | 更新の必要がなければ更新しないだけなので、余分に更新を試みるのは悪い事ではない。

    やはり当初の考え通り 1 の方向性で行く事にする。

    次に補完を行う文脈をどの様に判断するかについて

    文脈に応じた補完と言っても、どの様に文脈を判断するのかが問題になる。
    できるだけ補完点の後の情報に依存しないようにするのが望ましい。
    例えば arr=hoge となっている時に ar の点で補完を開始しようとしたとする。
    もし現在居る単語の種類を元にして補完を行おうとすると、
    現在の単語は変数の代入であるから変数の代入に出てきそうな単語しか補完候補に現れない。
    もし ar で始まるコマンド名に補完したいと考えている場合にはこれは不便である。

    実際に挿入をしながら補完を行う場合については、
    普通カーソルより後の部分は現在入力している物と関係ないと考えるのが自然である。
    というのも挿入を続ける事によって、挿入点以降の文字列の文法的意味は次々に変わっていくからである
    現在の入力状態で挿入点の次にある文字列が補完対象と同じ単語の中に含まれている様に見えても、
    挿入が其処で終わるとは限らないのでどんどんと挿入を続けていけば軈て別の単語になるなど。
    何れにしても、挿入点より後の情報を用いて補完するのは直観的でないという事である。
    なのでルールとして以下を設ける
    @ 挿入点より後の文字列は補完内容の決定に使用してはならない。

    次に現在の attr を使用して補完方法を決める事について。
    結論から言うとこれは使えないのではないかと思う。
    先ず、エラーがある場合には attr にはエラーが設定される。
    エラーが発生した時には別の配列にエラー情報を記録するように設計を変更したとしても、
    attr は未だ0文字も入力していない場合 (例えば ${ の直後) などでは文脈の判断に使えない。
    ${ の直後には変数名が来る事は明らかであるので、例え何も入力していなくても補完候補が出せた方が良い。
    @ attr は補完の文脈の決定を行うのには使わない。

    とすれば残るのはやはり直近の stat の状態である。
    stat は解析の再開に用いられる物であるから、
    次にどの様な文法的要素が来るのかを規定するのに充分な情報を持つ。
    但し、問題点は stat は解析結果ではなく解析を行う為の情報に過ぎない事である。
    この事から、stat を用いて補完を実行する為には、
    解析に極めて近い所まで処理する必要が出て来るという事である。

    complete 側でこれを処理するのは面倒だし、
    また、ble-syntax/parse で用いている stat の形式に大きく依存するので、
    これは ble-syntax 側で実装する方が適当である。
    つまり ble-syntax 側で指定した位置が文法的にどの様な物を期待する物なのかを決める。
    実際の補完候補の決定などは ble-edit 側で行えばよい。


    実装1 取り敢えず実装してみる

      取り敢えず簡単の実装の為に、プログラム補完は考えない事にする。
      補完をする為に必要な情報は何か。。
      補完の際に行う事が何かを考えそれを元に必要最低限の情報について考える。

      - 補完候補を表示する → 表示される文字列
        この為には補完候補の一覧が取得できれば良い。
        但し注意しなければならないのは、
        表示される補完候補と実際に補完される単語が一致しているとは限らないという事である。
        例えば、 a/b/c/ ディレクトリの下にあるファイルを保管しようとしている時、
        全ての補完候補に a/b/c/... とディレクトリ名が付いているのは煩い。
        普通は a/b/c/ 以下のファイル名の部分しか表示しない物である。

      - 一意確定部分を求める → 追加挿入される文字列
        共通一致部分。これの為にはこれから挿入しようとしている内容が必要。

        文脈によっては何らかの方法で共通一致以外の確定方法があるかもしれない。
        この時にはこれから挿入しようとしている物の内容は不明である…。
        というか様々な種類の確定方法が混在していた時に、それらをまとめて
        一つの答えを出すという操作は慎重に考える必要がある。
        どんな候補の場合にも確定できる方法と言えば
        やはりこれから挿入しようとする文字列を各候補に生成させる事である。

        特に意識したいのは曖昧一致による確定である。この場合には決定した時に
        既に入力した部分も含めて置き換えが行われる。
        これに対応するには、挿入される文字列などではなくて、
        既に出力されている部分も含めての置き換えを提出させるのでも良いかも知れない。
        その様にすればより自由度は向上する。しかし、問題は、
        異なる補完開始点を持つ候補が混在している場合である。
        その様な場合に共通一致部分を計算したり曖昧一致を計算したりするのは可能か?

        所で、曖昧一致と先頭一致では区別して、先頭一致の方を優先させる等の処理をしたい。
        例えば、先頭一致だけを見ると確定しているが、曖昧一致の候補まで含めると色々ある、
        という場合には先頭一致で確定させてしまって良い。
        (一方で、先頭一致の共通一致部分に関しては確定しない方が良い?
        或いは曖昧一致探索と先頭一致探索はそもそも混ざり合わない様に異なるキーに
        割り当てるべきなのかも知れない。)
        それぞれの候補についてそれが曖昧一致なのか先頭一致なのかで形式を変えても良いかも。
        しかしそれぞれの候補をどう取り扱うかは受け取った側で設定できるようにしたくもある。
        それに候補生成の方法を複雑にすると言うのもなんである。
        そう考えるとやはり候補の生成の際には両者を区別しない形で列挙して、
        それを使う側で先頭一致とそれ以外に分けるという方法の方が良いようにも思う。

      - 挿入する → 挿入関数名
        ただ挿入するだけではなく、様々な追加操作を行う可能性がある。
        例えば、一意確定の際にスペースまたは / を挿入するという事。
        或いはお節介な機能として確定した単語について
        様々な装飾・エスケープなどを施したいという需要があるかもしれない。
        これは色々と自由度が高い様な気がするので関数で実装する事にする。
        各候補についてどの関数を用いて挿入を行うかを取得できる様にする。

      他に問題になるのは、上記に示した情報をどの段階で生成するのかという事である。
      必要最低限と言えば、補完候補の文字列とその取り扱いを定義する関数さえ持っていれば、
      後は関数を呼び出す事によって、補完候補の表示文字列も生成できるし、
      追加挿入される部分について生成する事もできるし、候補表示の時の着色やら、
      メニュー表示にした時の説明文まで何でもできる。
      ただ、候補生成の時にしか分からない情報もあるかもしれないから、
      後でそれらの関数が利用できる様に各項目に data 等というフィールドが使える様にする。
      (これらはそれらの補完関数に形式・使用方法を任せる。)

      取り敢えずその形式で行く事にする。
      候補生成関数が用意するのは、
      1 補完候補
      2 補完関数群 (これは名前の形式を定めておき prefix 等を呈示する)
      3 2 で使用する内部データ (あれば)
      という事にする。
      補完の表示文字列については高確率で必要になるので、これも生成時に用意させる。
      4 表示文字列
      また、候補毎に挿入位置や元にしている文字列が異なるかもしれないので、
      これについても用意した方が良い様に思う。
      5 補完開始点・補完終了点・対象の単語
      補完対象の単語、というのはクォート除去・パラメータ展開などを行った後の値である。

      補完候補、表示文字列、対象の単語に関しては内部に任意の文字列を含みうるので、
      独立した変数に入れる様にした方が管理しやすい。
      一応、固定形式の末端に入れれば何とか抽出できない事もないが面倒なので止める。
      補完関数群の prefix 補完開始点・補完終了点などの情報は空白を含まないので、
      これらは一つに纏める事ができる。
      補完関数群で使用できる内部データは補完関数群の内部で簡単に使える様にする為に、
      やはり一つの独立したデータであるべきである。
      従って候補のデータは以下の様な物に改める:

      cand_word 単語
      cand_show 表示文字列
      cand_head 対象の単語
      cand_prop 関数群接頭辞 開始点 終了点
      cand_data 自由データ

      特に簡単な候補生成の為に cand_word さえ渡せば他を fill できる様にするべきである。

    実装2:

      実装1の方針で実装してみたが問題がある。
      上記の方針では異なる補完開始点や関数群に従った候補を混在させる事ができる様になっている。
      しかし、候補を一意に絞れない時の動作はどの関数群に従ったらよいか判断できない。

      但し、以下に挙げる様な特定の候補に関する操作に関しては、候補語との関数の指定で問題ない
      - 一意確定時の動作 (挿入した時に後に " " や "/" を追加するなど)
      - 各候補に対する説明の取得や色つきの表示文字列の取得など

      問題になるのは以下の動作である。
      - 共通部分確定時の挿入

        単純に挿入するだけであれば共通の動作であるので別に関数群に頼る事は無い。
        しかし、文脈によっては挿入によって文法構造が壊れてしまう事もある。
        その様な場合には色々な修飾が必要になってくる。

        例えば myfile-$ind の末端の様に変数名補完と
        ファイル名補完が混在している時を考える。
        変数名補完としては myfile-$index になる事を考え、
        ファイル名補完としては myfile-${ind}ex になる事を考えている場合、
        両者の補完は共に ex となるので共通一致で ex を挿入しようと言う事になるが、
        実際に挿入する場合にはどちらか一方のやり方で挿入する訳には行かない。
        結局の所、共通一致しそうに見えて一致しないというのが答えである。

        この判断をどの様にすれば良いのかについて慎重に考えなければならない。
        というかそもそも両者は異なる補完結果を与えるのだから、
        異なる候補として区別すればよいだけの事かも知れない。

        つまり、挿入の仕方は挿入関数を定義する事によって実現するのではなくて、
        そもそも候補列挙の時点で挿入文字列・挿入方法を完全に確定してしまって、
        その後で共通部分一致などを試す必要があるのではないかという事。
        逆に挿入時には共通の処理しか挟まない様にする。

      今後他にも共通操作に関して問題になる事があるかもしれないが、
      取り敢えず今回の共通部分確定時の挿入に関しては、
      事前に何が挿入されるか迄候補として生成して、
      共通部分探索時にそれを考慮に入れて絞る。

      今度の実装では候補生成を以下の様に行う:
      1 補完範囲の開始点と終了点を得る。
        更にその間にある部分の評価結果を文字列として取得する。
        (これは補完の種類によっては不要であるかもしれない)
        COMP1 = 補完範囲の開始点
        COMP2 = 補完範囲の終了点
        COMPS = 補完範囲の文字列
        COMPV = 補完範囲評価結果

        この次に具体的な候補を複数列挙する事になるが、
        ここまでの処理はそれらの候補の間で共通である。

      2 候補を生成する

        CAND = 候補の文字列
        ACTION = 関数群接頭辞
        DATA = 何か追加情報があれば。ACTION への引数的な物。

        此処までは候補に依存して完全に異なる物である
        エスケープなどの共通の修飾などについては後段に任せる。

      3 各候補に対する処理

        これ以降は既に指定した ACTION による関数で処理を行う。
        候補の違いは全て ACTION の違いで処理する。

        $ACTION/init で処理を行う

        SHOW = 表示文字列
        INSERT = 挿入文字列 ← CAND から生成する
        DATA に対する加工も。

      4 候補の情報の格納

        cand_word+=("INSERT")
        cand_show+=("SHOW")
        cand_prop+=("ACTION COMP1 COMP2")
        cand_data+=("DATA")

        その他の情報については後で使う事は無いと思う。
        何か特別に必要な物があれば DATA に入れる。
        一般的に使う機会が多そうな物があれば配列を増やす。

    新しく共通部分の探索も加えて取り敢えず実装を行った。
    今の所は仕組みとしては問題なく動いている。
    後はこの仕組みに従って少しずつ拡張していけば良い。


    | * <bug> complete
    |   引用符に囲まれた場合などに挿入位置がずれる。

    この問題は新しく実装し直した事によって解消した。

2015-02-25

  * <bug> accept-single-line-or-newline が二回目以降常に accept
  * <bug> 複数行の編集時に履歴移動をすると表示が乱れる

    他にも編集してから実行をすると実行後にずれるとか、
    複数行の場合には accept-line ではなくて newline の筈なのに accept されるとか。

    これには二つの別の問題が関係していた
    1. 表示を消す時の座標の間違い
    2. stty -nl で icrnl が設定される事により CR が LF に変更されていた

    accept の件は、本来は、行末が次の行に移動しているかどうかではなく
    $'\n' がコマンドラインに含まれているかどうかで判断するのが良い。
    唯単に端末が狭くて折り返しているだけで単一行の時もあるから。
    しかしそうだとしても accept されるのは不思議である。
    accept-single-line する前に一旦表示している筈だから _ble_line_endy
    は更新されている筈であるのに。

    % やはり _ble_line_endy の更新に失敗しているという事であろう。
    % と思ったらいつの間にかに accept が正しく動くようになっている。謎だ。

    それでも表示が乱れるのは変わっていない。
    色々試した結果、_ble_line_endx _ble_line_endy は正しい値になっている。
    よく見てみると、単純に表示を削除する時の座標を間違えていただけであった。
    これで問題なく動くようになった。

    accept の方の問題に関しては再現する条件がある様だ。
    良く分からないが echo hello の様に単純なコマンドを一回実行してからだと
    常に accept される様に変わってしまう。
    表示の部分で _ble_line_x 等の動作を確認してみたが問題は内容に見える。

    と思って ble-edit+accept-single-line-or-newline の内部で
    出力を行う様にしてみた所、何故か初めの一回だけしか呼び出されていない。。
    ble-bind で確認してみても何か別の物に置き換わっているという様子もないようだ。
    すると何が起きているのだろうか…。
    実行されているという事は accept-line は呼び出されていると思われる。
    →実際に accept-line で stackdump すると ble-decode-key/invoke-command
    から直接 accept-line が呼び出される様になる様だ。
    もう少し詳しく調べる事にする。
    →どうやら ble-decode-char の時点で 13 ではなく 10 を受信しているようだ。
      もっと遡ると ble-decode-byte でも 10 を受け取っているし、
      そもそも ble-decode-byte:bind でも 10 を受け取っている。
      (何故始めの1回だけ正しい物を受け取っているのか謎である。)

    - bind -X で確認してみたが異常はない。
    - 因みにコマンドを一回も実行しない限りはずっと 13 が受信できる。
      何か stty の設定と関係があるのだろうか。
    - M-c で ble-bind -cf のコマンドを実行した場合も同様である。

    判明した function .ble-stty.enter の中の stty -nl が駄目だった。
    stty nl としてみたら動くようになった。然しそうすると表示が滅茶苦茶になる。
    今迄の描画ルーチンでは全然駄目という事になる。

    | 解決方法は二つある。
    | stty のモードをもう一つ付け加えて、入力を受け付ける時にだけ stty nl にする。
    | 或いは、 stty nl でも正しく描画できる様に描画ルーチンを変更する。
    |
    | a 何とかして stty を使わずに端末の設定を切り替える方法はあるか?
    |
    |   現在の所 stty のモードの変更はコマンドを実行する瞬間だけで済んでいる。
    |   もし描画する時と表示する時で毎回 stty を呼び出して切り替えなければならないのだとすると、
    |   かなりコストが高い。
    |
    |   - できるならば stty を呼び出さずに端末を制御する方法が有れば良いのだが…。
    |   - 或いは、stty を裏で起動しっぱなしにしてリアルタイムで変更させるなんて言う事ができたら…。
    |     しかしそんな機能はない。
    |   - それとも新しく仮想端末を作ってしまって設定に応じて出力先を変更する、
    |     等という事も出来たりするのだろうか。。
    |
    |   mknod とか?? 試しに
    |   $ mknod testtty c 4 100
    |   等としてみる…。許可されていない操作ですと怒られて終わる。これでは駄目だ。
    |   $ mknod a c 136 10
    |   としても駄目だ。今度は
    |   $ mknod /dev/pts/10 c 136 10
    |   等としてみる。エラーメッセージが変わった。"許可がありません" になった。
    |   良く考えてみればこれは "許可されていない操作です" 以前の問題なので、
    |   寧ろ遠ざかったのではないかと思う。
    |   さて、システムが落ちても嫌なので無理矢理 sudo で作るのは止めておこう。
    |   使い方も良く分からない事であるし。
    |
    |   関係有りそうな質問が出ている:
    |     [[Create new /dev/pts/&lt;n&gt; device using bash script?>https://forums.opensuse.org/showthread.php/494468-Create-new-dev-pts-lt-n-gt-device-using-bash-script]]
    |   しかし解決法は呈示されていない。
    |
    |   [[screenの”Cannot open your terminal ‘/dev/pts/0′”対策 | Siguniang's Blog>https://siguniang.wordpress.com/2012/08/11/screen-and-pseudo-terminal/]]
    |   によると script コマンドを起動すると新しい pts が開かれる様である。
    |   例えば、script コマンドを無理矢理開いて、その後でその script コマンドが作成した端末に書き込んだりするとどうなるのだろう。
    |   script を & で開いて新しく作成された pts に何か書き込んでみたが何も起きない。
    |   プロセスを見てみたが script コマンドが新しく pts/8 な bash を中で開いている様だ。
    |   要するに bash が何か出力したら script がそれを読み出す、という事なのだろう。
    |   bash は -i で起動し入力待ち状態になる。この時に pts/8 に書き込んでも何も起きない。
    |   うーん。良く分からない。もう少し試してみる。
    |
    |   $ script $(tty) &
    |
    |   何とも微妙な事になる。先ず & で起動しても script は停止してしまう。
    |   仕様がないので fg に持ってくると今度は出力が二重化されている。
    |   うーん。
    |
    |   $ script $(tty) -c cat &
    |   としてみる。cat は起動されていない様だ。
    |   この状態で /dev/pts/8 に書き込んでも何も起こらない。
    |   といって fg で中にはいると C-z 等で抜ける事ができない。どうした物か。
    |   % どうも /dev/pts/8 に書き込むというのは cat に書き込むという事のようである?
    |   とも思ったがそういう訳ではないようだ。やはりちゃんと $(tty) の方に書き込まれている。
    |
    | b もし -nl で描画を設計しなければならないとすると結構骨である。
    |   echo 等で適当に出力する事ができないという事になる訳だから。
    |   何を出力するにしても .ble-line-* を通して描画するか、
    |   或いは stty を自分で設定して出力するかをしなければならない。
    |
    |   例えばログアウトや戻り値が 0 以外の時に [ble: hoge] 等と表示しているが、
    |   これらも全て適当な出力としてではなく "描画" として取り扱う様に注意をしなければならなくなる。
    |
    | c 実は stty をもっと細かく設定できるのではないか?
    |   というか入力と出力で別々に設定が出来た様な気がする。と思って stty --help を見てみたら、
    |
    |   入力設定:
    |      [-]icrnl      復帰 (CR) を改行 (LF) に翻訳
    |      [-]igncr      復帰 (CR) を無視
    |      [-]inlcr      改行 (LF) を復帰 (CR) に翻訳
    |
    |   出力設定:
    |    * [-]ocrnl      復帰 (CR) を改行 (LF) に翻訳
    |    * [-]ofdel      ヌル文字の代わりに埋める文字として削除文字を使用
    |    * [-]ofill      遅延のタイミングの代わりに埋める文字を使用
    |    * [-]olcuc      小文字を大文字に翻訳
    |    * [-]onlcr      改行 (LF) を復帰改行 (CR-LF) に翻訳
    |    * [-]onlret     改行 (LF) が復帰 (CR) として振舞う
    |    * [-]onocr      1桁目の復帰 (CR) を表示しない
    |
    |    nl            -icrnl -onlcr と同じ
    |    -nl           icrnl -inlcr -igncr onlcr -ocrnl -onlret と同じ
    |
    |   と書かれていた…。基本的に -nl で、問題のありそうな物を nl と同じ設定にする、
    |   という事にすれば良いのではないだろうか。
    |
    |   -nl: icrnl  → cr を nl に変換する (これが駄目)
    |   -nl: -inlcr → nl を cr に変換する (これはその儘でないと駄目)
    |   -nl: -igncr → cr を無視しない (これもその儘でないと駄目)
    |   -nl: onlcr  → 出力の nl を cr nl に変換する (これもその儘)
    |   -nl: -ocrnl → cr は nl にしない (その儘)
    |   -nl: -onlret → nl は cr として振る舞わない (謎)
    |
    |   結局 -nl -icrnl とかすれば良いのでは??

    stty -nl -icrnl とするだけで済んだ。呆気ない事だった。
    また無事に問題が解決したので、
    accept-single-line-or-newline の判定の修正を行う。
    表示上の行数ではなくてコマンド内に \n があるかどうかで判定する。

  * ble-syntax.sh: 条件式 [[ ... ]] と配列初期化子内の文脈に対応、コメントにも対応

    以下の問題はこの実装の後に確認したら直っていた。
    (そもそも何故この問題が起こっていたのかよく分かっていなかったが。)

    | 2015-02-17
    |
    | * [[ ]] の括弧が異なる色になる。
    |   "]]" は "[[" の色に合わせる様にしているのに…と思ったら、
    |   これに関してもコマンドとしての着色によって "[[" の色が後で
    |   上書きされている様だ。
    |
    |   取り敢えずコマンドとして解釈されない様に、
    |   ATTR_DEL を rword[0] に代入してみたが…。
    |   これだと [[ に対する引数を complete の規則で取り扱えない。
    |
    |   結局、正しくキーワードと解釈される事を期待して、
    |   "]]" に先に ATTR_CMD_KEYWORD を適用してしまう事にする。
    |   [[ ～ ]] の取り扱いは後で又考え直す事になると思う。
    |
    |   と思ったら今度は急に動かなくなった。
    |   先ず [[ まで入力した時点で初めの単語の長さが 0 になっている。
    |   更に ]] を用いて閉じると正しい長さにはなるが
    |   単語の種類がコマンドから引数に切り替わってしまう。
    |   また "[[ text " と入力すると最後の空白が単語として認識されている。

  * <bug> invalid nest " $()" の先頭に for を挿入した時
    →これは寧ろチェックのコードの方が誤っていた。nest の形式の変更に追随していなかった。

  * 複数行コマンドの履歴

    複数行のコマンドの履歴について何とかする…。eval -- ''... に置き換える等。
    読み取り時に負荷になる?

    →複数行のコマンドを履歴に登録する時には eval -- $'' の形式にする事にした。
      これは printf %q を用いて出力する事ができる。
      読み取りの際には history-load の awk で ^eval -- ... に対して一致させる。

    保存する時には printf %q を用いる。bash-3.0 でも bash-4.3 でも $'' の形式になる様だ。

    意外と問題もなく直ぐに実装できた。
    これで複数行のコマンドも心おきなく編集・実行できる。

  * <bug> 表示の属性の更新がうまく行かない事がある。

    例1: for ((abc)) の a を消すと bc が (( と同じ属性になる。
    例2: for (()) の (()) の中にカーソルを移動して中身を書くと )) の属性が中身と同じになる。

    挿入や削除のあった箇所で sgr の再設定がされていない様子。
    これは見たら直ぐに分かって修正できた。

  * カーソル移動

    複数行に渡っている場合には up down で中を移動できる様にする。
    カーソルが一番上にある時に up を押した時に前の履歴項目に移動する。

    →一通り対応した。

    従来の kill-forward-line, kill-backward-line, beginning-of-line, end-of-line は
    kill-forward-text, kill-backward-text, beginning-of-text, end-of-text に移動。
    新しく kill-forward-line, kill-backward-line, beginning-of-line, end-of-line,
    forward-line, backward-line, forward-line-or-history-next, backward-line-or-history-prev を実装。
    newline, accept-single-line-or-newline の実装。

  * ble-syntax.sh: $[...] の形式に対応 (何故か bash の説明には一切載っていないが使える)。

  * ble-edit.sh: printf %()T を用いた実装の導入、PS1 \D{...} に対応

    | 2013-06-12
    | * <bug> ps1, \D{format} に対応していない。

  * <bug> 編集文字列の行数が変わった時に info.draw の内容がずれる

    これは info.draw の問題というよりは寧ろ
    .ble-edit-draw.update の方の問題の様に見える。
    → .ble-edit-draw.update の側で正しく描画領域を確保して描画する様にしたら直った。

2015-02-24

  * 描画ちらつき

    未だちらつく。全体を再描画するのではなく変更部分だけ更新したい
    先ず、開始時に bash に編集文字列を消されるのに対抗して再描画するのは
    bleopt_suppress_bash_output=1 である今必要はないと思って省略しようとしたら…
    元からちゃんと bleopt_suppress_bash_output を見て省略していた。

    とするとちらつくのは専ら再描画の為に一旦全体を消してから
    全体を再度出力し直している事による。
    現在は実装を一新したので変更のあった部分だけ出力する様に変更を図る。

    現在の実装について確認する。
    特に文字列の座標計算と表示内容の構築を行っているのは以下の関数である。
    .ble-line-text.update-positions
    .ble-line-text.construct
    もう少し関数に細分化・分散していると思っていたが意外とコンパクトに纏まっている。
    現在、update-positions は construct から呼び出されるので直接外部から呼び出す事は無い。
    (むしろ外部から呼び出すと update の回数がずれて
    二重に shift を実行してしまって全体を計算し直すことになったりして良い事は無い。)
    つまり、実質的に interface は .ble-line-text.construct だけという事になる。

    計算結果は現在は専ら .ble-line-text.construct の戻り値を介して取得している。
    しかし、外部からもっと簡単に様々な情報にアクセスする事ができるようにしても良いと考える。
    幸いにしても .ble-line-text.construct の呼出元は一箇所しかないので、
    簡単に interface を変更する事が出来る。


    取り敢えず更新の必要な範囲についてだけ更新を行う様に変更する事を考える。
    実際には文字列の挿入や削除などの場合でも文字列は移動するだけだから ICH や DCH でもっと
    賢く再描画する事も可能かも知れない。
    しかし、取り敢えずの所は移動する文字についても完全に再描画する事にする。
    また、実際に必要とされる文字列についてはの /update で計算するのではなくて、
    使う側が必要になったら構築を呼び出す様に変更する。

  * <重い> 改行を挟んでいれば編集は軽くなると思っていたが軽くない

    update-positions は途中で終わると考えていたが、違うという事なのか?
    実際に調べてみた所 update-positions や highlight はちゃんと更新の必要がある範囲で終わっている様だ。
    試すと明らかに挿入が遅い。末端に文字列を書き込んでいる時にはそんなに重くないのに、
    改行を挟んでいる所に文字列を書き込むと遅い。
    再度試してみたが、そもそも内容が長くなってくると重いのは仕方がないとして、
    やはり途中に挿入するのが特に重い。

    試しに syntax を止めてみたら途端に滅茶苦茶軽くなった。
    syntax が full に走ってしまっている可能性がある…。
    また syntax を入れてみて試してみる。
    やはり死ぬ程遅いが、ble-syntax-highlight+syntax が返す更新範囲はそんなに大きくない。
    次に ble-syntax-highlight+syntax の中身を覗いてみる。
    何と解析が最後まで走っている事が判明した…。

    と思ってよく見てみると _ble_syntax_stat の shift に失敗していた。
    これを直して再度試してみる事にする。未だ最後まで走っている…。
    もっと調べてみるとそもそも dirty-range 拡大が最後まで走っている様だ。
    どうも word による dirty 拡大が連鎖で起こっている様子だ。

    そもそも dirty 拡大の時の拡大領域の値が +1 されているのは何故だったか良く分からなくなった。
    もともとは、その当該要素も確実に再解析の対象になる様にという事だったとは思うが、
    その時点での stat の値が一致していれば直前までの解析で良いのではないか? それでは不十分なのか?
    という事になる。というかそもそも dirty 拡大が必要なのは何故だったか?

    もしかすると word の古い取り扱いに関連していたのかも知れない。
    でもそうだとすると今回新しく word による dirty 拡大をした理由も何だか良く分からなくなる。
    もう少し落ち着いて考える。参照先が消滅している場合にはその stat は無効になる、と考えるのは自然である。
    例え解析の結果によって stat が全く同じ値になったとしてもこれは前の stat と同一か? と言えば異なるとした方が良い。
    とするならば解析範囲の拡大を行う事によってこれに対応するのではなくて、無効になった stat を削除すると言うのが正しい対処法ではないのか?
    word に対する dirty 拡大はもう少し異なる状況である。
    word については解析中断の条件に入っていないので word の情報を消したとしても無意味である。x
    抑も word の先頭が消滅・或いは無効化した時に word が更新された事を検知したいというのが目的だった。
    もし dirty 拡大をしていないと word の先頭が消滅・無効化した時でも再解析によって word の途中で
    一致した文脈状態になった時に其処で解析が終了してしまう。
    その時に _ble_syntax_word_umin _ble_syntax_word_umax に登録されないという問題が生じる。

    でも _ble_syntax_word_umin, _ble_syntax_word_umax に登録するという目的であれば、
    dirty-range 拡大によって無理矢理に解析をやり直させるよりは良い方法がある様に思う。
    無理矢理解析を行わせるように成っている為に必要のない所まで再解析・単語更新を強いる事になる。
    例えば、"$(echo hello world)" において先頭に a を挿入した場合、dirty 拡大を行っている場合、
    echo や hello, world 等までも再解析の対象になり、また _ble_syntax_word_umin の対象になる。
    実際に考慮に入れるべきなのは a"$(echo hello world)" という全体に対してのみの筈だ。
    (もし挿入によって文脈構造が変化する場合については echo hello world も自然に再解釈の対象になるので問題ない)。

    単語内部で更新が起こったかどうかによる判定は別に行うべきではないかと考える。
    と思って確認してみたが、既に単語内部で更新が起こった場合については _ble_syntax_word_umin に登録する様になっていた。
    これについては、念のため不等式を変更して word 先頭で編集が起こった場合にも対応する事にした。

    さて今回の変更で dirty 拡大を完全に廃止した事になるが、
    これによって従来動いていた物が動かなくなってはいないか確認するべきである。
    取り敢えず、編集のあった単語について正しく再解析が行われているかどうかについて確認を行う。

    - 色々試すと、単語の先頭に文字列を挿入しても _ble_syntax_word_umin に登録されなくなった。
      謎だ。と思ったら j を登録すべき所 i を登録していた。
      更に、一番最後の点 (index iN) を更新していなかった。
      文字列の末端でも状態を記録する為、一番最後の点まで確認しなければならないのだ。
      これは取り敢えず解決された。

    これに関しては dirty 拡大の取り扱いを止める事によって解決した。
    これで途中の編集に対して末端まで解析を実行する事は防げた。
    今迄 dirty 拡大を行った元でテストしてきたが、これがないと解析を行うべき所で解析されないなどの問題が
    今後発生するかもしれない。しかし、それはまたその時に対応する事にする。

    しかしながら、多少解消はした物のやはり途中に対する挿入は遅い。
    これは結局 shift をする為にループを回しているのがいけない様に思う。
    末端に挿入する場合には shift を確認する範囲は小さくなる。
    しかし初めの方に挿入する時には文字数と同じ数だけの shift のチェックを行わなければならない。
    何か簡単に shift が実行できてしまう様なデータ形式を思い付けば良いが、
    そうでなければこれは仕方がない。shift が遅いという新しい項目として残してここで終わりにする。

  * <bug> 文字削除時 invalid nest の assertion に引っかかる。
    invalid nest に引っかかる。
    再現: history で l "$(echo hello)" を出して "$ の直前に文字を挿入。その後文字を削除。
    別に history でなくても起こる様だ。

    dirty 拡大に代わり stat を削除する様に変更と言いつつ、
    stat の該当項目に -1 を代入していただけなのが災いしている?
    良く考えたら -1 既に "より上位の nest が存在しない" だとか "今は word の中ではない" という意味だから、
    本当は良くない。でもそうだとしても nest のチェックに引っかかるのかどうかというと疑問な気はする。
    取り敢えず本当に削除する様に変更して様子を見てみる事にする。
    →出なくなった。考えるのが面倒なのでもし今度出たらその時に考える事にして此処で終わりにする。

  * <bug> 編集内容が零文字になった瞬間に改行が起こって表示が消える。

    調べてみると編集文字列が "" になった瞬間に
    _ble_line_x _ble_line_y が 53 1 という変な値になっている。
    と思ったらこれは .ble-line-info.draw による表示の位置である。
    しかし、何故編集文字列が空になった時にだけ .ble-line-info.draw の
    位置が _ble_line_x に代入されているのだろうか。
    % と思ったがそれは当然である。
    % 変更点があって文字が描画された時には umin<umax なのでその前に描画が為されている。
    しかしそれでも変だ。では何故 "" になるまでは _ble_line_x に別の値が代入されているのだろう。

    別に文字が "" にならなくても末端から削除をしている時は
    新しい文字を描画する必要はないので umin==umax になっているはずである。

    何だか良く分からないのでまた別の方向でも調べてみる。
    部分更新ではなく、常に全体を更新する様にしてみる。
    →全体更新であっても勝手に改行が入ってしまう様である。
      もしかして何処かにデバグ用に埋め込んだ echo があるのか?
    →どうやら bash がエラーを出力していた様だ。
      何と echo 11.8 "$_ble_syntax_word_umin $_ble_syntax_word_umax" で 0 0 が出力される。
      _ble_syntax_word_umin の代入箇所を探しても 0 になる様な箇所はないのだが…。
      と思ったが分かった。削除した時に _ble_syntax_word_umin の shift によって
      有限の値だった物が 0 になっている。

      これが起こるのは仕方のない事なので、これに対して特別に対策を取る事にした。
      更新しようと考えていた単語が消滅した時には _ble_syntax_word_umin を ++ する。
      それによって対象の単語が一つもなくなった場合には -1 を代入する。

    これで直った。しかし、描画の際にエラーメッセージが消されてしまうというのは厄介な事である。

  * <bug> 改行しても先頭がコマンドになっていない

    何と [[ ${#BASH_REMATCH[0]} =~ $'\n' ]] としていた。当然 # は不要である。
    これは直ぐに直った。

  * <bug> _ble_region_highlight_table で空欄になっている箇所がある。
    echo " と入力した時の空白に対応する部分。

    これは function ble-syntax/highlight/set-attribute の中で
    既に設定されている物と同じ値かどうかの確認の際に、
    数値として比較していた為に空欄と 0 が同一視されている事による物であった。
    修正した。これは無事に 0 が代入される様になった事を確認した。

    それと共に _ble_syntax_attr_umin における色の既定値を正しく計算する様にした。
    (実際には問題にならなかったかも知れない。
    つまり _ble_syntax_attr_umin は必ず attr の設定されている点が設定される様な気がする。)

  * <bug> 単語の属性適用が後ろに続く単語にも続いている。
    単語の分割はちゃんとできているのに不思議だ。
    これは属性適用の側のバグだと思われる。

    再現:
    1 以下を先頭から順に入力する
      echo "$(less hello world)"
    2 "$( の直前に文字を挿入する
      echo a"$(less hello world)"
      この時 less の属性が less hello world 全体に適用される。
      その他の部分の着色については問題はない様に見える。

    取り敢えず属性適用の部分で何が起こっているか調べようとすると…。
    属性適用が起こっていない様だ。やはり再度試しても呼び出されていない。
    (よく考えてみれば _ble_syntax_word_umin はこの範囲を含んでいないので当たり前である。
    また、これは期待した動作でもある。この部分は変更していないのだから。)
    さて、この時に何故表示内容が崩れてしまうのか。。

    また、不思議なのは先頭にあるコマンドの着色がそのまま後ろに適用されてしまう点である。
    つまり、一旦 word による属性が全て解除された後に word による属性が適用されない、という訳ではない様だ。
    _ble_syntax_attr が削除されているという事だろうか。
    shift の際に属性が飛んでしまうという事なのか? shift ではちゃんと削除された場所以外は保持している筈なのだが。
    試しに _ble_syntax_attr の中を確認してみる。_ble_syntax_attr の中は正しい値になっている。
    という事は adapter での繋ぎ替えに失敗している? 念のため _ble_region_highlight_table を確認する。
    これも正しい値になっている。という事はやはり adapter が怪し。

    今度 _ble_highlight_layer_adapter_buff の中を出力させてみたらどうやら、
    問題は a を挿入前の時点で既に発生していた様だ。
    $( とした状態で順次入力を行っていくと常に最後にエラーの赤い印が付いた状態で入力していく。
    そうするとどうやら属性 0 が全てはぎ取られていく様だ。
    また遡って調べてみようと思ったが、_ble_region_highlight_table の時点で正しい状態だったから、

    やはり adapter の中での更新が問題な様に思われる。
    と思ったら見つけた。gprev に常に 0 が入っていた。
    これは全体に対して _ble_region_highlight_table を読み出していた時のままになっていたという事だろう。
    i1>0 の時には i1 直前の gprev を読み出す様にした。
    これで a を " 直前に挿入した時の色付けは正しくなった。

    しかし、今度は何故か入力していった時の色がおかしくなった。
    と思ったがこれは当然の事である。部分更新なので途中から出力している。
    それなのに前からの続きとして出力してしまっているので SGR が出力されていない。
    これは ble-edit-draw.update 側を修正する。
    これで正しく動作する様になった。

    意外と修正に手間取った。

  * <bug> _ble_syntax_attr の中に "BLE_ATTR_ERR" の文字列が混入している。
    一応算術式評価では BLE_ATTR_ERR の中を読みに行くので問題はないとはいえ、その様に設計したつもりはないので修正するべき。
    →これは parse の末端で起こっていた。修正した。

2015-02-23

  * 過去の ToDo について改めて整理を行う

    既に自然に実装された物、解決した物、或いは実装する事に意味が無くなった物などを整理する。

    | 2013-06-12
    |
    | * ble-decode-byte:bind の先頭でプロンプトを再描画する必要がある version の境を調べる。
    |   →これは bleopt_suppress_bash_output の実装で余り意味がなくなった。
    |     bleopt_suppress_bash_output=1 で問題が起きていないので、
    |     今後は bleopt_suppress_bash_output= について積極的な最適化をする事はない。
    |
    | * <bug> ウィンドウサイズを変更するとプロンプトが bash の表示する物になる
    |   これはウィンドウサイズを変更した時に bash が自動的にプロンプトを再描画する為。
    |   SIGWINCH を trap して自前で描画し直せばよい?
    |
    |   2015-02-09 bash-4.3 で試したが問題が再現しない。
    |
    |   2015-02-24 これも bleopt_suppress_bash_output=1 を実装したので
    |   今後はこの問題が発生する事は無いのではないかと考えている。

    これらは出力関連の問題であったが、bleopt_suppress_bash_output の実装により余り意味が無くなったので削除する。

    [Done]

    | 2013-06-10, X7 解析器
    |
    | # bash script の解析器を作る。
    | # これは syntax-highlight, complete 等から用いる。
    |
    | 先ず、シェルスクリプトの文法について整理する。
    |
    | !   履歴展開
    |     ! に非空白の文字列が続いている時
    | "   二重引用符の開始
    | '   単引用符の開始
    | `   コマンド
    | $'  引用符の開始
    | ${  パラメータ展開 {} の開始
    | $(  コマンド置換
    | $(( 算術式置換
    | $他 パラメータ展開
    |
    | コマンド修飾 (コマンドよりも前に来る事ができる物)
    |   [0-9]*(>|>>|&>|&>>|<|<>)(&[0-9]+|arg)
    |   [<>]( プロセス置換開始
    |
    | コマンド
    |   ((  算術式の開始
    |   [[  条件式の開始
    |   {   重文開始
    |   (   サブシェル開始
    |   aaa=hoge
    |   aaa[]=hoge
    |   aaa=(hoge)
    |     コマンドが続く
    |   time
    |   time -p
    |     コマンドが続く
    |
    | ; & | && || |&
    |   コマンドが続く
    |
    | ;; ;& ;;&
    |   case パターンが続く
    |
    | ※incremental に解析できる様に再帰呼び出しなどは避けたい。

    この中で実装されていないのは
    - time -p
    - aaa=(hoge), 他に aaa+=(hoge) というパターンもある。
    - ;; ;& ;;& の後に case のパターンを受ける
    - [[ 条件式の文法に正確に対応していない
    等である。その他については (多少の問題点は残るが) 実装してある。
    上記の物に関しては、より最近の文法対応リストに追加しておく事にする。

    | 2013-06-09
    |
    | * split, 書きかけたけれど結局使っていない関数
    |   function .ble-text.split {
    |     local GLOBIGNORE='*'
    |     test -n "${3+set}" && local IFS="$3"
    |     eval "$1=(\$2)"
    |   }

    これはどうでも良い。最近では手で書いている。というか手で書いた方が楽だ。

    | * ble-decode-char: cmap+default.sh を統合する?
    |
    |   改めてコードを見てみたが、それ程サイズが大きい訳でもないので、
    |   ble.sh の中に埋め込んでしまっても良いかも知れない。
    |   しかし、ユーザにカスタマイズの余地を残す、という意味では別のファイルになっていた方が親切である。
    |
    | * ble-decode-char:
    |
    |   これをユーザの側で生成するのには時間が掛かるので、
    |   予め作成しておいた dump ファイルも一緒に配布するのが良い。
    |
    |   連想配列を使う版と使わない版の二種類だけで良い。
    |   と思ったが、連想配列を使うか使わないかが影響を受けるのは、
    |   cmap の側と言うよりは keyname の方なので、元々巨大ではない。
    |   keyname の部分だけは ble.sh に統合してしまうと言う手もある。
    |
    |   *.dump についても統合してしまうという手もあるが、
    |   これについては中身が巨大なので余り統合する気にはなれない。
    |   (でも、最終的には統合した方が綺麗かも知れない。)
    |
    |   もしも統合しないのだとしたら、何れにしても複数ファイルになってしまう訳だから、
    |   cmap+default.sh を ble.sh 内部に統合する意味も余り無い…。
    |   というか、dump を一緒に配布する場合、
    |   そもそも cmap+default.sh を実行する事はない筈である。
    |

    ble.sh は益々肥大化しているのと、これからも様々な設定ファイルが増えていくだろうと予想されるので、
    single file で提供する事はもう考えない。

    | * <bug> キャレットが編集文字列の先頭にある場合、prompt の最後の文字の SGR が反映されない。
    |
    |   これに対応する為には prompt の指定から SGR を抽出するしかない。
    |   普通は prompt の最後の文字は空白にする (本当か?) ので気にしなくても良い気もするが。
    |
    |   これを真面目に実装するには二通りの方向性が考えられる。
    |
    |   一つは zsh の様に PS1 の色・スタイルの指定を %[] の中でやって貰うという方法である。
    |   これならば TERM に依存せずに解析できるので良い。但し、これは bash に非互換なので、
    |   bash から何も設定を変えずに移る、という事ができなくなる。また、% の指定に対応し始めると、
    |   その他の zsh の指定についても対応しないと収まりが悪い。全て実装しようと重うと大変である。
    |
    |   もう一つは PS1 を頑張って解析して、ESC [ ... m から SGR の指定を取り出す方法である。
    |   現実的には ESC [ m 以外で SGR を解釈する端末が存在するとは思えないから、
    |   これでも良い気がする。

    これも bleopt_suppress_bash_output=1 の実装により重要性が低下した。
    一応 bleopt_suppress_bash_output= の問題点として残して置くが、簡単な一行の説明に収める。

    | 2013-06-08
    |
    | * <bug> source を実行している間に C-c をして中断しようとするとその儘動きが止まる。
    |   通常のループなどで時間が掛かっている場合に C-c で止まる様にするには
    |   trap return INT 等とすれば良かったが、source の内部で時間が掛かっている場合には、
    |   C-c で止めようとするとそのまま全体の動きが止まってしまう様である。
    |
    |   序でに関数内のループで時間が掛かっている場合に関しても調べてみたが、
    |   こちらは C-c で正常に中断する事が出来るようである。
    |
    |   + 2013-06-11 12:29:07
    |     改めて試してみたら、ちゃんと停止はする様である。
    |     accept-line.exec でループ構文を使わずに再帰に書き換えたがその事が影響を与えたかも知れない?
    |     或いは、これは前に試した時の勘違い?
    |
    |     しかしながらまた例によって .ble-stty.enter が実行されていない様である。
    |     何故か分からないが処理の流れ的には正しくできている気がする。
    |     しかし、処理の順番が入れ替わっている気がする。
    |     exec.recursive から先に出力されるべき物が、プロンプトの表示よりも後になっている。
    |     後で再度調べ直す必要がある?

    これは gexec の実装の際に色々試して trap - DEBUG の方向性で解決する事にした。
    これによってどんな場合でも確実に停止できるのではないかと考えている。
    具体的に source を使って検証した訳ではないが、関数では充分にテストしたので大丈夫だと考えている。
    もし問題があったら改めてその時に考える事にして、この項目も削除する事にする。

  * <bug> info.draw で特殊文字が改行に跨っている時の座標計算

    例えば CR などの特殊文字を ^M と表示しているが、これが改行に跨って表示される。
    その時の座標がずれる。(そもそも改行に跨って表示されるのが誤り?)

    →空白を挿入する様にしていたのだが、挿入する空白の長さを空白を挿入した後の値で計算していた。
    つまり空白を挿入する必要がないという解釈になっていた。式の評価の順序を正しい物に変更した。

  * <bug> update-positions で dend-dbeg が負になると警告が出る
    →プロンプトの内容に変更があった際に初期位置 x y が変わる。
    その時の dbeg=0 の設定の際に dend や dend0 を正しく設定していなかった。

2015-02-22

  * <bug> word の内容変化を検知する事のバグ

    - transpose-chars 等を用いた場合 word の内容が変化しても word の着色が更新されないのではないか?
      →コードを見た所、単語内部で変更が起こった場合にはちゃんと ble-syntax/parse/touch-updated-word している。
      単語の終端点を巻き込んだ変項の場合には、否応なく parse で変更される筈なのでここで touch する必要はない。
      つまり、現状のコードでも問題が起こる事はないように思われる。

      と思ったが正しくできていない。
      echo 'd'is't' で真ん中の is を tranpose して見たが、どうも期待通りに動いていない様だ。
      と思って調べたら、そもそも transpose した時には単語の切り出し自体に失敗している様だ。
      長さ 0 になっている。途中で解析が終わっている為であろう。

    - 解析が単語の途中で終わった時に word が壊れない様にする為には?

      これは真面目に考えなければ対応方法が分からないので後で考える。
      (そもそも単語が終了した所で前の位置 word[wbegin] に書き込むというのが混乱の元なのかも。
      データ形式から考え直した方が良いのかもしれない。)

      眺めていたら簡単に書き換えられそうだったので書き換えた。
      _ble_syntax_word[]は単語の先頭ではなくて単語の終端に置く事にした。動いている。
      _ble_syntax_word を用いた dirty 拡大にも対応した。
      後 dirty 拡大の部分に問題を見つけたのでその部分も修正した。

  * <bug> .ble-line-info.draw を使った時行がずれる

    これは新しい描画関数で出力する様にした時に出力の順序を変えた所為だった。
    出力をバッファリングしている時には、その最中で別の複雑な関数を呼んではいけない。
    内部で独自に出力を行うかも知れず出力の順序
    (と _ble_edit_x, _ble_edit_y の参照順序) が変わるからである。

  * <bug> for や do に色が着かない?

    _ble_syntax_word_umin, _ble_syntax_word_umax の問題の様だ
    → ctx-redirect/check-word-end で wbegin=-1 を設定した後に touch していた所為で、
    _ble_syntax_word_umin=-1 になってしまい、範囲が無効化されていた様だ。
    ble-syntax/parse/touch-updated-word に assertion を追加した。

  * 描画の高速化2: 現在の不具合と layer に対する対応

    | x 現在 update-positions で位置が変化しただけの部分に対しても表示用の SGR 付き文字列を更新している。
    |   これは省略できる筈。改行やタブなどで出力内容に変化のある部分については別に記録して後で合成して表示する。
    |
    | x transpose-chars 等を用いた場合 word の内容が変化しても word の着色が更新されないのではないか?
    |
    | x word の属性が解除されてもそれが表示に反映されない。

    先ず、word の属性が解除された時の動作について考える事にする。これは layer の実装方法にも関わってくる。
    word の属性が解除された時、元々其処にあった属性を復元したい。
    これは _ble_syntax_attr を参照して再度値を書き込めば簡単に実現はできる。
    しかし、今後 ble-syntax とは独立した形で様々な着色を行う事になると思われる。
    その際に _ble_syntax_attr やら更にその後に付加される word の着色に対して毎回参照したり計算したりするのは現実的ではない。
    様々な着色を分離した形で実装する為にはちゃんとした仕組みが必要になる。

    改めて考えるにこの問題は、「word の着色をしても、概念的にはその下には syntax による着色が残っている」のに、
    それが word の着色によって失われてしまっているという事である。つまり、syntax による着色は依然として
    有効であり、word の着色が戻った時にまた有効になる物であるのに、それを上書きして消してしまっているという事である。
    本来は、word の着色やら syntax の着色やらを全て内部的に保持しておいて、表示の時に有効な物を選択して着色するという事が必要である。
    つまり、簡単に言うと layer 機能が必要になるという事である。

    しかし、layer 機能を実装するに当たって考えるべき事がある。効率である。
    現状で何とかぎりぎりで現実的な速度で表示できるようになっているが、
    layer の機能を愚直に実装した場合、現在の高速化に使っている方法がそのままでは使えないのでかなり重くなる。
    現在の方法を何とか適用しようとしても結構面倒な操作が必要であり、どれぐらい遅くなるかは未知数である。

    ここでは複数の方法について考え、また、layer としてどの程度の機能が必要に成るであろうかを整理する。
    もしかすると完全に layer の様なおおがかりな仕組みは実装しなくても良いかも知れない。

    a 始めに考えた方法は、各 layer で着色された文字列を保持しておき、
      表示の際に有効な layer の部分をぱちぱちつなぎ合わせて実装するという物である。
      しかし、これは同じ layer に属する部分は連続している筈だ、という仮定に基づいている。
      様々な layer が滅茶苦茶に混ざり合っている場合には却って遅くなる。
      また、表示の際につなぎ合わせを実行するので部分更新であっても
      文字列の長さ (というか正確には上位 layer の着色範囲の数) に比例する時間が必要になる。

      そもそも当初は「選択範囲の着色」や「括弧の対応」の着色が念頭にあった。
      これらは精々1つか2つの着色範囲しか持たないので、
      どんなに文字列が長くなったとしても繋ぎ替えの操作の階数は一定数に保たれる。
      しかし今後「各コマンドに対応した引数の着色」などに対応するとなると、
      これらも新しい layer として実装する必要があるし、かつ、
      文字列の長さに比例してつなぎ目も増えていく。

      部分更新やカーソル移動だけでも一定の繋ぎ替えの操作が必要になるのは問題である。
      この方法は全く現実的ではない。しかし、この方法を改良すれば何とかなる可能性はある。

    b 次に考えた方法は各 layer について色の配列を保持し、
      それを用いて表示する側で最終的な文字列を一つ構築するという方法である。
      そして部分更新の際には、各 layer の変更範囲を集計して最終的な文字列自体を書き換える。

      これが一番自然な実装に思われるが多少問題点が存在する。
      「括弧の対応」の場合には離れた2点で局所的な更新が実行される為、
      単純な変更最小点と変更最大点の間を全て更新するという方法にしていると、
      変更範囲が無駄に大きくなってしまう。特に編集文字列全体を囲むような括弧の場合に
      毎回全体を更新するのと同じ事になり非現実的である。

      この場合の対策は二つ考えられる。
      1 一つは変更範囲の管理方法を単純な最小点・最大点のペアではなくもっと詳細な物に変更するという方法。
      2 もう一つは、「括弧の対応」や「選択範囲」などの広い領域を cover する layer の場合には、
        自身の更新の特性を知っている筈で、そちらに編集文字列の update を任せるという方法。

      普通は 1 の方向に進みそうな物だが、これだと実装が複雑になる。
      というかどの様なデータ形式にするのが良いのかも良く考えなければならない。
      単純に (begin,end)* の様な構造にすると例えばしましまに更新した時に更新範囲が複雑になる。
      しましまに近い時は複数の範囲ペアをくっつけて一つの変更範囲ペアにしてしまう方が効率が良い。
      しかし、この様にすると変更範囲の合成も無駄に複雑になる。却って合成操作に計算時間が掛かるかもしれない。
      というか 1 と 2 を組み合わせて、(1) 複雑な着色をする物に関しては (begin,end) を一組だけ報告させて、
      (2) 離れた点での着色になる物に関しては (begin,end) を分割して報告させるなど、
      変更範囲の報告を各 layer に任せてしまえば良いのかも知れない。
      変更範囲ペアがそれ程沢山にならないのであれば
      変更範囲の合成についても複雑な事を考えずに素直に実装して良い。

      それでも未だ微妙な点がある。
      b.1 変更範囲が分かったとしても、どの layer が有効なのかの情報がないので、
        描画文字列を更新する際に上の layer から順番に描画属性が適用されているかを確認しなければならない。
        それも各文字についてこれを実行する必要がある。

        しかし、これは別の方法を用いたとしてもループの順序が異なっているだけで等価な事をする
        必要があるのかも知れない?? でもこの方法だと b.2 に挙げる様な layer の最適化が適用できない。

        変更範囲 pair に layer 情報を付加して対策するとしても、
        layer から着色が削除された場合については、
        結局着色が削除された部分についてどの仮想の layer が有効になるのかを計算しなければならない。
        特に下層の layer が複雑になっているかもしれないし、
        隣の変更範囲 pair と地続きになっている可能性を考えてくっつける事もできるかもしれないし#1、
        …など色々と再計算が複雑になってしまう。layer 情報を付加しても効果は限定的であろう。
        # #1 はこういう事である。層3 の属性を削除した時。更に層2、層1についても変更がある。
        # 更新範囲 <22><1><111> (更新の際に参照する範囲)
        # 変更操作 <33333><111>
        # 層3      .......
        # 層2      <-->
        # 層1        <-------->
        # 変更操作としては二つの範囲であるが、
        # 実際に更新の際に参照する属性が載っている部分はより下層で分裂している。
        # 結果として三つの変更範囲が得られる事になるが、よく見ると<1> と隣の <111> の
        # 範囲は同じ layer を参照しているので無駄に範囲が分裂している事になる。
        # これらの無駄に分裂した物をくっつける事ができるか、或いはくっつけた方が良いのかという事である。
        # この様な分裂は大した問題ではない様にも思えるが本当にそうだろうか。考えてみると、
        # 最大で全 layer での削除範囲の合計x2 個の無駄な分裂が起こる…やはり大した問題ではない気がする。
        # n^(layer 数) 等の様なスケールだったら考え物だった、編集箇所の数に比例する程度なら問題ない。

      b.2 region (選択範囲) だとか括弧の対応だとかはその着色を保持するのに配列を用意するまでの事は無い。
        region に関しては現在の mark と point だけで完全に記述できるし、括弧の対応に関しては
        配列の中は殆どの時に空である。というか、選択範囲の方も選択しない限り空である。

        これらの sparse な配列に対しても全て描画属性が設定されていないか確認するのは無駄だ。

      b.3 選択範囲が解除された時など、以前の状態に戻したくなった時に、
        また全て描画文字列を構築し直す必要がある。

        しかしながら、以前に計算したのと同じ物を計算するのは気にくわないという事を除けば、
        これについては大した問題点ではない様にも思う。というのも以前の状態に戻したくなるという状況は
        頻繁には生じないからである。

        これについてはおまけ的に解決できたら良いという指標で良いだろう。
        (これについて簡単な解決ができる方法の方が、
        将来的に別の問題が起こった時にも解決しやすい・汎用的だろうという程度の目安とする。)

    c 以上を踏まえて (もしかしたら却って非効率かも知れないが) もう一つの方法についても挙げる

      各 layer で「その layer 以下の描画属性を適用した状態の文字列」を管理する方法である。
      変更があった場合には、下の layer から順に変更範囲を上の layer に伝達し、
      下の layer は該当部分の変更を自分の持っている描画文字列に対して適用する。

      しかしこの方法は既に挙げた問題を解決できていない。多少実装が楽になるだろうというだけである。

      c.x1 複数の離れた変更範囲がある場合についての解決策にはなっていないので、
        結局複数の変更範囲 pair を扱う事になる。
      c.x2 次に、下層の layer の描画文字列の切り貼りをする為には、
        index 情報が必要 (各文字の表示にエスケープシーケンスを含めて何文字使っているか) であり、
        これらも独立した配列として管理しなければならない。
        例え選択範囲などの様な単純な描画属性に対してであっても、だ。
      c.o1 被覆されて実際には表示状態に変化を与えない下層の layer の更新が上部に伝達されない、
        というのは一つの利点ではある。しかし、その様な変化がある場合は稀であるし、
        結局内部的には下層の layer の保持する文字列に対する更新が行われている。

      少しこの方法に改良を入れて考えてみる。
      「その layer 以下の描画属性を適用した文字の配列」と考える。
      一番上の layer でなければ繋げた文字列をそのまま使うとは限らない。
      それならばそもそも繋げなくても良いのではないか。
      この様にしておけば index 情報を別に覚えておく必要はなくなる。
      パラメータ展開に index を指定するだけで任意の部分列を取り出す事ができる。
      これで c.x2 の問題はなくなる。

      | 但しカーソル移動をする時の為に index 情報は覚えておく必要がある?
      | とも思ったが、これも IFS= a="${cs[*]:i}" b=${#a} 等としてしまえば良い気がする。
      | そもそもカーソル移動は一回のキー入力に対して 1 回しか実行しないのだから、
      | 常に全ての位置についてのカーソル位置の為の index を保持している必要は全くない。
      | そればかりか、そもそも出力文字列に SCOSC SCORC を埋め込む形でカーソル位置を
      | 表現する必要性があるのかすら疑問である (一応この様にしておけば、何処か別の場所から
      | 出力があった場合 (や ble.sh の座標計算のバグがあった場合に)、
      | ずれても大丈夫というのはあるが。)
      |   という事なので毎回 ${cs[*]::i} 等として文字列を連結して長さを数えれば良い。と
      | 思ったが、連結までするぐらいであれば ${cs[*]::i}$SCOSC${cs[*]:i} とすれば良いだけの気が。
      | 所で、この方法に頼っている時に、文字列が長くなると効率二度の程度の影響があるかは
      | 気になる所である。一般に編集はそれ程の速度で行われる事は無いが、カーソル移動は、
      | キーボードの押しっぱなし等によって相当の速度で入力される可能性がある。従って、
      | 編集の際には効率的に問題にならなくても、カーソル移動の際の効率に影響を与える可能性は残る。
      |
      | 追記: 現状の実装で index 情報を記録しているのは元々は別にカーソル位置を任意に
      | 取り出す為ではなかった。これは、キャッシュした文字列を任意に切り貼りできる様に
      | する為の物であった。後で、これがカーソル移動の際に SCOSC を挿入する位置として
      | 活用できる事に気付いた為に使っているだけの事である (とは言っても他に "効率的" に
      | SCOSC の挿入位置を決める方法、または、カーソル位置の確実な復元方法は分からないが。)
      |
      | また、連結した文字列は一番最後の layer だけで保持する事にすればよい。
      | →そう思ったが、連結した文字列を後で再利用しようと思ったら結局 index 情報が必要になる。
      | index 情報を一緒に管理しながら既存の文字列を切り貼りするのと、
      | 最後のレイヤーが出してきた配列全体を連結するのとどちらの方が効率的かという話になる。
      | 配列全体の連結でもそんなに問題はないかも知れない?
      |
      | 少し時間を計測してみる事にする:
      |
      | a=({1..100000})
      | time IFS= eval 'b="${a[*]}"'
      | real    0m0.077s
      | bash の割に驚異的な速度である。
      |
      | time c="${a[*]::10000}""$ins""${a[*]:10000}"
      | real    0m0.200s
      | 多少時間が掛かる。でも 10 万の要素を連結している事を考えれば充分な速度だ。
      | コマンドラインに 100k も文字を書き込む事などない。10k でも多すぎる。
      |
      | index 情報によって文字列 b の中に於ける index が分かっている場合:
      | time c="${b::40000}""$ins""${b:40000}"
      | real    0m0.053s
      | 文字列にすれば滅茶苦茶速い、という訳でもない様だ。
      | (というかマルチバイトで記憶しているから文字数を数え上げなければならない、
      | という事なのだろうか?)
      |
      | 更に index 情報を用いているので、index 情報の更新も行わなければならない。
      | これだけ巨大な配列になってくると index 情報の shift にも相当の時間が掛かるだろう。
      | (何しろスクリプトで for でループを回さなければならない。)
      |
      | 色々考えるに index 情報を管理するのは効率的に駄目だ。
      | SCOSC でカーソル位置を管理したいと思う場合、
      | カーソル移動の際にも文字列を連結しなければならないのは惜しいが、
      | この辺りはカーソル移動を実際にやってみて遅ければ SCOSC は使うのを止めて、
      | ble.sh による座標計算を信用して update-positions のデータを元にカーソルの位置を動かす事にする。

      結論
      - 各 layer 毎に「その layer 以下で計算される描画属性を適用した文字の配列」を管理・更新する
      - 実装の為に描画属性を持たない文字の配列も用意する。
      - 連結済文字列をキャッシュするのはやめる
      - index 情報の管理も行わない
      - カーソル移動の際は以下の 2 通りが考えられる
        - 配列の連結を用いて SCOSC を埋め込む (毎回全文字列を出力する)
        - update-positions を信用してカーソルを計算した位置に動かす

      | 更に、もう一つ考えるべき事として各文字の一つ一つについて描画属性を付加するか、
      | 同じ属性の文字が続いている限りは描画属性の付加を省略するか、という事である。
      | 各文字一つ一つに対して描画属性を適用すると出力が無駄に長くなってしまう。
      | しかし、同じ属性の文字が続いている限りは付加を省略する、という形だと
      | 切り貼りをする際に切った点に新しく描画属性を追加しなければならないので、
      | 各点に於ける描画属性を別に管理する必要があるという事が問題になる。
      |
      | ユーザから見えなくても、余り汚い出力はしたくないので、
      | 各点に於ける描画属性を管理する方向性を考えたい。
      | さて、これはどの様に管理するのがよいかという事になる。
      |
      | A 一番簡単な方法は各点に於ける描画属性を配列に格納しておくという方法である。
      |   下層 layer から上層 layer まで、各層でその層以下の集約結果を配列として保持するという事である。
      |   しかし、これは update がある度に各 layer で描画属性の配列をコピー・書き換えしなければならず、大変だ。
      |   特に、選択範囲や括弧対応の場合にはこの様な配列を管理し、一々書き換えを行うのは非効率に思われる。
      |
      | B そうではなく、各 layer について "描画属性を返す関数" を実装してその中で最も適した方法で
      |   属性値を計算し返すようにするというのも一つの手である。
      |   複雑な色付けを行っている場合には、単に内部で描画属性の配列を管理する様にすればよい。
      |   さて、各 layer で独立に描画属性を管理する場合 (つまり、より下の layer の値について関知しない時)、
      |   下層 layer への問い合わせを順次行う必要がある (勿論、これは関数の呼出側で行う)。
      |   これの overhead についても多少気になるが、
      |   そもそも更新時の切り貼り自体そんなに沢山の箇所で行うとは思わないので、気にしない。
      |
      |   (寧ろ全ての点について描画属性を即座に返せる様に配列で管理するという A の方が無駄である。)

      結局、描画属性を後で必要とする頻度は小さいとして B を採用する事にする。
      つまり、各 layer について指定した位置での描画属性値を返す関数を用意させる。
      描画属性値が設定されず下位の layer に任せる場合には空文字列もしくは -1 を返させる。

      さて、この様な実装を行うと決めたからには、再度描画用出力の生成関数を実装し直さなければならない…。
      後、既に書いたコードも利用できる様に、既に書いたコードを利用する layer も作った方が良い。
      或いは先にそれを書いてから実装を始める。

      各 layer に関する関数名は ble-highlight-layer:*/* の形式にする。
      ble-edit.sh は複雑化して来たので、これらのコードは ble-color.sh の方に実装する事にする。
      ble-color.sh は当初 highlighter の類を記述する目的で作ったが、
      新しく ble-sytax.sh を作成した事で使われなくなった機能などが沢山ある。
      これらを整理・統合する目的もある。

      実装した。動いている様なので差し替えた。

    取り敢えず今回の実装で以下の項目は解決した。

    | x 現在 update-positions で位置が変化しただけの部分に対しても表示用の SGR 付き文字列を更新している。
    |   これは省略できる筈。改行やタブなどで出力内容に変化のある部分については別に記録して後で合成して表示する。

    元々の目的である

    | x word の属性が解除されてもそれが表示に反映されない。

    に関しては未だ実装していない。レイヤーの仕組みを整えたは良いが、各レイヤーを実装する必要はある。
    word の属性を設定しているレイヤーをどの様に実装するのが良いかはまた別の問題である。
    これについては項目を改めて後で考える事にする。

2015-02-21

  * 描画用のシーケンス構築を高速化する

    色々考えた結果、最終的に (a) 描画用のシーケンスと
    (b) TAB 等の位置を制御しながら出力する update-positions を合成しなければならないので、
    a, b の両方を高速に合成可能な形に改良する必要があるという結論に到る。

    update positions の側に関しては、
    出力の文字が事前に予測不可能な物は TAB 等限られているので、
    予測不可能な物に関してだけ合成時に特別な処理を行うという方向で行く。
    つまり、描画用の側で予測可能な文字についてのシーケンスを生成してしまう
    (予測不可能な物に関しては適当な可能性の高そうな文字列を入れておく)。
    update positions 側では出力する文字に関しては、
    特別な処理を行った物についてだけ記録を行う事にする。

    現状の update-positions の実装について

    | さて update positions では複雑な事を行っていて lc だとか lg だとかの計算も行っている。
    | これらの動作について今一度確認してからでないと update positions を弄れない。
    | 確認事項については以下の通り。
    | - lc lg の詳細な動作について。
    |   例えば行頭や行末での処理、複数文字で構成される文字の場合は?
    | - lc lg で計算した結果を使っている箇所は何処か?
    |   それらの場所に影響が出ない様に書き換える必要がある。
    |
    | 取り敢えず何処で使っているかについて調べる事にする。
    | 先ず update-positions の中で出力している物は lc lk lj g である。
    |
    | | - _ble_line_text_cache_lc については、update-positions 及びその中から呼び出される
    | |   save-cursor で設定されている。そして、.ble-line-text.construct で参照されて
    | |   変数 lc の戻り値を設定するのに使われている。lc は .ble-line-text.construct の戻り値か、
    | |   或いは編集文字列が空の場合にはプロンプトの構築によって計算された値になる可能性もある。
    | |   lc はそのまま _ble_line_cur 配列の第2要素(base0)に格納される。
    | |   _ble_line_cur[2] は .ble-edit-draw.update-adjusted の中で取り出されて、
    | |   .ble-text.c2s を通してから READLINE_LINE に設定される。
    | |
    | | - _ble_line_text_cache_lk は update-positions 及び save-cursor で設定される。
    | |   .ble-line-text.construct の中の初期の方に lk に代入されている。
    | |   lk は .ble-line-text.construct の中のループで参照されているが変更はされていない。
    | |   %%どうやら _ble_line_text_cache は lk の計算のキャッシュとして働いている様子である。%%
    | |   更に export する様なコードの残骸も残っている様だが関連するコードが見当たらないので、
    | |   これに関しては廃止されてから久しい、或いは、何か書きかけて取りやめたという可能性が高い。
    | |   さて、改めてよく見てみると lk は lg を抽出する為に使われている。つまり、
    | |   カーソルの一つ前の文字を出力する時に使う lg が何かを計算する為には、
    | |   カーソルの一つ前の文字の文字 index が必要になりそれが lk になっているという事である。
    | |   lk はその他の用途では使われていない。
    | |
    | | - _ble_line_text_cache_lj はコメントの説明を見てもこれまた何の用途の為にあるのか分からない変数である。
    | |   実際に使われている所を見ると、多分これは以前に高速化を行おうとして実装し書けて終わった機能である。
    | |   改めてもう少し解釈を書いておく事にする。現在の実装では全ての文字について一々計算を行っている。
    | |   しかし ASCII の印字可能文字が続いている場合には毎回計算しなくても位置や文字の計算は唯単に
    | |   increment して行って設定するだけである。なので、その様な場合には最後の ASCII 文字まで
    | |   計算を抑えておいて、最後の ASCII 文字までいった時にそれまで溜めていた計算を一気に行う事ができる。
    | |   lj は連続する印字可能文字の最初の位置を保持していると考えれば良い。
    | |   或いは、もっと実際的な機能としては次に本来の計算を実行するべき index という事になる。
    | |   これがコメントに書かれていた説明である。
    | |
    | |   しかしながら、一気に計算を行うと言っても、カーソル位置計算は簡単にはできないので
    | |   結局毎回計算をする事になっているという具合である。今は常に lj=i-1 の状態でループが回っている。
    | |   カーソル位置計算についても一気に行うコードを書いたら (或いは、単純な increment を続けられる
    | |   という事が分かる範囲を計算して、その範囲内だけで一気に行う様にしたら) lj を実際に遅延させるコードに
    | |   移行する予定であったのだろうと予想される。
    | |
    | |   何れにしてもこの変数は実装の詳細というか、最適化の為に用意した物であるので、
    | |   今回位置から実装し直すにあたってこの機能を継承する必要性はない。
    | |   この変数について実装は未だ不完全であるし、似たような機能が必要になればまた新しく考え直した方が良さそうである。
    | |
    | | - _ble_line_text_cache_g _ble_line_text_cache_ei
    | |   何とこの配列は現在は使用されていない。現在の実装では .ble-text-line.construct の中で
    | |   _ble_region_highlight_table から直接 g を読み取って使っている。
    | |   元々は任意のカーソル位置にある g を取得する為に使っていたという事だろうか。
    | |   しかしそれは _ble_region_highlight_table から読み取れば良い事だし、
    | |   そればかりか _ble_region_highlight_table からの lg の読み出しですら、
    | |   描画SGRと update-positions の合成のループを毎回するので、その中でおまけ的に処理している。
    | |
    | |   と思ったが、もしかするとこれは最適化によって消えた変数ではなくて、
    | |   最適化の為に導入しようとして結局導入には到らなかった変数なのではないだろうか。
    | |   _ble_line_text_cache_ei という似た様な位置で定義されていて使われていない変数があるので、
    | |   多分そう言う事だろう。これらの変数は未だ使われていない変数である。
    | |
    | | - _ble_line_text_cache_cs の意味は明確である。表示の為に出力される文字である。
    | |   使い方も単純で .ble-line-text.update-positions で値を fill して、
    | |   .ble-line-text.construct の合成のループで中身を読み出すという物だ。
    | |   上記の2行以外では参照も代入もされていない。
    | |
    | | - _ble_line_text_cache_x, _ble_line_text_cache_y は _ble_line_text_cache_lc
    | |   と全く同じ経路を辿って、別の関数で使われている。
    | |   つまり、cx cy という変数に一旦入って _ble_edit_cur に格納され、
    | |   その後其処から読み出されて使われている。
    |
    | まとめると、
    | - _ble_line_text_cache_x, _ble_line_text_cache_y, _ble_line_text_cache_cs
    |   が主な計算の目的である。
    | - _ble_line_text_cache_lc, _ble_line_text_cache_lk
    |   は左側にある文字の文字コードと sgr を求めるのに使う。
    |   文字幅などの情報は出力しない。
    | - _ble_line_text_cache_lj _ble_line_text_cache_g _ble_line_text_cache_ei
    |   は実装しかけて中断している機能の為の変数の様に思われる。気にしなくてよさそう。
    |
    | さて、次にしらべるべきなのは lc と lk の処理方法の詳細についてである。
    | - 左側に複数文字からなる文字があった場合や、
    |   改行があった場合の取り扱いはどうなっているのか
    |   →複数文字からなる文字があった場合にはその最後の文字を READLINE_LINE に設定している。
    |
    |
    | - 左側の文字の開始位置 (x y) の管理はどうなっているのか
    |   →これは単に文字コード lc から計算される幅を使ってカーソル位置を ESC [ D
    |   で後退させるだけという実装になっている。なので lc さえあれば良いという考えだ。
    | - 出力する sgr は本当に常に左側の文字の物で良いのか。
    |   もしそうならば何故 i-1 等ではなく lk という変数が存在するのか。
    |   →行頭の場合には右側の文字 (なければ空白) を READLINE_LINE に設定して
    |     READLINE_POINT=0 を設定する様になっている。
    |
    | * lc が "文字列" ではなくて単一の "文字" である理由
    |   READLINE_POINT に設定する値を計算する必要があるから。
    |   文字列であっても各文字についてバイト長を計算すれば READLINE_POINT を計算できるが面倒だ。
    |   単一の文字だけというルールにしておけば一回 c2bc を呼び出すだけで済む。
    |
    | * lj で計算を遅延している理由
    |
    |   これは行頭の文字が来た段階では右側に来る文字を予測できないからである。
    |   右側の文字が確定してから lc を計算する。
    |
    |   > 改めて見てみると lj 周りの実装が少し複雑になっている。
    |   > カーソル位置が行頭にあるのが何回か続くと lj が更新されずに続く事になる。
    |   > これは一体何の為の物だろうか???
    |   > 行頭が何回か続くとその後で一気に更新が実行される。
    |   >
    |   > lj が何の為にあるのか漸くわかった。これは「カーソルが行頭にある場合には
    |   > 左側にある文字ではなくて右側にある文字の情報を返す」という仕様に関係している。
    |   > 行頭に文字がある時には未だ次に文字が来るのか別の改行文字が来るのか分かっていない。
    |   > 右側に通常文字が来た場合にはそれで良いが、改行文字が来た場合には改行を出力する訳にも行かないから、
    |   > 代わりに空白文字を出力する事にするのである。そしてそれど同時に READLINE_POINT を 0 にする。

    現状の実装がどうなっているかについては大体分かった。一番処理を複雑にしているのは lc lk の計算である。
    然し、ここで思ったのだが何故 lc lk を毎回計算してキャッシュしているのかという事である。
    x や y に関しては初めから順に計算して累積していかなければ計算する事ができない。
    なのでカーソルを移動するたびに計算するよりは前に計算した物を再利用した方が速い。
    しかし lc lk に関しては x y cs のキャッシュさえ残っていればどの様な物になるかはその場で計算できる。
    ループの中で累積的に計算し、その時の状態をキャッシュする仕組みにしていると先読みができないのでアルゴリズム的に苦しくなるが、
    x y cs を全て update した後に必要な所だけ計算するという事にすれば先読みも何もあった物ではなく簡単に計算できる。
    それに分離した方が bleopt_suppress_bash_stdout に応じて計算するかしないかの選択もできる。

    取り敢えず x y cs だけを計算してその後でカーソル位置の lc lk だけを計算する様に簡単化した version の
    .ble-line-text.construct を作成してみる事にする。
    →様々なバグや bash の不具合が途中で見付かった為に随分と中断してしまったが、
      .ble-line-text.construct の単純 version は直ぐに実装できた。

    さて使ってみるとバグが出てきた。C-u 等をした時に表示内容が変になる。
    保持している文字列は正常の様だから、shift に失敗しているのではないかという気がする。
    と思ったが、そもそも送られてくる BLELINE_RANGE_UPDATE の時点で変だ。
    10 文字ある文字列の 5 文字目で C-u を実行した場合 (0 0 5) 等となる筈だが、
    (9 10 9) という値が入っている。というか、これは最後に追加した文字の分である。

    何処で変な事になっているのか調べる。
    先ず ble-edit/dirty-range/update の呼出を調べる。
    ble-edit/dirty-range/update 0 0 5 等となって正しい値が設定されている様に見える。
    では結果の _ble_edit_str_dbeg の類はどうなっているか? →これも問題ない。

    分かった。やはり .ble-line-text.construct が悪かった。
    dirty<=0 の時に shift が行われていなかった。
    (9 10 9) という物が表示されている様に見えていたのは、前回の shift の時に出力した物を見ていただけであった。
    dirty<=0 の時には shift がそもそも行われていないので、その前後に設置した出力にも引っかかっていなかったという事である。
    これを修正したらすぐに動くようになった。

    次に、.ble-line-text/update-highlight-layer を実装した。
    これは更新の必要のある部分だけ出力データを更新する物である。
    特に、色付けの変わった文字の部分について再計算を行う。
    現在は update-positions によって位置が変更された部分についても再計算を行っているが、
    これは将来的に削除して、update-positions による更新は別の所で処理する予定である。

    さて、新しく実装したはいいが動きが変だ。
    特定の状態にある時にカーソルを移動するだけでも位置がどんどんずれていく。
    と思ったら、これは dbeg<0 なのにこれを変更開始点としてしまっている所があった為だった。
    単に dbeg>=0 を付け忘れていただけですぐに直った。

    未だカーソルの移動が遅いと思って色々試していたら、
    どうやら ble-syntax-hightlight+syntax の中が重い。
    parse は更新された範囲だけに対して処理をしているので遅い筈はない。
    というかカーソルの移動の時には呼び出されない。という事は、
    その後の属性値の適用が重いという事になる。
    取り敢えず umin, uend を用いてその範囲だけ属性値を更新する様にした。
    それでも遅い。どうも word に対しての処理が重い様である。
    良く考えたら毎回各 word に対してファイルかどうかの判定を行っている。
    これは確かに重かろう。修正した。

    さて。次の問題。属性値の適用を _ble_syntax_attr_umin ～ uend
    の間に限った事によって問題が生じている。
    "word による着色" がなくなった時に再び属性値を _ble_syntax_attr から
    復元しなければならないが、 "word による着色" は _ble_syntax_attr_umin
    等の管理の範囲外である。これを正しく実装する為にはやはり layer の様な仕組みが必要となる。
    しかし layer の仕組みを実装するに当たってどの様にすれば良いかについては申し越し考える必要がある。

    ここでは、以下の問題点を挙げて一旦閉じる事にする。
    - "word による着色" がなくなった時にその部分の着色がなくなるべき

2015-02-20

  * bash-3.1 ESC [ の受信について

    bash-3.1 での ESC [ を受信する為に、以前の修正で ESC [ を CSI に変換していた。
    然し、今回 bash-4.3 で C-@ を受信する為に C-@ (0) を UTF-8 の 2-byte 符号で受信し直す様にした。
    この方法を用いれば ESC [ も "ESC の 2-byte 符号" + "[" として受信し直す事ができる筈だ。
    この様にすれば ble-decode-char に特別なコードを書き込んで
    CSI を無理矢理 ESC [ に戻す等という事をしなくても済みコードも綺麗になる。

    変更した。正しく動作している。

  * <bug> C-x a 等に対して x が読み取られる。

    ble-decode-byte を見てみた所ちゃんと 24 97 が受信されているのでこれは bind の問題ではない。
    その後の文字の処理の問題か、キーの処理の問題である。

    今度は .ble-decode-char の方で何が受信されているかを確認する。
    UTF-8 decode に問題があるとは思われないので、ここでも 24 97 になっている筈である。
    →果たして 24 97 になっている。OK

    今度は .ble-decode-key の方で受信されている物を確認する。
    67108984 97 が受信されている。67108984 は 16 進数に直すと、0x4000078 である。
    これは Ctrl フラグと 78 = 'X' の組合せになっている。この時点でも問題点は内容に思われる。
    とすると問題があるのは .ble-decode-key の中で行われている処理だろうか。

    と思ったら今迄の処理にかなり問題があるという事が分かった。
    というか段々思い出してきた。色々書き換えようと思って弄っている途中で中断していたような気がする。
    (或いは、訳が分からなくなったが取り敢えず動いているから良いという事にしたのだったか。)

    - 先ず、.ble-decode-key.invoke の KEYS に代入される値について。
      ${var//_/ } ではなく ${var//_/} になっているので key 分割に失敗する。

    - .invoke-default で最後に入力された文字だけを見て既定の関数を呼び出している。これは変だ。
      というかそもそも invoke-default はこのタイミングで呼び出すべき物なのかも謎である。

    - また、.ble-decode-key.invoke に失敗した時に _ble_decode_key__seq をクリアしているので、
      .ble-decode-key.invoke && return
      fallback
      とした時に fallback に辿り着く時には _ble_decode_key__seq の情報が消えて無くなっている。
      _ble_decode_key__seq= は呼出側で処理する事にする。

    - 一致に失敗したというエラーを出力してから途中一致する物がないかを探索している。
      失敗したと表示したのに何かを実行するのは変ではないか?
      でも複数のキーからなるシーケンスで失敗した場合にはその複数のキーについてエラーメッセージが表示されて欲しい。

      例えば、一致に失敗した時に
      1 遡って適用できるシーケンスがないか探す。見付かればそれを処理して終わり
      2 もし任意のキーに対する既定の動作が設定されていれば、それを処理して終わり
      3 何も設定されていなければ全体のキーについてのエラーメッセージを表示する
      と言う処理にすれば良いのではないかと思う。x

      さて、これを実装する為には…遡って適用できるシーケンスが見付かって実行した時点で制御を呼出元に戻したい。
      が、現在の emit の再帰呼び出しの方法だとそれができない。emit 関数を再実装する必要がある様に思う。

    また良く分からなくなった。何が望ましい動作なのだろうか。
    ble_opt_error_kseq_discard の意味を変えた方が良い様な気がしてきた。
    現在の実装を見ると ble_opt_error_kseq_discard になっている場合は部分一致がある場合でも捨てる事になっている。
    しかしそうではなくて、部分一致すら見付からなかった時に残っている
    キーの列をどの様に処理するかというのを制御したいのではないか。
    部分一致について処理しないようにしたいのであれば、そもそも keymap にそういう物を登録しない様にすれば良いだけの話である。
    keymap に色々設定しておいてから、ble_opt_error_kseq_discard で部分一致なバインドを
    on/off にするという使い方も可能ではあるが直観的ではないし、何が便利であるのかも分からない。

    ここで、ble_opt_error_kseq_discard は部分一致も見付からなかった場合に残っている出力を捨てる為の設定とする事にする。

    再実装した。すっきりした。

  * <bug> C-@ を受信できていない @ bash-4.3 [2015-02-11]

    > * bash-4.3 C-@ について
    >
    >   bash-4.3 になって bind -x が三文字以上に対して使える様に bugfix されたが、
    >   同時に C-@ を含むような系列に対して bind が正しく処理されなくなった。
    >   現在 bash-4.3 において C-@ を捕捉する事は出来ていない。

    bind -X を見ると確かに
      "\C-@": "ble-decode-byte:bind 0"
    が登録されているのだが受信できない様だ。

    $ bash
    $ bind '"\C-@":"test"
    $ bind -s | less
    $ bind -x '"\C-@":"echo test"'
    $ bind -X | less

    とここまで来て C-@ を押したら
    bash_execute_unix_command のエラーが発生するという事に気付いた。
    (ちらつきを抑える為に bash の出力を殺したのは良くなかったかも知れない)
    →bash の出力をファイルに書き出して、それをチェックする事にした。
      エラーを吐き出していればそれを visible-bell で表示する。

    仕様がないので "C-@ *" に関しても全て登録する事にした。
    →"C-@ *" に割り当てても駄目なようだ。
      というか C-@ を何度も押しても C-@ を続けている限りはエラーも起きない。
      つまり C-@ に関連して bash は何か特別な処理をしている? 気がする。

    % 2015-02-19
    %
    % 現在の所 bash-4.3 において keymap が見付かりませんでしたと表示されるのは
    % C-@ だけなので、keymap が見付かりませんでしたエラーを受信したら C-@
    % を受信したという事にしてしまうというのも一つの手である。
    % これは既に bash-3 で C-d を受け取るのに使用している方法を使えば良い。

    念のため他の version ではどうなっているかも調べておく。
    bash-4.2 は C-@ は普通に受信できる。bash-4.0 でも普通に受信できる。
    bash-3.2 OK。bash-3.1 OK。やはり bash-4.3 だけで C-@ が受信できない。

    bind -x ではなく単に bind '"\C-@":"hello"' 等とすると正しく受信できると分かった。
    ならば bind '"\C-@":"\xC0\x80"' 等としてしまえば問題ない。
    "\xC0\x80" は UTF-8 の表現方式で 0 を表す。
    (但し、UTF-8 は或る code point を表すのに最小の長さの符号化を要求するので、
    上記は正しくない、或いは、正規化されていない表現、という事になる。
    何れにしても、これは直後に .ble-decode-char+UTF-8 で 0 に翻訳される一時的な物なので問題はない。)
    →これで呆気なく動くようになった。

2015-02-19

  * <bug> 4.3, 3.1 いつの間にかに日本語が入力できなくなっている。いつから?

    3.1 は別の問題であった。独立した項目にする。

    4.3 では無効なシーケンスですという(自分で書いた)エラーメッセージが出る
    3.1, 3.2 では謎の文字が入力される。というか ^# と表示される。
    4.0 では何故か入力できる。"あ" とすれば 227 129 130 が UTF-8 で受信されている。
    4.2 でも入力できる。

    あ E3 81 82

    と思っていたらいよいよ全ての version で読み取れなくなった。
    今迄読み取れていたのは何だったのか…。良く分からない。
    .ble-text.c2s と .ble-text.s2c を弄っただけの筈だが何故だろう。
    スクリプトが行けないのかと思って色々試したがよく分からない。

    と思っていたらそもそも受信している byte が 129 130 だけになっていた。227 が何処かに消えている。
    というか ESC にも bind できていない。色々とおかしい。

    何でか分かった。bind に使う文字をどの様に生成するかが関係していた。
    bind に使う文字は utf-8 でエンコードして渡しては行けない。
    直接バイトを指定するか、そうでなければエスケープシーケンスを用いて渡す必要がある。
    直接バイトを指定すると別の文字とくっついたりして変な事になりそうなので専らエスケープシーケンスを用いる事にする。


    2015-02-20
      と思ったら今度は \C-_ \C-[ \C-] \C-^ 等が動作しなくなった。
      \C-@ も今迄エラーメッセージが表示されていたのに、今は bell が鳴る。
      と調べてみたら、この部分の変更が原因になっていた。
      通常文字までもエスケープシーケンスを用いて表現してしまった為に、
      \C-_ \C-[ \C-] \C-^ が \C-\135, etc になってしまっていた。
      エスケープシーケンスにするのは 127 以上の文字 (8bit 文字 + DEL) だけにして解決した。

  * <bug> bash-3.1, .ble-text.s2c が日本語に対して正しく働いていなかった。

    先ず 3.1, 3.2 で化けている事について。
    内部的には正しく入力できている様なのでこれは簡単に解決できるだろう。

    ^# 等という文字はないよ?? と思ったが、恐らく C-# とデコードされているのだろう。
    と思ったがやはり変だ。info.draw でも ^# と表示されているこの文字は一体何か?
    info.draw では特別なデコードは行っていない筈である。
    改めてみてみると文字コードについて 0 以上であるという仮定に基づいた処理になっている。
    負の文字コードになっているのであろう。
    そしてそれは文字デコードのエラーフラグが立っている事を示す?
    と思って ble_decode_Erro を確認したが別に符号ビットではなかった。
    というか符号ビットを立てるような富豪はないように見える。^# とは一体何なのか…。

    うーん。そして実際に出力してみると正しく "あ" と入力されている様子である。
    表示だけが変になっているという事の様である。これは一体どういう事なのか…。
    改めて見てみると .ble-text.s2c が怪しい。
    実際に試してみたら果たして -29 という値を吐き出している。

    そしてこれがどの様に実装されているかというと結局
      printf '%d' "'あ"
    の様な事をしている。これを実行してみると確かに -29 と表示される。
    これは utf-8 で "あ" を構成する初めのバイト 227 を signed char で解釈した時の値である。
    さて、とすれば bash-3 で unicode の文字コードを取得する正しい方法を考える必要がある。
    試しに
      /usr/bin/printf '%d' "'あ"
    等としてみたら、227 と表示されて、変な文字が余っているというエラーを出力した。使えない。

    bash-3.1, 3.2 では "${a:b:c}" の形式ではバイト単位ではなく文字単位の操作しかできないし困った…。
    decode してしまったのが問題だったという事なのか。でも、補間の場合など ble-decode-byte
    以外を通して入力される文字列もあり、これらも正しく表示する為には ble-decode-byte+UTF-8
    で逐次キャッシュを作成するという方法は使えない。やはりちゃんと計算する方法が必要である。

    うーん。どうやら
    while read -n 1 a; do printf '%d' "'$a"; done <<<"${text:i:1}"
    とすれば何とかできる様ではある。fork するよりは速いだろうか。

    或いは、c2s があるならば二分法で攻めるという手もあるかもしれない。幸い utf-8 は順序を保存する。
    と思ったが c2s 自体が bash-3 では絶望的に遅いので二分法はしたくない。

  * <bug> bash-4.2 が segfault する。算術式中の配列要素に関係して。

    | 何処で落ちるのかと調べてみたら .ble-edit-draw.redraw の中である。
    | 更に調べてみると以下の様な何の変哲もない部分である。
    |
    | local dbeg dend dend0
    | ((dbeg=BLELINE_RANGE_UPDATE[0],
    |   dend=BLELINE_RANGE_UPDATE[1],
    |   dend0=BLELINE_RANGE_UPDATE[2]))
    |
    | と、ここで思い出したのだが何かの bash の version が、
    | 一つの算術式の中で複数の配列参照を行うと落ちるという問題があった様な…。
    | 少し試してみた: ((x=arr[1],y=arr[2])) これで落ちる。
    | これは面倒臭い。かなり大幅な書き換えをしなければならない。
    | というか patch を当てるんだったらこの動作についても patch を当てて欲しい。

    算術式の中で配列を使うと segfault する問題について。

    | 算術式の中で配列要素を参照すると、次の token に添字が適用されている様だ。
    |
    | 算術式の中で配列要素を参照して代入すると segmentation fault する。
    | 算術式の中で2回以上配列要素の値を参照すると segmentation fault する。
    | 例えば ((x=arr[1],y=arr[2])) で落ちる。
    | 代入するのは平気な様である。また、参照すると必ず落ちる訳でも無い様だ。
    |
    | 配列でない変数に対しても同様に落ちる。
    | 評価時というよりは構文解析時に落ちているのかも知れない。
    | 括弧で括っても駄目だし、カンマ以外で区切っても駄目。let でも駄目。'' で囲んでも駄目。
    | 結局、安全に評価する為には、複数の参照がない様にするべきなのか?
    |
    | 調べたら http://osdir.com/ml/bug-bash-gnu/2013-01/msg00042.html に報告が上がっている。
    | http://osdir.com/ml/bug-bash-gnu/2013-01/msg00043.html で解決したという事になっているが。。
    | 4.2.39 で少なくともエラーが発生していた様だ。手許の bash-4.2 は 4.2.53 なのだが。。
    | もしかして 4.3 には適用されたけれども 4.2 には結局適用されなかったという事か?
    |
    | 所で上記ページで報告されている ((a=b[1],b=1)) という式を試してみたが、これでも落ちる。
    | つまり、配列に対する参照を複数回行った事が問題ではないという事。。うーん。
    | どの様な時に落ちてどの様な時に落ちないのか。。
    |
    | うーん。gdb で見ると配列添字が来るはずの所に次の tok が来ている。
    | 例えば ((a=b[1],b,c=1)) とすると問題なく動く。
    | ((a=b[1],c,d=1)) でもOK。評価結果も異常はないように見える。
    | また ((a=b[1],0,c=1)) とすると落ちる。((a=b[1],0)) は OK。
    | ((a=b[1],c,d=b[2])) も OK。
    | というか何故か分からないが配列に対する代入を実行しようとしている?
    | つまり、"配列添字" が次の tok にも適用されてしまっているという事か?
    |
    | ((a=b[1],1+1,d=b[2])) これは落ちるが、
    | ((a=b[1],c+1,d=b[2])) これはOK。
    | ((x=(c=123,a=b[1],c+1))) これもOK。評価結果 $x も問題ない。
    |
    | 所で速度比較を行ってみる。
    | ((a=arr[i%3]));((b=arr[i%2+1]))
    | ((a=arr[i%3],dummy,b=arr[i%2+1]))
    | 殆ど違いはない様だ。dummy= として挟んだ方が微妙に速いという程度。

    何れにしても ble-syntax.sh で大量の算術式を使ってしまったから、
    これは大変な書き換えだ…と思って実際に書き換えてみた所、
    意外とクラッシュのパターンになっている式は少ない様だ。
    書き換えたら簡単にはクラッシュしなくなったので取り敢えずはこれで一件落着とする。

    全ての実行パスについて試した訳ではないので未だクラッシュする罠が残っているかもしれないが、
    それは落ちてから考えれば良いという事にする。

  * ble-decode.sh: bind C-x の変更

    改めてテストしてみた所 C-x 単体に対して bind して segfault するのは 4.2 だけの様だから、
    bash-4.2 の時にだけ "C-x *" のペアで bind する事にした。
    ペアで登録していると2文字目が入力されるまで C-x が届かないので、
    その他の bash の version では "C-x" 単体で bind する事にする。
    (とはいいつつ、emacs keymap の設定だと C-x C-x 等の key binding があるので結局は
    ble.sh の内部で 1 文字目の C-x が pending する事になる訳だが)。

    また、これに伴って既定で bind されている "\C-x *" が上書きされなくなるので、
    bind -sp で列挙した物を全て bind -r する事にした。
    今迄は "\e" で始まる物しか bind -r していなかったが、そんなに速度が変わる物でもないだろう。

    + C-x は 4.2 だけの問題化と思いきや、3.1 がクラッシュした。

      改めて複数の version で確認を取る事にする。
      3.1 は先に述べたように落ちた。具体的には C-x C-b C-b 等として落ちた。
      3.2 も同様に C-x C-b で落ちる。4.0 も同様に落ちる。
      結局 C-x C-b 等と打って落ちないのは bash-4.3 だけである。

      結果として bash-4.2 の時にだけ "C-x *" ではなくて、
      bash-4.2 以下の時は全て "C-x *" で bind する事にした。


  * <bug> 日本語を入力すると位置がずれる @ 4.0 bleopt_suppress_bash_output=

    →どうも 4.0 は 3 と同じ様に bind -x の前後でプロンプトを消去する様だ。
      という事で bind 前後のコードを 3 と共通の物にした。

    また、C-d を捕捉する事もできていない。これについても対応した。
    と思ったら、どうも C-d が捕捉できなかったのは、bind 前後のコードを
    3 と共通の物にした所為で IGNOREEOF が設定されてしまった所為であった。
    4.0 では READLINE_LINE が存在するからわざわざ IGNOREEOF を設定する必要はない。
    4.1 用のコードと同じように READLINE_LINE を設定すれば良い。

    という事で bind 前後のコードの分岐を増やす事にした。
    bash の bind -x 関数の呼出の前のプロンプトの消し方に応じて _ble_bash>=40100 で分岐するのと、
    bash が READLINE_LINE 変数を用意しているかどうかに応じて _ble_bash>=40100 で分岐するのを区別する。

    しかしそれでも未だログアウト時のメッセージの表示位置が変になっている気がする。
    その他のコマンドの実行の時にはずれていないからそれ程問題という訳でもない。
    これは後で対処する事にする。■

  * <bug> 4.0 日本語を入力すると (( の中で日本語を使ったという文句が出る。
    どこかの算術式に文字列が紛れ込んでいるのだろうか。

    と思ったら関係ない所を直したら何故か動くようになった。
    と思ったが、直した箇所は adjusted をするかどうか、
    つまり READLINE_LINE を用いて bash の出力を制御するかどうかの部分である。
    つまり、問題点は adjusted の部分である。
    もう一度 READLINE_LINE を用いる様に正しく修正して試してみる。これで問題が再現するはず。

    再現した。カーソルの位置と出力されるタイミングから言って、
    これは明らかに adjusted の中から発生している。
    adjusted の中身は弄っていないから lc の計算方法を変更した事が原因であるのは明らかである。

    どうやら .ble-text.c2w が $ret 変数に値を返すはずなのが何も値を設定していない様である。
    前回の値の "あ" というのが残っている。
    もっと調べてみると、どうも ret に予め "あ" 等の文字列が入っていると
    ret を計算する為の筈の算術式の評価に失敗してしまう様である。
    ret は代入される側なので予め入っている値が何であれ関係ない等と思っていたが、
    良く考えてみたら算術式の評価の方法上 ret の中身を展開してまで数式として解釈する筈で、
    ret に何が入っているか分からない状態で算術式を起動するのは危険という事である。

    ble-decode-byte+UTF-8 でも似たような問題がないかと確認してみたら、
    此方の方は全く問題はなかった。こちらは計算した値を使ってそのまま
    decode-char を呼び出す様になっていて、
    外部の関数が用意した変数に値を設定して制御を返すという方式ではないので、
    未初期化の変数が算術式の中に登場するという事は無い。

  * <bug> bleopt_suppress_bash_output= にした時にプロンプトが二重になる

    暫く bash の出力を抑制して処理を行う様にしていたが、
    試しに bleopt_suppress_bash_output= を再度設定して動かしてみた所、
    bash がプロンプトを出力する様になっていた…。
    何故だろう。bind/tail の直後に PS1 をファイルに出力しても PS1 は空だ。
    bash が PS1 の内容を覚えているという事だろうか?
    でも同じ version で少し前には正しく動いていたはずである。

    どうも blerc デフォルトの .bashrc をロードした時になる様だ。
    しかし何故だろうか。何か変な PROMPT_COMMAND が設定されているのかとも思ったがそういう訳でもない。

    どうやら bind -x したコードの内部で PS1 を弄っても反映されない様だ。
    外で PS1 を設定する必要があるという事。
    今迄は ble.sh ロード時に PS1= を設定していたので、それがずっと生きていて動いていたが、
    .bashrc をロードすると PS1 に新しく値が設定されてしまうので駄目という事。

    よく考えたら、今迄もプロンプトが表示されてからすぐに入力をしたりすると
    表示が乱れるなど思い当たる事が他にもある。プロンプトが表示されるのが ble.sh をロードした直後なのに
    その後に未だ .bashrc 等の処理を行っていたのが原因である。
    その時間差の間に何かを入力した事によって表示がずれていた。

    思うに ble.sh のロード・初期化と、実際にアクティブにする attach の操作を分離すべきである。
    ble-initialize ble-attach ble-detach 関数を定義する事にした。
    また ble.sh に noattach の引数を渡した場合には、その場での attach をしない様にした。
    必要な場合は後で ble-attach を呼び出して貰う事にする。

    →これで一応 bleopt_suppress_bash_output= の時にも動作する様になった。
      bash-3.1 の場合にも C-d を正しく捕捉できない事を除けば正しく動作する様になった様に見える。
      (とはいいつつやはりちらつきは気になる。)

  * <bug> ble-detach が動かない

    まとめ
    - awk のエラーメッセージが tmp/$$.bind.save に混入していた
    - awk の -v var=value の中の value はエスケープシーケンスが解釈される
    - bash-4.3 bind -X で表示されるコマンドは特別なエスケープがされていて bind -x では使えない

    > 色々あるが取り敢えず $_ble_term_fghr と言った類の物が直接表示されている。
    >
    > 後、awk を呼び出そうとしたり何か変だ。取り敢えず分かり易い所から。
    > $$.bind.save の中を覗いてみる…と思ったら awk のエラーメッセージが bind.save の中に混入している:
    > awk: 警告: エスケープシーケンス `\'' は `'' と同等に扱われます
    >
    > するべき事は、
    > - awk のエラーメッセージは別の所に出力されるべき
    >   gawk の幾つかの version からは "/dev/fd/数字" を用いる事ができるのでそれが利用できる。
    >   但し少し古い version の gawk で動かなければ結局これは積極的には採用できない。
    > - メッセージの通りエスケープシーケンス \' に対する処理を行う。
    >
    > 何と awk -v APOS="'\\''" 'BEGIN{print APOS;exit}' だけでエラーになる…。
    > awk -v apos="'" 'BEGIN{print apos "\\" apos apos; exit}' はエラーにならない。
    > つまり -v で渡したパラメータに含まれるエスケープシーケンスを解釈するという事???
    > 調べてみたら POSIX レベルでそう動作する事になっている様だ。
    > [[bash - Should awk expand escape sequences in command-line assigned variables? - Stack Overflow>http://stackoverflow.com/questions/13808909/should-awk-expand-escape-sequences-in-command-line-assigned-variables]]
    >
    > 1回 ble-detach して再び ble-attach するとまたプロンプトが2重になる。
    > →これは .ble-edit/edit/attach での guard が1回しかロードされない事を前提とした物だった事による。修正した。
    >
    > 1回 ble-detach して再び ble-attach して、更に ble-detach すると
    > detach できていない。それに加えて "bash: : コマンド見付かりません" というエラーになる。
    > コマンドを実行しようとすると実行できずに、実行コード全体を一つのファイルと見做して実行しようとしている??
    >
    > と思ったら ble-decode-byte:bind が復元対象に入っていた。
    > 復元対象に入らない様に awk でチェックしていたはずなのにと思って確認したら
    > ble-decode-bind と指定していた事によりチェックが正しく機能していなかった。
    > また、それとは別に復元の仕方にも問題がある。
    > "à": "ble-decode-byte:bind 224; eval \\\"$_ble_decode_bind_hook\\\""
    > 等と、過剰にエスケープされている。これについてもう少し詳しく。
    >
    > 始めに attach した直後には bind -spX すると以下の様になる。
    > "\C-@\C-@": "ble-decode-byte:bind 0 0; eval \"$_ble_decode_bind_hook\""
    > その後で ble-detach してもこの結果は変わらない。
    > この次に ble-attach した後に bind.save を見ると
    > bind -x '"\C-@)": "ble-decode-byte:bind 0 41; eval \"$_ble_decode_bind_hook\""'
    > 等となっている。問題はない様に見える。が、これで登録すると先程の様な事になるという事か。
    >
    > →色々 bind -X の出力を調べるとコマンドの中に制御文字が含まれているとエスケープされる様だ。
    >   先ず " と \ は \" と \\ に変換されている。また DEL は \C-? になり ESC は \e になる。
    >   それ以外の制御文字 (0～31) は \C-なんとか の形に変換される。
    >   これらを元の文字に復元する簡便な方法は存在しない様に思われる (bash の機能を使ったとしても)。
    >   仕方がないので awk で変換のコードを書く。面倒なので gsub を繰り返し適用する方針で。
    > →これで取り敢えず正しい bind -x コードを出力する事ができる様になった。
    >
    > さて、これを解決したらすっかり ble-detach が動くようになった。
    > bleopt_suppress_bash_output=1 でもちゃんと問題なく動いている様に見える。
    > 何度も ble-attach, ble-detach を繰り返しても動いている。

2015-02-18

  * 履歴展開の対応

    ^string1^string2^ の形式の履歴展開の場合、順に入力しても履歴展開と認識されない。
    というか :x 等の modifers も順に入力しても履歴展開に含まれない。

    解析再開点を履歴展開の直前に置いておくか、何らかの単語?として取り扱わないと駄目。
    (「この点までは stat に値を設定しない」という変数を用意して、
    先読みを実行した場合にその変数に値を設定するというのも興味深い方法である。)

    後、試して気付いた事だが !!$:a 等と定義されていない修飾子を指定すると、
    単に履歴展開をせずに実行されるのかと思いきや、履歴展開のエラーになってコマンドが実行できない。
    このエラー報告と整合性のある色付けにしたい。
    結局、履歴展開についても内部の文法構造を気にして実装するという事になるのだろうか。

    他にも s/../../ や ^..^..^ は途中で中断すると空文字列を指定したとして解釈される事も分かった。
    説明書に書かれていない動作が色々あるが、この動作であれば却って順に入力していけば
    正しく全体が履歴展開として解釈される。
    適当に実装したが現状で大体OKなのではないかという気がする。

  * CSI → ESC [ 翻訳について

    現在 bash-3.1 ESC [ → CSI や、ESC ESC → ... を default keymap に設定しているが、
    その他の keymap の時に処理されないのは問題である。
    例えば isearch の時に bash-3 では矢印キーが使えない事になる。
    もっと前の段階で変換をするべきなのではないか?

    charmap はそう切り替わる物でもないので charmap のレベルで受け取った CSI を
    ESC [ に変更するという方法があると良い。できればハードコードするのではなく一般的な枠組として。
    →と思ったが一般的な枠組にすると強力すぎる様に思うので取り敢えずは
      char==91 に対してハードコードして介入する事にした @ .ble-decode-char
      (utf-8 CSI を送信する様な端末があった場合にもこれで対応できた事になる…が、そんな端末があるかは不明。)

  * <完> bash-3 で C-d を捕捉する方法?

    今は IGNOREEOF を大きな値にして即座にログアウトされない様にしている。
    所で C-d を押すと
      Use "exit" to leave the shell.
    だとか
      ログアウトする為には exit を入力して下さい
    だとか
      シェルから脱出するには "exit" を使用してください。
    だとか言ったメッセージが出力される。

    現在 bleopt_suppress_bash_stdout を設定している場合には
    bash のエラーメッセージはファイルに書き込まれるので、
    このファイルを読み取る事で C-d を押した事を検知する事は出来る。

    但し、押された事が検知できるのは C-d が押された後に初めて別のキーが押された時である。
    C-d では何もイベントが起きてくれないので。

    強引な手だが、常にファイルを監視する子プロセスを作成して、ファイルに Use "exit" ... が書き込まれたら
    シグナルを $$ に送ってそこで処理するという手が使えるかも知れない。
    しかし子プロセスで常にファイルを開いて確認するのでリソースを食う。余り使いたくない方法である。

    また或いは bash のエラー出力先にコプロセスを置いておきそこで受信をするという手も…。
    こちらの方が未だましである。もしかしてこれで行けるんじゃないか…と思って実装してみた。
    動いている…と思いきやすぐにエラーを吐いて終了する。
      trap -- 'myfunc' USR1
    するだけでもエラーになって死ぬので、行っている処理の問題ではなさそう。
    代わりに RTMIN を使ってみたがそれでも同じエラーが発生する。
      trap -- 'echo hello' USR1
    という程度であれば何も起きない。trap の中で関数を呼び出すのが駄目という事だろうか。

    もしかしてシグナルハンドラの処理中にシグナルハンドラが呼び出されている??
    或る程度処理に時間が掛かる関数を設定するとエラーになって死ぬという事だろうか??
    →必要な時にだけ呼び出す様に変更したら動くようになった
      (とはいいつつもシグナルによって動作しているので流石に遅い。しかし何とか動いているので良しとする。)
    →と思ったが内部で呼び出している mv を止めたらそんなに遅くはなくなった。fork はやはり重いという事か。

    > 2013-06-13
    >
    >   * 制限: bash-3 では C-d を捕捉する事ができない。

    取り敢えずこれは解決したとして良いだろう。

  * ble-edit.sh, ble-decode.sh: bugfix, bash-3 でカーソルキーの類が動かない。履歴が読み込まれていない。

    これらの原因は同じ物であった。高速化の為にコードを生成してそれを直接 source していたが、
    その為に source とプロセス置換を組み合わせたのがいけなかった様だ。
    bash-3 では source はプロセス置換から読み取ってくれない。
    (パイプからは読み取らないというポリシーなのか、
    或いはシークできないと実行できないという事なのか分からないが。)

    source <( ... ) を eval -- "$( ... )" に変更。

2015-02-17

  * ble-syntax (ble-syntax-highlight+syntax): 入れ子エラーの色の範囲
    例えば "(( echo" 等の場合。
    閉じていない入れ子構造がある場合に、入れ子構造の開始字句をエラー色にしている。
    しかし、一文字目しか色を付けていない為、入れ子開始の字句が複数文字で構成される場合に不格好である。
    字句単位で色を付けられるように fill-g 関数を修正し、それを用いる事にした。

  * ble-edit.sh (accept-line): - で始まるコマンドを実行できない。
    履歴展開の為にコマンドを history に渡した時に history へのオプションとして解釈されていた。
    というか eval も - で始まるコマンドを扱えないし、history -s で履歴に登録する事もできない。
    eval に関しては -- 以降はコマンド部分として解釈される様なのでそれを用いる。
    よく bash の man を読んでみたら組み込みコマンドの章の一番上の部分に -- について書かれていた。

  * <bug> ble-syntax.sh: 1"$1" と入力してから先頭の 1 を消すと単語情報が壊れる。
    単語の長さが再計算されていない事による物と思われるが良く分からない。

    落ち着いて現在の実装でどの様な振る舞いになるはずかについて考える。
    1"$1" の時は 1 の部分に単語情報が格納されている。
    ここで 1 を削除すると単語情報も消えて無くなる。
    次に 1 の部分から解析が始まるがこの時に新しく単語の開始点が設置される。(長さ 0)
    所が (単語の開始点が前回と一緒である為) 単語の末端に達する前に解析が終了する。

    さて後段で前方の単語への参照を保持しているはずで、
    参照している単語開始点が編集の対象だった時は dirty 範囲をそこまで拡大する手はずになっていた筈だが。
    見てみると編集の対象かどうかの判定が [i1,i2) になっている。
    これは単語の先頭で編集が行われた場合にその単語は編集されていないという判定である。
    これについてはもう少し考え他方がよいのかも知れないが
    単純そうな [i1,i2] に変更する事にする。(単純な物の方が大概自然である。)

    % どの様にしなければならないかというと。
    % 単語情報を削除してその場に新しく単語情報を追加する場合、

  * <bug> ble-syntax.sh: ${1}1${1} の状態で真ん中の 1 の直前に空白を入れると壊れる。
    他の部分に空白を入れたり空白以外の文字を入れても何も起こらないが、
    該当箇所に 1 を入れた時にだけ壊れる。

    試行錯誤
    > これについても現在の実装でどうなっているのかについて調べる。
    >
    > 先ず shift の際に何が起こるかについて。${1}2${3} → ${1} 2${3}
    > とずらした事で単語の先頭 (${1}の前) に対する参照が更新される事は無い。
    > 単語の先頭は編集位置よりも前にあるからである。
    > …よく考えたら、${3 を読み取ろうとした時点で inest/wbegin の値が一致してしまうので
    > 其処で単語の読み取りが終了してしまう事になる。
    > 別の単語の中にいながら局所的に同一の文法状態になる事が原因で途中で解析が終了しているという事だ。
    >
    > 本当か? ではなぜ echo ""2${3} → echo "" 2${3} の時には問題が発生しないのか?
    > 残っている情報
    >   ${ を読み取る直前の wbegin は "" の先頭にある。
    >   ${ を読み取る直前の inest は -1 である。
    >   ${ まで読み取った時の wbegin は -1 である。
    >   ${ まで読み取った時の inest は ${ の先頭の位置にある。
    > 新しい解析
    >   ${ を読み取る直前の wbegin は 2 の先頭にある。
    >   ${ を読み取る直前の inest は -1 である。ここは不一致なのでここで停止する事は無い。
    >   ${ まで読み取った時の wbegin は -1 である。
    >   ${ まで読み取った時の inest は ${ の先頭の位置にある。ここで一致する気がするのだが…。
    > dirty-range の拡大も考慮に入れる事にする。
    >   dirty-range の拡大は wbegin/inest の参照先が編集範囲内にある時に発生する。
    >   ${ の外側では wbegin inest は常に wbegin=0 inest=-1 になっている。
    >   これは dirty range の拡大には寄与しない。
    >   ${ の内側では wbegin inest は -1 及び ${} の先頭になっている。
    >   そしてこの先頭 of ${ は編集の対象ではない。つまり dirty-range の拡大は起きない。
    > →もっと色々試してみた結果
    >   (字句単位1)(字句単位2)(字句単位N)${3} の時に、
    >   字句単位1 の直後に空白を挿入する場合は OK で、
    >   字句単位2以後の直後に空白を挿入する場合に駄目になるという事が分かった。

    原因
    "(字句単位1)(字句単位2)(字句単位N)${3}" に空白挿入 の際:
    - 字句単位1の直後に空白を挿入する場合には再開点が単語の先頭になり、
      単語の先頭も編集対象としてマークされる為に単語全体が更新対象になり問題が発生しないという事の様だ。
    - しかし、字句単位2 の直後に空白を挿入する場合には再開点は字句単位2の先頭になり、
      単語全体は更新の対象とは見做されない事になる(ここまでは期待している動作である)。
      所が、その後で内側のネスト状態に入った所で局所的に前回の解析と同じ状態になり停止するという事のようだ。
    - また、字句単位N の直後に空白を挿入した場合には ${3} 全体が更新対象になるのでやはり問題は発生しない。

    対処

    局所的な文脈の一致ではなくて全体的な文脈の一致まで考慮しないと問題が残る。
    例えば現在の実装ではネストレベルが異なる場合でもネストの開始位置さえ同じであれば文脈が一致したと解釈してしまう。
    実装当初には「ネストの開始位置さえ一致していれば文脈的には同じ構造に戻ったと見做しても良い」
    という想定を行っていたが実際にはネストの開始位置が同じであっても文脈の構造が変化した可能性があるという事だ。

    例えば (CTX_EXPR の中で) ( を上書きして [ にした場合などがこれに含まれるのではないかと思う。
    これは類似のまた別の問題だ。現在の文脈情報に開始括弧の情報を含めていない事による。
    開始括弧の対応まで一致しているかどうかを確認する為には [inest] の type が同じかどうかまで確認しなければならない。
    これの比較を怠っている事は結構不味い。

    結局、細心の注意を払ってすれすれで実装するのではなく、安全確実な方法を採る方が良い。
    つまり、現在のネスト情報を親まで全部含めた形で記録して一致するか確認を行う。
    その為のネスト情報をどの様に記録するのが良いか?

    > 一番簡単なのは stat に全ての情報を入れてしまう事である。しかしもう少し効率化できないだろうか。
    > 再開の為に必要なのは stat に現在記録している 3 つ組だけである。
    > 後は自動的に pop によって情報が復元されていく。
    > さて、stat には3つ組しか記録しない様にして、
    > 更に比較を行う為にその場で inest を辿って stat を掘り返す事にするのは非効率である。
    > 代わりに初期の nest 状態だけ復元して、
    > その後は push/pop する時に nest 状態を更新するというのはどうだろう。
    > しかし、この方法で現在の解析の nest 状態を更新する事は出来るが、
    > 前回の解析の nest 状態を追跡する事は出来ない。push/pop の情報は記録していないからだ。
    >
    > 仕方がないので stat に全てを記録してしまう事にする。
    > 幸い _ble_syntax_stat を参照しているのは殆ど ble-syntax/parse だけなので、
    > この関数内での取り扱い方法だけ変更すればOKである。
    > と思ったが…もし stat にネストの全階層を記録していると shift が滅茶苦茶な事になる。
    >
    > というか現在 _ble_syntax_nest に対しては shift を実行していないがこれについても shift する必要があるという事か。
    > 前回使った _ble_syntax_nest は今回は使わないので shift を実行する意味はなかったのである。

    うーん。面倒だ。取り敢えず動くようにする為には
    1. _ble_syntax_nest もシフトする様にする
    2. _ble_syntax_nest を掘り返して文脈が一致するかどうか確認する
    という事になる。掘り返すのは効率的かどうかは疑問だが取り敢えず実装する。
    (今迄問題にならなかった事から、そもそもそんなに掘り返さなくてもすぐに不一致になるのかも。
    改めて考えてみるに其処まで性能の劣化になる様にも思われないのでこれで良い事にする)。

2015-02-16

  * ble-syntax.sh: 単語終了判定の処理の変更

    ble-syntax/parse/word-end の判定は
    字句単位の開始時ではなくて字句単位の読み取りの終了時にするべき?
    というのも単語を部分編集するとその単語の長さが 0 になってしまうから。
    これは単語を部分編集した時の更新範囲が典型的にその単語の末端までになるので、
    解析もその単語の末端までで終了してしまう事が多いから。
    然し乍ら、word-end は次の字句単位の読み取りの際に呼び出されるので
    その字句単位の終端を設定する機会がないという事になる。

    % しかし、もし word-end の判定を字句単位の終端時に行う事にすると
    % 別の問題が発生する。単語の末尾に字句を追加した時に単語が伸張してくれない。
    % というのも字句の直前で既に単語が終了している事になっているからである。

    再開した時に正しく再開できる様にする為の簡単な条件は、
    その点での解析状態が次の文字に依存してはならない、という事である。
    しかしそれは少々無理がある。次の文字が分からなければ
    字句単位がそこで終わるのかどうかさえ定かではない為である。
    そこで、現在は解析の再開は変更のあった点ではなく「その点よりも前の最近の再開点」としている。

    従って、其処で単語が終了するかどうかの判定もやり直されるのではないかという気がする。
    例えば、単語の末尾に文字を追加する事を考える。文字を追加した時に解析の再開は
    追加した文字の箇所で起こる訳ではない。追加位置の一つ前の再開点から開始される。
    そして一つ前の再開点の時点では未だ単語は終了していない事になっている筈だから、
    正しく単語は伸張されると期待される。
    なので、取り敢えず字句単位の終わりの時点で単語の終了を判定する様に書き換えてみて動くか見る。

    呆気なく動いている。此方の方が実装としても単純だし自然である。
    →初めは CTX_CMDI の類の文脈が成功した時しか単語の終了判定をしていなかったが、
      実際に色々やってみると、nest から抜けた場合や
      CTX_CMDI の文脈で認識されないエラー文字があった場合にも
      そこに単語の終了が来る可能性があるという事に気付いたので、
      任意の ctx の処理の後に単語終了判定を置く事にした。
    →今後、"ctx の処理の後の ctx" に応じて適切な単語終了判定を行える様に
      WORDEND[ctx] 的な配列に関数を入れる事にしても良いかも知れない。

  * ble-edit.sh (_ble_edit_str, ble-edit/dirty-range): 変更範囲の合成について

    入力文字列に対する部分変更があった時に、全体を計算し直すのは非効率である。
    どの様な変更があったのかを記録しておき、変更がなかった部分の計算については省略するのが得策である。
    その為には部分変更を何らかの方法で表現・記録しておかなければならない。
    ここでは str1 → str2 への変更操作を
      str2="${str1::beg0}$ins${str1:end0}"
    の形に一般化して考える事にする。
    この時 str1 の [beg0,end0] の範囲が str2 の [beg,end] になったと考える。
    beg=beg0 であり end=beg0+${#ins} である。この時変更範囲を
      (beg, end, end0) の三つ組みで表す事ができる。

    今考えたいのはこの様な変更操作を 2 回行って str3 を得た時に、
    str1 から str3 への部分変更をどの様な三つ組みで表せるかという事である。
    ※勿論自明な解として (0, ${#str3}, ${#str1}) 等を考える事ができるが、
      今はできるだけ共通部分を長くしたい、
      つまり、変更部分の長さ end-beg を最小にしたいのである。

    式で考えようとしたが式の上での場合分けが面倒だ。
      str1 -(dbeg dend dend0)→ str2 -(beg end end0)→ str3 の時
      i2 = i1<begA?i1: i1<endA0?-1: i1+(endA-endA0)
      i3 = i2<begB?i2: i2<endB0?-1: i2+(endB-endB0)

    記号的に場合分けするのではなく、もう少し具体的に場合分けを考えた方が良い。
      str1 = A [ B ] C → str2 = A | X | C となったとする。
      更に str3 に入る時に何処に切れ目が入るか ("[]" で表す) で分類できる。
      (1) str3 = A0 [A1] A2 |     X      |     C
      (2) str3 = A0 [A1     | X0]     X1 |     C
      (3) str3 = A0 [A1     |     X      | C0] C1
      (4) str3 = A          | X0 [X1] X2 |     C
      (5) str3 = A          | X0     [X1 | C0] C1
      (6) str3 = A          |     X      | C0 [C1] C2
      先ず beg は明らかに min(begA, begB) である。
      次に end は max(endA-endB0+endB, endB) である。
      end0 は end から逆算できる。或いは end の由来を考えて場合分けすれば良い。
      end が endA-endB0+endB の時は endA0 がそのまま end0 になる。
      end が endB の時は end0 = endB0-endA+endA0 になる。

      式で書くと:
      beg = min(begA,begB)
      end = endB + max(endA-endB0,0)
      end0= endA>endB0? endA0 : endB0-endA+endA0
          = endA0 - (endA-endB0>0?0:endA-endB0)

      整理すると:
      beg = min(begA,begB)
      end = endB
      end0= endA0
      if((del=endA-endB0)>0)
        end+=del;
      else
        end0-=del;

    数式での間接参照?
      alpha=111 beta=alpha*2 pref=bet
      echo $((${pref}a))
      → ちゃんと 222 になる。。bash-4.3, bash-4.1, bash-3.1 で確認した。

2015-02-13

  * <完> グローバルで実行するという事?

    % 次の様な関数で eval すればグローバルで評価できるかも。
    % 少し試した段階では問題は生じていない。
    %
    % geval () { trap -- "$*" RTMAX; kill -RTMAX $$; }
    %
    % + 何とジョブ管理にも正しく登録される様である。
    %   グローバルな変数は勿論定義される。
    %
    % + 返却値については流石に kill の戻り値としては入っていないが中で適当に拾えば良い。
    %   geval () { trap -- "$*"$'\n'"echo exit=\$?" RTMAX; kill -RTMAX $$; }
    %   (改行で区切る様にしないと $* が & や ; で終わっていた時に文法エラーになる。)
    %
    %   後 trap の内容を復元する為に
    %   | originalTrap="$(trap -p RTMAX INT)"
    %   | ...
    %   | trap - RTMAX INT
    %   | test -n "$originalTrap" && eval "$originalTrap"
    %   等とすると良いかもしれない。
    %
    %   但し、この様にコマンド実行中だけ ble の用意した trap を実行していると、
    %   コマンド実行中はユーザの trap した内容が実行されないという事に注意する。
    %   (外部コマンドの場合には bash ではなく外部コマンドがシグナルを受け取れるので問題ないが、
    %   シェル関数の場合にはユーザが予め設定した trap でシグナルを受け取る筈だ。)
    %
    % + C-z 時の返却値 → OK 拾える
    %   C-c 時の返却値 → 駄目。拾えない。これは今迄と同じ。なので INT に trap する。
    %   INT の復元もした方が良い? → $(trap -p RTMAX INT) とするだけなので気にしなくて良い。
    %
    % + jobs で kill -RTMAX $$ と表示される。
    %   といっても kill -RTMAX の待ち状態という訳ではないようだ。
    %   証拠に geval の次のコマンドは geval 内のコマンドで C-z した直後に実行されるし、
    %   また、geval 内部で二つの less を呼び出して両方とも C-z しても正しく実行される。

    と思ったら幻想だった。そもそもグローバルで実行していない。
    現在の文脈のままでシグナルハンドラが呼び出されている様だ。
    つまり、シグナルハンドラが関数内の環境に影響を与えられるという事。

    今の所グローバルで実行できるのは bind -x だけしかない気がする。
    しかし bind -x した物を呼び出す為にはユーザに何か入力をして貰わないといけない。
    (入力を再現する方法が有れば良いがそれをシェル内から実行する方法はない気がする)。
    或いは何とかして readline の accept-line を呼び出す事ができればよいが。

    うーん。汚い方法ではあるが、
    bind -x で "ble-decode-byte:bind 1 2 3; eval \"$_ble_onafter_bind\""
    等として任意の物を外で実行できる様にしておくとか。。
    →この方針で実装してみた。存外問題なく動いている。

  * <完> 現在の C-c のトラップの実装に関する疑問

    return で良いのか? return が使えない場合があるかも?
    →サブシェルを作らずに同じプロセスで実行する場合、
      内側の環境になるのは関数か source しかない。
      つまり、一番外側でない限りは return が使える。
      つまり、現状の様に関数内で実行している限りは return は常に使えるという事。

    return で正しく抜ける事ができるのか?
    一番内側の 関数/source しか抜けられないのでは?
    或いは、入れ子になっている場合に誰が受信するのか?

    | 実験
    |
    | trap INT はどの様な場合に働くのか?
    | 直接 $ sleep 10 に対して C-c しても trap されない。trap が動く条件は? 色々試した。
    | 何か変だ。殆どの場合で動かない様に思われる。
    | bind -x の中からだとまた違った結果になるのか、それとも現在の実装は問題があるのか…。
    | $ trap -- 'echo INT $a' SIGINT
    | $ sleep 10 →×
    | $ : $(sleep 10) →○
    | $ echo 10 && sleep 10 →×
    | $ sleep 10 && echo 10 →×
    | $ (sleep 10) && echo 10 →×
    | $ func1() { sleep 10;}; func1→×
    | $ プロンプトが表示されている時に C-c→○
    | $ for ((i=0;i<100000;i++)); do :; done→○中断する
    |   ループ内では trap できて、しかも自動的に中断されるという事
    | $ fib1() { (($1<=1)) && eval $2=1 && return; fib1 $(($1-1)) ${2}L ; fib1 $(($1-2)) ${2}R; let $2=${2}L+${2}R; }; fib 20 x→○中断する
    |   関数の再帰呼び出しも trap できて、しかも自動的に中断されるという事
    | $ trap 'echo INT $2=${!2};return' INT; fib 20 x→○中断しない
    |   →何度 C-c を押しても最後まで抜けられない…。return があるかないかで動作が異なる様だ。
    | $ for ((i=0;i<100000;i++)); do :; done→○中断する
    |   →これは単純に return ができない為に return をしなかった場合と同じ動作をしているという事。
    |     結局 trap の動作は return コマンドを書いたか書かなかったかではなく、実際に return しているかしていないかを見ている。
    |
    | 分かった事
    | - trap INT は現在の文脈 (関数内/source内) で最大1回だけ実行される
    |   子プロセスが INT を受け取った場合などには受け取らない。
    | - 唯単に trap INT するだけの場合、シェル内で行われている全ての処理が自動的に中断される
    | - trap INT の中で return 等を実行した場合は、return の後で処理が続行される
    |
    | これを受けて C-c を受信した時にどの階層まで抜けるかをコントロールする方法は:
    | - 一気にシェルの処理を終了したい場合には trap の中で return 等を書かない。
    | - 一つ上の関数・source に戻りたい場合は trap の中で return を書く。
    | - 但し、関数呼出を沢山行っている場合 C-c で抜ける事ができなくなる可能性がある。従って return は書かない方が良い。
    |   任意の階数の関数・source を抜ける方法はない。

    結論

    現在の実装は関数の再帰呼び出しなどを C-c で停止する事ができない。
    →実際に試してみた for ループは抜けるが再帰呼び出しはその場では抜けられない。
      (一応各再帰呼び出しは抜けている様である。その為に、
      C-c をすると fib1 の結果が変わる (前回の呼出の時の結果が残っていると正しい結果になるが))
    →これは C-c によってシェル内の無限ループを止める事ができなくなる可能性がある事を示す。よくない。

      trap で $_ble_hook_INT 等として後処理をする関数を付け加え、return はしない様にするべき?
      →これだと local で変数が被覆されている場合などに正しく対処できない。
        まあ _ble_... を宣言しなければ大丈夫である。

    実際にその様に実装してみたら問題がある。
    どうやら bind -x の中で実行している場合には return しないとそのまま実行が継続する様である。
    return すると現在の呼出階層だけは抜ける事ができるので以前はその様に実装していたという事か。
    以下はその前提で書いてみたコード。結局これは使えないという事になった。
    > &pre(agh-prog-bash){
    > function .ble-edit/exec2/eval-prologue {
    >   .ble-stty.leave
    >
    >   # 履歴置換
    >   set -H
    >
    >   # C-c に対する trap
    >   _ble_edit_exec_original_trapint="$(trap -p INT)"
    >   trap .ble-edit/exec/eval-TRAPINT INT
    >   trap 'echo INT' INT
    > }
    > function .ble-edit/exec2/eval {
    >   # BASH_COMMAND に return が含まれていても大丈夫な様に関数内で評価
    >   .ble-edit.accept-line.exec.setexit
    >   eval "$BASH_COMMAND"
    > }
    > function .ble-edit/exec2/eval-TRAPINT {
    >   # eval 中にシェルの処理で C-c (SIGINT) が来るとここに入る
    >
    >   # シェルが C-c で中断した時の終了値
    >   if ((_ble_bash>=40300)); then
    >     _ble_edit_accept_line_lastexit=130
    >   else
    >     _ble_edit_accept_line_lastexit=128
    >   fi
    >
    >   .ble-edit/exec2/eval-epilogue
    >
    >   # 未だ残っていれば続きを実行
    >   # (今迄実行していたコマンドは _ble_edit_accept_line[] から既に削除済)
    >   .ble-edit.accept-line.exec
    > }
    > function .ble-edit/exec2/eval-epilogue {
    >   # C-c trap を削除
    >   trap - INT
    >   eval "$_ble_edit_exec_original_trapint"
    >
    >   .ble-stty.enter
    >   _ble_edit_PS1="$PS1"
    >
    >   .ble-edit.accept-line.exec.adjust-eol
    >
    >   # SIGERR処理
    >   if [ "$_ble_edit_accept_line_lastexit" -ne 0 ]; then
    >     if declare -f TRAPERR &>/dev/null; then
    >       TRAPERR
    >     else
    >       echo "[91m[ble: exit $_ble_edit_accept_line_lastexit][m" 2>&1
    >     fi
    >   fi
    > }
    > function .ble-edit/exec2/recursive {
    >   (($1>=${#_ble_edit_accept_line})) && return
    >
    >   local BASH_COMMAND="${_ble_edit_accept_line[$1]}"
    >   _ble_edit_accept_line[$1]=
    >   if test -n "${BASH_COMMAND//[ 	]/}"; then
    >     # 実行
    >     local PS1="$_ble_edit_PS1" HISTCMD="${#_ble_edit_history[@]}"
    >     local _ble_edit_exec_original_trapint=
    >     .ble-edit/exec2/eval-prologue
    >     .ble-edit/exec2/eval
    >     _ble_edit_accept_line_lastexit="$?"
    >     .ble-edit/exec2/eval-epilogue
    >   fi
    >
    >   .ble-edit/exec2/recursive "$(($1+1))"
    > }
    > }

    ここで trap - RETURN という物を発見する。関数やソースを抜けるたびに実行されるという物のようだ。
    正にこれを使えるのではないか…? と思って trap '((_ble_edit_accept_line_INT)) && return' RETURN
    等としてみたら無限ループになる。それどころかメモリを食い荒らしている。
    ${FUNCNAME[*]} で確認すると RETURN が評価されるのは抜ける関数やソースの中である様だ。
    そこで return を呼び出すと再び trap RETURN が反応してしまうという事になっている様だ。
    つまり、trap - RETURN を用いても呼出元の文脈で評価される訳ではないので呼出元を更に抜ける事はできず、
    その上無限ループになってしまうという事になる。
    #trap '((_ble_edit_accept_line_INT)) && return' RETURN # 無限returnループになる

    今度は trap ERR して見ようとしたが…そもそも呼び出されないようだ。
    (それに trap ERR だと条件式の内部にあるコマンドについては呼び出されないというし確実に抜ける事は出来ない)
    #trap '((_ble_edit_accept_line_INT)) && echo hello && return 128' ERR # 呼び出されない

    或いは trap DEBUG というのを使う事ができるかもしれない。
    DEBUG について色々試してみた。
    - 先ず、trap 'command' DEBUG した command の中では DEBUG は一切発生しない。
      (もし発生していたら無限ループになってしまう。)
    - また、bind -x 関数の中で trap - DEBUG しても bind -x の関数を抜けると消える。
    - trap - DEBUG 等を用いて削除しようとしても何故かできない。trap -p でも何故か一覧に出ない
      | 更に、trap 'command' DEBUG の command の中で trap - DEBUG しようとしても消えない。
      | trap 'echo 123' DEBUG 等と DEBUG を上書きする事もできない。
      | というか trap の中でなくても上書きできない様だ。それどころか trap -p の一覧に出ない。
      | (通常のシェル環境で実行している場合にはちゃんと trap -p で出るのだが)。
      | trap DEBUG した関数内では trap -p の一覧にも出るし trap 'echo 123' DEBUG で後から書き換える事も出来る様だ。
    trap DEBUG をその場で削除できないという謎があるが取り敢えず動く様になったので良しとする。

2015-02-11

  * <bug> home, C-home, ... 等多くのキーに対して keymap が見付からないエラーになる

    やはり初めからシーケンスが登録されているキーに関しては
    中途半端に bind -x するとこのエラーになる様だ。
    bind -x が2文字までしかできないバグは bash-4.3 で解消された様だから、
    登録されているキーシーケンスを全て bind -x してしまう事にした。

    登録されていないキーシーケンスを入力した時には依然として
    keymap が見付からないエラーが発生するが、
    登録されていないエスケープシーケンスは先ず来ない事と、
    来たとしても自然に解釈する事ができないのでこのままでも良い。

    登録されているキーシーケンスの列挙は例によって時間が掛かる様なので、
    これもキャッシュとして出力してしまう事にした。
    実際にやってみて良好に動いているので良しとする。

  * <bug> ログアウトした後も stty の状態が正しくない。

    % 1 stty が正しく呼ばれているか? 正しく適用されるにはどうすれば良いか?
    %
    %   - visible-bell が最後に勝手に enter しているのかもしれないと思って切ったが駄目。
    %   - enter した時に x と表示する様にして最後に enter が起こっていないか
    %     確認したが起こっていない。
    %   - stty してから暫くしないと適用されないのかと思って sleep して見たが駄目。
    %   - stty してから何か出力しないといけないのかと思って leave してから
    %     メッセージを表示する様にしたが駄目。
    %
    %   C-d の中で leave して cat を実行すると C-c 等で終了できない。
    %   通常のコマンド実行の際にはちゃんと C-c できるのに何故だろう。
    %   何か設定で間違えている事があるのか、関数のネストが関係するのか、...。
    %
    %   cat は C-c が効くのに exit 後は C-c が効かない
    %   そして exit コマンドを実行して終了する時にも stty は正しく設定されていない。
    %   cat の時には正しく設定されていて exit の時には正しく設定されていない理由は何か?
    %   或いは bash 自体が何処かの時点での stty の状態を記録していて
    %   exit の時にその記録した時点での stty に設定してしまうのだろうか。
    %
    %   改めて確認してみる。
    %   C-d の中で直接 cat すると C-c できないが accept-line.add して実行して貰うとちゃんと
    %   C-c で止める事ができる。そこで exit を accept-line.add してみる殊にしたが、
    %   終了後の stty の状態は壊れた状態の儘である。
    %
    %   1 何故かは分からないがその場で実行しても stty は適用されないが
    %     accept-line の実行の枠組を使用して実行すると stty が適用されている。
    %     しかし次の項目にある様にこの振る舞いは今回は訳には立たない。
    %   2 accept-line の枠組を使用して stty が適用された状態にしても、
    %     そこから exit した場合には stty の状態は反映されない。
    %     途中に外部コマンドを挟んでも駄目。
    %
    %   .ble-stty.setup を殺して一度も stty で undef をしない様にしてみたら、
    %   当然の事ながらログアウト後に壊れているという事はないようだ。
    %
    % 2 detach してから exit するという事
    %
    %   bind -x 内 で exit しても勝手に stty の設定が壊れた状態に戻ってしまう。
    %   一旦 stty を正常な状態にして ble だけを終了し、
    %   その後で手動で exit したらどうなるか?
    %   つまり、ble の "detach" だけを行って exit をしない時 stty が壊れなければ、
    %   その後に普通に exit をする事で stty が壊れない様にできる。
    %
    %   これを試す為に、ble の設定を全て解除するコードを書く必要がある。
    %   つまり bind -x した物を全て外し、元々 bind されていた物を再適用する。
    %   →stty が正常な状態で復帰できた。この後で exit をしても壊れない。
    %
    % 3 しかし detach するだけだと分かりにくいのでやはり exit についても実装する。
    %
    %   その場で detach をして bind -x から抜け、その後で時間差で抜ける。
    %   その為にシグナルを用いる。
    %
    %   所が、シグナルハンドラの中で exit をするとその stty の状態で終了する様なので、
    %   シグナルハンドラの中でも stty で正しい状態を設定する様にする。
    %   これで正しい stty の状態で抜ける事ができる様になった。
    %
    %   所が、また問題がある。どうやら入力待ち状態にある時にシグナルは受け付けない様だ。
    %   まあ、スレッドが止まっている状態なのだから当然と言えばそんな気もする。
    %   この所為で次の文字を入力した時に初めて exit される。
    %
    %   と、ここでその場でシグナルを自分に投げたらどうなるのか…と思う。
    %   シグナルハンドラの内部からならば設定した stty で exit できる…
    %   という事はその場で読んでしまって充分なのではないか。
    %   と思ってその様に実装したら期待通りに動く…。
    %
    % 4 残っているのはユーザが exit コマンドを使用した時である
    %
    %   そのまま exit/logout されるとやはり stty が壊れる。
    %   exit/logout 関数を上書きすれば良い。
    %
    %   exit() {
    %     if (($BASHPID==$$)); then
    %       _ble_edit_detach_flag=exit
    %     else
    %       exit "$@"
    %     fi
    %   }

    と、ここで man の exit の所に EXIT トラップについて書かれている…。
    もしかしてこれを設定すれば良いだけの話では…。。
    結局 trap .ble-stty.exit-trap EXIT の一行で済む話だった。

    一応 detach という機能が実装されたので今回の変更が完全に無駄になった訳ではないが。

  * rcfile として起動すると history がロードされない。
    rcfile の中で history を参照しても中身が未だロードされていない様だ。
    history -n で読み込む事にした。

  * C-S-a 等の \e[2... が読み取れない。というか単なる [ に変換されている…?

    これも同様に bash_execute_unix_command のエラーが発生している様だ。
    試しに bash --norc として起動してから source ble.sh して見たら起きなくなった。
    なので、これに関しては余り気にする必要はない。
    bash --rcfile ble.sh 等として起動すればよい。

    所で --rcfile で起動すると history が正しく読み込まれていない。
    source ble.sh で起動した場合には正しく読み込まれている様である。
    rcfile の中では history を読み取る事が出来ないという事だろうか。

  * ちらつきを抑えるという事

    ちらつきを抑える為に ble-decode-bind:bind が呼び出される前後で
    標準出力・標準入力を繋ぎ変えて見る事にした。

    % が、ちらつきは変わらない。
    % 今迄ちらつきの無かった所ではちらつきがない儘だし、
    % ちらつきが起こっていた所はちらつきが起こっている。
    %
    % 設定を間違えると何も表示されなくなるから標準出力・標準入力の繋ぎ替え自体は
    % 効いていて、bash が出している物は出力されなくなっている筈である。
    %
    % | 但し、他の可能性もある。
    % | もしかすると bash は fd を個別に持っていてそれに対して出力しているかも?
    % | そうすると繋ぎ替えを 1 2 に対して行っても bash 自体の出力先を変更できない。
    % | 上の実験で何も表示されなくなったように見えたのが勘違いの可能性もある。
    % | つまり、ble では PS1 を空欄にしているので bash が何も出力していない様に見えるが、
    % | 実際には行を消してしまう物を出力しているかもしれない。)
    % |
    % | 念のため簡単なテストをしてみる。
    % | $ exec 3>&1
    % | $ function on { exec 1>&3 2>&3; }
    % | $ function off { exec 1>/dev/null 2>/dev/null; }
    % | $ bind -x '"\C-o":"on"'
    % | $ bind -x '"\C-p":"off"'
    % | 以上の設定の後で C-o C-p で表示・非表示が切り替わる事を確認した。
    % |
    % | つまり bind -x の内部で exec してもちゃんと bash のプロンプト表示も影響を受ける。
    %
    % という事は、ちらつきは bash がプロンプトをクリアする事によって起こるのではなく、
    % ble 自体の再描画によって起こっていると結論する事ができる。
    % (bash がクリアしたプロンプトを直後に再描画しているのは功を奏しているという訳だ)

    改めて動かしてみるとちらつきは起こらなくなっていた。
    テストの時に新しい物をちゃんとロードできていなかったという事か。
    何か腑に落ちないが今後はこの方針で行く事にする。
    一応 ble_opt_suppress_bash_output オプションで繋ぎ替えを off にできる様に残しておく。

    一応註記しておくべき事は、exec で標準出力・標準入力を潰しても
    カーソルの位置などが乱れる事なく動作しているという事である。
    と思ったらカーソルの位置がずれている…。
    →.ble-edit-draw.update-adjusted の関数内で bash の出力に対する対策をしていたので
      exec を実行している場合にはその対策を行わないように修正した。これで動いている。
    →が、しかし今度は C-d で前触れ無く (後処理無く) ログアウトする様になってしまった。
      READLINE_LINE READLINE_POINT の設定はその儘にして位置調整のシーケンスの出力だけ
      を行わない様にした。

    もう一つの確認事項は vbell のクリアがちゃんと出力されるかという事。
    これは 1 2 が端末に繋がっている時に fork している筈だから出力されるのではないかと思うが。
    →実際に試してみた所ちゃんと vbell の消去が出力されている様なので問題ない。

2015-02-09

  * <bug> bind -x '"\"":...' 及び bind -x '"\\":...'

    cygwin の bash-4.1 で改めて動かしてみた所色々問題がある

    1 '\' と '"' が bind -r できていない
      良く考えたら bind -r している訳ではなくて bind -x で上書きをしているのであった。
      そして bind -x している物を調べたら先程弄ったコードの簡単なミスだった。修正。

    2 カーソルキーの類が全て M-\\ と解釈されている
      これは 1 に関連する物だった \\ に bind する代わりに \[ に bind していた所為で
      CSI が M-\\ に翻訳されてしまっていたというだけの話であった。

  * <bug> bash-4.3 日本語が入力できない。
    8bit 文字は \ooo の形式で bind -x '"\ooo":...' しなければならなくなった。

    | 以前までは bind -x ではマルチバイト文字を 1 文字ずつしか受信できなかったのが、
    | いつの間にかに日本語として受信できるようになった様だ。
    | 今迄は octet の 256 文字を全て登録する事で入力を全て横取りできたが、
    | この所為で unicode にある全ての文字について bind しなければ日本語を受信できなくなった。
    | どうするか…。
    |
    | 例えば以下を設定した状態で "あ" と入力すると hello となる。tttqqqrrr とはならない。
    | hello を bind していない状態だと tttqqqrrr となる。あれ、受信できている…。
    |   bind '"\343\201\202":"hello"'
    |   bind '"\343":"ttt"'
    |   bind '"\201":"qqq"'
    |   bind '"\202":"rrr"'
    | つまり bind -x では受信できない、という事なのか? と思ったらちゃんと受信できる。
    |
    | では ble.sh で受信できないのは何故か? \ooo の形式で指定する必要がある?
    | と思って \ooo の形式で指定する様にしたら直ぐに入力できる様になった。

  * <bug> bash-4.3 "ESC [ 数字" 系のシーケンスを入れると
    bash_execute_unix_command: keymap云々 のエラーになる。

    問題: C-left C-right を使おうとするとキーマップがないと出る

    これは bash --norc から source しても変わらなかった。
    $ TERM=dumb bash --norc
    $ TERM=screen-256color; source ble.sh
    等としても同じだ…
    (というか source ble.sh する前に C-left C-right を試したら TERM=dumb でも動く。)

    他にも試してみたがどうも "ESC [ 数字" 系のシーケンスが全部駄目な様だ。

    仕様がないので "ESC [ *" を全て登録する事にする

  * <bug> bind -r すべき対象を bind -sp | fgrep していたが fgrep が結果をバイナリと判定する事がある

    fgrep -a とオプションを指定する事で解決した。

    | %%問題: bash で起動するとカーソルキーを使えるが bash --norc で起動するとカーソルキーを使えない%%
    |
    | これは謎である。~/.bashrc の中で設定しているものと関係があるのだろうか。
    | source ~/.mwg/bashrc; source ble.sh とするとカーソルキーを使える。
    | source ~/.mwg/share/mshex/shrc/bashrc_interactive でも使える。
    |
    | test-prebind.sh に bashrc_interactive の中から bind 関係の部分を抜き出してみても使える。
    |   どんどん絞り込みをしていく。複数の bind の組合せで起こっている?
    |   かなり不思議な事が起こっている…コメントの有無で結果が変わる…。
    |   そればかりか末尾の改行の数にも依存している。再現性がある事は明らか。
    |   改行の数が一定数以上ならばOK? でも改行の後に何があるかにも依存している。
    |
    |   bind よりも前に何を書いても大丈夫なように見えてコメントを沢山書いたら駄目になった。
    |   どうやら bind よりも前のコメントに何が書かれているかにも依存する様である。
    |   仕方がないのでコメントは以下に移動してくる。
    |
    |   # @bash-4.3
    |   # 以下を読み込んでから ble.sh を読まないと何故かカーソルキーが使えない
    |   #   bind よりも後の空白の数だとかコメントの文字数が
    |   #   違っただけで使えたり使えなかったりする。
    |   #   コメントの内容によっても結果が異なる様だ。
    |   #   bash のメモリ関連のバグだと思われる。セキュリティ的に危ないんじゃないか??
    |
    |   また気付いた事だが、暫く時間が経つと先程まで動いていた test-prebind.sh では動かなくなったりする。
    |
    | bash のバグとしか思えない動作なのでここでは置いておく事にする。
    |
    | →何と新たな事実が判明した…。
    |   カーソルキーが使えない場合については ble.sh 内の bind -r が走っていない。
    |   色々調べると bind -sp は色々物を出力しても、
    |   fgrep の段階で「バイナリ」と判断されたり判断されなかったりする様だ。
    |   fgrep でバイナリと判断されると中身が表示されない為に bind -r が走らない。
    |
    | 結局 何故 bind コマンドの周りのコメントやら何やらが fgrep のバイナリ判定に影響を与えるのかは分からなかった。
    | コメントの有無などで bind -sp で表示される順序などが変わるという事なのだろうか。
    | 或いは fork 元の bash のメモリの内容に fgrep の判定が影響を受けているとか。

  * "bash: bash_execute_unix_command: コマンドのキーマップがありません" と出る問題

    久しぶりに起動してみたら色々と動かない? @bash-4.3 of padparadscha

    カーソルキーを入力しようとすると
    bash: bash_execute_unix_command: コマンドのキーマップがありません
    等と表示される。検索すると bind -x した時の bind 先が不明な場合に発生するエラーメッセージの様だ。
    ESC で始まるキーシーケンスに対応するキーは全てこれなので ESC 関係が悪さをしているのだろう。

    bind -x した物の一覧を取得する方法があれば良いのだが。
    以前に探した時には見付からなかった気がするが、改めて調べてみる。と、
    bash-4.3 以降では bind -X を用いて bind -x した物の一覧を表示する事ができる様だ。
    早速試してみると確かに bind -x した物の一覧を閲覧する事ができる。

    そこで bind -x した物の削除を試みる。
    普通に bind -r $'\ez' しても削除できない…。
    と思ったら実はちゃんと削除できているが bind -X の表示に反映されていないだけという事が分かった。

    <bashbug> bash-4.3.33, bind -r して削除した後のコマンドが bind -X の一覧から削除されない。

    分かった事: 2文字シーケンスを登録すると1文字目にkeymap変更が割り当てられる

    | どうやら一回でも 2 文字のシーケンスを登録してしまうと
    | それらを全て削除しても 2 文字のキーシーケンスに対応する keymap を探す様だ。
    | 例えば "ab" というシーケンスを登録すると
    | 「"a" は2文字のキーシーケンスの1文字目」という情報が登録されてしまい、
    | a に続けてどの様な文字を打っても対応する2文字のキーシーケンスが見付からない!
    | という状態になってしまう。(実際に "ab" で試してみたらそうなった。)
    |
    | ※唯単に bind -x '"ab":"echo"' && bind -r ab 等としただけでは再現しない。
    |   予めあらゆる 1 文字コマンドについて bind -r && bind -x ... しておくとなる。
    |   bind -x でない通常の readline 関数がそれぞれの文字に割り当てられている場合はそれが呼び出される様だ。
    |   しかし、全てを bind -x で処理する為に readline 関数を解除していると "見付からない" という事になる。
    |   再現方法は以下の通りになる:
    |
    |   $ bind -x '"ab":"echo"' && bind -r ab && bind -x '"a":"echo"'
    |
    |   1つ目のコマンドも3つ目のコマンドも -x でなければ再現しない様だ。つまり、
    |   $ bind '"ab":self-insert' && bind -r ab && bind -x '"a":"echo"' → 再現しない。問題なし。
    |   $ bind -x '"ab":"echo"' && bind -r ab && bind -x '"a":self-insert' → 再現しない。問題なし。
    |   という事である。
    |
    | これを解決する為には "a" で始まるあらゆる2文字のシーケンスを登録すれば良い。
    |
    | これは C-x の状況と似たような状況である。
    | (以前の bash で試した時には C-x に続けて何か入力すると bash 毎落ちていた。
    | これがエラーメッセージを表示するという状態に修正されたのだろう。)

    取り敢えず "ESC なんとか" は如何にも bind -x で登録されそうな組合せなので、
    "ESC *" の全ての組合せを登録してしまう事にする。
    実際には bind -x でどの様な2文字のシーケンスが登録されているのか分からないので、
    あらゆる "* *" の組合せについて登録しない限りは万全とは言えない。
    とはいいつつあらゆる組合せについて 2 文字単位でしか入力を読み取れない状態にもなる。
    これは明らかに不便だ。結局、"ESC *" の組合せを登録する程度が限界だろう。

    分かった事2: ESC は bash-4.3 では初めから2文字のシーケンスの一部と解釈される

    | bash --norc で起動した状態から source ble.sh した場合は ESC * に bind しなくても良いかと思ったが、
    | 実際に試してみた所同様のメッセージ bash: bash_execute_unix_command: コマンドのキーマップがありません
    | が出る。bind -X で確認したが、やはり bind -x は何も存在していない状態から source ble.sh だった。
    | その他の version の bash がどうなのかは試していない。

    つまり、bind -x を何もしていない状態でも "ESC *" に対して bind しなければならないという事。


2013-06-13

  [Done]

  * <bug> bash-3.2.48, bash-3.1: カーソルの表示位置がずれる。
    と思ったら、そもそも READLINE_LINE 及び READLINE_POINT に対応していない様だ?
    これだと C-d で即座にログアウトしてしまう…。

    →これに関しては READLINE_LINE は空白のままで諦める事にした。
      この状態であれば bash による出力は何も為されないので、
      カーソル位置の修正などを行う必要はなく、ただ .ble-edit-draw.update を実行すればよい。

    →また、C-d に関しては IGNOREEOF を大きな値に設定して取り敢えず諦める事にした。
      制限としては C-d を受信する事が出来ないという事、C-d を押すと
      「ログアウトする為には exit を入力して下さい」と表示され、
      プロンプトの表示などが乱れる (というか何も表示されない) という事。

    [2013-06-13 21:24:46]

  * <bashbug> bash-3.1
    パラメータ展開の部分文字列で、範囲外のインデックスを指定すると ^? が返ってくる。
    これはどうしようもない。部分文字列は他の場所でも多用している上に代替手段が存在しない。
    (勿論、別のプログラムを呼び出せばこの機能を再現する事は出来るが、
    それをするととても遅くなるので受け入れがたい。)

    bash の ChangeLog を見てみたが、このバグに関する情報は書かれていない様な気がする。
    一応 bash-3.2 から bash-4.0 へ変わる時に配列の ${array[@]:*:*} で stray の ^?
    が出るバグを修正したと書いてある。また、${var##..} で空白が絡む時の stray ^? についても
    バグの修正が為された様だ。

    →何故かは知らないが、a=; echo "(${a::})" とすると ^? が出力されるが、
      a=; x="${a::}"; echo "($x)" とすると正しい結果が返ってくる。
      また "(${a::})" や "a${a::}b" 等とすると ^? が出力されるが、
      "(""${a::}"")" や "a""${a::}""b" とすると ^? は出力されない。
      もし "" で文字列を区切るだけで良いのだとしたら、少ない修正で bash-3.1 にも対応可能である。

      取り敢えずこの修正によって見た目ちゃんと動いている様子である。
      [2013-06-13 21:25:43]

    →また、bash-3.2.48 で確認してみた所、このバグは既に取り除かれている様だ。


2013-06-12

  [Done]

  * <bug> bash-3 では bind -x されたコマンドを受け取った時、
    一度改行してから実行される為に、行がずれていく。
    プロンプトは消去されないので再描画の必要はない。
    現在位置の情報を更新するだけで良かった。

  * <bug> ble-bind -D: cmap または kbd が全く定義されていない状態で
    ble-bind -D を実行すると内部の declare -p が無引数で実行されて、
    bash 内で定義されている全部の変数が出力されてしまう。
    これは、_ble_decode_cmap_@ または _ble_decode_kbd_@ が 1 つ以上あるか
    どうか確認してから declare -p を呼び出す様にすれば良い。

  * <bug> bash-3.1, ble-decode-kbd ESC の結果が 3 になる。
    .ble-decode-kbd.get-keycode: tmp の要素を数える所で、
    tmp の先頭要素の文字数を数えていた。

  * <bug> bash-3.1: 何と bash-3.1 の算術式では ?: を数珠繋ぎに出来ない。
    ちゃんと括弧で括っていかなければならない。これは結構痛いと思ったが、
    意外と書き直さなければならない所は少なかった。

    .ble-text.c2bc+UTF-8, .ble-text.c2w+emacs, .ble-text.c2w.ambiguous

  * <bug> bash-4 未満で _ble_decode_kbd__c2k を -A として宣言していた。
    -a に書き換えるだけでよい。
    [2013-06-13 00:26:51]

  * <opti> スタイルを一つの整数で表現する。

    文字列比較などをすると時間が掛かる為。
    ble-color.sh, ble-edit.sh 等を書き換えた。意外とすんなりできた。
    これで .ble-line-text.construct のループ内の処理をできるだけ算術式で記述し、速度向上を図る。
    →変更した。定量的に変化があったかどうかは分からないが。

  * ble-edit.sh: quoted-insert, self-insert, insert-string で
    _ble_edit_mark_active を解除するように変更

  * [ble: exit] の際の色を変更

  * 履歴展開: 展開に失敗した時の対処。
    その儘空白のコマンドを実行してしまっていた。
    履歴展開に失敗した時は bash では、前回編集中のコマンドが再度表示される。
    それに倣って書き換えた。
    [2013-06-12 15:15:47]

  * 履歴展開が使えない

    set -H としてみたが eval の中では有効には為らなかった
    (というか、多分、set -H は初めから設定されていたのではないかと思う)。
    history -p で変換してから実行すれば等価だろうか。
    ("" で囲んでも実行された、が、通常の履歴展開の動作もそうなっている様だ。)

    この方針で実装する事にした。
    [2013-06-12 15:14:22]

  * fword: IFS に加えて / も区切とする単語単位の操作を追加。

  * uword: IFS を参照してそれを基準にして単語境界を決めるように変更。


2013-06-11

  [Done]

  * <bug> 特定の操作をした時に accept-line の処理が中途半端で終了する
    C-c や C-z など。

    [C-z 完 2013-06-11 12:22:35]

    + C-\ の場合は問題なく続きが実行される。

    + 実は C-z をした時にも同様の事が起こっている様だ。

      こちらについては trap 'echo' TSTP, trap 'echo' 20, trap echo 'SIGTSTP' 等としても設定できない?
      trap -p をすると予め '' が割り当てられている様子である。
      その他にも予め '' が割り当てらｒている TTIN TTOU についても、
      trap を仕掛けても何も trap する事ができない様だ。

      念のため trap : 20; trap -p と、連続で実行してみたがやはり設定できていない。
      つまり、誰かが設定を戻しているという訳ではなく、初めから設定できないという事。
      また、stty susp undef としてから trap してみたが、それでも設定できない。

      然し乍ら C-z をした直後には、何故か redraw は実行される様だ。
      但し、stty の設定は元に戻っていないようで、
      C-c や C-z 等の文字を受け取る事は出来ない。

    + 然し C-z の直後には何故か prompt が表示されている。
      これは一体誰が表示しているのだろうか?
      →確かめてみた所、C-z した時は実行中のコマンド全てに失敗する訳ではないようだ。
        accept-line.exec 内のループを抜けるに留まるらしい。

        for コマンドが C-z を受信するという事だろうか?
        試しに accep-line.exec 呼出元で 1 回ループにくるんで見たところ、
        C-z でそのループまで抜けるようになった。
        つまり、for 等のコマンドを使わずに実行すれば良いという事だろうか。
        (一応再帰と条件分岐さえあればループは可能。)

        試してみた所 && による条件分岐は C-z で止まらない
        また、if 文による条件分岐も C-z では止まらない様だ。


2013-06-10

  [Done]

  * <opti> .ble-line-text.construct 文字連結最適化?
    [2013-06-11 03:37:38 余り効果は無かった]

    カーソル移動だけの時は配置の再計算を省略できるようにしたが、
    カーソル移動がそれ程速くなったとは思えない。(少しは軽くなった気がしないでもないが)
    何がボトルネックになっているのだろう。残りは、文字連結程度しかない。
    なので、文字連結の最適化について考え直してみる。

    色々試してみた結果、配列に格納していって最後に join するのが速いようである。
    また、${#out} の様な長さの評価の仕方は O(N) の計算量なので
    ループの中で毎回参照するのは避けた方が良い。
    →余り改善したようには思われない…。

    或いは単に関数の呼出に時間が掛かっているだけなのか?
    →でもこれはあり得ない。何故なら編集文字列が短い時にはきびきびと動くから。

    それとも cache_g[i] やら cache_ei[i] の代入に時間が掛かっているのか。
    →試しに off にしてみたがそれ程変わった雰囲気もない。

    或いは座標位置の再計算をしてしまっている? → 確認してみたが、ちゃんと再計算は省略されている。

    改めてどの場所で時間が掛かっているか確かめる為に、
    カーソル移動しか起こっていない場合には文字連結部分を省略してみる事にした。
    (この様にするとカーソル移動によって更新されるべき物が更新されないので、実際には使えない方法である。)
    →すると動作がとても速くなったので、やはりこの文字連結を行っている部分が悪い様だ。

    更に、ダミーで文字連結のループを回して何処に時間が掛かっているのか調べる事にした。
    →文字を配列に登録する部分はそんなに時間は掛かっていないようだ。
    →文字列の長さを計算する部分も関係ない。
    →cache_ei や cache_g に代入している部分も関係ない。

    # →と、ここで SGR 系列を追加している部分を有効にしてみたら急に遅くなった。
    #   先程やった時には余り変化が無かったように感じたが恐らく勘違いだった。
    # →どうも文字列比較 if test "$seq" != "$seq0"; then の部分が重い様子である。
    #   (seq, seq0 はそれぞれ3文字なのでそれ程重いとは思えないのだが)
    #   以下のような色々な物を試してみたが、速さに大差は無いようである (当然か)。
    #   if test -n "${seq#"$seq0"}"; then
    #   if test "$seq" != "$seq0"; then
    #   if [ -n "${seq#"$seq0"}" ]; then
    #   if [ "$seq" != "$seq0" ]; then
    #
    #   或いは、sgr の表現を整数にして、整数同士で比較する様にすると速いかも知れない。
    と、ここまでで SGR 系列の部分が怪しいのではないかと色々調べてきたが、
    やはり? 違うようだ。別の所をコメントアウトして SGR 系列の部分だけ残してみると充分速い。

    どうも、何処が特に重いという訳でもなく、これが bash の限界という事のようだ。
    早く dirty または色変更した部分だけしか再計算を実行しなくても済む様に変更した方が良いという事だろう。

  * カーソル移動では dirty を設定しない様に変更。
    →意外と少なかった。移動は全て .ble-edit.goto-char を介して実行されていた為、
      .ble-edit.goto-char の中で実行されている .ble-edit.set-dirty を削除するだけで良かった。
      その他は set-mark, exchange-point-and-mark ぐらい。

    + と思ったらカーソルを移動しても、カーソルの移動が表示に適用されなくなった。
      良く考えたらカーソルの移動をした場合、文字の配置を再計算する必要はないが、
      表示の際の領域反転などは再度計算し直す必要があるので、
      描画に関しては再度実行する必要がある。

    # * 現在 cursor 移動も dirty として扱っているが、
    #   別にその様に扱う必要性はないのではないか?
    #
    #   dirty としたのは色付け関数によって括弧の強調などの色付けがカーソルの位置に
    #   依存して行われる可能性があったからである。
    #   色付け関数が region_highlight なり何なりを呼び出した時点で、
    #   set-dirty が自動的に為されるような仕組みにしておけば問題ない。

  * <bug> set-mark: 動作が emacs と違う。
    emacs では既に mark が active な場合でも、
    active なまま新しく現在位置を mark の位置とする。
    active 状態をトグルするなどといった事はしない。
    [2013-06-11 00:23:12]

  * _ble_edit_mark_active
    今迄の型は整数型で 0 または 1 の値を取っていたが、
    今後は様々な種類のマーク (S-move によって有効になったマークなど) を区別する為に、
    + マークが設定されていない場合は ''
    + set-mark によってマークが設定されている場合は '1'
    + S-move によってマークが設定されている場合は 'S'
    + (その他のマークを設定する事が在れば必ず有限長の文字列)
    等のように文字列とする事にした。これに伴って何カ所か修正。
    [2013-06-11 00:14:30]

  * <bug> 今迄 sword としていたのは寧ろ unix-word の事だった。
    名称を sword から uword に変更。
    [2013-06-10 22:41:22]

  * <bug> uword の定義で空白を SP HT にしているが、LF も含める。
    [2013-06-10 22:41:28]

  * sword 関連に対応 [2013-06-10 22:43:42]

    IFS=$'|&;()<> \t\n' (シェルのメタ文字) を区切り文字として単語分割する。
    但し、quote については正しく処理していない。

    # unix-word の定義について調べて uword として実装する。

  * forward-word, backward-word を emacs や readline と同様の位置に移動する様に変更。

  * <opti> 長い文字列を編集するのに時間が掛かる。

    これは毎回 construct-line でカーソルの位置の計算と出力文字列の構築を行っているからである。
    特に、一つ一つの文字幅を毎回計算しているのが一番重い気がする。
    理想的には dirty な部分以降の計算を実行すれば良いはずである。

    と思ったが、カーソルの位置が変われば SCOSC, SCORC の埋込位置が変わる為、
    現状の実装方法ではやはりカーソルの位置から再度計算し直さなければならない。

    これの解決方法としては、
    + 先ず全ての文字の後で x y lc lg がどの様な状態になるべきかを計算し、これを cache 配列に記憶する。
    + また、全ての文字に対して esc_line 中の何文字目に対応するかも記憶しておく。
    + esc_line 自体も何処かに記憶しておく。
    construct-line 関数は以下の処理を実行する
    1 dirty が設定された場所から位置解析をやり直す。
      この解析では各文字だけを記録し、escape sequences の構築まではしない。
    2 更に色付けの処理を dirty が設定された場所からやり直す。
    3 色付けによって変更された箇所から escape sequences を構築し esc_line とする。
    4 esc_line のカーソル位置と末端に SC と RC を挿入して ret に入れる。
    5 カーソル位置の x y lc lg を取り出す。

    新しく .ble-line-text.construct という関数を作る事にした。

    + 先ず始めに .ble-line-text.update-positions で dirty から x y lc を更新する。

      i文字目を処理している時:

      1 cache_x[i], cache_y[i] の更新
        cache_x[i], cache_y[i] には i 文字目を出力する **前** のカーソル位置が格納される。
        (或いは、i-1 文字目を出力した **後** のカーソル位置とも言う事が出来る。)

      2 次に cache_lc[i] の更新を行う。
        cache_lc[i] は、cache_x[i]!=0 の場合は、その左側に位置する文字、即ち i-1 番目の文字のコードを保持する。
        cache_x[i]==0 の場合は、その次に同じ行に来る文字のコードを保持する。

        cache_lc[i] は x!=0 の時は、前回の文字コード (lc) をそのまま代入すれば良い。
        然し、x==0 の時は、次に x!=0 になるまで代入を実行する事は出来ない。
        ここで変数 li を導入する。li は、次に cache_lc を代入するべき位置を保持する。

        x!=0 の場合には cache_lc[li] ～ cache_lc[i] までの値を代入し、li=i+1 とする。
        x==0 の場合には cache_ic に対する代入は実行せず li の位置も進めない。
        cache_lc[li] ～ cache_lc[i] に対する代入は以下のように行う。
        x!=0 となった行 y が cache_y[j] と一致するならば lc を代入する。# これだと ^A 等の場合に A に化けるのでは?■
        x!=0 となった行 y が cache_y[j] と異なるならば 32 (空白) を代入する。

        for(j=li;j<i;j++)
          assert(_ble_line_text_cache_x[j]==0);

      3 cache_lg[i] の更新は未だ行わない。

    + その後紆余曲折を経て新しい「編集文字列構築器」ができた。
      古い関数
        .ble-cursor.construct-line.chk-cursor
        .ble-cursor.construct-line
      は削除する。
      [2013-06-10 22:02:41]


2013-06-09

  [Done]

  * <bug> source ble.sh でエラーが発生するようになった。
    どうやら ble-bind で発生している様だ、
    と見てみたら OPTARGS の変数存在確認で "${OPTARGS+set}" を引用符で囲むのを忘れていた。
    [2013-06-10 04:00:03]

  * <opti> プロンプトの初期化が異様に遅い @ cygwin

    プロンプトで \j が3回参照されている。
    それぞれの \j の呼出で2つのプロセスが生成されているので、
    プロンプトの初期化で合わせて 6 つのプロセスが生成されている事になる。
    cygwin のプロセス生成の速度は測ってみたら秒間 10 程度であったので確かに時間を食う。
    (本来はプロセスを生成せずにこれを処理したいが。)

    プロンプトの初期化中にコマンドを実行する場合は、
    コマンドの実行結果をキャッシュするように変更。
    [2013-06-10 03:31:58]

    更に job の数を wc を使わずに数える様に変更。
    [2013-06-10 03:53:44]

    これらの変更によって cygwin でなくてもかなり軽くなった様に思われる。

  * <bug> /bin/printf, source ble.sh 時にエラー @ cygwin
    c2s: /bin/printf が使えない環境で source ble.sh 時にエラーメッセージが出る。
    /bin/printf の stderr を /dev/null に落とすように変更。
    [2013-06-10 03:37:02]

  * <bug> [ -v ] のエラーが発生する @ cygwin
    cygwin 環境で動かしてみる→エラーが発生して初期化に失敗する。
    ble-bind で OPTARGS の変数存在チェックに test -v を使用していた。
    bash-4.1 以下でも動くようにする為には test -n "${OPTARGS+set}" を使用するべき。
    [2013-06-10 03:34:53]

  * <bug> c2s-hex: /bin/printf を用いて
    function .ble-text.c2s-hex を定義するべき所を
    function .ble-text.c2s を定義していた。
    [2013-06-10 03:33:23]

  * <bug> 再描画の際に sgr 情報が失われる。
    カーソル位置を設定する時、lc と共に sgr の情報として lg も記録するようにしたい。

    construct-prompt に関しては取り敢えず置いておき、
    construct-line の方での対応を済ませる。
    [2013-06-09 19:25:13]

  * <bug> 編集文字列が右端一杯の時に縦の位置がずれる。
    <del>右端付近に tab があると縦の位置がずれて表示される。</del>

    多分、tab の所為で発生する改行についてちゃんと対策が取れていない為である。
    後でゆっくり考える必要がある。

    と思って色々試していたら、別に tab がなくても編集文字列末端が右端付近に位置している時には
    縦の位置がずれてしまうという事が分かった。
    原因は construct-line の中で SCORC を出力する位置にあった。
    最後の改行を出力する前に SCORC を設定していた。本当は最後の改行の出力も済ませてから
    SCORC を設定するべきだった。

    + これで丁度右端ぎりぎりまで編集文字列がある場合に常に (カーソルが何処にあっても)
      位置がずれると言う問題は解決した。

    + しかし、それでもカーソルが丁度右端にある時のカーソルの位置が変な事になっている。
      右端にあるので本来はカーソルは見えない (?) 筈であるのに最後の文字 (右端から一文
      字戻った場所) に表示されたり、次の行の最後の文字の位置に表示されたりする。

      そもそも一番右端にカーソルが来た場合に何処にカーソルを置くべきかという事だが、
      xenl が有効な端末でも無効な端末でも同様に表示するのであれば、次の行の先頭に表示する
      べきである。(その事も考えて編集文字列が丁度右端に到達している時に、xenl に対して
      改行を出力しているのである)

      問題は、SCOSC をしている時に行末端に位置している為に、SCORC で戻ってきた時に、
      (折角改行したのに) 行末端の位置に戻ってきてしまう事である。
      今迄は行末端に来た時、xenl であっても次に文字が来た時に次の行に自動的に移動するから
      敢えて改行は出力しないようにしていたが、SCORC で戻ってくる事も考えると、
      ちゃんと xenl の場合には明示的に次の行に移っておいて、その後で SCOSC される様にする
      べきである。

      その様に書き換えたらちゃんと期待通りにずれずに動くようになった。TAB がきても問題ない
      [2013-06-09 18:37:58]

  * <bug> 全ての文字に対して SGR を出力している。
    編集文字列の表示で出力している escape sequence を見てみると SGR が変化していないのに
    毎回 SGR の設定を出力している様だという事が分かった。前回の文字と SGR の設定が同じ場合には、
    SGR の設定は出力しないようにしていた筈である。
    →改めて確認してみた所 seq0=seq としていた。seq0="$seq" でなければならない。
      「前回の SGR」の値が常に誤った設定になっていたから、毎回 SGR が出力されたのである。
    [2013-06-09 18:06:30]

  * <bug> 改行を含むコマンドを編集している時、
    行の先頭にカーソルがある時に、そこに位置する文字が空白に化けて表示される。
    本来ならば行頭に文字がある場合、その文字を lc に設定する事になっているはずである。

    見てみた所、.ble-cursor.construct-line.chk-cursor までは正しく処理できている様に見える。
    と思ったら、update-adjusted で lc から READLINE_LINE を設定するのではなく、
    単に空白を READLINE_LINE に代入していた。
    [完 2013-06-09 16:53:31]

  * <bug> tab が幅ゼロで表示されている。
    時々幅を持って表示されるがその規則は謎。

    と思ってみていたら tab の幅が負の大きな値になったりしている。
    絶対値は大体 x と同じぐらいである。と、ここで /it とするべき所を %it としている事に気付いた。
    同様のコードを色々な所に書き散らしていたので、それらも纏めて修正した。
    [2013-06-09 16:43:12]

  * <bug> 改行を含むコマンドを実行すると、実行後にカーソル位置がずれる。
    [2013-06-09 16:14:26]

    これは前回のプロンプトが表示されていると勘違いして原点に移動する為である。
    _ble_line_x, _ble_line_y を 0 に設定するべき。

    →.ble-edit.accept-line.exec.adjust-eol で
      _ble_line_x, _ble_line_y を 0 に設定する事にした。

  * <bug> quoted-insert
    一部の文字を read -n で読む事が出来ない。
    →これは全ての文字を ble で処理できるようになったら
      ble の仕組みを通じて読む事にすれば良い。

    改めて試してみた所、大概の入力は読み取れている? 後で再度確認する必要有り。
    確認してみた所 ^I ^J ^M の入力をする事ができない。
    やはり、ble-decode-char 辺りに quoted-insert を仕掛ける必要がある。

    # * ble-edit-quoted-insert:
    #   現在はデバグの為に一部の文字列しか捕まえられないので、
    #   read -N を使って実装を行っているが、
    #   全部を ble で処理するようになった時は、
    #   ble-decode-char に対して干渉するだけで良い?

    .ble_decode-char:
    _ble_decode_char__hook 変数を追加、この変数が設定されている場合は、
    この変数に代入されている文字列をコマンドとして実行するように変更。
    [2013-06-09 16:09:46]

  * デフォルトの cmap である term+default を読み込むのに時間が掛かる。
    [完 2013-06-09 15:46:02]

    恐らく ble-decode-kbd 辺りの処理に時間が掛かっているのではないかと思う。
    ble-bind に -D オプションでも追加して、これを追加した場合は、
    ble-bind コマンドによる設定ではなく、cmap 配列に直接値を代入する方式として、
    設定スクリプトを吐き出す様に変更するか?

    直接値を設定する様にすると既に何かを設定している時にそれを上書きする事で、
    データを破壊する事にもなるかもしれないので、その辺りについては確かめる必要がある。
    基本的には設定を追加・上書きするようにすれば良い。

    →試しに配列に直接値を代入する形式でデータを出力してみた。
      出力したデータは 100 KB にも及び巨大だが、
      それを source してみた所 0.1 秒以内にロードできた。
      速度としては充分である。

    + 既存の設定が存在している時にこれを追加して問題になりそうなのは
      "_" を代入する場合と "数字" を代入する場合である。
      "_" を代入する場合は既存の "数字" の設定があった場合に、その既存の設定を消す事になる。
      "数字" を代入する場合は既存の "_" の設定が存在する場合に、それを消す事になる。
      "数字_" を追加する場合については、既存の設定が何であれ完全に上書きしてしまうので関係ない。

      既存の設定に対して安全に追加する事が出来るように書き換えてみたが、
      やはり処理に時間が掛かるようになった。term+default.sh で生成したエントリを全て追加するのに 1 秒弱かかる。
      直接配列を設定する場合には 0.075 秒しかかかっていなかったので、12-13 倍の違いがある。

      また、dump 結果を source してから気付いた事だが、ただ cmap 内の情報を dump するだけでなく、
      キーとキーコードの対応表も一緒に読み込まなければ意味がない。
      そして、後から登録する方式だと、登録したいキーに対応するキーコードが既に使われている場合に、
      番号の再配置を実行しなければならないが、これはかなり重い処理になると思われるので現実的でない。

    + 結局、現実的には既存の cmap に対して追加登録をするのではなく、
      cmap、キーコード・キー対応表を全て入れ替える形にするしかない。

    + 所で良く考えたら declare -p "${!_ble_decode_...@}" 等とすれば

      特別にロジックを書かなくても変数の内容を直接 dump する事ができるのでは?
      実際に試してみた所、declare で出力した物も、
      自分で書いた配列要素を一つ一つ初期化する形式の物も、
      source するのにはそれ程時間の違いはなかった。両方とも 0.105 秒程度かかる。
      若干 declare の形式の方が時間が掛かっている気もするが、誤差の範囲内であろう。

      今後は declare -p を使って dump する事とし、今迄に書いた関数は削除する:
      [2013-06-09 14:37:52]

      function .ble-decode-char.dump-entry {
        local tseq="$1" ccode
        eval "local -a ccodes=(\${!_ble_decode_cmap_$tseq[@]})"
        echo "_ble_decode_cmap_$tseq=()"
        for ccode in "${ccodes[@]}"; do
          eval "local ent=\${_ble_decode_cmap_$tseq[$ccode]}"
          echo "_ble_decode_cmap_$tseq[$ccode]=$ent"
          if test "${ent//[0-9]/}" = _; then
            .ble-decode-char.dump-entry "${tseq}_$ccode"
          fi
        done
      }
      function .ble-decode-char.dump-entryA {
        local tseq="$1" ccode
        eval "local -a ccodes=(\${!_ble_decode_cmap_$tseq[@]})"
        for ccode in "${ccodes[@]}"; do
          eval "local ent=\${_ble_decode_cmap_$tseq[$ccode]}"
          echo ".ble-decode-char.add-entry $tseq $ccode $ent"
          if test "${ent//[0-9]/}" = _; then
            .ble-decode-char.dump-entryA "${tseq}_$ccode"
          fi
        done
      }
      function .ble-decode-char.add-entryA {
        local bseq="$1" byte="$2" val="$3"
        if test -z "${val##*[0-9]_}"; then
          eval "_ble_decode_cmap_$bseq[$byte]=$val"
        elif test -z "${val##*[0-9]}"; then
          eval "
           local ent=\"\${_ble_decode_cmap_$bseq[$byte]}\"
           _ble_decode_cmap_$bseq[$byte]=${val}\${ent##*[0-9]}
          "
        elif test "$val" = _; then
          eval "
           local ent=\"\${_ble_decode_cmap_$bseq[$byte]}\"
            _ble_decode_cmap_$bseq[$byte]=\${ent%_}${val}
          "
        else
          echo unexpected value 2>&1
        fi
      }

    + cmap+default.dump が存在すればそれを source する事にし、
      もしなければ cmap+default.sh から構築してから dump する様にする。

      と思ったら正しくロードされていない。新しく構築した場合にはちゃんと動いているが、
      cmap+default.dump からロードするとロードされていない。
      関数内から cmap+default.dump を source していて、
      cmap+default.dump 内では declare で変数を宣言している為、
      その関数内の局所的な変数としてロードされている。

      これをちゃんと動く様にする為には declare を宣言しなければ良いのだが、
      連想配列については、それが連想配列だという事を明示的に宣言できない。
      →しかし既に別の場所で宣言している筈だから問題ないのでは?
        実際に試してみた所、既に declare -A されている場合、
        新しく代入する場合でも問題は起こらないという事が分かった。

      と言う訳で先頭の declare -? を削除して dump を出力する事にしたが、
      今度はエラーが発生する。よく見たら代入の右辺に一々引用符がついていて、
      配列としての代入ではなくて一つの長い文字列としての代入になってしまっている。
      declare の時には、declare コマンドが文字列として受け取った右辺を展開してから代入するので問題にならないのだろう。

      今回は値としては常に一文字以上の [0-9_] だけで構成される物なので、引用符を全て外しても問題ないだろう。
      という訳で sed で引用符の類も全て削除する事にした。
      その上で source の時間を計測してみた所 0.064 秒にまで縮んだ (単にファイルサイズの問題のような気もしてきた…)。

    + 無事に cmap+default.dump で現実的な速度で初期化できる様になったので、
      <del>古いコード (必要最低限の物だけの設定) は削除する。</del>
      と思ったが、後でまた欲しくなるかも知れないので、cmap+minimal.sh として残しておく事にした。


2013-06-08

  [Done]

  * <bug> ble-line-info: 表示している間、編集文字列のカーソル位置の文字が空白になる。
    [完 2013-06-09 01:42:41]

    これはカーソル位置を移動する時に _ble_edit_lc も変更してしまっているのが原因。
    _ble_edit_lc は描画関連の処理が終了してユーザの入力待ち状態になった時に、
    最終的にカーソルが存在しているべき位置の文字を示す物であって、
    これは一時的なカーソルの移動の際に変更するべき物ではない。

    現状では「最終的にカーソルが存在しているべき位置と其処の文字」と、
    「現在の描画処理の為に移動しているカーソルの位置と其処の文字」を一緒に扱っている。
    変数を分けるべきではないだろうか。
    + _ble_line_curx _ble_line_cury _ble_line_curlc は配列に纏める事にし、
      これは「最終的にカーソルがあるべき位置と文字」とする事にした。
      また、_ble_line_x, _ble_line_y という変数を追加し、これを
      「描画中の現在カーソルが存在している位置」とする事にした。

    + .ble-edit-draw.goto-origin, .ble-edit-draw.goto-end 関数を廃止し、
      .ble-edit-draw.goto-xy 関数を定義し、任意の座標に簡単に移動できるようにした。

    + この変更によって .ble-line-info.draw, .ble-line-info.clear で
      復帰する必要が無くなったかも知れない。
      現在のカーソルの位置が分かっているのだから、
      わざわざ元の位置に戻らなくても良い。
      次に移動する必要が生じた時に適切に移動すれば良いだけである。
      (勿論、その為には .ble-line-info.* で現在のカーソル位置の情報を更新する必要がある。)

      最終的に必ず update-adjusted が呼び出される。
      そして update-adjusted は必ず始めに update を呼び出す。
      update は現状の実装では必ず編集文字列部分は表示し直すから、
      結局必ずキャレットの場所へ移動する事になる。

    + と思って実際に試してみたら位置を移動するようになってしまった。

      これは単に _ble_line_x の変数名を _ble_edit_x としていた為であった。
      正しい変数に移動後の座標を書き込んでいなかった。

      しかしこれを修正しても未だカーソルの位置がおかしい。
      座標位置を勘違いしていると言うよりは、
      info 情報を出力した直後のカーソル位置になっていて、
      その後 update-adjusted 等の操作が行われた形跡がない。

      と思ったら _ble_line_y に対して数式をその儘代入していて、
      計算した結果を代入していなかった。
      しかしこのバグは今回の異常とは関係ない気もする。

      果たして実際に試してみると未だ直っていない。
      また、.ble-edit-draw.update の前後で現在の座標位置が変化していない。
      本来であればこの部分で適切な位置への移動が行われると期待している。
      という事で改めて .ble-edit-draw.update を見てみると、
      実は .ble-edit-draw.update の先頭で
      _ble_edit_dirty が全く設定されていない時には何の操作もせずに終了するようになっていた。
      _ble_edit_dirty が設定されていなくても、位置が異なる場合には移動を実施する様に変更する。
      →これで取り敢えずカーソル位置は正しくなった。
      [2013-06-09 01:42:41]

      また、その際に sgr の値を再設定する必要もある。(sgr は今迄は SCORC, DECRC 等に頼っていたが、
      本来は自分で管理できるようにしておきたい所である。)
      これについては別項目で取り扱う事にする。

  * <bug> 複数行に渡る編集を実行している時に、何かを入力する度に表示位置がずれていく。
    [2013-06-09 01:17:29]

    ずれない様に設計している積もりだったが正しく動作していない様子である。
    先ず始めにずれて上にはみ出た行が消去されていない事から、
    .ble-edit-draw.clear の時点で原点に移動して削除するということができていない様である。
    可能性としては、現在の位置座標を勘違いしているか、原点へ移動する為の制御系列を誤って生成しているかのどちらかである。

    .ble-edit-draw.redraw-cache の始めで現在位置がどうなっているかについて確認を行う。
    →座標値については正しく計算されている様である。
    という事は goto-xy が怪しいと思って改めて考えてみたら、
    今回の場合は y の移動量 dy が負になる。その時に ESC [ A に渡す引数を絶対値にするのを忘れていた。

  * <bug> 色々変更している内にカーソルが先頭に移動するようになってしまった。
    [完 2013-06-09 01:08:14]

    goto-xy の引数に文字列で式を指定できるようにしていたが、
    これをすると goto-xy の中で新しく宣言した変数に影響を受けて値が変わってしまうので、
    やはり goto-xy の引数にちゃんと評価した後の数値を指定する様に変更した。

  * 不要なデバグ用の古い関数 .ble-dbg,esc2a を削除 [2013-06-09 00:32:04]

  * ble-edit.sh (complete-filename): 引数が一意に確定した場合、
    ディレクトリ名の場合には後に / を挿入し、それ以外の場合には SP を挿入する様に変更。
    今迄はディレクトリ名であっても後に / を挿入していた。
    [2013-06-08 16:50:34]

  * <bug> ble-decode-kbd: '*' を変換しようとすると、ファイル名展開が実行されてしまう。
    仮定: * や ?, - が含まれるような single-key 指定は、
          必ず最後の一文字だけが * や ?, - 等の特殊文字である。
          それ以外の指定を行った場合の動作は保証しない。
    仮定: C- 等のような中途半端な指定は C-- と解釈される。
    [2013-06-08 16:01:32]

  * keyflag の定義を emacs と同じ物に変更。
    Meta=1<<28 Ctrl=1<<27 Shft=1<<26 Hypr=1<<25 Supr=1<<24 Altr=1<<23

  * <bug> ble-decode-kbd: C-- や - 等を正しく変換する事が出来なかった。


2013-06-06

  [Done]

  * 取り敢えず色付け関数

  * <bug> C-c: プロセスを停止した直後、プロンプトが表示されない
    [完 2013-06-07 03:52:15]

    これは accept-line の処理が中途半端になったまま終了してしまうからである。

    + C-c 等でプロセスを停止した時に 正しく終了されるか?
      →正しく終了されていない様である。

    先ず何か入力するまでプロンプトが表示されない。
    (但し、^? などに対してはちゃんと読み取れる様である。
    ^? でも何でもいいから入力をすると復帰する。)
    これは accept-line の後の .ble-edit-draw.redraw が実行されていない為であろう。

    適当に trap 'echo hello' INT とすると、
    続きが実行される様になった。因みに hello の文字列は何処かに消える?
    なので trap : INT 等とする事にする。
    (既に存在している trap を上書きしてしまう事になるが仕方がない。)
    [2013-06-07 03:19]

    と思ったが、実際に試してみると、シェルの処理で重い場合に C-c をすると
    trap : INT や trap 'echo hello' INT 等としていた場合にシェルの応答がなくなってしまう
    という事が分かった。因みに trap を何も仕掛けていなければ正しく終了する。

    と、思っていたが trap return INT にしておけば一応問題は起こらない様だ。
    [2013-06-07 03:52:15]

    <del>しかし trap 'return 128' INT にすると今度は return は関数内でなければ
    使えないというエラーメッセージが表示される。</del>
    どうも trap を定義した場所が関数内なら return を書いてもエラーは出ない様だ。
    なので、.ble-edit.accept-line.exec.eval 内で trap をする事にした。
    しかし、return 128 等としても戻り値は常に 0 となる様子なので、
    _ble_edit_accept_line_INT という変数を介して 128 の値を返す事にした。
    [2013-06-07 04:12:50]

  * <bug> readline の accept-line をしない限り $? が設定されない?
    前回のコマンド実行の $? を何処か別の変数に覚えておいて、
    次のコマンドを実行する直前に設定し直せばよい。
    設定するには、return で好きな値を返すだけの適当な関数を作って、
    その関数を呼び出せばよい。
    [2013-06-07 02:20:26]

  * <bug> .ble-edit-comp.complete-filename: 変数リーク ret [2013-06-07 02:02:07]

  * <bug> return による accept-line 中断
    [2013-06-07 02:09:41]

    C-c や C-z をした時の様に、
    コマンドライン中に return が含まれていた場合にも同様の事が発生する。
    これについてはコマンドを実行する際に一つ関数にくるんで実行すればよい

  * ジョブ管理にアクセスできるか?
    問題なくアクセスできるようである。

  * accept-line: 存在しないコマンドでも history に追加される。
    [キャンセル 2013-06-07 01:55:03]

    history に追加する前にそのコマンドが存在するか確認。
    そもそも存在しない・実行できないコマンドに対しては history への追加を省略する。

    存在するかどうかの確認は type で確認できる物、及び、for などの文法要素?
    →試しに for を type -t に入れてみたら keyword となったので、
      for 等を特別に区別する必要性はない。

    と改めて調べてみたら、元々の bash でも存在しないコマンドもちゃんと history に追加されていた。
    なのでこれについて解決する必要性はない。

  * <bug> accept-line: [完 2013-06-07 01:53:25]

    ret 変数に値を設定できない。
    というか、accept-line を呼び出すまでにネストした
    関数で local として宣言されている変数名は全て使えない…。

    a. accept-line は呼出のネストの浅い所で実行する?
       (例えば ble-decode-byte などで)
    b. 内部変数として使用している変数名を重複の無い物 (_ble_* を予約) にする?

    a. の方針で行くとしたら、呼出が開始された一番浅い場所を見つける必要がある。
    ble-decode-byte から ble-decode-char, ble-decode-key と呼び出される過程で、
    何処が一番初めに呼ばれたかを判定するのは難しい。

    ble-decode-byte:bind が起点になる場合は明らか。
    ble-decode-char が起点になるかどうかの判定は難しい。
    代わりに内部の呼出では .ble-decode-char を使う事にして、
    外部からの呼出 (起点) では ble-decode-char を使い、
    ble-decode-char は .ble-decode-char の呼出 + 修飾処理、という事にすれば良い。

    従って、書き換えは
    1 全ての ble-decode-byte, ble-decode-char, ble-decode-key の内部呼出を
      .ble-decode-byte, .ble-decode-char, .ble-decode-key に書き換える。
      また、それぞれの関数名も書き換える。
    2 ble-decode-byte, ble-decode-char, ble-decode-key を定義し、
      中で .ble-decode-byte, .ble-decode-char, .ble-decode-key を呼び出すと共に、
      その他の前後の処理を追加する。
    という手順で行えば良い。

    先ず、ble-decode-byte は内部的には何処からも呼び出されていない様である。
    ble-decode-char は ble-decode.sh 内にしか存在しない。
    ble-decode-key は ble-decode.sh が殆どで、ble-edit.sh に一箇所だけ存在する。
    これらを書き換えて、呼出の起点に近い場所で実行するように変更した。

    しかし、未だ漏れている変数が存在するようだ。以下の変数は値が漏れている。
    arr file line ret spec

    spec: .ble-edit.history-add
    line: .ble-edit.history-load, ble-decode-bind
    file: .ble-term.initialize
    arr: ble-getopt
    ret: ble-edit+self-insert, ble-decode-bind, ble-bind,
      ble-decode-unkbd 定義直後にテストコードが残っていた
    _getopt_*: ble-bind

  * <bug> ble-decode-byte+C: 文字コードとして空文字列を返していた。
    [2013-06-07 00:51:25]

  * C-c 等でプロセスを停止した後、次のコマンドを実行するまで行が二重化する
    [2013-06-07 00:19:05]

    C-c でプロセスが失敗した後に accept-line を押すと line が二重に表示される。
    これは実際に別のコマンドが実行されるまで続く。
    多分、これも stty の設定が変化しているから?
    多分エコーの設定が有効になっている為に、
    C-j/C-m が入力された時に行の位置がずれてしまうからだろう。

    これは空コマンドだった場合にも .ble-stty.enter を実行すればよい。
    というか寧ろ ble-decode-byte:bind 辺りで実行しても良いかも知れない。

  * <bug> accept-line: 時々コマンドを実行した時に現在位置が上の方に移動してしまう。

    <del>どうも accept-line を実行した時に、カーソル直前に存在する文字が
    特殊文字であるとこの現象が発生するようである。</del>

    どうも特殊文字でなくても、カーソルの位置が line の最後の文字以外に置いてある時に、
    この現象が発生するようである。そして特殊文字を入力する時は大抵、先に引用符を書いておいてから、
    引用符の中に入って特殊文字を入力し、そのまま accept-line する為に、この条件に該当する。

    そしてこの条件が該当しそうな箇所が .ble-edit-draw.goto-end にある。
    と思ったら、_ble_line_cury に x 座標を代入していた。
    [2013-06-06 23:57:43]

  * <bug> カーソルの表示位置がおかしくなった
    construct-line で変数名を変更したのに、それを参照している construct-line.chk-cursor で
    変数名の変更していないのが原因だった。
    [2013-06-06 23:38:24]

  * <bug> \\ や \$ が含まれる時の位置計算が誤っている。
    [2013-06-06 23:37:21]

  * .ble-line-info.clear: 既にクリアされている場合は動作を省略 [2013-06-06 23:05:49]

  * discard-line, accept-line: 実行の前に .ble-line-info.clear [2013-06-06 23:06:17]

  * construct-prompt: シェル変数 x y lc に計算結果を直接書込をする様に変更。
    [完 2013-06-06 23:05:09]

    + キャッシュ情報は 配列 _ble_line_prompt に記録する事にした。
      _ble_cursor_prompt__LINENO, _ble_cursor_prompt__RESULT の変数を廃止
    + 呼出元を調整。

  * complete 候補一覧を表示
    取り敢えず表示するだけ表示 [2013-06-06 18:07:53]

  * ble-decode:
    ble-edit-bind の部分にあった bash に対する bind のロジックを
    ble-decode.sh の方に移動させる事にした。
    [2013-06-06 17:41:05]

  * isearch: C-d を押した時に空欄だと即座に終了してしまう。
    (C-d に delete-char-or-exit が設定されている場合)。
    なので、isearch で C-d を押した時は isearch モードを抜けてから
    唯の delete-char を実行する様に変更。
    [2013-06-06 17:40:50]

  * C-x に対する hook

  * ble-bind
    ESC → Meta が自動的に実行される様になったので、
    Meta について改めて登録する必要はなくなった。ので、その機能は削除。
    [完 2013-06-06 17:18:33]

  * <bug> ble-decode-char
    [完 2013-06-06 17:02:07]

    M-delete 等の操作が正しく key に翻訳されていない。
    これは ESC を meta に変換する機能を入れても入れなくても同様。
    更に ble-bind -k で Meta の付いた物を自動的に登録しても登録しなくても同じ。

    と思ったらそもそも ble-decode-char 自体に二つ連続した ESC は入ってこない様だ。
    screen または bash bind -x で消えてしまっている可能性がある。

    + 試しに bashrc 内で bind している '[D' と '[C', '[3;5~' を削除してみた。
      削除自体は正しく出来たようだが、依然として '' は消えた儘になっている。

    +  /etc/inputrc を見てみたが '\e\e' に関係する物は設定されていない。
      また、~/.inputrc は作っていなかった。

    + .screenrc を見てみたが C-M-tab に windowlist を割り当てている以外は怪しい所はない。
      それに emacs を起動している間はちゃんと ESC ESC を入力する事が出来ているのだから、
      screen は犯人ではない。やはり bash が怪しい。

    A 仕様がないので、直接 "" に対して bind を実行してしまえばよい。
      其処で bind -x '"":ble-decode-byte:bind 27 27' として見たが、
      そうすると今度は ESC ESC を受け取った時に、
        bash: bash_execute_unix_command: コマンドのキーマップがありません
      というエラーが発生してしまう。

    B 取り敢えず、苦肉の策として ESC ESC を何か別の物に変換して受信する事にした。
      ble-bind -k 'ESC [ 2 7 ^' __esc__
      ble-bind -@f __esc__ 'ble-decode-char 27'
      bind -s '"":"[27^[27^"'

      と思ったら、何故か "ESC ^ ^ ESC ^ ^ [ 2 7 [ 2 7" という謎の順番で受信される。訳が分からない。
      bind -s '"":"[1027~[1027~"' に変えてみたら、
      "ESC 2 2 7 ~ ESC 2 2 7 ~ [ 1 0 [ 1 0" となる。^ が悪かった訳ではない様だ。
      文字数の問題?
      bind -s '"":"[^[^"' → "ESC ESC ESC [ ^ [ ^"
      どうやら ESC 後の 3 番目の文字が繰り返される様である?
      bind -s '"\e\e":"\e[^\e[^"' → "ESC ESC ESC [ ^ [ ^" # bind で文字化けしているのかとも思ったがそうではないようだ。
      bind -s '"\e\e":"\e[~"' → "ESC [ ~ ESC [ ESC ESC ESC ..." # 理解不能

      もしかして、ble-decode-char の方のバグだろうか。。
      今度は ble-decode-byte の方で出力を行ってみる事にした。
      "[27^[27^" → "ESC ^ ESC ^ [ 2 7 [ 2 7"             この時点で謎
      "[1027~[1027~" → "ESC 2 7 ~ ESC 2 7 ~ [ 1 0 [ 1 0" ~ でも駄目
      "[^[^" → "ESC ESC [ ^ [ ^"                         短くしても駄目
      "[1027^" → "ESC 2 7 ^ [ 1 0"                         単体の ESC でも発生する
      "\e[~" → "ESC [ ~"                                     これは正しく受信されている
      "\e[^" → "ESC [ ^"                                     これも OK
      "\e[7^" → "ESC ^ [ 7"                                  これは駄目
      "\e[?^" → "ESC ^ [ ?"                                  これも駄目
      "\e[?~" → "ESC ~ [ ?"                                  これも駄目

      取り敢えず ESC を含んで 3 文字以上のシーケンスが何故か化ける様なので、
      3文字 で "ESC [ ^" とする事にした。
      これで受信される物は正しくなったと思われる。

    + BUG 受信しているバイトは正しいが ble-decode-char が正しく処理してくれない。

      動作を見ていると ESC [ ^ を受け取った時点で __esc__ が生成されている。
      そしてその直後に M-[ が出力されている。
      更に次の "[" を受け取った時に再び M-[ が出力される。

      一つの原因は、_ble_decode_key__seq をクリアしない内にコマンドを実行している為、
      コマンドの内部で新しいキーが来た時に _ble_decode_key__seq に追加されて処理されてしまう事である。
      これは、コマンドを実行する前に _ble_decode_key__seq= とする事で解決する。
      基本的にコマンドを実行する時には、ble-decode-key の内部状態を終了状態と同じにしてからにするべきである。
      要するに破壊的操作を全て終えてから、コマンドを実行する、という事。

      ble-decode-key の中の _ble_decode_char__seq についても同様である。
      これを修正した所、どうやらちゃんと期待通りに動くようになった。

  * ble-decode-char
    ESC を meta に翻訳するのは自動にするべき。
    例えば M-あ などまで考慮していたら、全てを登録し尽くす事は無理なので。

  * <bug> ble-decode-key でシーケンス全体の一致に失敗して、
    部分一致に成功した時、一致部分の直後のキーが失われる。
    これは 一致した場合に ble-decode-key "$fail" を実行せずに関数を抜けていたのが原因である。
    依然 ble-decode-char で起こったのと同様の問題点。
    その時には ble-decode-key には問題がないと判断したが、問題は在ったようだ。
    [完 2013-06-06 16:58:25]

  * <bug> ble-edit-bind: "\e ": set-mark を unbind できていない。
    [完 2013-06-06 15:26:53]

  * ble-edit-bind: bind -s についても表示できるから、これについても全て unbind する。
    [完 2013-06-06 15:26:48]

  * <bug> ble-bind -d
    -m isearch 等を用いて登録したキーシーケンスが表示されない。
    現在登録されている kmap 名のリストを追加して、
    ble-bind -d で全ての kmap について表示するように変更した。


2013-06-05

  [Discussion]

  * COMP_KEY
    bash の manual には最後のキーとあるが、
    文字で表現するのか、名前で表現するのか文字コード (?) で表現するのか分からない。
    実際に、適当な関数を登録して確かめてみると良いだろう。

    →試してみた所文字コードが表示された。
      更に function キーに complete を割り当てて試してみた所、
      バイトシーケンスでの最後のバイトが渡される様である。
      (しかし、これでは不便? な気がするので、独自解釈で ble の keycode を用いる事にする。
      その際に C-* 系統の物は変換した方が良いかも知れない。)

  [Done]

  * visible-bell: 鳴った瞬間だけ緑色に点滅する様に変更。
    これで連続で visible-bell が鳴った時でも見た目に分かる。

    # + 鳴った瞬間だけ赤くして直ぐに暗くする

  * <bug> isearch: self-insert で単に入力しているだけなのにどんどん遡ってしまう。
    self-insert の時には現在行から一致を初める様に変更する。
    [完 2013-06-05 23:42:37]

  * <bug> quoted-insert, v だとか q が挿入される
    これは self-insert の仕様変更について行ってなかったのが原因。
    代わりに insert-string を使う実装に変更した。
    [完 2013-06-05 19:57:59]

  * clear-screen: vbell の削除トラップをクリアする
    [完　2013-06-05 19:18:02]

  * isearch: arr の top が行き先と同じであれば、arr に push せずに pop する
    [完 2013-06-05 19:03:41]

  * isearch: 表示位置への移動などをもっとまともな物に変更する。
    [完 2013-06-05 18:47:07]

  * isearch: 終了時に isearch の表示を消す
    [完 2013-06-05 18:47:17]

  * isearch: prev でもうこれ以上戻れない時、isearch から抜けない
    [完 2013-06-05 18:48:15]

  * c2w 二分法: 0-161 の間の文字が怪しい?
    + 初めから範囲にない場合 (0-161) の場合は先に除外するべきだった。
    + l&1 を括弧で囲む必要があった。
    + while の条件は l<u ではなく l+1<u であった。
    [完 2013-06-05 18:27:32]

  * ble-core.sh (.ble-print-visible-bell): .time 削除で date +%s の値が overflow しない様に
      部分文字列を取りだす部分が間違っていた。
    [2013-06-05 16:14:46]

  * ble-core.sh (.ble-print-visible-bell): SC, RC を頻繁に使うので、後で変更しやすいように
    _ble_term_sc, _ble_term_rc 定数に定義。
    [2013-06-05 16:14:46]

  * __defchar__ は制御文字には適用しないように変更


2013-06-04

  [Done]

  * <bug> どうも履歴の動作が怪しいような気がする。
    C-p C-n で動くと変な出てき方をする…気がする。
    それに先程実行したはずのコマンドが出てきたり出てこなかったりする。

    →と思ったら history-add で実際に登録される場合だけ
      _ble_edit_history_ind, _ble_edit_history_edit を初期化していた。
      それ以外の場合は、前回の履歴位置・編集内容をそのまま使う事になっていた。
      そうすると例えば、前回履歴を遡って実行したコマンドは空白に変化し、
      また、現在の履歴の位置も途中の場所にいたりと変な事になる。

    [完 2013-06-05 02:50:10]

  * vbell:
    ble.sh をロードした時に、
    古い .time ファイルは全部削除する機能をつける。

  * ble-bind -c: meta も登録する
    → 完了 2013-06-05 02:40:02

  * ble-bind 引数はシェル変数で渡す様にした方が良い? (-f オプションの削除)
    + self-insert は KEYS[0] シェル変数を用いる様に変更した。
    + f オプションの削除

  * ble-bind -c, -k オプションの名前を変更する
    → それぞれ -k, -f に変更した。2013-06-05 02:40:06

  * bug? bind
    何と " を bind する事ができていない。
    と思って改めて試してみたらちゃんと bind されている??
    取り敢えず保留という事にする。

  * <bug> 次のコマンドを実行するまで prompt が更新されない
    CMD ではなく LINENO を参照するように変更

  * abell はロックするので vbell の後に送信するべき [完 2013-06-05 01:25:27]

  * 矢印キーなどの動作を取得する事が出来るかチェック [完 2013-06-05 01:25:41]
    (1) ESC で始まるシーケンスを全て削除する?
        試しに全て削除してみたら、(自分で bind -x で設定した物を除いて、)
        上下左右のキーや function キーも効かなくなった。
        ので、C-[ さえ bind -x してしまえば恐らく処理できると思われる。

        → source されたスクリプトの中で bind -r を実行しても削除されない?
        と思ったら bind の時は必要だった引用符 " が、bind -r の時には不要だった。

    (2) ESC に bind できるか?
        一応 ESC には bind できているみたいだが、delete を押してもそうと認識されない。
        しかも二回に一回だけ通常の文字列として delete が入力される。
        奇数回目の delete は何処へ行っているのか?

        ble-decode-key の受信する key を見てみた所、
        delete を入力した直後には ble-decode-key には delete が来ない。
        その次の文字を入力すると ble-decode-key に delete が渡される。
        その後に続く文字は一文字ずつ分解されて届く様である。

        先ず、問題点として
        a. ~ を受け取った時点で delete に確定している筈なので、
          その時点で delete が届かないのがおかしい
        b. また、delete が受信された後の文字が単体で必ず decode-key に渡ってくるのが問題である。
        c. delete は処理されなかったはずなのに、その事を表すエラーメッセージが表示されない

    + BUG: delete が届かない? [完 2013-06-05 00:00:50]

      と思って実際に初期化が終わった後の cmap を見てみたら
      最後の文字なのに「継続あり」の _ がついている。
      .ble-decode-char.bind を見たら条件が反対になっていた。
      (.ble-decode-key.bind の方は大丈夫かと思ってみたら大丈夫だった、
      .ble-decode-key.bind に合わせる形の方向で修正した。)

      ** デバグの為に一時的にバグ状態に戻してある **
      →他のバグも解決したのでこれはまた修正した。

    + BUG: 曖昧文字の失敗後に、その失敗に関連した文字がすぐに送信されてくる?
      [完 2013-06-05 01:25:41]

      と思って手でエスケープシーケンスを入力したりしてみたが、少し違うようだ。
      delete ESC [ まで入力した段階では delete までしか出力されていない。
      ここまでの動作は正しいが、次に A を入力した時点で、
      ESC [ A がその儘出力されて出て来る。

      本来は ESC [ A は up と翻訳されて欲しい。
      _ble_decode_cmap_* を見てみたがここの部分は問題ない様に見える。
      (a. の方の BUG の事を考えると、本当は ESC [ A だけでは未だ出力されないはず…。
      そして実際に、先行する delete がない状態では ESC [ A を送信してもその時点では何も出力されない。
      従って、cmap の問題ではなく内部状態に何らかの異常が出来ていると考える方が自然である。)

      と思ってみてみた所、delete ESC [ まで入力した段階では、
      実は未だ ESC [ は bash まで届いていない? 様である。
      screen だか或いは途中の何かが文字を止めているという事だろうか。。
      (と、ここで screen に C-TAB = [9;5^ に対する hook をかけているという事を思い出した)。

      そして、ble-decode-char は delete のシーケンスが残っている状態で
      ESC を受け取った時にそれを組み立てずにそのまま出力しているらしい。
      要するに奇数回目の入力と偶数回目の入力で何が違うかというと、
      偶数回目の入力の一番初めの文字 ESC が到着した時には、
      未だ奇数回目のシーケンスが残留しているという事である。

      という所で、怪しい部分を発見したが…その部分は今回と関係ないような気もする。
      しかし取り敢えず、その部分を修正する (余分な return を消す)。すると今度は、
       ble-decode-key に渡される key 自体は何も可笑しい所がないように見えるのに、
      実際に編集文字列に現れてくる文字列には違う入力されている。。
      先にエラーメッセージが表示されない謎を解決した方が早いかも。

      下のバグを解決したらこちらのバグも解決した。先程の修正で良かった様だ。
      今迄 ESC [ A が裸で出力されている様に見えたのは勘違いで、
      1 delete のシーケンスが残っている状態で ESC が来ると、
        delete だけ出力されて ESC は出力されずに終わる (一つ目のバグ)。
      2 delete のシーケンスが化けて (二つ目のバグ)
        (1) で出力し損ねた ESC になって、self-insert で入力される。
      という流れになっていたのだった。つまり
        ESC [ A ESC [ A
        ~~~~~~~~~~~
        delete      [ A
        ~~~~~~
        ESC         [ A
      と言う風に変換されていたのだった。


      因みに .ble-decode-key.emit の方には同様のバグがないかと確認してみたが、
      その様なバグはなかった。ちゃんと余分な return は消されていた…。

    + BUG: 知らないシーケンスが届いた筈なのにエラーメッセージが表示されない。
      [完 2013-06-05 01:13:43]

      と見てみたら、すぐに気付いた。「知らないシーケンスが届いた時に "$key" 単体を
      文字と解釈できる場合には __defchar__ で処理する」という所で $key の代わりに $fail と
      書いていた。そしてこの $fail は呼出元の ble-decode-char の $fail を参照して、
      出力していない筈の文字を出力してしまうという事になっていた。

      これで解決できたと思ったら、今度は up が変な文字として入力されてしまう様になった。
      これは __defchar__ で処理するのは unicode の16面までという制限をかければ良い。
      0x110000 という定数が何回か出てきたので ble_decode_function_key_base という定数として定義し直した。
      これを用いて文字として解釈できる unicode の範囲を絞って扱う事にした。

  * <bug> history add したコマンドの \ が消えている。
    [完 2013-06-04 23:26:03]

    どうやら読み込む時に read が勝手に \ を消しているようだ。
    read に勝手に \ を解釈されたくなければ read -r とする。
    登録・書込の方には問題はないようだ。

    他にも read を使っている所があるのでそれについても修正をする必要がある。

  * <bug> .ble-edit.construct-prompt: \w でホームディレクトリ以下のパスが  ~// となる。
    [完 2013-06-04 23:05:35]

    ~ に続きがある場合に / を追加する様に書いていたが、
    良く考えたら ~ に続きがある場合には / がどうせ先頭になっているので必要なかった。

  * <bug> HISTIGNORE の値に反して一文字のコマンドが history に追加されている
    [完 2013-06-04 22:50:16]

    単に配列変数の名前を間違えていただけだった。

  * <bug> (.ble-edit.construct-prompt): \! (HISTCMD) が常に 1
    これは bind -x で登録された関数から見るとこうなってしまうという事なのだろうか。
    代わりに _ble_edit_history の要素数を返せば問題はないだろう。
    [完 2013-06-04 22:43:49]

  * <bug> ble-decode-byte を直接呼び出すと PS1 の値が破壊される
    [完 2013-06-04 22:32:33]

    PS1 が解除された状態で ble-decode-byte が呼び出され…?
    調べてみた所、ble-decode-byte の中で PS1 を代入していた。

    良く考えてみたら、再描画や adjust-cursor 等の呼出は、
    直接コマンドを叩いて呼び出した時には必要のない物である。
    なので、bind -x する時専用の ble-decode-byte を作って、
    その中で PS1 の設定や再描画、カーソル位置微調整を行えば良い。
    →その様に変更した。

  * suspend した時にどうなるか?

    特に問題が生じるという訳でもない様だ?
    但し、以下の点については意識する必要がある。

    (1) stty の設定がどうなっているか
        [完 2013-06-04 20:34:42]

        <del>恐らく stty を復元したままになっている。
        従って ^W ^U 等の操作を行う事ができないと思う。</del>

        <del>直後に直すのは諦めるとしても、
        次に ^W ^U など以外の文字が入力された時に、
        stty の状態を確認して元に戻すという事はするべきである。</del>

        と思っていたらどうやら suspend で止まった場合でも、
        スクリプトの続きから開始される様である。
        つまり、accept-line の後半部分も suspend の直後に実行される。
        なので何の問題も生じない。

    (2) コマンド履歴に suspend したプロセスが追加されていない。
        [完 2013-06-04 19:54:07]

        コマンド履歴に追加される前にコマンドが実行されている。
        これは登録を先に行うように変更するだけでよい。

        (但し bash ではコマンド見付からなかった場合には、
        コマンド履歴に追加されないようになっている。
        コマンドを実行に移す前に予め、
        そのコマンドが存在するかどうかぐらいは判定しても良さそう。)

    (3) 編集中のコマンドが残っている [完 2013-06-04 20:36:18]

        これも編集文字列をクリアする前にコマンドを実行しているからである。
        コマンドを実行に移す前に編集文字列をクリアする事にする。

  * ちらつきを抑える方法: 最初に再描画 [完 2013-06-04 18:32:52]
    ble-decode-byte に入った瞬間に .ble-decode-key.redraw を実施する?
    その時は、前回から内容が変わっていない筈なので、前回保存した情報をそのまま出力すれば良い。
    そして呼出が終わった後に変更があればその時点で再描画をまた実行する。

    + BUG: prompt の表示が省略されている [完]

      → 前回保存した内容が prompt 表示を省略する物だった為
      → prompt 表示の省略をしない物をキャッシュに入れておく事にした。

      関数 redraw-cached は「フル」で表示し直すが内容は「前回」のまま、という関数である。
      ので、表示の省略などは行わないので、この方法で良い。

    + BUG: 前回の残像が残っている [完]

      redraw をする際に前回表示した内容を消していないので残ってしまう。
      これは .ble-edit-draw.redraw, .ble-edit-draw.update でも同様に起こりうる問題である。
      (今迄は bash が1行目を勝手に消していたので気付かなかっただけである。)

    + BUG: 表示が滅茶苦茶になる

      原因は色々あった。
      事。
      "前回の表示内容" に関しては保存していたが、
      その内容を出力した際に現在のカーソルが何処に移動するかといった情報を保存・復元するのを忘れていた。
      唯単に前回の表示内容を出力しただけだと、内部的にカーソル位置が先頭から動いていない事になっている。
      なので、ちゃんと "前回の表示内容" を保存すると共に、その内容を表示した時にカーソルが何処へ移動するか等の情報も保存するように変更した。

    何とか、前回の表示内容を再度出力する物が完成したので、昔のコードは削除する。
    | function ble-decode-byte {
    |-  # bash によって描画された物が全部消されている
    |-  # .ble-edit-draw.set-dirty -1
    |+  .ble-edit-draw.redraw-cache

    これでちらつきはかなり改善された。

    しかし、ちらつきが全くないと迄は言えない。もし気になる様だったら

  * bug unkbd [2013-06-04 17:59:04]

    配列への追加で、添字に ${#kbd[@]} とするべき所 ${kbd[@]} としていた。

  * LINENO が更新されない?
    →これは一回 unset LINENO してから自分で設定すればよい。

    どうせ自分で LINENO は管理しなければならないのでこの方法でよい。


2013-06-04, X6

  stty 関連 (tty が制御文字を奪うという事) [2013-06-04 13:33:26]

  * tty の設定で動かなくなるキーと tty で設定されていても動くキーがある。
    よく分からないので表にする事にする。

    ^S ^Q
      →stty で外すか -ixon の設定にすれば OK
        基本的に -ixon の設定で行く方針。常にこの状態という事にする。

    ^C
      →bind する時は stty intr "" でも問題ない。
        然し、実際に使う時には stty intr undef でないと読み取れない。
    ^Z
      →^C と同様 bind 時はどちらでも問題ない。
        実際に読み取りの時は stty susp undef でないと駄目。
    ^\ (quit) も ^C や ^Z と同様である。

    ^V
      →bind する前に stty lnext undef する必要がある。
        bind した後も stty lnext undef の儘保持しておく必要がある。

    ^U (kill) ^W (werase) も ^V と同じである

    ^?
      →bind する間だけ stty erase undef し、
        <del>その後で stty erase "" などと復元すれば良い?</del>
        と思ったが何故か stty erase undef でなくても動いたり、
        stty erase undef でないと動かなかったりよく分からない。
        取り敢えず ^V の時と同じようにずっと erase undef の儘にしておく事にする。


    <a href="http://lists.gnu.org/archive/html/bug-bash/2004-08/msg00157.html">'bind "\C-?": delete-char' does not work any more</a>

    ※文字列編集中だけ外されている stty 項目がある可能性?

    #              | key    bind  read
    # -------------+-------------------
    # -ixon        | ^S ^Q
    # kill undef   | ^U     必要  必要
    # lnext undef  | ^V     必要  必要
    # werase undef | ^W     必要  必要
    # erase undef  | ^?     必要  必要
    # intr undef   | ^C     不要  必要
    # susp undef   | ^Z     不要  必要
    # susp undef   | ^\     不要  必要
    # -------------+-------------------

  * ^? が偶に bind 出来ないように見える問題

    どうやら一回目に stty を解除して bind に挑戦すると失敗している様で、
    二回目に bind に挑戦すると成功している様だ?
    再度 stty の設定を元の状態に戻して ble.sh を設定してみたら、
    ^? ^U ^V ^W の四つについて bash の bind が機能していないという事が分かった。

    改めて bind -x '"":ble-decode-byte 127' を手で入力してみた所使える様になる。
    やはり stty を設定した直後には bind を設定する事が出来ないという事だろうか。

    色々試してみる
    (1) stty の後に適当に echo するとどうなるか?
        →適当に echo するだけでは駄目なようだ。

    (2) stty の後に sleep で待ってから設定するとどうなるか?
        →sleep で待っても駄目なようだ。

    (3) stty の後に >/dev/null で適当な文字列を書き込むとどうなるか?
        →やはり駄目。

    (4) read -n 1 で適当に文字を読み取るとどうなるか?
        →これでも駄目だった。

    (5) subshell ( date ) を呼び出す
        →駄目

    もしかして source ble.sh で一つのコマンドとして実行しているから設定が有効になっていないという事だろうか?
    後、一回 exit してから入るとうまく行くのは、C-d で exit する直前に .ble-stty.leave していなかったからであった。
    或いは bashrc 等のスクリプトから実行するとうまく行くのかも知れない。

    仕方がないので現状では .ble-decode-byte:bind で、
    既に ^U ^V ^W ^? に bind しているかどうか確認して、
    設定されていない様だったら設定を行う様にする事にした。

  * C-@: 効かないと思っていたら bind できていない [完]

    bind -x '" ":ble-decode-byte 0'
    →確かにこれでは bind できない
      bind は '"' という文字列を受け取ったと勘違いする。

    bind -x '"\C-@":ble-decode-byte 0'
    →これで正しく bind 出来るようになった。

  * 全ての文字を入力可能かどうか確認

    C-@ OK (bind する時に直接 ^@ の文字を引数に指定できない事に注意)
    C-a OK
    C-b OK
    C-c OK (stty intr undef)
    C-d OK (READLINE_LINE にダミー文字を設定。可成り苦労した…)
    C-e OK
    C-f OK
    C-g OK
    C-h OK
    C-i OK
    C-j OK
    C-m OK (stty の改行変換周りで状況が違うかも?)
    C-n OK
    C-o OK
    C-p OK
    C-q OK (stty -ixon)
    C-r OK
    C-s OK (stty -ixon)
    C-t OK
    C-u OK (stty kill undef)
    C-v OK (stty lnext undef)
    C-w OK (stty werase undef)
    C-x OK (二文字の組合せで bind すれば良い)
      * 直接 bind すると C-x に続けて何かの文字を打った瞬間に
        bash が segmentation fault する
      * C-x ? (? = \0 - \377) の組合せで全て登録しておけばよい。
        (恐らく C-x は C-x とそれに続く何らかの文字の組合せでしか使われないだろう。
        その場合にはこれで問題はない。)

    C-y OK
    C-z OK (stty susp undef)

    C-[ OK
      * 単独の C-[ は通常通りに bind するだけで OK。
      * C-[ C-[ の並びは何故か受信できないので、
        bind '"":"[27^[27^"' 等として、
        一旦別のシーケンスに翻訳してから受信する必要がある。

    C-\ OK (stty quit undef)
    C-] OK
    C-_ OK
    C-^ OK (.bashrc で設定しているのを解除する必要はある)
    C-? OK (stty erase undef)


2013-06-04, X5

  C-x に bind -x すると死ぬ [2013-06-04 09:42:42]

  * 先ず第一に、C-x に対して bind しても、
    単体の C-x に対して bind で指定したコマンドは呼ばれない。
    (bind -r で予め元々登録されていた関数を全て削除しても同様である。)

  * 更に続けて何らかの入力をした場合、
    その sequence が bash bind で何も割り当てられていなかった場合、
    bash が segmentation fault で落ちる。

  * C-x は単体では割り当てられず、
    必ず C-x hoge の形で入ってくるとするならば、
    C-x ではなく C-x ? に対して bind をすれば良い。


2013-06-03, X4

  history にアクセスする方法 [2013-06-03 08:19:09]

  * history -s で値を設定する事が出来る。

    但し、これは最新の履歴を置き換える形でしか追加する事が出来ない?
    と思ったが、最新の history -s コマンドを置き換えるだけであって、
    昔の履歴を削除する訳ではない様だ (多分)
    →実際に試してみた所期待通りに動いている様なので良しとする。

  * また history -s は HISTIGNORE に該当する物に関しては削除するようだ。
    なので HISTIGNORE などについての特別な配慮は要らず、
    とにかくコマンドを history -s で追加すればよい。

  * 次に isearch で history コマンドを検索する時にどの様にするのが良いのかという事。
    history | grep だと結構処理に時間が掛かりそう
    といって history の内容を何処かの配列に出してくるのも大変な気がする

  * また history 中のコマンドに改行が含まれていた場合、
    検索などの結果が乱れてしまう事になる。

  * 何故か、プロセス置換の中で history を呼び出すと HISTTIMEFORMAT= が有効にならない。
    cat < (HISTTIMEFORMAT=A history)  # 効かない
    cat < (HISTTIMEFORMAT=A; history) # 効く


2013-06-02

  [Done]

  * source 直後の prompt は PS1 をそのままに。
    未だ一度も呼ばれていないのでそもそも自前でプロンプトを表示していない。
    →分かりにくいのでやめた。
      ble.sh の最後に、自分自身で明示的にプロンプト描画関数を呼び出す事にした。

  * quoted-insert C-@ の扱いについて
    →bash でも元から入力できない様なので気にしない
      self-insert で文字コード 0 を渡された場合には無視

  * 取り敢えず実装する物:
    現在の編集行を表示する機能?
    →これは暫定的に唯 print するだけの物でよい。

  * ble-decode-key, ble-bind:
    コマンドが設定されていない時の既定のコマンドを指定できる様にして、

    其処に self-insert を割り当てていたが、この様にしておくと、
    self-insert で変な文字が入力されてしまう
    (一応 self-insert 中で flag は外す様にしているが)。
    更に、どんなに変な操作をしてもエラーメッセージが表示されない。

    本来コマンドが設定されていないとしても flag の付いていない "文字" だけを
    self-insert で処理するべきである。従って、"文字" に対してだけ既定のコマンドを
    適用するように変更する。これは "文字" だけの既定動作なので変数名としても
    __default とするのは気分が悪い。其処で新しく __defchar__ という名前の keyname/keycode
    を定義し、そのキーに対してコマンドが定義されている場合に、"文字" をそのコマンドで処理するように変更した。

    また、空文字列の bind 呼出で __default に値を設定できる機能は削除した。
    <del>空文字列を指定した場合は、既定の動作を指定する。</del>

  * ble-decode-key:
    と思ったが、isearch-map 等を定義する時には、bind されていない key を指定した場合には、
    通常のモードに復帰してそのモードでの操作を実行したいから default の機能は使用したい。
    また、前の様な実装に戻す事も出来たが折角 __defchar__ を定義したので、
    それと同じ方式にした方が良いだろう。と言う事で __default__ というキーを定義する事にした。


2013-06-01

  [現在の実装状況]

  ble-getopt
    取り敢えず枠組は完成している。
    後で拡張を行う余地はある。

  ble-decode
    ble-decode-byte
    ble-decode-char
    ble-decode-key

    ble-decode-bind
    ble-decode-kbd
    ble-decode-unkbd

  ble-text 文字幅
    例えば → 8594 が曖昧幅の文字である。
    設定の名称をどの様にするか
      narrow/wide/emacs
      west/east/emacs

  [Done]
  * ble-decode: ble-decode-* 関数の実装
  * ble-getopt.sh: 短形式オプション引数 (':' 区切) で、'::' の様に、
    区切が連続する場合に、正しく空引数として認識するように変更。
  * mwg.text.getCharFromCode, mwg.text.getCharCodeAt:
    それぞれ .ble-text.c2s, .ble-text.s2c に名称変更。
  * .ble-text.c2s:
    0x100 以上の文字コードを指定した場合に変な文字に変換されるバグを修正。
  * .ble-text.c2s:
    一度文字コードを取得した文字についてキャッシュする様に変更。


X3

  末端に改行を置かずに終了したコマンドの扱い

  * その様なコマンドがあるとプロンプトの表示が乱れる原因である。
  * 右に或る回数だけ進んで其処で空白を出力してから行頭に復帰すれば良い?
    元々1桁目にいた場合にはぎりぎり改行をせずに済み、
    2桁目以降にいた場合には改行してしまうように調整をすれば良い。
    右に行くには ESC [ 桁数 C を出力すれば良い。

  * 適当にやってみたが色々やってもうまく行かない。ちゃんと端末の動作を考えるべき。

  * 先ずは xenl の場合。
    幾ら右に行っても一文字出力する分の余裕は必ず残る。
    従って右端に行ってから 2 文字は出力しないと行けない。

    例えば (1) COLS-2 だけ右に進んでから (2) 2 文字出力して、(3) それから復帰する。

    この様にすると
    何も出力していない場合   |   何か出力している場合
　　(0) [_              ]    |   (0) [a_             ]
        [               ]    |       [               ]
    (1) [------------>_ ]    |   (1) [a------------>_]
        [               ]    |       [               ]
    (2) [             xx_    |   (2) [a             x]
        [               ]    |       [x_             ]
    (3) [_<-------------]    |   (3) [a             x]
        [               ]    |       [_<             ]

    xenl でない端末の場合は COLS-3 に変えれば良いだけか?
    (1) COLS-3 だけ右に進んでから (2) 2 文字出力して、(3) それから復帰する。

    何も出力していない場合   |   何か出力している場合
　　(0) [_              ]    |   (0) [a_             ]
        [               ]    |       [               ]
    (1) [----------->_  ]    |   (1) [a----------->_ ]
        [               ]    |       [               ]
    (2) [            xx_]    |   (2) [a            xx]
        [               ]    |       [_              ]
    (3) [_<------------ ]    |   (3) [a            xx]
        [               ]    |       [_              ]

    多分これで OK。



X2

  C-v に bind できない?

  * どうやら stty が C-v を食う設定になっていてこの設定が有効になっている間は、
    bind で C-v に割り当てをしたり C-v に対する割り当てを削除したりと言った操作ができない様だ。
    stty lnext undef で C-v に対する割り当てを削除した上で C-v に対して bind を行えばよい。
    (stty が食う所までは理解できるが、stty の設定によって bind すら出来なくなるのは何故か?)

  * 但し、その後で stty lnext $'\26' などとして設定を元に戻すと、
    やはり C-v は stty に食われて bash にシグナルとして伝達する。
    問題が生じなければ stty lnext undef で放置という事で良い気がする。

    然し C-z に bind 擦る為に結局 stty susp undef をして、
    コマンド実行直前に復元して、コマンド実行後にまた undef するという事をしたくなりそうだから、
    その際には lnext も復元させる事にすればよい。

  * 何故かスクリプトで stty lnext undef の直後に
    bind -x '"":ble-decode-byte 22' を実行すると、
    self-insert が割り当てられてしまう。
    bind -x の文と stty lnext の文を別の関数に配置したらこの様な事は起きなくなったが、謎。


X1

  C-d を受け取る為には READLINE_LINE に何か設定する必要がある。
   するとオリジナルのプロンプトが表示されるがこれをどの様に殺すか?

  [振舞]
  + READLINE_LINE が空の状態だと C-d を受け取れない。
    受け取る前にログアウトしてしまう。
    (man bash には EOF への翻訳は delete-char で行われる様に書かれているが、
    それとは別に C-d を bash が受け取った段階でチェックされ、
    条件に適合すればログアウトしてしまう)
  + READLINE_POINT が READLINE_LINE 末端を指している時は、
    プロンプトを表示し終わった直後に位置の移動は行わない。
    表示後のカーソル位置は、書き込んだ最後の場所になる。
  + READLINE_POINT が READLINE_LINE 先頭を指している場合は、
    bash が其処にカーソルがあるべきと考えている位置にカーソルが移動してしまう。
    (プロンプトの幅?)
  + 制御文字を EADLINE_LINE に代入しても、表示される時には ^A 等の表示に翻訳される。
    従って、通常の文字を代入しておくのが無難である。
  + 試しに READLINE_LINE=$'\0' として READLINE_LINE='1' として見たが、
    これはどうやら READLINE_LINE は空文字列であると解釈されて、
    C-d は即座にログアウトと解釈されてしまうので駄目である。

  [目的]
  + C-d を読む為に READLINE_LINE の内容は何でも良いから 1 文字以上必要
  + プロンプトを表示し終わった時の位置を制御したい

  [対策]
  + PS1 は空欄にする
  + カーソル位置 x が 2 桁目以降にある場合は、
    x-1 桁目に移動して READLINE_LINE には x-1 桁目の文字を入れる。
    READLINE_POINT には 1 (正確には x-1 桁目の文字のバイト数) を代入しておけば良い。
    また SGR で予め x-1 桁目の文字のスタイルを吐き出しておく。
  + カーソル位置 x が 1 桁目にある場合は、
    READLINE_LINE には 1 桁目の文字を入れておく。
    READLINE_POINT には 0 を入れておく。
    また SGR で予め 1 桁目の文字のスタイルを吐き出しておく。
  + 全角文字などに対する対策も必要

  + これを正しく実装する為には、取り敢えず現在のカーソル位置を把握している必要がある。
    またカーソルの左側に位置している文字と、その幅を記録しておく必要もある。
    (幅を記録する必要はあるのか→ない気がする。)

  *rule*

  + lc はカーソルの左側に位置する文字の文字コードを表す。
    常に graphical な文字であり、bash によって直接表示される。
    x=0 の場合には lc に入っている文字コードの値は未定義であり、使用してはならない。
  　(つまり x, lc を設定する側では x=0 の時は lc の中身は気にしなくて良い。)。


  関数 x y lc ; .ble-cursor-move.text text ; x y lc

    .ble-cursor-move.text は指定した文字を現在位置 x y に書き込んだ時に、
    カーソルがどの様に移動するかを計算する。この時 lc の値も一緒に計算する。

    ** 注意点 **
    text に BS や VT が含まれる場合、lc を適切に計算する事が出来ない。
    BS, VT が含まれる場合、その直前の文字 (BS で消した文字の直前の文字、及び、VT で移動した先の左側にある文字)
    を今迄の出力から知る事は出来ない。この様な場合は暫定的に lc=32 (空白文字) を設定する。
    (この関数は prompt の幅を計算する為にある。PS1 に BS や VT などの制御文字を \[ \] で
    囲まずに設定する事は考えにくいので、現状ではこれについて対策する予定はない。)


  関数 .ble-cursor.construct-prompt ; ret=(x y lc ps1esc)

    プロンプト文字列を実体化し ps1esc とする。
    更に、プロンプトを端末の左端から表示し始めた時の、最後のカーソルの位置 x y を計算する。
    また、lc にはカーソルの位置の左側にある文字の文字コードを返す。

    ** 注意点 **
    エスケープシーケンスなど実際に prompt の位置に文字として表示されない物は、必ず \[ ... \] で囲む事。
    \[ \] で囲んだ中でカーソルの移動などを行うとカーソル位置を正しく計算できない可能性がある。
    \[ \] で囲んだ中でカーソルを移動させたとしても、また元の位置に戻す事が望ましい。


  関数 _ble_cursor_x _ble_cursor_lc ; .ble-edit.adjust-cursor

    ble-decode-byte の最後にこの関数を呼び出して、READLINE_LINE, READLINE_POINT
    の調整を実行する事にした。ちゃんと実装した物が完成したので、
    暫定的に書いた調整コードは削除 (以下)

    # # 何か入力されていないと C-d で exit してしまう。
    # # これは delete-char で判定するのではなく、
    # # あらゆる関数を呼び出す前にチェックされる様だ。
    # # また、READLINE_POINT が文字列末端に設定されていれば OK

    # [暫定v1]
    # READLINE_LINE="${_ble_edit_str:_ble_edit_str_ind:1}"
    # test -z "$READLINE_LINE" && READLINE_LINE=' '
    # READLINE_POINT=1

    # [暫定v2]
    # echo -n "[D"
    # if ((_ble_edit_ind>0)); then
    #   READLINE_LINE="${_ble_edit_str:_ble_edit_ind-1:1}"
    # else
    #   READLINE_LINE='_'
    # fi
    # READLINE_POINT=1


2013-05-29 highlight.sh

  bash で highlight?

  一応、bind -x で通常文字に対して適当な関数を割り当てれば
  入力に対して hook をする事は可能なようである。
  但し、関数の呼出が終わった後に入力行が再度描画されるので、
  折角色を付けて出力したとしても上から塗り潰される事になる。

  後 bind -x のもう一つの問題として、
  複数行に亙る行を編集している時に bind -x の関数を呼び出すと、
  処理が終わった後に再描画される訳だが、
  その時の再描画で表示している行の位置が下にずれる。
  これは bind -x の関数で何の操作もしていなくても同様である。
  これを正しく処理する為には、

  (1) 現在の端末の幅を取得する
  (2) 文字列の表示上の長さを取得する
  (3) prompt の長さを取得する。

  などの機能を正しく実装する必要がある。
  (1) は shopt -s chkwinsize でもすれば取り敢えずできる。
  (3) は (2) さえ正確に記述でき、現在のカーソル位置が分かれば現在の位置から逆算できる。
  逆に言えば、(2) と (3) さえ正確に計算できれば現在のカーソル位置も端末に問い合わせることなく分かるという事でもある。

  + 現在のカーソルの位置を取得する関数は書けた。一応動いている。
    但し CSI 6 n (DSR CPR) に対応している端末でないと動かない。

  * 現在位置を予測するという事

    文字列の表示上の長さを計算するには、
    <del>文字列の文字コードを utf-8 と仮定すれば編集文字列を走査して、</del>
    文字コード列を生成し、更に其処から文字幅に変換して、
    加算するという事をすれば良い。

    と思ったが…実際には改行やら TAB やらがあるので、
    現在の正確な位置が分からないと文字列の表示上の長さなどの情報を取得する事は出来ない。
    やはり何とかして端末が表示される長さを算出する必要があるだろうか。
    端末が表示される長さを取得する方法:

    A READLINE_LINE が空だった時の位置を記録しておく?
      + 漢字や平仮名で始まるコマンドを入力した場合に対処できない。しかしそんなコマンドは存在するだろうか。
      + 前のコマンドの出力が改行で終わらなかった場合にどうなるか?
        →1 文字でも入力すれば再描画されてプロンプトは行頭に出て来る。
          0 文字の時に取得した位置はその時にしか信用できないので、1 文字の時に取得した文字の方が良い?
      + <strong>×</strong> プロンプトは複数行に跨らないという仮定をしないとできない。
        然し、人によってはプロンプトを複数行に分けるという人もいる (cygwin の人みたいに)。

    B 自分で PS1 を解析して長さを計算する?
      + <strong>△</strong> 実装が大変。エスケープシーケンスの類にも対応しなければならない。
      + (\a \n \r \ooo はCと同じ意味, \x \f \b はそのまま出力, \v \t \u は別の意味, \e は ESC)
